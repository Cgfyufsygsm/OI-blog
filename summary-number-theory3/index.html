<!DOCTYPE html>
<html dir="ltr" lang="zh-CN">
<head><meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/><meta content="莫比乌斯反演相关 警告：本节对推式子能力要求较高。
这一部分内容在 OI 中的考察以式子的化简求值为主。
整除分块 是学习莫比乌斯反演前的很重要的前置知识。
是基于 \(\lfloor n / i\rfloor\) 最多只有 \(\sqrt n\) 种取值的。可以加快运算。将相同的 \(\lfloor n / i\rfloor\) 合在一起，体现了分块思想。
基本形式 例题：UVA11526 H(n)
\(T\) 组询问，每次给定 \(n&amp;lt; 2^{31}\)，求 \(\displaystyle\sum_{i=1}^n\left\lfloor\frac{n}{i}\right\rfloor\)。
首先 \(O(n)\) 做法肯定是寄了的，考虑优化。打个表发现很多段 \(\lfloor n / i\rfloor\) 的值都是一样的，并且下面说明这些不同的值只有 \(O(\sqrt n)\) 种。
证明：对于 \(i\le \sqrt n\)，\(\lfloor\frac n i\rfloor\) 至多有 \(\sqrt n\) 个取值，然后对于 \(i\gt \sqrt n\)，\(\lfloor \frac n i\rfloor\lt \sqrt n\)，所以 \(\lfloor \frac n i\rfloor\) 也至多有 \(\sqrt n\) 种取值。所以 \(\lfloor\frac n i\rfloor\) 至多有 \(2\sqrt n\) 种取值。" name="description"/><title>数论复习 3（反演与筛法）</title>
<link href="https://oi.imyangty.com/summary-number-theory3/" rel="canonical"/>
<link href="/scss/style.min.a5821f3d3ab84ce5a0ac21477e347a2e0ca00292e398d16c5e8e36ded6e35a23.css" rel="stylesheet"/><meta content="数论复习 3（反演与筛法）" property="og:title"/>
<meta content="莫比乌斯反演相关 警告：本节对推式子能力要求较高。
这一部分内容在 OI 中的考察以式子的化简求值为主。
整除分块 是学习莫比乌斯反演前的很重要的前置知识。
是基于 \(\lfloor n / i\rfloor\) 最多只有 \(\sqrt n\) 种取值的。可以加快运算。将相同的 \(\lfloor n / i\rfloor\) 合在一起，体现了分块思想。
基本形式 例题：UVA11526 H(n)
\(T\) 组询问，每次给定 \(n&amp;lt; 2^{31}\)，求 \(\displaystyle\sum_{i=1}^n\left\lfloor\frac{n}{i}\right\rfloor\)。
首先 \(O(n)\) 做法肯定是寄了的，考虑优化。打个表发现很多段 \(\lfloor n / i\rfloor\) 的值都是一样的，并且下面说明这些不同的值只有 \(O(\sqrt n)\) 种。
证明：对于 \(i\le \sqrt n\)，\(\lfloor\frac n i\rfloor\) 至多有 \(\sqrt n\) 个取值，然后对于 \(i\gt \sqrt n\)，\(\lfloor \frac n i\rfloor\lt \sqrt n\)，所以 \(\lfloor \frac n i\rfloor\) 也至多有 \(\sqrt n\) 种取值。所以 \(\lfloor\frac n i\rfloor\) 至多有 \(2\sqrt n\) 种取值。" property="og:description"/>
<meta content="https://oi.imyangty.com/summary-number-theory3/" property="og:url"/>
<meta content="清烛的博客" property="og:site_name"/>
<meta content="article" property="og:type"/><meta content="Post" property="article:section"/><meta content="OI" property="article:tag"/><meta content="笔记" property="article:tag"/><meta content="2021-08-12T14:49:34+08:00" property="article:published_time"/><meta content="2021-08-12T14:49:34+08:00" property="article:modified_time"/><meta content="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg16.webp" property="og:image"/>
<meta content="数论复习 3（反演与筛法）" name="twitter:title"/>
<meta content="莫比乌斯反演相关 警告：本节对推式子能力要求较高。
这一部分内容在 OI 中的考察以式子的化简求值为主。
整除分块 是学习莫比乌斯反演前的很重要的前置知识。
是基于 \(\lfloor n / i\rfloor\) 最多只有 \(\sqrt n\) 种取值的。可以加快运算。将相同的 \(\lfloor n / i\rfloor\) 合在一起，体现了分块思想。
基本形式 例题：UVA11526 H(n)
\(T\) 组询问，每次给定 \(n&amp;lt; 2^{31}\)，求 \(\displaystyle\sum_{i=1}^n\left\lfloor\frac{n}{i}\right\rfloor\)。
首先 \(O(n)\) 做法肯定是寄了的，考虑优化。打个表发现很多段 \(\lfloor n / i\rfloor\) 的值都是一样的，并且下面说明这些不同的值只有 \(O(\sqrt n)\) 种。
证明：对于 \(i\le \sqrt n\)，\(\lfloor\frac n i\rfloor\) 至多有 \(\sqrt n\) 个取值，然后对于 \(i\gt \sqrt n\)，\(\lfloor \frac n i\rfloor\lt \sqrt n\)，所以 \(\lfloor \frac n i\rfloor\) 也至多有 \(\sqrt n\) 种取值。所以 \(\lfloor\frac n i\rfloor\) 至多有 \(2\sqrt n\) 种取值。" name="twitter:description"/><meta content="summary_large_image" name="twitter:card"/>
<meta content="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg16.webp" name="twitter:image"/>
<link href="https://q1.qlogo.cn/g?b=qq&amp;nk=375836877&amp;s=5" rel="shortcut icon"/>
<link href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/styles/github-dark-dimmed.min.css" rel="stylesheet"/>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
</head>
<body class="article-page">
<script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky">
<button aria-label="切换菜单" class="hamburger hamburger--spin" id="toggle-menu" type="button">
<span class="hamburger-box">
<span class="hamburger-inner"></span>
</span>
</button>
<header>
<figure class="site-avatar">
<a href="/">
<img alt="Avatar" class="site-logo" height="300" loading="lazy" src="/img/avatar_huea3ce2119467b51fdd2a81393644a76d_51594_300x0_resize_q75_box.jpg" width="300"/>
</a>
<span class="emoji">😅</span>
</figure>
<div class="site-meta">
<h1 class="site-name"><a href="/">清烛的博客</a></h1>
<h2 class="site-description">烟火已谢，笙歌未停</h2>
</div>
</header><ol class="social-menu">
<li>
<a href="mailto:i@imyangty.com" target="_blank" title="email">
<svg class="icon icon-tabler icon-tabler-mail" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
<rect height="14" rx="2" width="18" x="3" y="5"></rect>
<polyline points="3 7 12 13 21 7"></polyline>
</svg>
</a>
</li>
<li>
<a href="https://github.com/Cgfyufsygsm" target="_blank" title="GitHub">
<svg class="icon icon-tabler icon-tabler-brand-github" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
<path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5"></path>
</svg>
</a>
</li>
<li>
<a href="https://t.me/Cgfyufsygsm" target="_blank" title="Telegram">
<svg class="icon icon-tabler icon-tabler-brand-telegram" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
<path d="M15 10l-4 4l6 6l4 -16l-18 7l4 2l2 6l3 -4"></path>
</svg>
</a>
</li>
<li>
<a href="https://twitter.com/Cgfyufsygsm" target="_blank" title="Twitter">
<svg class="icon icon-tabler icon-tabler-brand-twitter" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
<path d="M22 4.01c-1 .49 -1.98 .689 -3 .99c-1.121 -1.265 -2.783 -1.335 -4.38 -.737s-2.643 2.06 -2.62 3.737v1c-3.245 .083 -6.135 -1.395 -8 -4c0 0 -4.182 7.433 4 11c-1.872 1.247 -3.739 2.088 -6 2c3.308 1.803 6.913 2.423 10.034 1.517c3.58 -1.04 6.522 -3.723 7.651 -7.742a13.84 13.84 0 0 0 .497 -3.753c-.002 -.249 1.51 -2.772 1.818 -4.013z"></path>
</svg>
</a>
</li>
</ol><ol class="menu" id="main-menu">
<li>
<a href="/">
<svg class="icon icon-tabler icon-tabler-home" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<polyline points="5 12 3 12 12 3 21 12 19 12"></polyline>
<path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7"></path>
<path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6"></path>
</svg>
<span>主页</span>
</a>
</li>
<li>
<a href="/about/">
<svg class="icon icon-tabler icon-tabler-user" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<circle cx="12" cy="7" r="4"></circle>
<path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2"></path>
</svg>
<span>关于</span>
</a>
</li>
<li>
<a href="/idx/">
<svg class="icon icon-tabler icon-tabler-hash" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<line x1="5" x2="19" y1="9" y2="9"></line>
<line x1="5" x2="19" y1="15" y2="15"></line>
<line x1="11" x2="7" y1="4" y2="20"></line>
<line x1="17" x2="13" y1="4" y2="20"></line>
</svg>
<span>导航</span>
</a>
</li>
<li>
<a href="/archives/">
<svg class="icon icon-tabler icon-tabler-archive" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<rect height="4" rx="2" width="18" x="3" y="4"></rect>
<path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10"></path>
<line x1="10" x2="14" y1="12" y2="12"></line>
</svg>
<span>归档</span>
</a>
</li>
<li>
<a href="/search/">
<svg class="icon icon-tabler icon-tabler-search" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<circle cx="10" cy="10" r="7"></circle>
<line x1="21" x2="15" y1="21" y2="15"></line>
</svg>
<span>搜索</span>
</a>
</li>
<li>
<a href="/friends/">
<svg class="icon icon-tabler icon-tabler-link" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5"></path>
<path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5"></path>
</svg>
<span>友链</span>
</a>
</li>
<li>
<a href="https://blog.imyangty.com" target="_blank">
<svg class="icon icon-tabler icon-tabler-home" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<polyline points="5 12 3 12 12 3 21 12 19 12"></polyline>
<path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7"></path>
<path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6"></path>
</svg>
<span>主博客</span>
</a>
</li>
<div class="menu-bottom-section">
<li id="dark-mode-toggle">
<svg class="icon icon-tabler icon-tabler-toggle-left" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<circle cx="8" cy="12" r="2"></circle>
<rect height="12" rx="6" width="20" x="2" y="6"></rect>
</svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<circle cx="16" cy="12" r="2"></circle>
<rect height="12" rx="6" width="20" x="2" y="6"></rect>
</svg>
<span>暗色模式</span>
</li>
</div>
</ol>
</aside>
<main class="main full-width">
<article class="has-image main-article">
<header class="article-header">
<div class="article-image">
<a href="/summary-number-theory3/">
<img alt="Featured image of post 数论复习 3（反演与筛法）" loading="lazy" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg16.webp"/>
</a>
</div>
<div class="article-details">
<header class="article-category">
<a href="/categories/oi/">
                OI
            </a>
<a href="/categories/summary/">
                总结
            </a>
</header>
<div class="article-title-wrapper">
<h2 class="article-title">
<a href="/summary-number-theory3/">数论复习 3（反演与筛法）</a>
</h2>
</div>
<footer class="article-time">
<div>
<svg class="icon icon-tabler icon-tabler-calendar-time" fill="none" height="56" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="56" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4"></path>
<circle cx="18" cy="18" r="4"></circle>
<path d="M15 3v4"></path>
<path d="M7 3v4"></path>
<path d="M3 11h16"></path>
<path d="M18 16.496v1.504l1 1"></path>
</svg>
<time class="article-time--published">Aug 12, 2021</time>
</div>
<div>
<svg class="icon icon-tabler icon-tabler-clock" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<circle cx="12" cy="12" r="9"></circle>
<polyline points="12 7 12 12 15 15"></polyline>
</svg>
<time class="article-time--reading">
                    阅读时长: 17 分钟
                </time>
</div>
</footer>
</div>
</header>
<section class="article-content">
<h2 id="莫比乌斯反演相关">莫比乌斯反演相关</h2>
<p>警告：本节对推式子能力要求较高。</p>
<p>这一部分内容在 OI 中的考察以式子的化简求值为主。</p>
<h3 id="整除分块">整除分块</h3>
<p>是学习莫比乌斯反演前的很重要的前置知识。</p>
<p>是基于 <span class="math inline">\(\lfloor n / i\rfloor\)</span> 最多只有 <span class="math inline">\(\sqrt n\)</span> 种取值的。可以加快运算。将相同的 <span class="math inline">\(\lfloor n / i\rfloor\)</span> 合在一起，体现了分块思想。</p>
<h4 id="基本形式">基本形式</h4>
<blockquote>
<p>例题：<a href="https://www.luogu.com.cn/problem/UVA11526">UVA11526 H(n)</a></p>
<p><span class="math inline">\(T\)</span> 组询问，每次给定 <span class="math inline">\(n&lt; 2^{31}\)</span>，求 <span class="math inline">\(\displaystyle\sum_{i=1}^n\left\lfloor\frac{n}{i}\right\rfloor\)</span>。</p>
</blockquote>
<p>首先 <span class="math inline">\(O(n)\)</span> 做法肯定是寄了的，考虑优化。打个表发现很多段 <span class="math inline">\(\lfloor n / i\rfloor\)</span> 的值都是一样的，并且下面说明这些不同的值只有 <span class="math inline">\(O(\sqrt n)\)</span> 种。</p>
<p>证明：对于 <span class="math inline">\(i\le \sqrt n\)</span>，<span class="math inline">\(\lfloor\frac n i\rfloor\)</span> 至多有 <span class="math inline">\(\sqrt n\)</span> 个取值，然后对于 <span class="math inline">\(i\gt \sqrt n\)</span>，<span class="math inline">\(\lfloor \frac n i\rfloor\lt \sqrt n\)</span>，所以 <span class="math inline">\(\lfloor \frac n i\rfloor\)</span> 也至多有 <span class="math inline">\(\sqrt n\)</span> 种取值。所以 <span class="math inline">\(\lfloor\frac n i\rfloor\)</span> 至多有 <span class="math inline">\(2\sqrt n\)</span> 种取值。</p>
<p>那么现在考虑给定 <span class="math inline">\(l\)</span>，要求确定出分块右端点 <span class="math inline">\(r\)</span> 满足 <span class="math inline">\(\forall i\in[l,r]\)</span> 都有 <span class="math inline">\(\lfloor n / i\rfloor = \lfloor n / l\rfloor\)</span>，且 <span class="math inline">\(r\)</span> 最大，那么就是如下限制条件： <span class="math display">\[
\begin{cases}
k = \lfloor n / l\rfloor\\
r = \displaystyle\max_{ik\le n}\{i\}
\end{cases}
\]</span> 那么就有 <span class="math inline">\(\displaystyle r = \left\lfloor\frac nk\right\rfloor = \left\lfloor\frac{n}{\left\lfloor\frac n l\right\rfloor}\right\rfloor\)</span>。</p>
<p>代码实现：</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a aria-hidden="true" href="#cb1-1"></a>ll calc(ll n) {</span>
<span id="cb1-2"><a aria-hidden="true" href="#cb1-2"></a>    ll ans = <span class="dv">0</span>;</span>
<span id="cb1-3"><a aria-hidden="true" href="#cb1-3"></a>    <span class="cf">for</span> (ll l = <span class="dv">1</span>, r; l &lt;= n; l = r + <span class="dv">1</span>) {</span>
<span id="cb1-4"><a aria-hidden="true" href="#cb1-4"></a>        r = n / (n / l);</span>
<span id="cb1-5"><a aria-hidden="true" href="#cb1-5"></a>        ans += (r - l + <span class="dv">1</span>) * (n / l);</span>
<span id="cb1-6"><a aria-hidden="true" href="#cb1-6"></a>    }</span>
<span id="cb1-7"><a aria-hidden="true" href="#cb1-7"></a>    <span class="cf">return</span> ans;</span>
<span id="cb1-8"><a aria-hidden="true" href="#cb1-8"></a>}</span></code></pre></div>
<blockquote>
<p>例题：<a href="https://www.luogu.com.cn/problem/P3935">P3935 Calculating</a></p>
<p>若 <span class="math inline">\(x\)</span> 分解质因数结果为 <span class="math inline">\(x=p_1^{k_1}p_2^{k_2}\cdots p_n^{k_n}\)</span>，令<span class="math inline">\(f(x)=(k_1+1)(k_2+1)\cdots (k_n+1)\)</span>，求 <span class="math inline">\(\sum_{i=l}^rf(i)\)</span> 对 <span class="math inline">\(998\,244\,353\)</span> 取模的结果。<span class="math inline">\(1\le l\le 10^{14}\)</span>，<span class="math inline">\(1\le r\le 1.6\times 10^{14}\)</span>，<span class="math inline">\(r-l&gt;10^{14}\)</span>。</p>
</blockquote>
<p>首先设 <span class="math inline">\(s(n) = \displaystyle\sum_{i=1}^n f(i)\)</span>，然后答案即为 <span class="math inline">\(s(r) - s(l-1)\)</span>，然后注意到 <span class="math inline">\(f(x)\)</span> 实际就是约数个数函数，那么 <span class="math inline">\(s(n)\)</span> 即为 <span class="math display">\[
\sum_{i=1}^n\sum_{d\mid i}1 = \sum_{i=1}^n\left\lfloor\frac{n}{i}\right\rfloor
\]</span> 直接按上面方法做即可。</p>
<blockquote>
<p>例题 <a href="https://www.luogu.com.cn/problem/P2261">P2261 [CQOI2007]余数求和</a></p>
<p>给定 <span class="math inline">\(1\le n,k\le 10^9\)</span>，求 <span class="math inline">\(\displaystyle\sum_{i=1}^nk\bmod i\)</span>。</p>
</blockquote>
<p>注意到 <span class="math inline">\(k\bmod i\)</span> 可以拆成 <span class="math inline">\(k - i\lfloor k / i\rfloor\)</span>，然后整个式子可以化为 <span class="math display">\[
kn - \sum_{i=1}^ni\left\lfloor \frac k i\right\rfloor
\]</span> 每一块内统计平均值啥的即可。</p>
<h4 id="其他变形">其他变形</h4>
<p>使用类似的分析方法可以处理更多类似的问题。</p>
<blockquote>
<p>例题 <a href="https://www.luogu.com.cn/problem/P2260">P2260 [清华集训2012]模积和</a> <span class="math display">\[
\sum_{1\le i\le n} \sum_{1\le j\le m,i\ne j} (n \bmod i) \times (m \bmod j)\bmod19940417
\]</span> <span class="math inline">\(1\le n,m\le 10^9\)</span>。</p>
</blockquote>
<p>二维整除分块。不妨假设 <span class="math inline">\(n\le m\)</span>，首先容斥一波将 <span class="math inline">\(i\ne j\)</span> 去掉： <span class="math display">\[
\sum_{i=1}^n(n\bmod i)\sum_{j=1}^m(m\bmod j) - \sum_{i=1}^n(n\bmod i)(m\bmod i)
\]</span> 然后用上面的化简方法把取模拆开： <span class="math display">\[
\left(n^2 - \sum_{i=1}^ni\left\lfloor\frac ni\right\rfloor \right)\times\left(m^2 - \sum_{i=1}^mi\left\lfloor\frac mi\right\rfloor \right) - \sum_{i=1}^n\left(n - i\left\lfloor \frac n i \right\rfloor\right)\left(m - i\left\lfloor \frac m i \right\rfloor\right)
\]</span> 前面的两大坨是一般通过整除分块，我们看后面一部分： <span class="math display">\[
\begin{aligned}
&amp;\sum_{i=1}^n\left(n - i\left\lfloor \frac n i \right\rfloor\right)\left(m - i\left\lfloor \frac m i \right\rfloor\right)\\
=&amp;\sum_{i=1}^n\left(nm - ni\left\lfloor \frac n i \right\rfloor - mi\left\lfloor \frac m i \right\rfloor + i^2\left\lfloor \frac n i \right\rfloor\left\lfloor \frac m i \right\rfloor\right)\\
=&amp;n^2m - n\sum_{i=1}^n\left\lfloor \frac n i \right\rfloor - m\sum_{i=1}^n\left\lfloor \frac m i \right\rfloor + \sum_{i=1}^ni^2\left\lfloor \frac n i \right\rfloor\left\lfloor \frac m i \right\rfloor
\end{aligned}
\]</span> 前三项比较好做，主要问题是第四项。实际上你会发现由于 <span class="math inline">\(\lfloor n /i\rfloor\)</span> 和 <span class="math inline">\(\lfloor m / i\rfloor\)</span> 都成块状，所以转折点一共也是 <span class="math inline">\(O(\sqrt n)\)</span> 的，一样可以整除分块，每次对 <span class="math inline">\(\lfloor n / \lfloor n / l\rfloor\rfloor\)</span> 和 <span class="math inline">\(\lfloor m / \lfloor m / l\rfloor\rfloor\)</span> 取个 <span class="math inline">\(\min\)</span> 即可。而对于 <span class="math inline">\(\sum i^2\)</span> 有公式在开头给出，在此不表。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a aria-hidden="true" href="#cb2-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb2-2"><a aria-hidden="true" href="#cb2-2"></a><span class="pp">#define il </span><span class="kw">inline</span></span>
<span id="cb2-3"><a aria-hidden="true" href="#cb2-3"></a></span>
<span id="cb2-4"><a aria-hidden="true" href="#cb2-4"></a><span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> ll;</span>
<span id="cb2-5"><a aria-hidden="true" href="#cb2-5"></a></span>
<span id="cb2-6"><a aria-hidden="true" href="#cb2-6"></a><span class="kw">inline</span> ll min(ll a, ll b){<span class="cf">return</span> a &lt; b ? a : b;}</span>
<span id="cb2-7"><a aria-hidden="true" href="#cb2-7"></a></span>
<span id="cb2-8"><a aria-hidden="true" href="#cb2-8"></a><span class="at">const</span> ll mod = <span class="dv">19940417</span>, inv2 = <span class="dv">9970209</span>, inv6 = <span class="dv">3323403</span>;</span>
<span id="cb2-9"><a aria-hidden="true" href="#cb2-9"></a></span>
<span id="cb2-10"><a aria-hidden="true" href="#cb2-10"></a>ll n, m, ans;</span>
<span id="cb2-11"><a aria-hidden="true" href="#cb2-11"></a></span>
<span id="cb2-12"><a aria-hidden="true" href="#cb2-12"></a>ll calc(ll n, ll k) {</span>
<span id="cb2-13"><a aria-hidden="true" href="#cb2-13"></a>    ll ret = <span class="dv">0</span>;</span>
<span id="cb2-14"><a aria-hidden="true" href="#cb2-14"></a>    n = min(n, k);</span>
<span id="cb2-15"><a aria-hidden="true" href="#cb2-15"></a>    <span class="cf">for</span> (ll l = <span class="dv">1</span>, r = <span class="dv">1</span>; l &lt;= n; l = r + <span class="dv">1</span>) {</span>
<span id="cb2-16"><a aria-hidden="true" href="#cb2-16"></a>        r = min(n, k / (k / l));</span>
<span id="cb2-17"><a aria-hidden="true" href="#cb2-17"></a>        ret += ((r - l + <span class="dv">1</span>) * (k / l * l) % mod + (r - l + <span class="dv">1</span>) * (r - l) % mod * (k / l) % mod * inv2 % mod) % mod;</span>
<span id="cb2-18"><a aria-hidden="true" href="#cb2-18"></a>        ret %= mod;</span>
<span id="cb2-19"><a aria-hidden="true" href="#cb2-19"></a>    }</span>
<span id="cb2-20"><a aria-hidden="true" href="#cb2-20"></a>    <span class="cf">return</span> ret;</span>
<span id="cb2-21"><a aria-hidden="true" href="#cb2-21"></a>}</span>
<span id="cb2-22"><a aria-hidden="true" href="#cb2-22"></a></span>
<span id="cb2-23"><a aria-hidden="true" href="#cb2-23"></a>il ll summod(ll n) {</span>
<span id="cb2-24"><a aria-hidden="true" href="#cb2-24"></a>    <span class="cf">return</span> (n * n % mod - calc(n, n) + mod) % mod;</span>
<span id="cb2-25"><a aria-hidden="true" href="#cb2-25"></a>}</span>
<span id="cb2-26"><a aria-hidden="true" href="#cb2-26"></a></span>
<span id="cb2-27"><a aria-hidden="true" href="#cb2-27"></a>il ll sum(ll n) {</span>
<span id="cb2-28"><a aria-hidden="true" href="#cb2-28"></a>    <span class="cf">return</span> n * (n + <span class="dv">1</span>) % mod * (<span class="dv">2</span> * n + <span class="dv">1</span>) % mod * inv6 % mod;</span>
<span id="cb2-29"><a aria-hidden="true" href="#cb2-29"></a>}</span>
<span id="cb2-30"><a aria-hidden="true" href="#cb2-30"></a></span>
<span id="cb2-31"><a aria-hidden="true" href="#cb2-31"></a>ll calc2(ll n, ll m) {</span>
<span id="cb2-32"><a aria-hidden="true" href="#cb2-32"></a>    ll top = min(n, m);</span>
<span id="cb2-33"><a aria-hidden="true" href="#cb2-33"></a>    ll ret = n * m % mod * top % mod;</span>
<span id="cb2-34"><a aria-hidden="true" href="#cb2-34"></a>    ret -= m * calc(top, n);</span>
<span id="cb2-35"><a aria-hidden="true" href="#cb2-35"></a>    ret = (ret + mod) % mod;</span>
<span id="cb2-36"><a aria-hidden="true" href="#cb2-36"></a>    ret -= n * calc(top, m);</span>
<span id="cb2-37"><a aria-hidden="true" href="#cb2-37"></a>    ret = (ret + mod) % mod;</span>
<span id="cb2-38"><a aria-hidden="true" href="#cb2-38"></a>    <span class="cf">for</span> (ll l = <span class="dv">1</span>, r; l &lt;= top; l = r + <span class="dv">1</span>) {</span>
<span id="cb2-39"><a aria-hidden="true" href="#cb2-39"></a>        r = min(min(top, n / (n / l)), m / (m / l));<span class="co">//同时取min，注意上界问题</span></span>
<span id="cb2-40"><a aria-hidden="true" href="#cb2-40"></a>        ll sqri = sum(r) - sum(l - <span class="dv">1</span>);</span>
<span id="cb2-41"><a aria-hidden="true" href="#cb2-41"></a>        ret = (ret + sqri * (n / l) % mod * (m / l) % mod) % mod;</span>
<span id="cb2-42"><a aria-hidden="true" href="#cb2-42"></a>    }</span>
<span id="cb2-43"><a aria-hidden="true" href="#cb2-43"></a>    <span class="cf">return</span> ret;</span>
<span id="cb2-44"><a aria-hidden="true" href="#cb2-44"></a>}</span>
<span id="cb2-45"><a aria-hidden="true" href="#cb2-45"></a></span>
<span id="cb2-46"><a aria-hidden="true" href="#cb2-46"></a><span class="dt">int</span> main() {</span>
<span id="cb2-47"><a aria-hidden="true" href="#cb2-47"></a>    scanf(<span class="st">"</span><span class="sc">%lld</span><span class="st"> </span><span class="sc">%lld</span><span class="st">"</span>, &amp;n, &amp;m);</span>
<span id="cb2-48"><a aria-hidden="true" href="#cb2-48"></a>    ans = summod(n) * summod(m) % mod;</span>
<span id="cb2-49"><a aria-hidden="true" href="#cb2-49"></a>    ans = (ans - calc2(n, m) + mod) % mod;</span>
<span id="cb2-50"><a aria-hidden="true" href="#cb2-50"></a>    printf(<span class="st">"</span><span class="sc">%lld\n</span><span class="st">"</span>, ans);</span>
<span id="cb2-51"><a aria-hidden="true" href="#cb2-51"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb2-52"><a aria-hidden="true" href="#cb2-52"></a>}</span></code></pre></div>
<blockquote>
<p>例题：给定 <span class="math inline">\(n\le 10^{18}\)</span>，求</p>
<p><span class="math display">\[
\sum_{k=1}^n \sum_{d^2 \mid k} d \bmod 998244353
\]</span></p>
</blockquote>
<p>首先我们不妨改变枚举顺序，先枚举 <span class="math inline">\(d\)</span>： <span class="math display">\[
\sum_{d=1}^{\lfloor\sqrt n\rfloor}d\sum_{k=1}^n[d^2\mid k]
\]</span> 实际上就是 <span class="math display">\[
\sum_{d=1}^{\lfloor\sqrt n\rfloor}d\left\lfloor\frac{n}{d^2}\right\rfloor
\]</span> 在这里，我们使用更一般化的思路，令 <span class="math inline">\(d^* = d^2\)</span>，类似上面一样推导：<span class="math inline">\(\begin{cases}k = \lfloor n / l^2\rfloor\\r^* = \lfloor n / k\rfloor\end{cases}\)</span>，那么就有 <span class="math inline">\(r^* = \displaystyle\left\lfloor\frac{n}{\left\lfloor\frac n l^2\right\rfloor}\right\rfloor\)</span>，开个根即得到 <span class="math inline">\(r = \left\lfloor\sqrt{\left\lfloor\frac{n}{\left\lfloor\frac{n}{l^2}\right\rfloor}\right\rfloor}\right\rfloor\)</span>。于是本题 <span class="math inline">\(O(n^{1/4})\)</span> 解决。</p>
<blockquote>
<p>例题：求 <span class="math display">\[
\sum_{i=1}^n\left\lceil\frac ni\right\rceil
\]</span></p>
</blockquote>
<p>向上取整啥的不管，注意到 <span class="math inline">\(\displaystyle\left\lceil\frac nm\right\rceil = \left\lfloor\frac{n + m - 1}{m}\right\rfloor\)</span>，所以原式变为对 <span class="math inline">\(\displaystyle\left\lfloor\frac{n+i-1}{i}\right\rfloor\)</span> 求和。类似上面推导：<span class="math inline">\(k=\lfloor(n+l-1)/l\rfloor\)</span>，然后 <span class="math inline">\(r\)</span> 要满足 <span class="math inline">\(\lceil n / r\rceil = k\)</span>，即 <span class="math inline">\(n\le kr\le n + r - 1\)</span>，于是乎 <span class="math inline">\(r = \displaystyle\left\lfloor\frac{n - 1}{k - 1}\right\rfloor = \left\lfloor\frac{n - 1}{\left\lfloor\frac{n+l-1}{l}\right\rfloor - 1}\right\rfloor\)</span>，记得最后一步特判，此时 <span class="math inline">\(k - 1 = 0\)</span>，右边界为 <span class="math inline">\(n\)</span>。</p>
<h3 id="狄利克雷卷积">狄利克雷卷积</h3>
<p>定义两个数论函数 <span class="math inline">\(f(n),g(n)\)</span> 的狄利克雷卷积 <span class="math inline">\((f*g)(n)\)</span> 为 <span class="math display">\[
(f*g)(n) = \sum_{d\mid n}f(d)g\left(\frac nd\right)
\]</span> 类比一下一般的加法卷积 <span class="math inline">\(c_k = \sum_{i}a_ib_{k - i}\)</span>，我们可以发现狄利克雷卷积为<strong>关于乘法</strong>的卷积。</p>
<p>其具有如下常见性质：</p>
<ol type="1">
<li><p>交换律：<span class="math inline">\(f*g = g*f\)</span>，乘法满足交换律，得证。</p></li>
<li><p>结合律：<span class="math inline">\((f*g)*h=f*(g*h)\)</span>： <span class="math display">\[
\sum_{(ij)k = n}(f(i)g(j))h(k)=\sum_{i(jk) = n}f(i)(g(j)h(k))
\]</span></p></li>
<li><p>对加法的分配律：<span class="math inline">\((f+g)*h = f*h + g*h\)</span>： <span class="math display">\[
\begin{aligned}
&amp;(f(n) + g(n)) * h(n)\\
=&amp;\sum_{d\mid n}(f(d) + d(d))h\left(\frac nd\right)\\
=&amp;\sum_{d\mid n}f(d)h\left(\frac nd\right) + \sum_{d\in n}g(d)h\left(\frac nd\right)\\
=&amp;f(n)*h(n) + g(n)*h(n)
\end{aligned}
\]</span></p></li>
<li><p>与数乘的结合律：<span class="math inline">\((cf)*g = c(f*g)\)</span>。</p></li>
<li><p><strong>单位元</strong>：<span class="math inline">\(\epsilon * f = f\)</span>，<span class="math inline">\(\epsilon(n) = [n = 1]\)</span>。即这个单位元函数当 <span class="math inline">\(n = 1\)</span> 时返回 <span class="math inline">\(1\)</span>，当 <span class="math inline">\(n\not=1\)</span> 时返回 <span class="math inline">\(0\)</span>。 <span class="math display">\[
\begin{aligned}
f * \epsilon &amp;= \sum_{d\mid n} f(d)\epsilon\left(\frac nd\right)
\end{aligned}
\]</span> 不难验证其正确性：只有当 <span class="math inline">\(d = n\)</span> 时 <span class="math inline">\(\epsilon(n/d)\)</span> 才等于 <span class="math inline">\(1\)</span>，只保留了 <span class="math inline">\(f(n)\)</span> 这一项。</p></li>
<li><p>狄利克雷逆元：<span class="math inline">\(f^{-1}*f=\epsilon\)</span>。考虑如何求这个逆元： <span class="math display">\[
\begin{aligned}
\epsilon &amp;= f^{-1}*f\\
\epsilon &amp;= \sum_{d\mid n}f^{-1}(d)f\left(\frac nd\right)\\
\epsilon(n) &amp;= f^{-1}(n)f(1) + \sum_{d\mid n\land d &lt; n} f^{-1}(d)f\left(\frac nd\right)\\
f^{-1}(n) &amp;=\frac1{f(1)}\left(\epsilon(n) -  \sum_{d\mid n\land d &lt; n} f^{-1}(d)f\left(\frac nd\right)\right)
\end{aligned}
\]</span> 于是这个逆元就被求出来了。不难发现只要 <span class="math inline">\(f\)</span> 满足 <span class="math inline">\(f(1)\not=0\)</span>，其就会具有逆元。</p></li>
</ol>
<h3 id="莫比乌斯函数">莫比乌斯函数</h3>
<p>在这之前可能需要回顾一下之前讲过的几个数论函数，下面将不会重复提及。</p>
<p>上面的 <span class="math inline">\(\mu(n)\)</span> 就是莫比乌斯函数。写得更清楚的定义为： <span class="math display">\[
\mu(n) = \begin{cases}
1&amp;n = 1\\
0&amp;n\text{ 含有平方因子}\\
(-1)^{\omega(n)}&amp;\omega(n)\text{ 为 }n\text{ 的本质不同质因子个数}
\end{cases}
\]</span> 同时其有一个等价的定义： <span class="math display">\[
\mu(n) = 1^{-1}(n)
\]</span> 即，<span class="math inline">\(\mu(n)\)</span> 为常函数 <span class="math inline">\(1(n)\)</span> 的狄利克雷逆元。这就意味着 <span class="math inline">\(\mu*1 = \epsilon\)</span>，所以 <span class="math display">\[
\sum_{d\mid n}\mu(d) = \epsilon(n) = [n = 1]
\]</span> 有一个常见的反演结论是： <span class="math display">\[
[i\perp j] = [\gcd(i,j) = 1] = \sum_{d\mid\gcd(i,j)}\mu(d)
\]</span> 这个意义应该是很好理解的，不赘述了。</p>
<p>下面还有一个常见反演结论（欧拉反演）： <span class="math display">\[
\varphi * 1= \operatorname{id}
\]</span> 证明：由于 <span class="math inline">\(\varphi\)</span> 为积性函数，所以我们只需证明 <span class="math inline">\(n = p^c\)</span> 时其成立即可。 <span class="math display">\[
\begin{aligned}
\varphi * 1 &amp;= \sum_{d\mid n}\varphi(d)\\
&amp;= \sum_{i = 0}^c\varphi(p^i)\\
&amp;= 1 + p^0(p - 1) + p^1(p -1) + \cdots + p^{c - 1}(p - 1)\\
&amp;= p^c\\
&amp;= \operatorname{id}
\end{aligned}
\]</span> 另外，两边同时卷 <span class="math inline">\(\mu\)</span> 可以得到 <span class="math display">\[
\varphi = \operatorname{id}*\mu = \sum_{d\mid n}d\mu\left(\frac nd\right)
\]</span></p>
<p><span class="math inline">\(\mu\)</span> 的求法见下文线性筛部分。</p>
<h3 id="莫比乌斯反演公式">莫比乌斯反演公式</h3>
<h4 id="基本形式-1">基本形式</h4>
<p>内容是，已知两数论函数 <span class="math inline">\(f(n)\)</span>，<span class="math inline">\(g(n)\)</span>： <span class="math display">\[
f(n) = \sum_{d\mid n}g(d)\iff g(n) = \sum_{d\mid n}\mu\left(\frac nd\right)f(d)
\]</span> 这个公式被称为莫比乌斯反演公式（Möbius inversion formula），用狄利克雷卷积表示就是 <span class="math display">\[
f = g * 1\iff g = f * \mu
\]</span> 写成狄利克雷卷积的形式就好证明了，直接左边卷上 <span class="math inline">\(\mu\)</span> 就能得到右边。</p>
<h4 id="扩展形式">扩展形式</h4>
<p>乘积形式的： <span class="math display">\[
f(n) = \prod_{d\mid n}g(d) \iff g(n) = \prod f(d)^{\mu(\frac nd)},\forall n &gt; 1
\]</span> 证明：两边同时取对数： <span class="math display">\[
\begin{aligned}
\ln f(n) &amp;= \sum_{d\mid n}\ln g(d)\\
\ln g(n) &amp;= \sum_{d\mid n}\ln f(d)\mu\left(\frac nd\right)\\
g(n) &amp;= \prod_{d\mid n}f(d)^{\mu(\frac nd)}
\end{aligned}
\]</span> 倍数形式的： <span class="math display">\[
f(n) = \sum_{n\mid d}g(d)\iff g(n) = \sum_{n\mid d}\mu\left(\frac dn\right)f(d)
\]</span> 证明： <span class="math display">\[
\begin{aligned}
&amp;\sum_{n\mid d}\mu\left(\frac dn\right)f(d)\\
=&amp;\sum_{k= 1}^\infty\mu(k)f(kn) = \sum_{k = 1}^\infty\mu(k)\sum_{kn\mid d}g(d)\\
=&amp;\sum_{n\mid d}g(d)\sum_{k\mid \frac{d}{n}}\mu(k)= \sum_{n\mid d}g(d)\epsilon\left(\frac dn\right)\\
=&amp;g(n)
\end{aligned}
\]</span> 将 <span class="math inline">\(d\)</span> 表示成 <span class="math inline">\(kn\)</span> 的形式，然后将左边的式子代入。之后交换枚举顺序变为枚举 <span class="math inline">\(n\)</span> 的倍数然后反求 <span class="math inline">\(k\)</span>，最后发现就是 <span class="math inline">\(\epsilon\)</span>。</p>
<h3 id="莫比乌斯反演与容斥的关系">莫比乌斯反演与容斥的关系</h3>
<p>参考了论文哥的博客。</p>
<p>首先根据算术基本定理，将一个 <span class="math inline">\(n\)</span> 分解为 <span class="math inline">\(p_i^{k_i}\)</span> 的结构，然后对于一个数论函数 <span class="math inline">\(f\)</span>，定义其 zeta 变换 <span class="math inline">\(f\zeta\)</span>： <span class="math display">\[
f\zeta(n) = \sum_{d\mid n}f(d)
\]</span> 其实质是枚举了 <span class="math inline">\(k_i\)</span> 表示中的每一维都不大于自己的数，相当于一个高维前缀和。（其实这个就是狄利克雷前缀和，<a href="https://www.luogu.com.cn/problem/P5495">P5495 Dirichlet 前缀和</a>）求这个东西的时候可以像 FMT 一样，类似埃筛的 <span class="math inline">\(O(n\log\log n)\)</span>。</p>
<p>然后如何从高维前缀和还原成单点的值呢？考虑使用容斥原理，回顾一下高维前缀和的式子。需要枚举每一维相同或者小 <span class="math inline">\(1\)</span> 的数，以此决定容斥系数。定义 <span class="math display">\[
\mu(n) = \prod_{i = 1}^\infty (-1)^{[e_i = 1]}0^{[e_k &gt; 1]}
\]</span> 即：某一维为 <span class="math inline">\(0\)</span> 时，对函数值没有影响，某一维为 <span class="math inline">\(1\)</span> 时，函数值乘上 <span class="math inline">\(-1\)</span>，某一维大于 <span class="math inline">\(1\)</span> 时，函数值为 <span class="math inline">\(0\)</span>。否则若 <span class="math inline">\(n\)</span> 为 <span class="math inline">\(c\)</span> 个质数的积，则 <span class="math inline">\(\mu(n) = (-1)^c\)</span>。</p>
<p>我们枚举 <span class="math inline">\(d\mid n\)</span>，用 <span class="math inline">\(\dfrac nd\)</span> 找到每一维的差，再用 <span class="math inline">\(\mu\)</span> 找到对应的容斥系数，即： <span class="math display">\[
f(n) = \sum_{d\mid n}\mu\left(\frac nd\right)f\zeta(d)
\]</span> 把这个变换称为莫比乌斯变换，即 <span class="math display">\[
f\mu(n) = \sum_{d\mid n}\mu\left(\frac nd\right)f(d)
\]</span> 而 <span class="math inline">\(f\zeta\mu = f\)</span>。</p>
<p>所以本质上，莫比乌斯反演是一个容斥的过程。<span class="math inline">\(\mu\)</span> 充当着容斥系数这一角色。</p>
<h3 id="应用">应用</h3>
<p>下面放几个莫比乌斯反演的经典应用。假定 <span class="math inline">\(n\ge m\)</span>。</p>
<h4 id="典例-0">典例 0</h4>
<p><span class="math display">\[
\sum_{i =1 }^n\gcd(i,n) = \sum_{d\mid n}d\varphi(n/d)
\]</span></p>
<p>对应例题<a href="https://www.luogu.com.cn/problem/P2303">P2303 [SDOI2012] Longge 的问题</a>。</p>
<p>这里是一个比较常用的技巧：有很多的 <span class="math inline">\(\gcd(i,n)\)</span> 都是一样的，我们枚举 <span class="math inline">\(\gcd\)</span>：<span class="math inline">\(\displaystyle\sum_{d\mid n}d\sum_{i= 1}^n[\gcd(i, n)= d]\)</span>，然后化为 <span class="math inline">\(\gcd(i,j) = 1\)</span> 的形式：<span class="math inline">\(\displaystyle\sum_{d\mid n}d\sum_{i=1}^{n/d}[\gcd(i,n/d)=1]\)</span>，注意到右边那个东西实际上就是 <span class="math inline">\(\varphi(n/d)\)</span>，所以就化简完了。</p>
<h4 id="典例-1">典例 1</h4>
<p><span class="math display">\[
\sum_{i = 1}^n\sum_{j = 1}^m[\gcd(i,j) = k] = \sum_{d=1}^{\lfloor \frac nk\rfloor}\mu(d)\left\lfloor\frac{n}{kd}\right\rfloor\left\lfloor\frac{m}{kd}\right\rfloor
\]</span></p>
<p>对应例题<a href="https://www.luogu.com.cn/problem/P3455">P3455 [POI2007]ZAP-Queries</a>。</p>
<p>简要推导：首先<strong>将其化为 <span class="math inline">\(\gcd(i, j) = 1\)</span> 的形式</strong>，得到 <span class="math inline">\(\displaystyle\sum_{i = 1}^{n'}\sum_{j = 1}^{m'}\sum_{d\mid\gcd(i,j)}\mu(d)\)</span>，然后写成枚举 <span class="math inline">\(d\)</span> 的形式：<span class="math inline">\(\displaystyle\sum_{i = 1}^{n'}\sum_{j = 1}^{m'}\sum_{d = 1}[d\mid\gcd(i,j)]\mu(d)\)</span>，再调换一下求和顺序：<span class="math inline">\(\displaystyle\sum_{d=1}^{\min(n',m')}\mu(d)\sum_{i = 1}^{n'}\sum_{j = 1}^{m'}[d\mid\gcd(i,j)]\)</span>。最后的式子即要求 <span class="math inline">\(i,j\)</span> 同为 <span class="math inline">\(d\)</span> 的倍数，所以最终得到答案。</p>
<h4 id="典例-2">典例 2</h4>
<p><span class="math display">\[
\sum_{i = 1}^n\sum_{j = 1}^m[\gcd(i,j) \in P] = \sum_{T = 1}^n\left\lfloor\frac{n}{T}\right\rfloor\left\lfloor\frac{m}{T}\right\rfloor\sum_{k\mid T\land k\in P}\mu\left(\frac Tk\right)
\]</span> 其中 <span class="math inline">\(P\)</span> 为质数集。对应例题<a href="https://www.luogu.com.cn/problem/P2257">P2257 YY的GCD</a>。</p>
<p>简要推导：首先枚举这个质数 <span class="math inline">\(k\)</span>，然后像上一题一样化简可以得到 <span class="math inline">\(\displaystyle\sum_{k\in P}\sum_{d=1}^{\lfloor \frac nk\rfloor}\mu(d)\left\lfloor\frac{n}{kd}\right\rfloor\left\lfloor\frac{m}{kd}\right\rfloor\)</span>。现在仍然不够快，接下来<strong>巧妙换元令 <span class="math inline">\(T = kd\)</span></strong>，然后调换枚举顺序改为枚举 <span class="math inline">\(T\)</span>：<span class="math inline">\(\displaystyle\sum_{T= 1}^n\left\lfloor\frac{n}{T}\right\rfloor\left\lfloor\frac{m}{T}\right\rfloor\sum_{k\mid T,k\in P}\mu\left(\frac Tk\right)\)</span>。后者可以预处理，然后套整除分块即可。</p>
<h4 id="典例-3">典例 3</h4>
<p><span class="math display">\[
\sum_{i = 1}^n\sum_{j = 1}^m\operatorname{lcm}(i, j) = \sum_{d = 1}^nd\sum_{k = 1}^{\lfloor\frac nd\rfloor}\mu(k)k^2\sum_{i = 1}^{\lfloor\frac{n}{kd}\rfloor}\sum_{j = 1}^{\lfloor\frac{m}{kd}\rfloor}ij
\]</span></p>
<p>对应例题<a href="https://www.luogu.com.cn/problem/P1829">P1829 [国家集训队]Crash的数字表格 / JZPTAB</a>。</p>
<p>简要推导：<span class="math inline">\(\displaystyle\sum_{i = 1}^n\sum_{j = 1}^m\frac{ij}{\gcd(i, j)}\)</span>，然后枚举 gcd，变成 <span class="math inline">\(\displaystyle\sum_{d = 1}^n\sum_{i = 1}^n\sum_{j = 1}^m\frac{ij}{d}[\gcd(i,j) = d]\)</span>，然后是经典反演，变成 <span class="math inline">\(\displaystyle\sum_{d = 1}^nd\sum_{i = 1}^{\lfloor\frac nd\rfloor}\sum_{j = 1}^{\lfloor\frac md\rfloor}ij\sum_{k\mid \gcd(i,j)}\mu(k)\)</span>，再然后调换顺序枚举 <span class="math inline">\(k\)</span>，<span class="math inline">\(\displaystyle\sum_{d = 1}^nd\sum_{k = 1}^{\lfloor\frac nd\rfloor}\mu(k)\sum_{i = 1}^{\lfloor\frac nd\rfloor}\sum_{j = 1}^{\lfloor\frac md\rfloor}ij[k\mid i][k\mid j]\)</span>，最后得到 <span class="math inline">\(\displaystyle\sum_{d = 1}^nd\sum_{k = 1}^{\lfloor\frac nd\rfloor}\mu(k)k^2\sum_{i = 1}^{\lfloor\frac{n}{kd}\rfloor}\sum_{j = 1}^{\lfloor\frac{m}{kd}\rfloor}ij\)</span>。这个东西的后半坨可以 <span class="math inline">\(O(1)\)</span>，然后就是套两层整除分块的事情了。</p>
<h4 id="典例-4">典例 4</h4>
<p><span class="math display">\[
\sum_{i=1}^n\sum_{j=1}^m\sigma_0(ij) = \sum_{d=1}^n\mu(d)F(\lfloor n / d\rfloor)F(\lfloor m /d \rfloor)
\]</span></p>
<p>其中，<span class="math inline">\(F(n) = \displaystyle\sum_{i=1}^n\left\lfloor\frac ni\right\rfloor = \sum_{i=1}^n\sigma_0(i)\)</span>。推导：首先是一个经典结论，证明见下文： <span class="math display">\[
\sigma_0(xy) = \sum_{i\mid x}\sum_{j\mid y}[i\perp j]
\]</span> 然后就可以开始反演了：<span class="math inline">\(\displaystyle\sum_{i=1}^n\sum_{j=1}^m\sigma_0(i,j) = \sum_{i=1}^n\sum_{j=1}^m\sum_{x\mid i}\sum_{y\mid j}[\gcd(x,y) = 1]\)</span>，然后调换一下内外层求和顺序有 <span class="math inline">\(\displaystyle\sum_{i=1}^n\sum_{j=1}^m[\gcd(i,j) = 1]\left\lfloor\frac ni\right\rfloor\left\lfloor \frac mj\right\rfloor\)</span>。将 <span class="math inline">\([\gcd(i,j) = 1]\)</span> 用 <span class="math inline">\(\mu\)</span> 来化开之后变为 <span class="math inline">\(\displaystyle\sum_{i=1}^n\sum_{j=1}^m\left\lfloor\frac ni\right\rfloor\left\lfloor \frac mj\right\rfloor\sum_{d\mid i,d\mid j}\mu(d)\)</span>，再将 <span class="math inline">\(d\)</span> 提到最外面就有 <span class="math inline">\(\displaystyle\sum_{d=1}^n\mu(d)\left(\sum_{d\mid i, i\le n}\sum_{d\mid j,j\le m}\left\lfloor\frac ni\right\rfloor\left\lfloor \frac mj\right\rfloor\right)\)</span>，里面直接再除以个 <span class="math inline">\(d\)</span> 就有上面那个式子了。</p>
<p>至于为什么 <span class="math inline">\(\displaystyle\sum_{i=1}^n\left\lfloor\frac ni\right\rfloor = \sum_{i=1}^n\sigma_0(i)\)</span>，分析一下 <span class="math inline">\(\sigma_0\)</span> 是如何被贡献出来的即可。</p>
<h4 id="其余例题">其余例题</h4>
<blockquote>
<p>例题 1：<a href="https://www.luogu.com.cn/problem/P1447">P1447 [NOI2010] 能量采集</a>：求 <span class="math display">\[
\sum_{i=1}^n\sum_{j=1}^m(2\gcd(i,j) - 1)
\]</span></p>
</blockquote>
<p>显然将式子化简就变成 <span class="math inline">\(2\displaystyle\sum_{i=1}^n\sum_{j=1}^m\gcd(i,j)-nm\)</span>。现在考虑 <span class="math inline">\(\sum_i\sum_j\gcd(i,j)\)</span> 怎么求。考虑枚举之：<span class="math inline">\(\sum_{d}d\sum_i\sum_j[\gcd(i,j)=d]\)</span>，发现后面就是上面的典例 <span class="math inline">\(1\)</span>，可以 <span class="math inline">\(O(n\sqrt n)\)</span> 干掉。但是其可以进一步优化。考虑答案式 <span class="math inline">\(\displaystyle\sum_{d=1}^nd\sum_{k=1}^{\lfloor n /d\rfloor}\mu(k)\lfloor n/kd\rfloor\lfloor m/kd\rfloor\)</span>。用典例 <span class="math inline">\(2\)</span> 的换元，换得 <span class="math inline">\(\displaystyle\sum_{T=1}^{n}\sum_{d\mid T}d\mu(T/d)\lfloor n / T\rfloor\lfloor m / T\rfloor\)</span>，注意到前面的经典结论：<span class="math inline">\(\phi = \mu*\mathrm{id}\)</span>，所以可以写成 <span class="math inline">\(\displaystyle\sum_{T=1}^n\lfloor n / T\rfloor\lfloor m / T\rfloor\phi(T)\)</span>。这样就变成 <span class="math inline">\(O(n) - O(\sqrt n)\)</span> 的了。</p>
<blockquote>
<p>例题 <span class="math inline">\(2\)</span>：禁止查看。</p>
</blockquote>
<p><del>禁止查看。</del></p>
<blockquote>
<p>例题 <span class="math inline">\(3\)</span>：<a href="https://www.luogu.com.cn/problem/P3312">洛谷 P3312 [SDOI2014]数表</a></p>
<p><span class="math inline">\(Q\le 2\times 10^4\)</span> 次询问，给定 <span class="math inline">\(n,m\le 10^5,a\)</span>，求 <span class="math display">\[
\sum_{i = 1}^n\sum_{j = 1}^m\sigma(\gcd(i,j))\times[\sigma(\gcd(i,j)) \le a]\bmod 2^{31}
\]</span></p>
</blockquote>
<p>不妨先忽略 <span class="math inline">\(\sigma(\gcd(i,j)) \le a\)</span> 的限制来化简式子： <span class="math display">\[
\begin{aligned}
&amp;\sum_{i = 1}^n\sum_{j = 1}^m\sigma(\gcd(i,j))\\
=&amp;\sum_{d = 1}^n\sigma(d)\sum_{i = 1}^{\lfloor n/d\rfloor}\sum_{j = 1}^{\lfloor m / d\rfloor}\sum_{x\mid i\land x \mid j}\mu(x)\\
=&amp;\sum_{d = 1}^n\sigma(d)\sum_{x = 1}^{\lfloor n / d\rfloor}\lfloor n / dx\rfloor\lfloor m/ dx\rfloor\mu(x)\\
=&amp;\sum_{T = 1}^n\lfloor n / T\rfloor\lfloor m / T\rfloor\sum_{d\mid T}\sigma(d)\mu(T/d)
\end{aligned}
\]</span> 最后一步换了个元令 <span class="math inline">\(T = dx\)</span>。若再考虑让 <span class="math inline">\(f(T) = \displaystyle\sum_{d\mid T}\sigma(d)\mu(T/d)\)</span>，则要求的东西就被转化为了 <span class="math display">\[
\sum_{T = 1}^n\lfloor n / T\rfloor\lfloor m / T\rfloor f(T)
\]</span> 然后注意到，<span class="math inline">\(\sigma(d)\)</span> 能对 <span class="math inline">\(f(T)\)</span> 产生贡献当且仅当 <span class="math inline">\(\sigma(d)\le a\)</span>，那么不妨离线所有询问然后将询问按 <span class="math inline">\(a\)</span> 排序，再将预处理好的 <span class="math inline">\(\sigma(d)\)</span> 从小到大排序，用树状数组维护 <span class="math inline">\(f\)</span>，每次加 <span class="math inline">\(\sigma(d)\mu(T / d)\)</span> 都会使得 <span class="math inline">\(d\)</span> 的倍数对应的 <span class="math inline">\(f(T)\)</span> 增加。对于每个询问直接整除分块。时间复杂度 <span class="math inline">\(O(q\sqrt n\log n + n \log^2 n)\)</span>。</p>
<blockquote>
<p>例题 <span class="math inline">\(4\)</span>：<a href="https://www.luogu.com.cn/problem/CF1139D">CF1139D Steps to One</a></p>
<p>给定正整数 <span class="math inline">\(m\le 10^5\)</span>，初始空数列，每次随机一个 <span class="math inline">\(1\sim m\)</span> 的整数加在数列末尾，数列的 <span class="math inline">\(\gcd = 1\)</span> 时停止。问期望长度，对 <span class="math inline">\(10^9 + 7\)</span> 取模。</p>
</blockquote>
<p>不妨设 <span class="math inline">\(f_i\)</span> 为当前数列 <span class="math inline">\(\gcd\)</span> 为 <span class="math inline">\(i\)</span> 时，期望的剩余步数。则我们有朴素转移： <span class="math display">\[
f_i = \frac 1m\sum_{j=1}^mf_{\gcd(j, i)} + 1
\]</span> 边界条件为 <span class="math inline">\(f_1 = 0\)</span>，答案即为 <span class="math inline">\(\dfrac 1m\sum f_i\)</span>。需要注意特判 <span class="math inline">\(\gcd(i,j) = i\)</span> 的情况，解个方程后发现就是 <span class="math display">\[
f_i = \frac{1 + \frac1m\sum_{j=1,i\not\mid j}^m f_{\gcd(i,j)}}{1 - \lfloor\frac{m}{i}\rfloor}
\]</span> <span class="math inline">\(O(m^2\log m)\)</span> 显然有点寄，套路地枚举 <span class="math inline">\(g = \gcd(i,j)\)</span>，令 <span class="math inline">\(c(i,g)\)</span> 表示 <span class="math inline">\(\sum_{x=1}^m[\gcd(x, i) = g]\)</span>，则 <span class="math display">\[
f_i = \frac{1 + \frac1m \sum_{g\mid i,g\ne i}f_gc(i,g)}{1 - \lfloor\frac mi\rfloor}
\]</span> 现在推导 <span class="math inline">\(c\)</span>： <span class="math display">\[
\begin{aligned}
c(i,g) &amp;= \sum_{x=1}^m[\gcd(x,i) = g]\\
&amp;=\sum_{x' =1}^{\lfloor \frac mg\rfloor}[\gcd(x', i/g) = 1]\\
&amp;=\sum_{x'=1}^{\lfloor\frac mg\rfloor}\sum_{d\mid \gcd(x', i / g)}\mu(d)\\
&amp;=\sum_{d\mid \frac ig}\mu(d)\left\lfloor\frac{m}{gd} \right\rfloor
\end{aligned}
\]</span> 于是求 <span class="math inline">\(c(i,g)\)</span> 的时间复杂度为 <span class="math inline">\(O(\sqrt{\frac ig})\)</span>。设总时间复杂度为 <span class="math inline">\(T(m)\)</span>，则 <span class="math display">\[
T(m) = \sum_{i=2}^m\sum_{g\mid i}O\left(\sqrt{\frac ig}\right) = \sum_{i=2}^m\sum_{j\mid i}O(\sqrt j) \sim m\int_1^mj^{-0.5}\mathrm{d}j = O(m\sqrt m)
\]</span> 但是这题还有另一种做法，即直接从期望开推： <span class="math display">\[
\begin{aligned}
E(n) &amp;= \sum_{i\ge 1}P(i = n)\times i\\
&amp;= \sum_{i\ge 1}P(i = n)\sum_{j=1}^i 1\\
&amp;=\sum_{j\ge 1}\sum_{i\ge j}P(n = i)\\
&amp;=\sum_{i\ge 1}P(n\ge i)\\
&amp;= 1 + \sum_{i\ge1}P(n&gt;i)
\end{aligned}
\]</span> 求 <span class="math inline">\(P(n &gt; i)\)</span> 的时候考虑 <span class="math inline">\(\gcd_{j=1}^{n}\{a_j\} = 1\)</span> 的时候就会结束，简单容斥一下再反演： <span class="math display">\[
\begin{aligned}
P(n&gt;i) &amp;= P\left(\gcd_{j=1}^i\{a_i\} &gt;1\right)\\
&amp;= 1 - P\left(\gcd_{j=1}^i\{a_i\} =1\right)\\
&amp;= 1 - \frac{\sum_{d=1}^m\mu(d)\lfloor\frac md\rfloor^i}{m^i}\\
&amp;= -\frac{\sum_{d=2}^m\mu(d)\lfloor\frac md\rfloor^i}{m^i}
\end{aligned}
\]</span> 回代上面的式子，有 <span class="math display">\[
\begin{aligned}
E(n) &amp;= 1 + \sum_{i\ge 1} P(n &gt; i)\\
&amp;= 1 - \sum_{i\ge 1}\frac{\sum_{d=2}^m\mu(d)\lfloor\frac md\rfloor^i}{m^i}\\
&amp;= 1 - \sum_{i\ge 1}\frac{1}{m^i}\sum_{d=2}^m\mu(d)\left\lfloor\frac md\right\rfloor^i\\
&amp;= 1 - \sum_{d=2}^m\mu(d)\sum_{i\ge 1}\left(\frac{\lfloor\frac md\rfloor}{m}\right)^i&amp;\text{recall the formula }x + x^2+\cdots=\frac{x}{1-x}\\
&amp;= 1 - \sum_{d=2}^m\mu(d)\frac{\lfloor\frac md\rfloor}{m - \lfloor\frac md\rfloor}
\end{aligned}
\]</span> 可以 <span class="math inline">\(O(m)\)</span>，但也可以上杜教做到 <span class="math inline">\(O(m^{2/3})\)</span> 但没必要。</p>
<blockquote>
<p>例题 <span class="math inline">\(5\)</span>：<a href="https://www.luogu.com.cn/problem/CF1559E">CF1559E Mocha and Stars</a></p>
<p>求满足如下条件的序列 <span class="math inline">\((a_1, a_2, \cdots , a_n)\)</span> 的数量：</p>
<ul>
<li><span class="math inline">\(\forall i\in[1, n], a_i\in[l_i, r_i]\)</span>；</li>
<li><span class="math inline">\(\sum a_i\le m\)</span>；</li>
<li><span class="math inline">\(\gcd(a_1, a_2, \cdots, a_n) = 1\)</span></li>
</ul>
<p><span class="math inline">\(2\le n\le 50\)</span>，<span class="math inline">\(1\le m\le 10^5\)</span>，答案对 <span class="math inline">\(998244353\)</span> 取模。</p>
</blockquote>
<p>不考虑 <span class="math inline">\(\gcd\)</span> 的限制，发现其为一个背包。令 <span class="math inline">\(f_{i, j}\)</span> 为前 <span class="math inline">\(i\)</span> 个物品，背包容量为 <span class="math inline">\(j\)</span> 的方案数，则有转移方程： <span class="math display">\[
f_{i, j} = \sum_{k = l_i}^{r_i}f_{i - 1, j - k}
\]</span> 这样直接去做是 <span class="math inline">\(O(nm^2)\)</span> 的，发现转移可以使用前缀和优化，具体设 <span class="math inline">\(s_{i, j}\)</span> 表示 <span class="math display">\[
s_{i, j} = \sum_{k = 0}^jf_{i, k}
\]</span> 然后就有了转移方程 <span class="math display">\[
f_{i, j} = s_{i - 1, j - l_i} - s_{i - 1, j - r_i - 1}
\]</span> 背包部分的复杂度为 <span class="math inline">\(O(nm)\)</span>。接下来考虑 <span class="math inline">\(\gcd\)</span> 的限制，对于这种多个的情况一样可以考虑反演： <span class="math display">\[
\begin{aligned}
&amp;\sum_{a_1=l_1}^{r_1}\sum_{a_2=l_2}^{r_2}\cdots\sum_{a_n=l_n}^{r_n}[\gcd(a_1,\cdots,a_n)=1]\left[\sum_{i = 1}^na_i\le m\right]\\
=&amp;\sum_{a_1=l_1}^{r_1}\sum_{a_2=l_2}^{r_2}\cdots\sum_{a_n=l_n}^{r_n}\left[\sum_{i = 1}^na_i\le m\right]\sum_{d \mid \gcd(a_1,\cdots,a_n)}\mu(d)\\ =&amp;\sum_{a_1=l_1}^{r_1}\sum_{a_2=l_2}^{r_2}\cdots\sum_{a_n=l_n}^{r_n}\left[\sum_{i = 1}^na_i\le m\right]\sum_{d\mid a_1,\cdots,d \mid a_n}\mu(d)\\
=&amp;\sum_{d=1}^m\mu(d)\sum_{a_1=\lceil\frac{l_1}{d}\rceil}^{\lfloor\frac{r_1}{d}\rfloor}\sum_{a_2=\lceil\frac{l_2}{d}\rceil}^{\lfloor\frac{r_2}{d}\rfloor}\cdots\sum_{a_n=\lceil\frac{l_n}{d}\rceil}^{\lfloor\frac{r_n}{d}\rfloor}\left[\sum_{i = 1}^na_i\le \left\lfloor\frac m d\right\rfloor\right]
\end{aligned}
\]</span> 然后枚举 <span class="math inline">\(d\in[1, m]\)</span>，发现其就是个子问题，<span class="math inline">\(O(nm\log m)\)</span> 解决。对于 <span class="math inline">\(\mu(d) = 0\)</span> 的情况跳过还可以加速。</p>
<blockquote>
<p>例题 <span class="math inline">\(6\)</span>：<a href="https://www.luogu.com.cn/problem/P6271">P6271 [湖北省队互测2014]一个人的数论</a></p>
<p>定义 <span class="math inline">\(f_m(n)\)</span> 为所有小于 <span class="math inline">\(n\)</span> 且与 <span class="math inline">\(n\)</span> 互素的正整数的 <span class="math inline">\(m\)</span> 次方之和。给定 <span class="math inline">\(m\)</span> 的值和 <span class="math inline">\(n\)</span> 的质因数分解式，求 <span class="math inline">\(f_m(n)\bmod 10^9 + 7\)</span> 的值。</p>
<p>若 <span class="math display">\[
n = \prod_{i = 1}^{w}p_i^{\alpha_i}
\]</span> 有 <span class="math inline">\(1\le w \le 1000\)</span>，<span class="math inline">\(2\le p_i\le 10^9\)</span>，<span class="math inline">\(1\le \alpha_i\le 10^9\)</span>，<span class="math inline">\(0\le m \le 100\)</span>。</p>
</blockquote>
<p>一道非常牛逼的题。首先明确要求的内容为 <span class="math display">\[
\sum_{i=1}^{n-1}i^m[\gcd(i, n) = 1]
\]</span> 然后直接开始反演： <span class="math display">\[
\begin{aligned}
\sum_{i=1}^{n-1}i^m[\gcd(i, n) = 1] &amp;= \sum_{i=1}^{n}i^m[\gcd(i, n) = 1]\\
&amp;=\sum_{i=1}^ni^m\sum_{d\mid \gcd(i,n)}\mu(d)\\
&amp;=\sum_{d\mid n}\mu(d)\sum_{i=1}^{\frac nd}(id)^m\\
&amp;=\sum_{d\mid n}\mu(d)d^m\sum_{i=1}^{\frac nd} i^m
\end{aligned}
\]</span> 然后似乎就化不动了。。但是注意到式子里有形如 <span class="math inline">\(f(n) = \displaystyle\sum_{i=1}^n i^m\)</span>，即自然数幂之和，其必然为关于 <span class="math inline">\(n\)</span> 的 <span class="math inline">\(m + 1\)</span> 次多项式，因为 <span class="math inline">\(m\)</span> 很小所以可以暴力将 <span class="math inline">\(f(x) = \displaystyle\sum_{i=0}^{m+1}f_ix^i\)</span> 的系数消元出来。然后回代一下式子： <span class="math display">\[
\begin{aligned}
&amp;\sum_{d\mid n}\mu(d)d^m\sum_{i=1}^{\lfloor\frac nd\rfloor} i^m\\
=&amp;\sum_{d\mid n}\mu(d)d^m\sum_{i=1}^{m+1}f_i\left(\frac nd\right)^{i}\\
=&amp;\sum_{i=1}^{m+1}f_i\sum_{d\mid n}\mu(d)d^m\left(\frac nd\right)^{i}
\end{aligned}
\]</span> 发现后面那坨是积性函数的卷积，所以可以对于所有的 <span class="math inline">\(p_i^{\alpha_i}\)</span> 求一遍然后乘起来，现在考虑怎么快速求之。</p>
<p>注意到有个东西叫 <span class="math inline">\(\mu\)</span>，所以会产生贡献的只有 <span class="math inline">\(d = 1\)</span> 和 <span class="math inline">\(d = p_i\)</span> 的情况，所以要算的实际就是 <span class="math inline">\(p_i^{\alpha_ii} - p_i^{m + \alpha_ii - i}\)</span>。问题解决了，时间复杂度 <span class="math inline">\(O(m^3 + m(m + w))\)</span>。</p>
<h3 id="常见结论方法">常见结论/方法</h3>
<ul>
<li><p><strong>写代码的时候注意 <code>long long</code> 和取模的问题，很容易出岔子。</strong></p></li>
<li><p>化简式子的时候可以将无关变量提前： <span class="math display">\[
\sum_{i = 1}^nf(n)\sum_{j = 1}^mk\times g(n) = \sum_{i = 1}^nf(n)k\sum_{j = 1}^mg(n)
\]</span></p></li>
<li><p>交换枚举顺序： <span class="math display">\[
\sum_{i = 1}^nf(n)\sum_{d\mid i}g(d) = \sum_{d = 1}^ng(d)\sum_{i = 1}^{\lfloor\frac nd\rfloor}f(id)
\]</span></p></li>
<li><p>尝试构造 <span class="math inline">\(\epsilon = [n = 1]\)</span>： <span class="math display">\[
\begin{aligned}
&amp;\sum_{i = 1}^n\sum_{j = 1}^mf(\gcd(i, j))\\
=&amp;\sum_{d = 1}^n\sum_{i = 1}^n\sum_{j = 1}^mf(d)[\gcd(i,j) = d]\\
=&amp;\sum_{d = 1}^nf(d)\sum_{i = 1}^n\sum_{j = 1}^m[\gcd(i,j) = d]
\end{aligned}
\]</span> 之后就懒得写了。</p></li>
<li><p><span class="math inline">\(\operatorname{lcm}(i,j) = \dfrac{ij}{\gcd(i,j)}\)</span></p>
<p>过于平凡，不写。</p></li>
<li><p>巧妙换元减少枚举数量： <span class="math display">\[
\sum_{P(k)}\sum_{d = 1}^{\lfloor \frac nk\rfloor}\mu(d)\left\lfloor\frac{n}{kd}\right\rfloor\left\lfloor\frac{m}{kd}\right\rfloor = \sum_{T = 1}^n\left\lfloor\frac{n}{T}\right\rfloor\left\lfloor\frac{m}{T}\right\rfloor\sum_{k\mid T, P(k)}\mu\left(\frac Tk\right)
\]</span></p></li>
<li><p>除数函数的重要性质: <span class="math display">\[
d(xy) = \sum_{i\mid x}\sum_{j\mid y}[\gcd(i,j) = 1]
\]</span> 证明：考虑一一映射每个因子。</p>
<p>设 <span class="math inline">\(k\mid xy\)</span>，<span class="math inline">\(k\)</span> 中有因子 <span class="math inline">\(p^c\)</span>，我们强行规定先取 <span class="math inline">\(i\)</span> 中的 <span class="math inline">\(p\)</span>，除非不够，再去取 <span class="math inline">\(j\)</span> 中的 <span class="math inline">\(p\)</span>。这样子，如若我们要求 <span class="math inline">\(i\perp j\)</span>，则每个因子 <span class="math inline">\(k\)</span> 都唯一对应一个 <span class="math inline">\((i, j)\)</span>。命题得证。</p>
<blockquote>
<p>对于一般的除数函数 <span class="math inline">\(\sigma_k\)</span>，上述性质仍然可以扩展： <span class="math display">\[
\sigma_k(xy) = \sum_{i\mid x}\sum_{j\mid y}\left(\frac{x}{i}\right)^kj^k[\gcd(i,j) = 1]
\]</span> 证明依旧考虑上面的思路。可能写成这样会更好理解： <span class="math display">\[
\sigma_k(xy) = \sum_{i\mid x}\sum_{j\mid y}i^kj^k[\gcd(x / i, j) =1]
\]</span> 然后换一下 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(x / i\)</span> 就可以了。</p>
</blockquote></li>
<li><p>欧拉函数的某性质： <span class="math display">\[
\varphi(ab) = \varphi(a)\varphi(b)\frac{\gcd(a,b)}{\varphi(\gcd(a,b))}
\]</span> 证明：考虑唯一分解定理。对于某质因数 <span class="math inline">\(p\)</span>，若他在 <span class="math inline">\(a,b\)</span> 中都出现了，则 <span class="math inline">\(\varphi(a)\varphi(b)\)</span> 把两个 <span class="math inline">\(p\)</span> 变成了 <span class="math inline">\(p - 1\)</span>，乘上一个 <span class="math inline">\(\dfrac{\gcd(a,b)}{\varphi(\gcd(a,b))}\)</span> 可以将其修正过来。</p></li>
</ul>
<h2 id="筛法">筛法</h2>
<h3 id="埃筛">埃筛</h3>
<p>通过“<span class="math inline">\(x\)</span> 是合数，则 <span class="math inline">\(x\)</span> 的倍数也是合数”来减少标记次数，即只标记所有素数的倍数。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a aria-hidden="true" href="#cb3-1"></a><span class="dt">void</span> Eratosthenes() {</span>
<span id="cb3-2"><a aria-hidden="true" href="#cb3-2"></a>    isp[<span class="dv">0</span>] = isp[<span class="dv">1</span>] = <span class="dv">1</span>;</span>
<span id="cb3-3"><a aria-hidden="true" href="#cb3-3"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">2</span>; i &lt;= N; ++i) {</span>
<span id="cb3-4"><a aria-hidden="true" href="#cb3-4"></a>        <span class="cf">if</span> (!isp[i]) {</span>
<span id="cb3-5"><a aria-hidden="true" href="#cb3-5"></a>            prime[++totp] = i;</span>
<span id="cb3-6"><a aria-hidden="true" href="#cb3-6"></a>            <span class="cf">if</span> (<span class="dv">1</span><span class="bu">ll</span> * i * i &lt;= N)</span>
<span id="cb3-7"><a aria-hidden="true" href="#cb3-7"></a>                <span class="cf">for</span> (<span class="dt">int</span> j = i * i; j &lt;= N; j += i)</span>
<span id="cb3-8"><a aria-hidden="true" href="#cb3-8"></a>                    isp[j] = <span class="dv">1</span>;</span>
<span id="cb3-9"><a aria-hidden="true" href="#cb3-9"></a>        }</span>
<span id="cb3-10"><a aria-hidden="true" href="#cb3-10"></a>    }</span>
<span id="cb3-11"><a aria-hidden="true" href="#cb3-11"></a>    <span class="cf">return</span>;</span>
<span id="cb3-12"><a aria-hidden="true" href="#cb3-12"></a>}</span></code></pre></div>
<p>时间复杂度 <span class="math inline">\(O(n\log\log n)\)</span>，没有什么弔用，复杂度分析略（因为不会），唯一用处是可以拿来分析 Dirichlet 前缀和的复杂度。</p>
<h3 id="线性筛">线性筛</h3>
<p>又名欧拉筛，可以以线性的时间复杂度筛出给定值域内的素数。上文已经提到了如何用欧拉筛筛素数，但是欧拉筛的强大之处在于，其利用的<strong>每个合数被最小质因子筛去</strong>性质使得它可以同时求出积性函数的值。</p>
<h4 id="欧拉函数莫比乌斯函数">欧拉函数/莫比乌斯函数</h4>
<p>首先再次强调：<strong>每个合数 <span class="math inline">\(n\)</span> 会被其最小质因子 <span class="math inline">\(p\)</span> 筛去</strong>，下面令 <span class="math inline">\(n' = n / p\)</span>。</p>
<ul>
<li><p>对于 <span class="math inline">\(p\not\mid n'\)</span> 的情况，<span class="math inline">\(n'\)</span> 和 <span class="math inline">\(p\)</span> 必然互质，此时有 <span class="math inline">\(\varphi(n) = \varphi(n')\times \varphi(p) = (p - 1)\varphi(n')\)</span>。</p></li>
<li><p>否则对于 <span class="math inline">\(p\mid n'\)</span> 的情况，<span class="math inline">\(n'\)</span> 必然包含 <span class="math inline">\(n\)</span> 的所有质因子，拆开 <span class="math inline">\(\varphi(n)\)</span> 的表达式有 <span class="math display">\[
\begin{aligned}
\varphi(n) &amp;= n\times \prod \frac{p_i - 1}{p_i}\\
&amp;= p\times n'\times \prod\frac{p_i - 1}{p_i}\\
&amp;= p\times \varphi(n')
\end{aligned}
\]</span></p></li>
</ul>
<p>那么事情就变得明朗了，对于质数，<span class="math inline">\(\varphi(n) = n - 1\)</span>，对于合数，在筛的过程中按照上面的公式求就可以了。注意边界 <span class="math inline">\(\varphi(1) = 1\)</span>。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a aria-hidden="true" href="#cb4-1"></a><span class="dt">void</span> sieve() {</span>
<span id="cb4-2"><a aria-hidden="true" href="#cb4-2"></a>    phi[<span class="dv">1</span>] = <span class="dv">1</span>;</span>
<span id="cb4-3"><a aria-hidden="true" href="#cb4-3"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">2</span>; i &lt;= maxn; ++i) {</span>
<span id="cb4-4"><a aria-hidden="true" href="#cb4-4"></a>        <span class="cf">if</span> (!vis[i]) {</span>
<span id="cb4-5"><a aria-hidden="true" href="#cb4-5"></a>            phi[i] = i - <span class="dv">1</span>;</span>
<span id="cb4-6"><a aria-hidden="true" href="#cb4-6"></a>            p[++tot] = i;</span>
<span id="cb4-7"><a aria-hidden="true" href="#cb4-7"></a>        }</span>
<span id="cb4-8"><a aria-hidden="true" href="#cb4-8"></a>        <span class="cf">for</span> (<span class="dt">int</span> j = <span class="dv">1</span>; j &lt;= tot &amp;&amp; i * p[j] &lt;= maxn; ++j) {</span>
<span id="cb4-9"><a aria-hidden="true" href="#cb4-9"></a>            vis[i * p[j]] = <span class="dv">1</span>;</span>
<span id="cb4-10"><a aria-hidden="true" href="#cb4-10"></a>            <span class="cf">if</span> (i % p[j] == <span class="dv">0</span>) {</span>
<span id="cb4-11"><a aria-hidden="true" href="#cb4-11"></a>                phi[i * p[j]] = p[j] * phi[i];</span>
<span id="cb4-12"><a aria-hidden="true" href="#cb4-12"></a>                <span class="cf">break</span>;</span>
<span id="cb4-13"><a aria-hidden="true" href="#cb4-13"></a>            }</span>
<span id="cb4-14"><a aria-hidden="true" href="#cb4-14"></a>            phi[i * p[j]] = (p[j] - <span class="dv">1</span>) * phi[i];</span>
<span id="cb4-15"><a aria-hidden="true" href="#cb4-15"></a>        }</span>
<span id="cb4-16"><a aria-hidden="true" href="#cb4-16"></a>    }</span>
<span id="cb4-17"><a aria-hidden="true" href="#cb4-17"></a>    <span class="cf">return</span>;</span>
<span id="cb4-18"><a aria-hidden="true" href="#cb4-18"></a>}</span></code></pre></div>
<hr/>
<p>而于莫比乌斯函数，则相对更好考虑。还是令 <span class="math inline">\(n' = n / p\)</span>，<span class="math inline">\(p\)</span> 为 <span class="math inline">\(n\)</span> 的最小质因子。</p>
<p>对于质数，<span class="math inline">\(\mu(n) = -1\)</span>，对于合数，按照上面的方式分类讨论：</p>
<ul>
<li><span class="math inline">\(p\not\mid n'\)</span>，则 <span class="math inline">\(n'\)</span> 与 <span class="math inline">\(p\)</span> 一定互质，<span class="math inline">\(\mu(n) = -\mu(n')\)</span>。</li>
<li>否则 <span class="math inline">\(p\mid n'\)</span>，这说明 <span class="math inline">\(n\)</span> 里面至少有一个平方因子（<span class="math inline">\(p^2\)</span>），所以 <span class="math inline">\(\mu(n) = 0\)</span>。</li>
</ul>
<p>还是注意边界，<span class="math inline">\(\mu(1) = 1\)</span>，记不住的话考虑积性函数的性质。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a aria-hidden="true" href="#cb5-1"></a><span class="dt">void</span> sieve() {</span>
<span id="cb5-2"><a aria-hidden="true" href="#cb5-2"></a>    mu[<span class="dv">1</span>] = <span class="dv">1</span>;</span>
<span id="cb5-3"><a aria-hidden="true" href="#cb5-3"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">2</span>; i &lt;= N; ++i) {</span>
<span id="cb5-4"><a aria-hidden="true" href="#cb5-4"></a>        <span class="cf">if</span> (!vis[i]) {</span>
<span id="cb5-5"><a aria-hidden="true" href="#cb5-5"></a>            mu[i] = -<span class="dv">1</span>;</span>
<span id="cb5-6"><a aria-hidden="true" href="#cb5-6"></a>            prime[++tot] = i;</span>
<span id="cb5-7"><a aria-hidden="true" href="#cb5-7"></a>        }</span>
<span id="cb5-8"><a aria-hidden="true" href="#cb5-8"></a>        <span class="cf">for</span> (<span class="dt">int</span> j = <span class="dv">1</span>; j &lt;= tot &amp;&amp; i * prime[j] &lt;= N; ++j) {</span>
<span id="cb5-9"><a aria-hidden="true" href="#cb5-9"></a>            vis[i * prime[j]] = <span class="dv">1</span>;</span>
<span id="cb5-10"><a aria-hidden="true" href="#cb5-10"></a>            <span class="cf">if</span> (i % prime[j]) mu[i * prime[j]] = -mu[i];</span>
<span id="cb5-11"><a aria-hidden="true" href="#cb5-11"></a>            <span class="cf">else</span> <span class="cf">break</span>;</span>
<span id="cb5-12"><a aria-hidden="true" href="#cb5-12"></a>        }</span>
<span id="cb5-13"><a aria-hidden="true" href="#cb5-13"></a>    }</span>
<span id="cb5-14"><a aria-hidden="true" href="#cb5-14"></a>    <span class="cf">return</span>;</span>
<span id="cb5-15"><a aria-hidden="true" href="#cb5-15"></a>}</span></code></pre></div>
<p><del>当然一般是最后要做前缀和的，这个另说吧。</del></p>
<h4 id="除数函数">除数函数</h4>
<p>首先，若将 <span class="math inline">\(n\)</span> 唯一分解：<span class="math inline">\(\displaystyle n = \prod_{i=1}^sp_i^{\alpha_i}\)</span>，则有 <span class="math inline">\(d(n) = \displaystyle\prod_{i=1}^s(1 + \alpha_i)\)</span>。其组合意义为：每个质因子选不大于 <span class="math inline">\(\alpha_i\)</span> 个出来，其一定为 <span class="math inline">\(n\)</span> 的因数。</p>
<p>由于 <span class="math inline">\(n\)</span> 会被最小质因子 <span class="math inline">\(p\)</span> 筛去，所以还需要对每个数额外维护其最小质因子的幂次 <span class="math inline">\(f\)</span>。</p>
<ul>
<li>对于质数，<span class="math inline">\(d(n) = 2\)</span>，<span class="math inline">\(f(n) = 1\)</span>。</li>
<li>当 <span class="math inline">\(p\not\mid n'\)</span>，根据 <span class="math inline">\(d\)</span> 的积性，有 <span class="math inline">\(d(n) = 2d(n')\)</span>，<span class="math inline">\(f(n) = 1\)</span>。</li>
<li>否则，根据上面的公式有 <span class="math inline">\(\displaystyle d(n) = \frac{d(n')}{1 + f(n')} \times(2 + f(n’))\)</span>，<span class="math inline">\(f(n) = f(n') + 1\)</span>。</li>
</ul>
<hr/>
<p>对于 <span class="math inline">\(\sigma\)</span>，有如下公式：<span class="math inline">\(\sigma(n) = \displaystyle\prod_{i=1}^s\sum_{j=0}^{\alpha_i}p_i^j\)</span>。组合意义为：考虑每个质因子里面选不同的次数出来组合成这 <span class="math inline">\(d(n)\)</span> 个因数。</p>
<p>类似的，需要维护最小质因子的各次幂之和 <span class="math inline">\(g\)</span>：</p>
<ul>
<li>对于质数，<span class="math inline">\(\sigma(n) = g(n) = 1 + n\)</span>。</li>
<li>当 <span class="math inline">\(p\not\mid n'\)</span>，根据 <span class="math inline">\(\sigma\)</span> 的积性有 <span class="math inline">\(\sigma(n) = (p + 1)\sigma(n')\)</span>，<span class="math inline">\(g(n) = 1 + p\)</span>。</li>
<li>否则，根据上面的公式有 <span class="math inline">\(g(n) = pg(n') + 1\)</span>，<span class="math inline">\(\displaystyle \sigma(n) = \frac{\sigma(n')}{g(n')}\times g(n)\)</span>。</li>
</ul>
<p>代码就不放了，感受了上面的过程之后遇到题目可以自己推导。</p>
<p>而对于一般的 <span class="math inline">\(\sigma_k\)</span>，一样有公式 <span class="math inline">\(\sigma_k(n) = \displaystyle\prod_{i=1}^s\sum_{j=0}^{\alpha_i} p_i^{jk}\)</span>。同样维护一下 <span class="math inline">\(g\)</span> 即可。</p>
<h4 id="幂函数">幂函数</h4>
<p>当然，直接 <span class="math inline">\(O(n\log n)\)</span> 求幂函数也是可以的，但是某些时候时限可能会卡的很紧。</p>
<p>根据 <span class="math inline">\(\mathrm{id}_k\)</span> 的完全积性，对于质数处的点值快速幂一下，其他情况直接乘起来就没问题了。</p>
<h3 id="杜教筛">杜教筛</h3>
<p>杜教筛可以在<strong>低于线性</strong>的时间复杂度内求出一类<strong>积性函数</strong>的前缀和。</p>
<p>前置知识：上文莫比乌斯反演部分，积性函数部分。</p>
<h4 id="算法流程">算法流程</h4>
<p>是一种类似<em>硬构造</em>的感觉。令我们要求的积性函数为 <span class="math inline">\(f(n)\)</span>，其前缀和为 <span class="math inline">\(S(n)\)</span>。</p>
<p>现在想办法构造一个 <span class="math inline">\(S(n)\)</span> 关于 <span class="math inline">\(S\left(\left\lfloor\dfrac ni\right\rfloor\right)\)</span> 的递推式，不妨让 <span class="math inline">\(f\)</span> 卷上另一个积性函数 <span class="math inline">\(g\)</span> 然后考虑其前缀和： <span class="math display">\[
\begin{aligned}
&amp;\sum_{i=1}^n (f*g)(i)\\
=&amp;\sum_{i=1}^n\sum_{d\mid i}g(d)f\left(\frac id\right)\\
=&amp;\sum_{d=1}^ng(d)\sum_{i=1}^{\lfloor\frac nd\rfloor}f(i)\\
=&amp;\sum_{d=1}^ng(d)S\left(\left\lfloor\dfrac nd\right\rfloor\right)
\end{aligned}
\]</span> 第三行是交换枚举顺序然后提出了 <span class="math inline">\(g(d)\)</span>。</p>
<p>然后将 <span class="math inline">\(g(1)S(n)\)</span> 移项一下就得到了杜教筛的核心式子： <span class="math display">\[
g(1)S(n) = \sum_{i=1}^n(f*g)(i) - \sum_{d=2}^ng(d)S\left(\left\lfloor\dfrac nd\right\rfloor\right)
\]</span> 如果能快速算出 <span class="math inline">\((f*g)(n)\)</span> 和 <span class="math inline">\(g(n)\)</span> 的前缀和的话，就意味着上面的式子可以快速递归计算。见下面伪代码：</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a aria-hidden="true" href="#cb6-1"></a>ll getSum(<span class="dt">int</span> n) {</span>
<span id="cb6-2"><a aria-hidden="true" href="#cb6-2"></a>    <span class="cf">if</span> (hash[n]) <span class="cf">return</span> hash[n]; <span class="co">// 记忆化</span></span>
<span id="cb6-3"><a aria-hidden="true" href="#cb6-3"></a>    ll ret = f_g_sum(n); <span class="co">// 求 (f*g)(i) 的前缀和</span></span>
<span id="cb6-4"><a aria-hidden="true" href="#cb6-4"></a>    <span class="cf">for</span> (ll l = <span class="dv">2</span>, r; l &lt;= n; l = r + <span class="dv">1</span>) { <span class="co">// 整除分块</span></span>
<span id="cb6-5"><a aria-hidden="true" href="#cb6-5"></a>        r = min(n, n / (n / l));</span>
<span id="cb6-6"><a aria-hidden="true" href="#cb6-6"></a>        ret -= (<span class="va">g_sum</span>(r) - <span class="va">g_sum</span>(l - <span class="dv">1</span>)) * getSum(n / l);</span>
<span id="cb6-7"><a aria-hidden="true" href="#cb6-7"></a>    }</span>
<span id="cb6-8"><a aria-hidden="true" href="#cb6-8"></a>    <span class="cf">return</span> ret;</span>
<span id="cb6-9"><a aria-hidden="true" href="#cb6-9"></a>}</span></code></pre></div>
<p>由于网上关于杜教筛复杂度的证明有各种说法，所以此处先咕着。总之一般而言，杜教筛时间复杂度为 <span class="math inline">\(O(n^{0.75})\)</span>，若用线性筛提前处理好前 <span class="math inline">\(n^{2/3}\)</span> 项的话复杂度则降低为 <span class="math inline">\(O(n^{2/3})\)</span>。</p>
<h4 id="常见模型">常见模型</h4>
<blockquote>
<p>模型 <span class="math inline">\(1\)</span>：筛 <span class="math inline">\(\varphi\)</span>。</p>
</blockquote>
<p>发现 <span class="math inline">\(\varphi * \boldsymbol 1 = \mathrm{id}\)</span>，所以取 <span class="math inline">\(f = \varphi\)</span>，<span class="math inline">\(g = 1\)</span>，然后就可以很容易杜教筛辣： <span class="math display">\[
S(n) = \frac{n(n+1)}{2} - \sum_{d=2}^n S\left(\left\lfloor\dfrac nd\right\rfloor\right)
\]</span></p>
<blockquote>
<p>模型 <span class="math inline">\(2\)</span>：筛 <span class="math inline">\(\mu\)</span>。</p>
</blockquote>
<p>会发现 <span class="math inline">\(\mu * \boldsymbol 1 = \varepsilon\)</span>，所以取 <span class="math inline">\(f = \mu\)</span>，<span class="math inline">\(g = \boldsymbol 1\)</span>，然后： <span class="math display">\[
S(n) = 1 - \sum_{d=2}^nS\left(\left\lfloor\dfrac nd\right\rfloor\right)
\]</span></p>
<blockquote>
<p>模型 <span class="math inline">\(2.5\)</span>：求 <span class="math inline">\(\sum\limits_{i=1}^n[2\not\mid i]\mu(i)\)</span>。</p>
</blockquote>
<p>即奇数位置上的和。设其为 <span class="math inline">\(T(n)\)</span>，<span class="math inline">\(\mu\)</span> 的前缀和为 <span class="math inline">\(S(n)\)</span>。考虑用 <span class="math inline">\(S(n)\)</span> 减去偶数位置上 <span class="math inline">\(\mu\)</span> 的和，至于偶数位置上 <span class="math inline">\(\mu\)</span> 的和，考虑若其只有一个 <span class="math inline">\(2\)</span> 因子，那么 <span class="math inline">\(/2\)</span> 之后其必然是奇数，而若有多个 <span class="math inline">\(2\)</span> 的因子的话，显然我们可以不管，于是这部分贡献就是 <span class="math inline">\(-T(\lfloor n / 2\rfloor)\)</span>。所以 <span class="math display">\[
T(n) = S(n) + T(\lfloor n / 2\rfloor)
\]</span></p>
<blockquote>
<p>模型 <span class="math inline">\(3\)</span>：筛 <span class="math inline">\(\sigma_k\)</span>，即除数函数，定义见上文。</p>
</blockquote>
<p>由于 <span class="math inline">\(\sigma_k = \boldsymbol 1 * \mathrm{id}_k\)</span>，所以 <span class="math inline">\(\sigma_k * \mu = \mathrm{id}_k\)</span>，然后： <span class="math display">\[
S(n) = \sum_{i=1}^n\mathrm{id}_k(i) - \sum_{d=2}^n\mu(d)S\left(\left\lfloor\dfrac nd\right\rfloor\right)
\]</span> 顺便需要筛出 <span class="math inline">\(\mu\)</span>。</p>
<blockquote>
<p>模型 <span class="math inline">\(4\)</span>：<span class="math inline">\(\mu\cdot \mathrm{id}_k\)</span> 和 <span class="math inline">\(\varphi\cdot \mathrm{id}_k\)</span>。点乘型。</p>
</blockquote>
<p>构造 <span class="math inline">\(g\)</span> 的时候让 <span class="math inline">\(g\)</span> 来一个 <span class="math inline">\(\mathrm{id}_k\)</span> 卷掉即可。具体地： <span class="math display">\[
\begin{aligned}
(\mu\cdot \mathrm{id}_k)* \mathrm{id}_k &amp;= \sum_{d\mid n}\mu(d)d^k\left(\frac nd\right)^k\\
&amp;= n^k\sum_{d\mid n}\mu(d)\\
&amp;= \varepsilon
\end{aligned}
\]</span> 至于欧拉，则有 <span class="math display">\[
\begin{aligned}
(\varphi \cdot \mathrm{id}_k) * \mathrm{id}_k &amp;= \sum_{d\mid n}\varphi(d)d^k\left(\frac nd\right)^k\\
&amp;= n^k\sum_{d\mid n}\varphi(d)\\
&amp;= \mathrm{id}^{k + 1}
\end{aligned}
\]</span> 然后杜教筛的过程略。</p>
<blockquote>
<p>note：常见的 <span class="math inline">\(\mathrm{id}_k\)</span> 前缀和：</p>
<ul>
<li><span class="math inline">\(\displaystyle\sum_{i=1}^n\mathrm{id}(i) = \frac{n(n+1)}{2}\)</span>，这个应该是较常规的等差数列求和。</li>
<li><span class="math inline">\(\displaystyle\sum_{i=1}^n\mathrm{id}_2(i) = \frac{n(n+1)(2n+1)}{6}\)</span>，证明可以考虑数归。</li>
<li><span class="math inline">\(\displaystyle\sum_{i=1}^n\mathrm{id}_3(i) = \left[\frac{n(n+1)}{2}\right]^2\)</span>，证明同样考虑数归。</li>
</ul>
<p>此外，由于 <span class="math inline">\((\sum \mathrm{id}_k)(n)\)</span> 是关于 <span class="math inline">\(n\)</span> 的 <span class="math inline">\(k+ 1\)</span> 次多项式（经典结论），故当 <span class="math inline">\(k\)</span> 不大时可以考虑将系数插出来然后 <span class="math inline">\(O(k)\)</span> 单次求值。</p>
</blockquote>
<p>上面的几个式子建议牢记，可以省去自己推的麻烦。</p>
<blockquote>
<p>模型 <span class="math inline">\(6\)</span>：筛 <span class="math inline">\(\mu^2\)</span>。</p>
</blockquote>
<p>应该是比较神仙的构造 <span class="math inline">\(g\)</span> 函数了。</p>
<p>此处取 <span class="math inline">\(g(n) = [n = k^2, k\in \mathbb{N}_+]\)</span>。虽然 <span class="math inline">\(g\)</span> 的前缀和看似不好求，但是我们对于<strong>这种真值表达式的函数，可以改变枚举的策略使得其恒成立，变为常数函数</strong>。</p>
<p><span class="math inline">\((f*g)(n) = \displaystyle\sum_{d\mid n}g(d)f(n / d)\)</span>，观察发现 <span class="math inline">\(g(d)f(n / d)\)</span> 仅在 <span class="math inline">\(d\)</span> 取到 <span class="math inline">\(n\)</span> 的最大平方因子时为 <span class="math inline">\(1\)</span>，否则为 <span class="math inline">\(0\)</span>。因为若 <span class="math inline">\(d\)</span> 不为最大平方因子，则 <span class="math inline">\(n / d\)</span> 肯定含平方因子，<span class="math inline">\(\mu^2(n / d) = 0\)</span>。否则 <span class="math inline">\(n / d\)</span> 一定不含平方因子，<span class="math inline">\(f(n / d) = g(d) = 1\)</span>。所以 <span class="math inline">\(f*g = \boldsymbol 1\)</span>。</p>
<p>套回杜教筛的式子： <span class="math display">\[
\begin{aligned}
S(n) &amp;= \sum_{i=1}^n (f*g)(i) - \sum_{d=2}^ng(d)S\left(\left\lfloor\frac nd\right\rfloor \right)\\
&amp;= n - \sum_{d=2}^{\lfloor \sqrt n\rfloor} S\left(\left\lfloor\frac{n}{d^2}\right\rfloor \right)
\end{aligned}
\]</span> 没法整除分块，所以可能复杂度危。</p>
<p>但其实还有另一种方法：我们考虑容斥。<span class="math inline">\(S(n)\)</span> 可以看作 总数 - 一个平方数的倍数 + 两个平方数的倍数 - …..，发现容斥系数就是 <span class="math inline">\(\mu\)</span>，所以 <span class="math inline">\(S(n) = \displaystyle\sum_{i=1}^{\lfloor \sqrt n\rfloor}\mu(i)\lfloor n / i^2\rfloor\)</span>。</p>
<p>另有小结论 <span class="math inline">\(\mu^2(n) = \displaystyle\sum_{d^2\mid n}\mu(d)\)</span>。</p>
<h4 id="应用-1">应用</h4>
<blockquote>
<p>例题 <span class="math inline">\(1\)</span>：<a href="https://www.luogu.com.cn/problem/P4213">P4213 【模板】杜教筛（Sum）</a></p>
<p><span class="math inline">\(T\le 10\)</span> 组询问，一次询问查询 <span class="math inline">\(\varphi\)</span> 和 <span class="math inline">\(\mu\)</span> 的前缀和，<span class="math inline">\(n&lt; 2^{31}\)</span>。</p>
</blockquote>
<p>主要看下代码怎么写的。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a aria-hidden="true" href="#cb7-1"></a><span class="kw">using</span> ll = <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span>;</span>
<span id="cb7-2"><a aria-hidden="true" href="#cb7-2"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">1e7</span> + <span class="dv">15</span>;</span>
<span id="cb7-3"><a aria-hidden="true" href="#cb7-3"></a><span class="bu">std::</span>unordered_map&lt;ll, ll&gt; Mu, Phi;</span>
<span id="cb7-4"><a aria-hidden="true" href="#cb7-4"></a>ll mu[maxn], phi[maxn];</span>
<span id="cb7-5"><a aria-hidden="true" href="#cb7-5"></a><span class="dt">int</span> vis[maxn], p[maxn], tot;</span>
<span id="cb7-6"><a aria-hidden="true" href="#cb7-6"></a></span>
<span id="cb7-7"><a aria-hidden="true" href="#cb7-7"></a><span class="dt">void</span> init() {<span class="co">// 线性筛 mu 和 phi 在 1e7 处前缀和的过程省略}</span></span>
<span id="cb7-8"><a aria-hidden="true" href="#cb7-8"></a></span>
<span id="cb7-9"><a aria-hidden="true" href="#cb7-9"></a>ll getSumPhi(ll n) {</span>
<span id="cb7-10"><a aria-hidden="true" href="#cb7-10"></a>    <span class="cf">if</span> (n &lt;= maxn)</span>
<span id="cb7-11"><a aria-hidden="true" href="#cb7-11"></a>        <span class="cf">return</span> phi[n];</span>
<span id="cb7-12"><a aria-hidden="true" href="#cb7-12"></a>    <span class="cf">if</span> (Phi[n])</span>
<span id="cb7-13"><a aria-hidden="true" href="#cb7-13"></a>        <span class="cf">return</span> Phi[n];</span>
<span id="cb7-14"><a aria-hidden="true" href="#cb7-14"></a>    ll ans = (ll)(n + <span class="dv">1</span><span class="bu">ll</span>) * (ll)n / <span class="dv">2</span><span class="bu">ll</span>; <span class="co">// id 的前缀和</span></span>
<span id="cb7-15"><a aria-hidden="true" href="#cb7-15"></a>    <span class="cf">for</span> (ll l = <span class="dv">2</span>, r; l &lt;= n; l = r + <span class="dv">1</span>) {</span>
<span id="cb7-16"><a aria-hidden="true" href="#cb7-16"></a>        r = n / (n / l);</span>
<span id="cb7-17"><a aria-hidden="true" href="#cb7-17"></a>        ans -= (r - l + <span class="dv">1</span><span class="bu">LL</span>) * getSumPhi(n / l);</span>
<span id="cb7-18"><a aria-hidden="true" href="#cb7-18"></a>    }</span>
<span id="cb7-19"><a aria-hidden="true" href="#cb7-19"></a>    <span class="cf">return</span> Phi[n] = ans; <span class="co">// 记忆化</span></span>
<span id="cb7-20"><a aria-hidden="true" href="#cb7-20"></a>}</span>
<span id="cb7-21"><a aria-hidden="true" href="#cb7-21"></a></span>
<span id="cb7-22"><a aria-hidden="true" href="#cb7-22"></a>ll getSumMu(ll n) {</span>
<span id="cb7-23"><a aria-hidden="true" href="#cb7-23"></a>    <span class="cf">if</span> (n &lt;= maxn)</span>
<span id="cb7-24"><a aria-hidden="true" href="#cb7-24"></a>        <span class="cf">return</span> mu[n];</span>
<span id="cb7-25"><a aria-hidden="true" href="#cb7-25"></a>    <span class="cf">if</span> (Mu[n])</span>
<span id="cb7-26"><a aria-hidden="true" href="#cb7-26"></a>        <span class="cf">return</span> Mu[n];</span>
<span id="cb7-27"><a aria-hidden="true" href="#cb7-27"></a>    ll ans = <span class="dv">1</span>; <span class="co">// epsilon 的前缀和就是 1</span></span>
<span id="cb7-28"><a aria-hidden="true" href="#cb7-28"></a>    <span class="cf">for</span> (ll l = <span class="dv">2</span>, r; l &lt;= n; l = r + <span class="dv">1</span>) {</span>
<span id="cb7-29"><a aria-hidden="true" href="#cb7-29"></a>        r = n / (n / l);</span>
<span id="cb7-30"><a aria-hidden="true" href="#cb7-30"></a>        ans -= (r - l + <span class="dv">1</span><span class="bu">LL</span>) * getSumMu(n / l);</span>
<span id="cb7-31"><a aria-hidden="true" href="#cb7-31"></a>    }</span>
<span id="cb7-32"><a aria-hidden="true" href="#cb7-32"></a>    <span class="cf">return</span> Mu[n] = ans; <span class="co">// 记忆化</span></span>
<span id="cb7-33"><a aria-hidden="true" href="#cb7-33"></a>}</span></code></pre></div>
<blockquote>
<p>例题 <span class="math inline">\(2\)</span>：<a href="https://loj.ac/p/6491">LOJ#6491. 「XXOI 2018」简单的最大公约数</a></p>
<p>ABC162E - Sum of gcd of Tuples (Hard) 的加强：给定 <span class="math inline">\(1\le N, K\le 10^{11}\)</span>，求 <span class="math display">\[
\sum_{a_1 = 1}^K\sum_{a_2 = 1}^K\cdots\sum_{a_N = 1}^K\gcd_{i = 1}^N\{a_i\}\bmod {10^9 + 7}
\]</span> 答案对 <span class="math inline">\(2^{64}\)</span> 取模。</p>
</blockquote>
<p>先考虑反演： <span class="math display">\[
\begin{aligned}
&amp;\sum_{a_1 = 1}^K\sum_{a_2 = 1}^K\cdots\sum_{a_N = 1}^K\gcd_{i = 1}^N\{a_i\}\\
=&amp;\sum_{a_1 = 1}^K\cdots\sum_{a_N = 1}^K\sum_{d\mid a_1,\cdots d\mid a_N}\varphi(d)\\
=&amp;\sum_{d = 1}^K\varphi(d)\sum_{a_1 = 1}^K\cdots\sum_{a_N = 1}^K[d\mid \gcd\{a_i\}]\\
=&amp;\sum_{d = 1}^K\varphi(d)\left\lfloor\frac Kd\right\rfloor^N
\end{aligned}
\]</span> 然后就可以整除分块 + 杜教筛了，时间复杂度为 <span class="math inline">\(O(n^{2/3})\)</span>。</p>
<blockquote>
<p>例题 <span class="math inline">\(3\)</span>：<a href="https://www.luogu.com.cn/problem/P3768">P3768 简单的数学题</a></p>
<p>给定 <span class="math inline">\(n\le 10^{10}\)</span> 和 <span class="math inline">\(5\times 10^8\le p\le 1.1\times 10^9\)</span>，保证 <span class="math inline">\(p\)</span> 为质数，求 <span class="math display">\[
\left(\sum_{i=1}^n\sum_{j=1}^nij\gcd(i,j) \right)\bmod p
\]</span></p>
</blockquote>
<p>首先显然先欧拉反演： <span class="math display">\[
\begin{aligned}
\sum_{i=1}^n\sum_{j=1}^nij\gcd(i,j) &amp;= \sum_{i=1}^n\sum_{j=1}^nij\sum_{d\mid \gcd(i,j)}\varphi(d)\\
&amp;= \sum_{d=1}^n\varphi(d)\sum_{i=1}^n[d\mid i]i\sum_{j=1}^n[d\mid j]j\\
&amp;= \sum_{d=1}^n\varphi(d)d^2 \left( \frac{(1 + \lfloor n / d\rfloor)\lfloor n / d\rfloor}{2}\right)^2
\end{aligned}
\]</span> 发现后面那坨式子可以整除分块，而 <span class="math inline">\(\varphi(d)d^2\)</span> 就是上面讲的 <span class="math inline">\(\varphi \cdot \mathrm{id}_k\)</span> 类型，直接做即可。</p>
</section>
<footer class="article-footer">
<section class="article-tags">
<a href="/tags/OI/">OI</a>
<a href="/tags/note/">笔记</a>
</section>
<section class="article-copyright">
<svg class="icon icon-tabler icon-tabler-copyright" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<circle cx="12" cy="12" r="9"></circle>
<path d="M14.5 9a3.5 4 0 1 0 0 6"></path>
</svg>
<span>Licensed under CC BY-NC-SA 4.0</span>
</section>
</footer>
<link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css" integrity="sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn" rel="stylesheet"/><script crossorigin="anonymous" defer="" integrity="sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8" src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js">
</script><script crossorigin="anonymous" defer="" integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js">
</script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.querySelector(`.article-content`), {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ]
        });})
</script>
</article>
<aside class="related-contents--wrapper">
<h2 class="section-title">相关文章</h2>
<div class="related-contents">
<div class="flex article-list--tile">
<article class="has-image">
<a href="/note-gf/">
<div class="article-image">
<img data-hash="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg28.webp" data-key="" loading="lazy" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg28.webp"/>
</div>
<div class="article-details">
<h2 class="article-title">生成函数胡扯</h2>
</div>
</a>
</article>
<article class="has-image">
<a href="/note-set-power-series/">
<div class="article-image">
<img data-hash="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg39.webp" data-key="" loading="lazy" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg39.webp"/>
</div>
<div class="article-details">
<h2 class="article-title">集合幂级数胡扯</h2>
</div>
</a>
</article>
<article class="has-image">
<a href="/note-linear-basis/">
<div class="article-image">
<img data-hash="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg19.webp" data-key="" loading="lazy" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg19.webp"/>
</div>
<div class="article-details">
<h2 class="article-title">线性基学习笔记</h2>
</div>
</a>
</article>
<article class="has-image">
<a href="/note-wqs/">
<div class="article-image">
<img data-hash="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg28.webp" data-key="" loading="lazy" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg28.webp"/>
</div>
<div class="article-details">
<h2 class="article-title">wqs 二分学习笔记</h2>
</div>
</a>
</article>
<article class="has-image">
<a href="/note-builtin/">
<div class="article-image">
<img data-hash="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg9.webp" data-key="" loading="lazy" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg9.webp"/>
</div>
<div class="article-details">
<h2 class="article-title">__builtin 系列函数总结</h2>
</div>
</a>
</article>
</div>
</div>
</aside>
<footer class="site-footer">
<section class="copyright">
        © 
        
            2019 - 
        
        2024 清烛的博客
    </section>
<section class="powerby">
        Built with <a href="https://gohugo.io/" rel="noopener" target="_blank">Hugo</a> <br/>
        主题 <b><a data-version="3.11.0" href="https://github.com/CaiJimmy/hugo-theme-stack" rel="noopener" target="_blank">Stack</a></b> 由 <a href="https://jimmycai.com" rel="noopener" target="_blank">Jimmy</a> 设计
    </section>
</footer>
<div aria-hidden="true" class="pswp" role="dialog" tabindex="-1">
<div class="pswp__bg"></div>
<div class="pswp__scroll-wrap">
<div class="pswp__container">
<div class="pswp__item"></div>
<div class="pswp__item"></div>
<div class="pswp__item"></div>
</div>
<div class="pswp__ui pswp__ui--hidden">
<div class="pswp__top-bar">
<div class="pswp__counter"></div>
<button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title="Share"></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
<div class="pswp__preloader">
<div class="pswp__preloader__icn">
<div class="pswp__preloader__cut">
<div class="pswp__preloader__donut"></div>
</div>
</div>
</div>
</div>
<div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
<div class="pswp__share-tooltip"></div>
</div>
<button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
</button>
<div class="pswp__caption">
<div class="pswp__caption__center"></div>
</div>
</div>
</div>
</div><script crossorigin="anonymous" defer="" integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js">
</script><script crossorigin="anonymous" defer="" integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js">
</script><link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css" integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" rel="stylesheet"/><link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css" integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" rel="stylesheet"/>
</main>
</div>
<script crossorigin="anonymous" integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js">
</script><script defer="" src="/ts/main.js" type="text/javascript"></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>
</body>
</html>

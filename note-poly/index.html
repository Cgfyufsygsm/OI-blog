<!DOCTYPE html>
<html dir="ltr" lang="zh-CN">
<head><meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/><meta content="前言 upd：笔者写这篇文章的时候水平不足，在省选后可能会考虑重构，并将生成函数计数和形式幂级数科技分开。
多项式全家桶的总结笔记。篇幅极长，善用 TOC 进行跳转。
如有错漏之处烦请指出。
开始全家桶之前 形式化定义 约定：\(f_i\)（或者 \([x^i]f(x)\)）表示 \(f(x)\) 在 \(x^i\) 处的系数，即一个多项式可以表示为 \(\displaystyle\sum_{i = 0} f_ix^i\) 的形式。
两个多项式的加减法定义为
\[ f(x) \pm g(x) = \sum_{i = 0}(f_i \pm g_i)x^i \]
复杂度 \(O(n)\)
两个多项式的乘法（加法卷积）定义为：
\[ f(x)*g(x) = \sum_{i = 0}x^i\sum_{j = 0}f_jg_{i - j} \]
不难发现其正确性。可以手动模拟一下多项式的乘法看看是不是这样子的。其本质也就是卷完之后合并同类项。朴素的做的话复杂度是 \(O(n^2)\) 的，下面要讲的 FFT/NTT 可以加速到 \(O(n\log n)\)
界 有些时候，题目只对多项式的前若干项感兴趣，所以我们给运算设定一个上界，即 \(\pmod{x^n}\)。意思就是只考虑这个多项式的前 \(n\) 项，从 \(x^n\) 开始以后的全部舍掉。
不难发现由加法和乘法是从低位到高位贡献的，所以
\[ \begin{aligned} (f(x) \bmod{x^n} \pm g(x)\bmod{x^n})\bmod{x^n} &amp;amp;= (f(x) \pm g(x))\bmod{x^n}\\ (f(x) \bmod{x^n}) * (g(x)\bmod{x^n})\bmod{x^n} &amp;amp;= (f(x) * g(x))\bmod{x^n}\\ \end{aligned} \]" name="description"/><title>多项式全家桶笔记</title>
<link href="https://oi.imyangty.com/note-poly/" rel="canonical"/>
<link href="/scss/style.min.a5821f3d3ab84ce5a0ac21477e347a2e0ca00292e398d16c5e8e36ded6e35a23.css" rel="stylesheet"/><meta content="多项式全家桶笔记" property="og:title"/>
<meta content="前言 upd：笔者写这篇文章的时候水平不足，在省选后可能会考虑重构，并将生成函数计数和形式幂级数科技分开。
多项式全家桶的总结笔记。篇幅极长，善用 TOC 进行跳转。
如有错漏之处烦请指出。
开始全家桶之前 形式化定义 约定：\(f_i\)（或者 \([x^i]f(x)\)）表示 \(f(x)\) 在 \(x^i\) 处的系数，即一个多项式可以表示为 \(\displaystyle\sum_{i = 0} f_ix^i\) 的形式。
两个多项式的加减法定义为
\[ f(x) \pm g(x) = \sum_{i = 0}(f_i \pm g_i)x^i \]
复杂度 \(O(n)\)
两个多项式的乘法（加法卷积）定义为：
\[ f(x)*g(x) = \sum_{i = 0}x^i\sum_{j = 0}f_jg_{i - j} \]
不难发现其正确性。可以手动模拟一下多项式的乘法看看是不是这样子的。其本质也就是卷完之后合并同类项。朴素的做的话复杂度是 \(O(n^2)\) 的，下面要讲的 FFT/NTT 可以加速到 \(O(n\log n)\)
界 有些时候，题目只对多项式的前若干项感兴趣，所以我们给运算设定一个上界，即 \(\pmod{x^n}\)。意思就是只考虑这个多项式的前 \(n\) 项，从 \(x^n\) 开始以后的全部舍掉。
不难发现由加法和乘法是从低位到高位贡献的，所以
\[ \begin{aligned} (f(x) \bmod{x^n} \pm g(x)\bmod{x^n})\bmod{x^n} &amp;amp;= (f(x) \pm g(x))\bmod{x^n}\\ (f(x) \bmod{x^n}) * (g(x)\bmod{x^n})\bmod{x^n} &amp;amp;= (f(x) * g(x))\bmod{x^n}\\ \end{aligned} \]" property="og:description"/>
<meta content="https://oi.imyangty.com/note-poly/" property="og:url"/>
<meta content="清烛的博客" property="og:site_name"/>
<meta content="article" property="og:type"/><meta content="Post" property="article:section"/><meta content="OI" property="article:tag"/><meta content="笔记" property="article:tag"/><meta content="FFT" property="article:tag"/><meta content="NTT" property="article:tag"/><meta content="生成函数" property="article:tag"/><meta content="容斥原理" property="article:tag"/><meta content="拉格朗日插值" property="article:tag"/><meta content="2021-03-13T12:41:09+08:00" property="article:published_time"/><meta content="2021-03-13T12:41:09+08:00" property="article:modified_time"/><meta content="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg23.webp" property="og:image"/>
<meta content="多项式全家桶笔记" name="twitter:title"/>
<meta content="前言 upd：笔者写这篇文章的时候水平不足，在省选后可能会考虑重构，并将生成函数计数和形式幂级数科技分开。
多项式全家桶的总结笔记。篇幅极长，善用 TOC 进行跳转。
如有错漏之处烦请指出。
开始全家桶之前 形式化定义 约定：\(f_i\)（或者 \([x^i]f(x)\)）表示 \(f(x)\) 在 \(x^i\) 处的系数，即一个多项式可以表示为 \(\displaystyle\sum_{i = 0} f_ix^i\) 的形式。
两个多项式的加减法定义为
\[ f(x) \pm g(x) = \sum_{i = 0}(f_i \pm g_i)x^i \]
复杂度 \(O(n)\)
两个多项式的乘法（加法卷积）定义为：
\[ f(x)*g(x) = \sum_{i = 0}x^i\sum_{j = 0}f_jg_{i - j} \]
不难发现其正确性。可以手动模拟一下多项式的乘法看看是不是这样子的。其本质也就是卷完之后合并同类项。朴素的做的话复杂度是 \(O(n^2)\) 的，下面要讲的 FFT/NTT 可以加速到 \(O(n\log n)\)
界 有些时候，题目只对多项式的前若干项感兴趣，所以我们给运算设定一个上界，即 \(\pmod{x^n}\)。意思就是只考虑这个多项式的前 \(n\) 项，从 \(x^n\) 开始以后的全部舍掉。
不难发现由加法和乘法是从低位到高位贡献的，所以
\[ \begin{aligned} (f(x) \bmod{x^n} \pm g(x)\bmod{x^n})\bmod{x^n} &amp;amp;= (f(x) \pm g(x))\bmod{x^n}\\ (f(x) \bmod{x^n}) * (g(x)\bmod{x^n})\bmod{x^n} &amp;amp;= (f(x) * g(x))\bmod{x^n}\\ \end{aligned} \]" name="twitter:description"/><meta content="summary_large_image" name="twitter:card"/>
<meta content="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg23.webp" name="twitter:image"/>
<link href="https://q1.qlogo.cn/g?b=qq&amp;nk=375836877&amp;s=5" rel="shortcut icon"/>
<link href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/styles/github-dark-dimmed.min.css" rel="stylesheet"/>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
</head>
<body class="article-page">
<script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky">
<button aria-label="切换菜单" class="hamburger hamburger--spin" id="toggle-menu" type="button">
<span class="hamburger-box">
<span class="hamburger-inner"></span>
</span>
</button>
<header>
<figure class="site-avatar">
<a href="/">
<img alt="Avatar" class="site-logo" height="300" loading="lazy" src="/img/avatar_huea3ce2119467b51fdd2a81393644a76d_51594_300x0_resize_q75_box.jpg" width="300"/>
</a>
<span class="emoji">😅</span>
</figure>
<div class="site-meta">
<h1 class="site-name"><a href="/">清烛的博客</a></h1>
<h2 class="site-description">烟火已谢，笙歌未停</h2>
</div>
</header><ol class="social-menu">
<li>
<a href="mailto:i@imyangty.com" target="_blank" title="email">
<svg class="icon icon-tabler icon-tabler-mail" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
<rect height="14" rx="2" width="18" x="3" y="5"></rect>
<polyline points="3 7 12 13 21 7"></polyline>
</svg>
</a>
</li>
<li>
<a href="https://github.com/Cgfyufsygsm" target="_blank" title="GitHub">
<svg class="icon icon-tabler icon-tabler-brand-github" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
<path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5"></path>
</svg>
</a>
</li>
<li>
<a href="https://t.me/Cgfyufsygsm" target="_blank" title="Telegram">
<svg class="icon icon-tabler icon-tabler-brand-telegram" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
<path d="M15 10l-4 4l6 6l4 -16l-18 7l4 2l2 6l3 -4"></path>
</svg>
</a>
</li>
<li>
<a href="https://twitter.com/Cgfyufsygsm" target="_blank" title="Twitter">
<svg class="icon icon-tabler icon-tabler-brand-twitter" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
<path d="M22 4.01c-1 .49 -1.98 .689 -3 .99c-1.121 -1.265 -2.783 -1.335 -4.38 -.737s-2.643 2.06 -2.62 3.737v1c-3.245 .083 -6.135 -1.395 -8 -4c0 0 -4.182 7.433 4 11c-1.872 1.247 -3.739 2.088 -6 2c3.308 1.803 6.913 2.423 10.034 1.517c3.58 -1.04 6.522 -3.723 7.651 -7.742a13.84 13.84 0 0 0 .497 -3.753c-.002 -.249 1.51 -2.772 1.818 -4.013z"></path>
</svg>
</a>
</li>
</ol><ol class="menu" id="main-menu">
<li>
<a href="/">
<svg class="icon icon-tabler icon-tabler-home" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<polyline points="5 12 3 12 12 3 21 12 19 12"></polyline>
<path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7"></path>
<path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6"></path>
</svg>
<span>主页</span>
</a>
</li>
<li>
<a href="/about/">
<svg class="icon icon-tabler icon-tabler-user" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<circle cx="12" cy="7" r="4"></circle>
<path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2"></path>
</svg>
<span>关于</span>
</a>
</li>
<li>
<a href="/idx/">
<svg class="icon icon-tabler icon-tabler-hash" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<line x1="5" x2="19" y1="9" y2="9"></line>
<line x1="5" x2="19" y1="15" y2="15"></line>
<line x1="11" x2="7" y1="4" y2="20"></line>
<line x1="17" x2="13" y1="4" y2="20"></line>
</svg>
<span>导航</span>
</a>
</li>
<li>
<a href="/archives/">
<svg class="icon icon-tabler icon-tabler-archive" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<rect height="4" rx="2" width="18" x="3" y="4"></rect>
<path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10"></path>
<line x1="10" x2="14" y1="12" y2="12"></line>
</svg>
<span>归档</span>
</a>
</li>
<li>
<a href="/search/">
<svg class="icon icon-tabler icon-tabler-search" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<circle cx="10" cy="10" r="7"></circle>
<line x1="21" x2="15" y1="21" y2="15"></line>
</svg>
<span>搜索</span>
</a>
</li>
<li>
<a href="/friends/">
<svg class="icon icon-tabler icon-tabler-link" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5"></path>
<path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5"></path>
</svg>
<span>友链</span>
</a>
</li>
<li>
<a href="https://blog.imyangty.com" target="_blank">
<svg class="icon icon-tabler icon-tabler-home" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<polyline points="5 12 3 12 12 3 21 12 19 12"></polyline>
<path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7"></path>
<path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6"></path>
</svg>
<span>主博客</span>
</a>
</li>
<div class="menu-bottom-section">
<li id="dark-mode-toggle">
<svg class="icon icon-tabler icon-tabler-toggle-left" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<circle cx="8" cy="12" r="2"></circle>
<rect height="12" rx="6" width="20" x="2" y="6"></rect>
</svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<circle cx="16" cy="12" r="2"></circle>
<rect height="12" rx="6" width="20" x="2" y="6"></rect>
</svg>
<span>暗色模式</span>
</li>
</div>
</ol>
</aside>
<main class="main full-width">
<article class="has-image main-article">
<header class="article-header">
<div class="article-image">
<a href="/note-poly/">
<img alt="Featured image of post 多项式全家桶笔记" loading="lazy" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg23.webp"/>
</a>
</div>
<div class="article-details">
<header class="article-category">
<a href="/categories/oi/">
                OI
            </a>
<a href="/categories/note/">
                笔记
            </a>
</header>
<div class="article-title-wrapper">
<h2 class="article-title">
<a href="/note-poly/">多项式全家桶笔记</a>
</h2>
</div>
<footer class="article-time">
<div>
<svg class="icon icon-tabler icon-tabler-calendar-time" fill="none" height="56" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="56" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4"></path>
<circle cx="18" cy="18" r="4"></circle>
<path d="M15 3v4"></path>
<path d="M7 3v4"></path>
<path d="M3 11h16"></path>
<path d="M18 16.496v1.504l1 1"></path>
</svg>
<time class="article-time--published">Mar 13, 2021</time>
</div>
<div>
<svg class="icon icon-tabler icon-tabler-clock" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<circle cx="12" cy="12" r="9"></circle>
<polyline points="12 7 12 12 15 15"></polyline>
</svg>
<time class="article-time--reading">
                    阅读时长: 48 分钟
                </time>
</div>
</footer>
</div>
</header>
<section class="article-content">
<h2 id="前言">前言</h2>
<p>upd：笔者写这篇文章的时候水平不足，在省选后可能会考虑重构，并将生成函数计数和形式幂级数科技分开。</p>
<p>多项式全家桶的总结笔记。篇幅极长，善用 TOC 进行跳转。</p>
<p>如有错漏之处烦请指出。</p>
<h2 id="开始全家桶之前">开始全家桶之前</h2>
<h3 id="形式化定义">形式化定义</h3>
<p>约定：<span class="math inline">\(f_i\)</span>（或者 <span class="math inline">\([x^i]f(x)\)</span>）表示 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\(x^i\)</span> 处的系数，即一个多项式可以表示为 <span class="math inline">\(\displaystyle\sum_{i = 0} f_ix^i\)</span> 的形式。</p>
<p>两个多项式的加减法定义为</p>
<p><span class="math display">\[
f(x) \pm g(x) = \sum_{i = 0}(f_i \pm g_i)x^i
\]</span></p>
<p>复杂度 <span class="math inline">\(O(n)\)</span></p>
<p>两个多项式的乘法（加法卷积）定义为：</p>
<p><span class="math display">\[
f(x)*g(x) = \sum_{i = 0}x^i\sum_{j = 0}f_jg_{i - j}
\]</span></p>
<p>不难发现其正确性。可以手动模拟一下多项式的乘法看看是不是这样子的。其本质也就是卷完之后合并同类项。朴素的做的话复杂度是 <span class="math inline">\(O(n^2)\)</span> 的，下面要讲的 FFT/NTT 可以加速到 <span class="math inline">\(O(n\log n)\)</span></p>
<h3 id="界">界</h3>
<p>有些时候，题目只对多项式的前若干项感兴趣，所以我们给运算设定一个上界，即 <span class="math inline">\(\pmod{x^n}\)</span>。意思就是<strong>只考虑这个多项式的前 <span class="math inline">\(n\)</span> 项</strong>，从 <span class="math inline">\(x^n\)</span> 开始以后的全部舍掉。</p>
<p>不难发现由加法和乘法是从低位到高位贡献的，所以</p>
<p><span class="math display">\[
\begin{aligned}
(f(x) \bmod{x^n} \pm g(x)\bmod{x^n})\bmod{x^n} &amp;= (f(x) \pm g(x))\bmod{x^n}\\
(f(x) \bmod{x^n}) * (g(x)\bmod{x^n})\bmod{x^n} &amp;= (f(x) * g(x))\bmod{x^n}\\
\end{aligned}
\]</span></p>
<p>下面我们就开始学习多项式的各种操作吧</p>
<h2 id="快速傅里叶变换fft">快速傅里叶变换（FFT)</h2>
<p>FFT 可以加速卷积，让时间复杂度从 <span class="math inline">\(O(n^2)\)</span> 降到 <span class="math inline">\(O(n\log n)\)</span>，学习 FFT 的基础操作前，需要先了解复数，因为 FFT 就是基于单位复数根的良好性质实现的。</p>
<h3 id="复数基础">复数基础</h3>
<p>（数学旧人教选修 2-2 内容）</p>
<p>定义虚数单位 <span class="math inline">\(\mathrm i = \sqrt{-1}\)</span>，把形如 <span class="math inline">\(a + b\mathrm i\:(a,b\in\mathbb R)\)</span> 的数称为复数，所有复数的集合称为复数集 <span class="math inline">\(\mathbb C\)</span>。</p>
<p>复数一般使用 <span class="math inline">\(z\)</span> 表示，表示为 <span class="math inline">\(z = a + b\mathrm i\)</span>，这种形式称为复数的代数形式。<span class="math inline">\(a\)</span> 被称为复数的实部，<span class="math inline">\(b\)</span> 称为复数的虚部，未加说明的情况下一般认为 <span class="math inline">\(a,b\in\mathbb R\)</span>。很明显地，当 <span class="math inline">\(a = 0\land b\not=0\)</span> 时，这个复数为纯虚数，当 <span class="math inline">\(b=0\)</span> 时，这个复数为实数。</p>
<p>每个复数 <span class="math inline">\(a + b\mathrm i\)</span> 都能对应平面直角坐标系里面的一个点 <span class="math inline">\((a,b)\)</span>，同样的也可以对应一个向量 <span class="math inline">\((a,b)\)</span>。故定义复数的模为 <span class="math inline">\(\sqrt{a^2 + b^2}\)</span>。</p>
<p>定义复数的加法与乘法： <span class="math display">\[
\begin{aligned}
&amp;(a + b\mathrm i) + (c + d\mathrm i)\\
=&amp;(a + c) + (b + d)\mathrm i
\end{aligned}
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
&amp;(a+b\mathrm i)(c + d\mathrm i)\\
=&amp;ac + ad\mathrm i + cb\mathrm i + bd\mathrm i^2\\
=&amp;(ac - bd) + (ad + bc)\mathrm i
\end{aligned}
\]</span></p>
<p>这都是比较显然的。</p>
<p>容易看出复数满足很多实数的运算律。</p>
<p>定义复数 <span class="math inline">\(z=a+b\mathrm i\)</span> 的共轭复数为 <span class="math inline">\(\overline{z} = a - b\mathrm i\)</span>，不难发现 <span class="math inline">\(z\)</span> 与 <span class="math inline">\(\overline{z}\)</span> 关于实轴对称。 <span class="math display">\[
z\overline z=(a+b\mathrm i)(a-b\mathrm i) = a^2 + b^2=|z|^2
\]</span> 复数既然可以对应平面直角坐标系中的向量，不难发现其可以使用其模长与辐角来表示： <span class="math display">\[
z=a+b\mathrm i\iff z = r(\cos\theta+\mathrm i\sin\theta)
\]</span> 其中 <span class="math inline">\(r\)</span> 为 <span class="math inline">\(z\)</span> 的模长，<span class="math inline">\(\theta\)</span> 为其辐角。即我们可以把一个复数表示成二元组 <span class="math inline">\((r,\theta)\)</span> 的形式。</p>
<p>现在考虑两个复数 <span class="math inline">\((r_1,\theta_1)\)</span> 与 <span class="math inline">\((r_2,\theta_2)\)</span> 相乘得到的结果： <span class="math display">\[
\begin{aligned}
(r_1,\theta_1)\times(r_2,\theta_2) &amp;= r_1(\cos\theta_1 + \mathrm i\sin\theta_1)r_2(\cos\theta_2 + \mathrm i\sin\theta_2)\\
&amp;=r_1r_2(\cos\theta_1\cos\theta_2 - \sin\theta_1\sin\theta_2 + \mathrm i\sin\theta_1\cos\theta_2 + \mathrm i\sin\theta_2\cos\theta_1)\\
&amp;=r_1r_2\left(\cos(\theta_1 + \theta_2) + \mathrm i\sin(\theta_1 + \theta_2)\right)\\
&amp;=(r_1r_2,\theta_1 + \theta_2)
\end{aligned}
\]</span> 于是我们可以概括复数乘法的法则：模长相乘，辐角相加。（上述推导需要掌握基本的三角恒等变换）</p>
<h3 id="从欧拉公式到单位圆">从欧拉公式到单位圆</h3>
<p>给出复数指数幂的定义： <span class="math display">\[
\mathrm e^{x +y\mathrm i} = e^x(\cos y + \mathrm i\sin y)
\]</span> 这个公式是基于如下事实（可以理解为这几个函数在 <span class="math inline">\(x = 0\)</span> 处的泰勒展开）： <span class="math display">\[
\begin{aligned}
\sin(x) &amp;= x - \frac{x^3}{3!}+\frac{x^5}{5!} - \frac{x^7}{7!} + \frac{x^9}{9!} + \cdots = \sum_{k = 1}^\infty\frac{(-1)^{k - 1}x^{2k - 1}}{(2k-1)!}\\
\cos(x) &amp;= 1 - \frac{x^2}{2!} + \frac{x^4}{4!} - \frac{x^6}{6!} + \frac{x^8}{8!} + \cdots = \sum_{k = 0}^\infty\frac{(-1)^{k} x^{2k}}{(2k)!}\\
\mathrm e^x &amp;= 1 + x + \frac{x^2}{2!} + \frac{x^3}{3!} + \frac{x^4}{4!} + \cdots = \sum_{k = 0}^\infty\frac{x^k}{k!}
\end{aligned}
\]</span> 将 <span class="math inline">\(x + y\mathrm i\)</span> 代入进去即可推导。</p>
<p>如果 <span class="math inline">\(x = 0\)</span>，我们就得到大名鼎鼎的欧拉公式： <span class="math display">\[
\mathrm e^{x\mathrm i} = \cos x + \mathrm i\sin x
\]</span> 更特殊地，如果 <span class="math inline">\(x = \pi\)</span>，得到的就是下面这个神奇的式子： <span class="math display">\[
\mathrm e^{\pi\mathrm i} = -1
\]</span> 复平面上我们可以定义类似于平面直角坐标系上的单位圆，单位圆上的所有复数构成集合 <span class="math inline">\(\{z: |z| = 1\}\)</span>。这些复数都可以表示为 <span class="math inline">\(\cos\theta + \mathrm i\sin\theta\)</span> 或 <span class="math inline">\(e^{\theta \mathrm i}\)</span> 的形式。</p>
<h3 id="多项式的表示法">多项式的表示法</h3>
<p>系数表示法：顾名思义 <span class="math display">\[
f(x) = a_0 + a_1x + a_2x^2 + \cdots + a_nx^n\iff f(x) = \{a_0,a_1,a_2,\cdots,a_n\} = 
\begin{bmatrix}
x^0 &amp; x^1 &amp; x^2 &amp;\cdots &amp; x^n
\end{bmatrix}
\begin{bmatrix}
a_0\\a_1\\a_2\\\vdots\\a_n
\end{bmatrix}
\]</span> 点值表示法：</p>
<p>我们知道由一个多项式在 <span class="math inline">\(n + 1\)</span> 个点上的取值是可以唯一确定一个多项式的，其本质也就是线性方程组的解。所以一个 <span class="math inline">\(n\)</span> 次多项式可以用 <span class="math inline">\(n + 1\)</span> 个点表示：</p>
<p><span class="math display">\[
f(x) = \{(x_0,y_0),(x_1,y_1),\cdots,(x_n,y_n)\}
\]</span></p>
<p>或者：</p>
<p><span class="math display">\[
\begin{bmatrix}
x_0^0 &amp; x_0^1 &amp; x_0^2 &amp;\cdots &amp;x_0^n\\
x_1^0 &amp; x_1^1 &amp; x_1^2 &amp;\cdots &amp; x_1^n\\
\vdots &amp; \vdots &amp; \vdots &amp; &amp;\vdots\\
x_n^0 &amp; x_n^1 &amp; x_n^2 &amp; \cdots &amp; x_n^n
\end{bmatrix}\begin{bmatrix}
a_0\\a_1\\ \vdots \\ a_n
\end{bmatrix}
=\begin{bmatrix}
y_0\\y_1\\ \vdots\\ y_n
\end{bmatrix}
\]</span></p>
<p>通过下面的这个形式我们看得出来其就是一个典型的线性方程组的形式，不难证明其解的唯一性。</p>
<p>并且我们发现点值表示法有一个很明显的优势：可以在 <span class="math inline">\(O(n)\)</span> 的时间内将两个多项式乘起来，只需把对应点的 <span class="math inline">\(y\)</span> 乘起来即可。</p>
<p>通俗的来说，FFT 实现的就是快速求多项式乘法的过程：先把系数表示法转成点值表示法（DFT，离散傅里叶变换），乘完之后再把点值还原为插值（IDFT，离散傅里叶逆变换）。可是朴素的 DFT 需要的时间复杂度为 <span class="math inline">\(O(n^2)\)</span>，IDFT 还回其系数需要高斯消元是 <span class="math inline">\(O(n^3)\)</span> 的。而 FFT 利用了一些很特殊很特殊的值加速了 DFT 和 IDFT 的过程，使得总时间复杂度降低到了 <span class="math inline">\(O(n\log n)\)</span>。</p>
<h3 id="单位复数根">单位复数根</h3>
<p>解这个方程： <span class="math display">\[
x^n = 1
\]</span> 我们会发现这个方程在实数范围内只有 <span class="math inline">\(1\)</span> 或者 <span class="math inline">\(2\)</span> 个解。然而代数基本定理告诉我们这样的方程有 <span class="math inline">\(n\)</span> 个复数域上的解。由模长相乘辐角相加我们知道因为最终 <span class="math inline">\(x^n = 1\)</span>，所以这些满足条件的 <span class="math inline">\(x\)</span> 的模长必定也是 <span class="math inline">\(1\)</span>。然后需要满足他们的辐角的 <span class="math inline">\(n\)</span> 倍能被 <span class="math inline">\(2\pi\)</span> 整除。</p>
<p>不难发现其就是 <span class="math inline">\(n\)</span> 等分单位圆：</p>
<figure>
<img alt="" src="https://oi-wiki.org/math/poly/images/fft2.jpg"/><figcaption>img</figcaption>
</figure>
<p>我们记 <span class="math inline">\(n\)</span> 次单位根的第 <span class="math inline">\(k\)</span> 个记为 <span class="math inline">\(\omega_n^k\)</span>，不难发现 <span class="math inline">\(\omega_k^n = \mathrm e^{\frac{2k\pi i}{n}}\)</span>。由此可见，单位复数根具有一些非常好的性质比如： <span class="math display">\[
\begin{aligned}
\omega_n^0 = \omega_n^n &amp;= 1\\
\omega_n^k &amp;= \omega_{2n}^{2k}\\
\omega_{2n}^{k + n} &amp;= -\omega_{2n}^k\\
\left(\omega_{2n}^{k + n}\right)^2 &amp;=\omega_n^k 
\end{aligned}
\]</span> 利用这些性质，我们可以加速 DFT 的过程。FFT 就是利用分治思想加速求每个 <span class="math inline">\(f(\omega_n^k)\)</span> 的值</p>
<h3 id="dft">DFT</h3>
<p>此时 DFT 的分治思想就是分开考虑奇次项和偶次项：</p>
<p>考虑 <span class="math display">\[
f(x) = a_0x^0 + a_1x^1 + a_2x^2 + \cdots
\]</span> 将其分为两个多项式 <span class="math display">\[
\begin{aligned}
f(x) &amp;= a_0x^0 + a_2x^2 + a_4x^4 + a_6x^6 + a_8x^8 + \cdots +a_1x^1 + a_3x^3 + a_5x^5 + a_7x^7 + a_9x^9 + \cdots\\
&amp;= a_0x^0 + a_2x^2 + a_4x^4 + a_6x^6 + a_8x^8+\cdots +x(a_1x^0 + a_3x^2 + a_5x^4 + a_7x^6 + \cdots)
\end{aligned}
\]</span> 考虑两个新多项式： <span class="math display">\[
\begin{aligned}
f_0(x) &amp;= a_0x^0 + a_2x^1 + a_4x^2 + a_6x^3 + \cdots\\
f_1(x) &amp;= a_1x^0 + a_3x^1 + a_5x^2 + a_7x^3 + \cdots
\end{aligned}
\]</span> 不难发现 <span class="math display">\[
f(x) = f_0(x^2) + xf_1(x^2)
\]</span> 利用单位复数根的性质： <span class="math display">\[
\begin{aligned}
\mathrm{DFT}(f(\omega_n^k)) &amp;= \mathrm{DFT}(f_0(\omega_n^{2k})) + \omega_n^k\mathrm{DFT}(f_1(\omega_n^{2k}))\\
&amp;=\mathrm{DFT}(f_0(\omega_{\frac n2^k})) + \omega_n^k\mathrm{DFT}(f_1(\omega_{\frac n2^k}))
\end{aligned}
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
\mathrm{DFT}(f(\omega_n^{k + \frac n2})) &amp;= \mathrm{DFT}(f_0(\omega_n^{2k + n})) + \omega_{n}^{k + \frac n2}\mathrm{DFT}(f_1(\omega_n^{2k + n}))\\
&amp;=\mathrm{DFT}(f_0(\omega_n^n\omega_n^{2k})) - \omega_n^k\mathrm{DFT}(f_1(\omega_n^n\omega_n^{2k}))\\
&amp;=\mathrm{DFT}(f_0(\omega_{\frac n2^k})) - \omega_n^k\mathrm{DFT}(f_1(\omega_{\frac n2^k}))
\end{aligned}
\]</span></p>
<p>其中 <span class="math inline">\(k &lt; \displaystyle\frac n2\)</span>。不难发现只要我们求得出 <span class="math inline">\(\mathrm{DFT}(f_0(\omega_{\frac n2^k}))\)</span> 与 <span class="math inline">\(\mathrm{DFT}(f_1(\omega_{\frac n2^k}))\)</span> 的话，就可以同时求出 <span class="math inline">\(\mathrm{DFT}(f(\omega_n^k))\)</span> 和 <span class="math inline">\(\mathrm{DFT}(f(\omega_n^{k + \frac n2}))\)</span>。接下来再对 <span class="math inline">\(f_0\)</span> 与 <span class="math inline">\(f_1\)</span> 递归 DFT 即可。其时间复杂度函数是形如下面这样的： <span class="math display">\[
T(n) = T(n/2) + O(n)
\]</span> 所以总复杂度为 <span class="math inline">\(\Theta(n\log n)\)</span></p>
<p>实际实现的时候一定要注意传进去的系数一定要是 <span class="math inline">\(2^m\)</span> 个的，不然分治的过程中左右不一样会出问题。第一次传进去的时候就高位补 <span class="math inline">\(0\)</span>，补成最高项次数为 <span class="math inline">\(2^{m - 1}\)</span> 的多项式。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a aria-hidden="true" href="#cb1-1"></a><span class="dt">void</span> dft(<span class="dt">int</span> lim, complex *a)</span>
<span id="cb1-2"><a aria-hidden="true" href="#cb1-2"></a>{</span>
<span id="cb1-3"><a aria-hidden="true" href="#cb1-3"></a>    <span class="cf">if</span> (lim == <span class="dv">1</span>) <span class="cf">return</span>;<span class="co">//常数项直接返回</span></span>
<span id="cb1-4"><a aria-hidden="true" href="#cb1-4"></a>    complex a1[lim &gt;&gt; <span class="dv">1</span>], a2[lim &gt;&gt; <span class="dv">1</span>];</span>
<span id="cb1-5"><a aria-hidden="true" href="#cb1-5"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; lim; i += <span class="dv">2</span>)</span>
<span id="cb1-6"><a aria-hidden="true" href="#cb1-6"></a>        a1[i &gt;&gt; <span class="dv">1</span>] = a[i], a2[i &gt;&gt; <span class="dv">1</span>] = a[i + <span class="dv">1</span>];<span class="co">//把系数按照奇偶分开</span></span>
<span id="cb1-7"><a aria-hidden="true" href="#cb1-7"></a>    dft(lim &gt;&gt; <span class="dv">1</span>, a1, type);<span class="co">//求 DFT(f_0())</span></span>
<span id="cb1-8"><a aria-hidden="true" href="#cb1-8"></a>    dft(lim &gt;&gt; <span class="dv">1</span>, a2, type);<span class="co">//求 DFT(f_1())</span></span>
<span id="cb1-9"><a aria-hidden="true" href="#cb1-9"></a>    complex Wn = complex(cos(<span class="fl">2.0</span> * pi / lim), sin(<span class="fl">2.0</span> * pi / lim)), w = complex(<span class="dv">1</span>, <span class="dv">0</span>);</span>
<span id="cb1-10"><a aria-hidden="true" href="#cb1-10"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; (lim &gt;&gt; <span class="dv">1</span>); ++i, w = w * Wn)</span>
<span id="cb1-11"><a aria-hidden="true" href="#cb1-11"></a>    {</span>
<span id="cb1-12"><a aria-hidden="true" href="#cb1-12"></a>        a[i] = a1[i] + w * a2[i];<span class="co">//求 DFT(f(\omega_n^k))</span></span>
<span id="cb1-13"><a aria-hidden="true" href="#cb1-13"></a>        a[i + (lim &gt;&gt; <span class="dv">1</span>)] = a1[i] - w * a2[i];<span class="co">//求 DFT(f(\omega_n^{k+\fracn2}))</span></span>
<span id="cb1-14"><a aria-hidden="true" href="#cb1-14"></a>    }</span>
<span id="cb1-15"><a aria-hidden="true" href="#cb1-15"></a>    <span class="cf">return</span>;</span>
<span id="cb1-16"><a aria-hidden="true" href="#cb1-16"></a>}</span></code></pre></div>
<h3 id="idft">IDFT</h3>
<p>好了现在假装我们已经求出了两个多项式的点值表达并已经将他们乘起来，但是我们最终还是要把他还原回去到系数表示的。这个过程就叫做 IDFT。</p>
<p>其实就是我们需要求解下面关于 <span class="math inline">\(a\)</span> 的线性方程组：</p>
<p><span class="math display">\[
\begin{bmatrix}
(\omega_n^0)^0 &amp; (\omega_n^0)^1 &amp; (\omega_n^0)^2 &amp;\cdots &amp;(\omega_n^0)^n\\
(\omega_n^1)^0 &amp; (\omega_n^1)^1 &amp; (\omega_n^1)^2 &amp;\cdots &amp; (\omega_n^1)^n\\
\vdots &amp; \vdots &amp; \vdots &amp; &amp;\vdots\\
(\omega_n^{n})^0 &amp; (\omega_n^{n})^1 &amp; (\omega_n^{n})^2 &amp; \cdots &amp; (\omega_n^n)^n
\end{bmatrix}
\begin{bmatrix}
a_0\\a_1\\ \vdots \\ a_n
\end{bmatrix}=\begin{bmatrix}
y_0\\y_1\\ \vdots\\ y_n
\end{bmatrix}
\]</span></p>
<p>我们将其乘上左边矩阵的逆：</p>
<p><span class="math display">\[
\begin{bmatrix}
a_0\\a_1\\ \vdots \\ a_n
\end{bmatrix}=\begin{bmatrix}
(\omega_n^0)^0 &amp; (\omega_n^0)^1 &amp; (\omega_n^0)^2 &amp;\cdots &amp;(\omega_n^0)^n\\
(\omega_n^1)^0 &amp; (\omega_n^1)^1 &amp; (\omega_n^1)^2 &amp;\cdots &amp; (\omega_n^1)^n\\
\vdots &amp; \vdots &amp; \vdots &amp; &amp;\vdots\\
(\omega_n^{n})^0 &amp; (\omega_n^{n})^1 &amp; (\omega_n^{n})^2 &amp; \cdots &amp; (\omega_n^n)^n
\end{bmatrix}^{-1}
\begin{bmatrix}
y_0\\y_1\\ \vdots\\ y_n
\end{bmatrix}
\]</span></p>
<p>模相同的正交列向量构成的矩阵的逆是转置的模分之一倍，所以：</p>
<p><span class="math display">\[
\begin{bmatrix}
(\omega_n^0)^0 &amp; (\omega_n^0)^1 &amp; (\omega_n^0)^2 &amp;\cdots &amp;(\omega_n^0)^n\\
(\omega_n^1)^0 &amp; (\omega_n^1)^1 &amp; (\omega_n^1)^2 &amp;\cdots &amp; (\omega_n^1)^n\\
\vdots &amp; \vdots &amp; \vdots &amp; &amp;\vdots\\
(\omega_n^{n})^0 &amp; (\omega_n^{n})^1 &amp; (\omega_n^{n})^2 &amp; \cdots &amp; (\omega_n^n)^n
\end{bmatrix}^{-1} =\frac {1}{n+1} \begin{bmatrix}
(\omega_n^{-0})^0 &amp; (\omega_n^{-0})^1 &amp; (\omega_n^{-0})^2 &amp;\cdots &amp;(\omega_n^{-0})^n\\
(\omega_n^{-1})^0 &amp; (\omega_n^{-1})^1 &amp; (\omega_n^{-1})^2 &amp;\cdots &amp; (\omega_n^{-1})^n\\
\vdots &amp; \vdots &amp; \vdots &amp; &amp;\vdots\\
(\omega_n^{-n})^0 &amp; (\omega_n^{-n})^1 &amp; (\omega_n^{-n})^2 &amp; \cdots &amp; (\omega_n^{-n})^n
\end{bmatrix}
\]</span></p>
<p>所以不难发现，IDFT 其实就是再做了一遍 DFT，只不过是反起来的。只是算出来最后的系数结果都要除以点值的个数，反映在代码里面就是那个 <code>lim</code> 变量。</p>
<p>不难发现 <span class="math inline">\(\omega_n^k\)</span> 的共轭就是虚部取反，所以可以在 DFT 函数里面传一个参数表示是否为 IDFT。</p>
<p>这样子一个递归版的 FFT 就写完了，总体的代码如下：</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a aria-hidden="true" href="#cb2-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb2-2"><a aria-hidden="true" href="#cb2-2"></a><span class="pp">#include </span><span class="im">&lt;cctype&gt;</span></span>
<span id="cb2-3"><a aria-hidden="true" href="#cb2-3"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb2-4"><a aria-hidden="true" href="#cb2-4"></a><span class="pp">#define FOR</span>(i,<span class="pp"> </span>a,<span class="pp"> </span>b)<span class="pp"> </span><span class="cf">for</span><span class="pp"> </span>(<span class="dt">int</span><span class="pp"> </span>i<span class="pp"> </span>=<span class="pp"> </span>a;<span class="pp"> </span>i<span class="pp"> </span>&lt;=<span class="pp"> </span>b;<span class="pp"> </span>++i)</span>
<span id="cb2-5"><a aria-hidden="true" href="#cb2-5"></a></span>
<span id="cb2-6"><a aria-hidden="true" href="#cb2-6"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">2e6</span> + <span class="dv">5</span>;</span>
<span id="cb2-7"><a aria-hidden="true" href="#cb2-7"></a><span class="at">const</span> <span class="dt">double</span> pi = acos(-<span class="fl">1.0</span>);</span>
<span id="cb2-8"><a aria-hidden="true" href="#cb2-8"></a></span>
<span id="cb2-9"><a aria-hidden="true" href="#cb2-9"></a><span class="kw">inline</span> <span class="dt">int</span> read()</span>
<span id="cb2-10"><a aria-hidden="true" href="#cb2-10"></a>{</span>
<span id="cb2-11"><a aria-hidden="true" href="#cb2-11"></a>    <span class="dt">char</span> c = getchar();</span>
<span id="cb2-12"><a aria-hidden="true" href="#cb2-12"></a>    <span class="dt">int</span> s = <span class="dv">0</span>;</span>
<span id="cb2-13"><a aria-hidden="true" href="#cb2-13"></a>    <span class="cf">while</span> (!isdigit(c))</span>
<span id="cb2-14"><a aria-hidden="true" href="#cb2-14"></a>        c = getchar();</span>
<span id="cb2-15"><a aria-hidden="true" href="#cb2-15"></a>    <span class="cf">while</span> (isdigit(c))</span>
<span id="cb2-16"><a aria-hidden="true" href="#cb2-16"></a>        s = <span class="dv">10</span> * s + c - <span class="ch">'0'</span>, c = getchar();</span>
<span id="cb2-17"><a aria-hidden="true" href="#cb2-17"></a>    <span class="cf">return</span> s;</span>
<span id="cb2-18"><a aria-hidden="true" href="#cb2-18"></a>}</span>
<span id="cb2-19"><a aria-hidden="true" href="#cb2-19"></a></span>
<span id="cb2-20"><a aria-hidden="true" href="#cb2-20"></a><span class="kw">struct</span> complex</span>
<span id="cb2-21"><a aria-hidden="true" href="#cb2-21"></a>{</span>
<span id="cb2-22"><a aria-hidden="true" href="#cb2-22"></a>    <span class="dt">double</span> x, y;</span>
<span id="cb2-23"><a aria-hidden="true" href="#cb2-23"></a>    complex(<span class="dt">double</span> xx = <span class="dv">0</span>, <span class="dt">double</span> yy = <span class="dv">0</span>)</span>
<span id="cb2-24"><a aria-hidden="true" href="#cb2-24"></a>    {</span>
<span id="cb2-25"><a aria-hidden="true" href="#cb2-25"></a>        x = xx, y = yy;</span>
<span id="cb2-26"><a aria-hidden="true" href="#cb2-26"></a>    }</span>
<span id="cb2-27"><a aria-hidden="true" href="#cb2-27"></a>} a[maxn], b[maxn];</span>
<span id="cb2-28"><a aria-hidden="true" href="#cb2-28"></a></span>
<span id="cb2-29"><a aria-hidden="true" href="#cb2-29"></a>complex <span class="kw">operator</span>+(<span class="at">const</span> complex &amp;a, <span class="at">const</span> complex &amp;b) {<span class="cf">return</span> complex(a.x + b.x, a.y + b.y);}</span>
<span id="cb2-30"><a aria-hidden="true" href="#cb2-30"></a>complex <span class="kw">operator</span>-(<span class="at">const</span> complex &amp;a, <span class="at">const</span> complex &amp;b) {<span class="cf">return</span> complex(a.x - b.x, a.y - b.y);}</span>
<span id="cb2-31"><a aria-hidden="true" href="#cb2-31"></a>complex <span class="kw">operator</span>*(<span class="at">const</span> complex &amp;a, <span class="at">const</span> complex &amp;b) {<span class="cf">return</span> complex(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);}</span>
<span id="cb2-32"><a aria-hidden="true" href="#cb2-32"></a></span>
<span id="cb2-33"><a aria-hidden="true" href="#cb2-33"></a><span class="dt">void</span> dft(<span class="dt">int</span> lim, complex *a, <span class="dt">int</span> type)<span class="co">//type = 1 DFT；type = -1 IDFT</span></span>
<span id="cb2-34"><a aria-hidden="true" href="#cb2-34"></a>{</span>
<span id="cb2-35"><a aria-hidden="true" href="#cb2-35"></a>    <span class="cf">if</span> (lim == <span class="dv">1</span>) <span class="cf">return</span>;<span class="co">//返回常数项</span></span>
<span id="cb2-36"><a aria-hidden="true" href="#cb2-36"></a>    complex a1[lim &gt;&gt; <span class="dv">1</span>], a2[lim &gt;&gt; <span class="dv">1</span>];</span>
<span id="cb2-37"><a aria-hidden="true" href="#cb2-37"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; lim; i += <span class="dv">2</span>)</span>
<span id="cb2-38"><a aria-hidden="true" href="#cb2-38"></a>        a1[i &gt;&gt; <span class="dv">1</span>] = a[i], a2[i &gt;&gt; <span class="dv">1</span>] = a[i + <span class="dv">1</span>];</span>
<span id="cb2-39"><a aria-hidden="true" href="#cb2-39"></a>    dft(lim &gt;&gt; <span class="dv">1</span>, a1, type);</span>
<span id="cb2-40"><a aria-hidden="true" href="#cb2-40"></a>    dft(lim &gt;&gt; <span class="dv">1</span>, a2, type);</span>
<span id="cb2-41"><a aria-hidden="true" href="#cb2-41"></a>    complex Wn = complex(cos(<span class="fl">2.0</span> * pi / lim), type * sin(<span class="fl">2.0</span> * pi / lim)), w = complex(<span class="dv">1</span>, <span class="dv">0</span>);</span>
<span id="cb2-42"><a aria-hidden="true" href="#cb2-42"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; (lim &gt;&gt; <span class="dv">1</span>); ++i, w = w * Wn)</span>
<span id="cb2-43"><a aria-hidden="true" href="#cb2-43"></a>    {</span>
<span id="cb2-44"><a aria-hidden="true" href="#cb2-44"></a>        a[i] = a1[i] + w * a2[i];</span>
<span id="cb2-45"><a aria-hidden="true" href="#cb2-45"></a>        a[i + (lim &gt;&gt; <span class="dv">1</span>)] = a1[i] - w * a2[i];</span>
<span id="cb2-46"><a aria-hidden="true" href="#cb2-46"></a>    }</span>
<span id="cb2-47"><a aria-hidden="true" href="#cb2-47"></a>    <span class="cf">return</span>;</span>
<span id="cb2-48"><a aria-hidden="true" href="#cb2-48"></a>}</span>
<span id="cb2-49"><a aria-hidden="true" href="#cb2-49"></a></span>
<span id="cb2-50"><a aria-hidden="true" href="#cb2-50"></a><span class="dt">int</span> main()</span>
<span id="cb2-51"><a aria-hidden="true" href="#cb2-51"></a>{</span>
<span id="cb2-52"><a aria-hidden="true" href="#cb2-52"></a>    <span class="dt">int</span> n = read(), m = read();</span>
<span id="cb2-53"><a aria-hidden="true" href="#cb2-53"></a>    FOR(i, <span class="dv">0</span>, n) a[i].x = read();</span>
<span id="cb2-54"><a aria-hidden="true" href="#cb2-54"></a>    FOR(i, <span class="dv">0</span>, m) b[i].x = read();</span>
<span id="cb2-55"><a aria-hidden="true" href="#cb2-55"></a>    <span class="dt">int</span> lim = <span class="dv">1</span>;</span>
<span id="cb2-56"><a aria-hidden="true" href="#cb2-56"></a>    <span class="cf">while</span> (lim &lt;= n + m) lim &lt;&lt;= <span class="dv">1</span>;<span class="co">//lim一定要大于 n + m</span></span>
<span id="cb2-57"><a aria-hidden="true" href="#cb2-57"></a>    dft(lim, a, <span class="dv">1</span>);</span>
<span id="cb2-58"><a aria-hidden="true" href="#cb2-58"></a>    dft(lim, b, <span class="dv">1</span>);</span>
<span id="cb2-59"><a aria-hidden="true" href="#cb2-59"></a>    FOR(i, <span class="dv">0</span>, lim)</span>
<span id="cb2-60"><a aria-hidden="true" href="#cb2-60"></a>        a[i] = a[i] * b[i];<span class="co">//点值乘起来</span></span>
<span id="cb2-61"><a aria-hidden="true" href="#cb2-61"></a>    dft(lim, a, -<span class="dv">1</span>);<span class="co">//IDFT还回去</span></span>
<span id="cb2-62"><a aria-hidden="true" href="#cb2-62"></a>    FOR(i, <span class="dv">0</span>, n + m)</span>
<span id="cb2-63"><a aria-hidden="true" href="#cb2-63"></a>        printf(<span class="st">"</span><span class="sc">%d</span><span class="st"> "</span>, (<span class="dt">int</span>)(a[i].x / lim + <span class="fl">0.5</span>));<span class="co">//最后要除那个数然后还原回去，四舍五入</span></span>
<span id="cb2-64"><a aria-hidden="true" href="#cb2-64"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb2-65"><a aria-hidden="true" href="#cb2-65"></a>}</span></code></pre></div>
<h3 id="位逆序置换">位逆序置换</h3>
<p>然而，上面的代码连模板都跑不过去……</p>
<p>考虑继续优化 DFT 的过程。递归的过程中开了大量的空间并且常数巨大，考虑非递归写法。</p>
<p>只考虑我们对 <span class="math inline">\(0\)</span> 到 <span class="math inline">\(7\)</span> 操作：</p>
<p>递归的过程：</p>
<pre class="plain"><code>original        0   1   2   3   4   5   6   7
recursion#1     0   2   4   6   1   3   5   7
recursion#2     0   4   2   6   1   5   3   7
recursion#3     0   4   2   6   1   5   3   7
original bin    000 001 010 011 100 101 110 111
now bin         000 100 010 110 001 101 011 111</code></pre>
<p>可见递归到最后的结果无非就是一个二进制反转。</p>
<p>所以我们可以考虑非递归，一开始就先把所有的数放到最后的位置，然后迭代的时候一步步还回去即可。这个过程就是位逆序置换（蝴蝶变换）</p>
<p>考虑处理出 <span class="math inline">\(x\)</span> 二进制位翻转之后的数 <span class="math inline">\(R(x)\)</span>。易知 <span class="math inline">\(R(0) = 0\)</span>。我们可以从小到大求 <span class="math inline">\(R(x)\)</span>。很明显，<span class="math inline">\(\lfloor x/2\rfloor\)</span> 的二进制位是 <span class="math inline">\(x\)</span> 右移一位，那么如果知道了 <span class="math inline">\(R(\lfloor x/2\rfloor)\)</span> 就可以很容易的求出 <span class="math inline">\(R(x)\)</span>，再分 <span class="math inline">\(x\)</span> 的奇偶性判断就可以了。 <span class="math display">\[
R(x) = \left\lfloor\frac{R(\lfloor x/2\rfloor)}{2}\right\rfloor + (x\bmod 2)\times\frac{len}2
\]</span> 举个例子：翻转 <span class="math inline">\((10101110)_2\)</span>，首先我们知道它的二分之一倍为 <span class="math inline">\((01010111)_2\)</span>，其翻转结果为 <span class="math inline">\((11101010)_2\)</span>，除以二变为 <span class="math inline">\((01110101)_2\)</span>，由于它是偶数所以前面不用补 <span class="math inline">\(1\)</span>。不难发现其就是一开始要求的翻转结果。</p>
<p>预处理翻转结果的代码：</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a aria-hidden="true" href="#cb4-1"></a><span class="cf">while</span> (lim &lt;= n + m) lim &lt;&lt;= <span class="dv">1</span>;</span>
<span id="cb4-2"><a aria-hidden="true" href="#cb4-2"></a>FOR(i, <span class="dv">0</span>, lim - <span class="dv">1</span>)</span>
<span id="cb4-3"><a aria-hidden="true" href="#cb4-3"></a>    rev[i] = ((rev[i &gt;&gt; <span class="dv">1</span>] &gt;&gt; <span class="dv">1</span>) | (((i &amp; <span class="dv">1</span>) ? (lim &gt;&gt; <span class="dv">1</span>) : <span class="dv">0</span>)));</span></code></pre></div>
<p>然后在处理翻转的时候只需要下面几行：</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a aria-hidden="true" href="#cb5-1"></a>FOR(i, <span class="dv">0</span>, lim - <span class="dv">1</span>)</span>
<span id="cb5-2"><a aria-hidden="true" href="#cb5-2"></a>    <span class="cf">if</span> (i &lt; rev[i])</span>
<span id="cb5-3"><a aria-hidden="true" href="#cb5-3"></a>        myswap(a[i], a[rev[i]]);</span></code></pre></div>
<p>不难验证其正确性。</p>
<p>而且观察我们在求 <span class="math inline">\(\mathrm{DFT}(f(\omega_n^k))\)</span> 时我们需要算两遍 <span class="math inline">\(\omega_n^k\mathrm{DFT}(f_1(\omega_{\frac n2^k}))\)</span>，复数的乘法常数很大，考虑使用临时变量记录以降低常数。</p>
<p>这样子的话迭代版的 DFT 过程就很好写了：</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a aria-hidden="true" href="#cb6-1"></a><span class="dt">void</span> DFT(<span class="dt">int</span> lim, complex *a, <span class="dt">int</span> type)</span>
<span id="cb6-2"><a aria-hidden="true" href="#cb6-2"></a>{</span>
<span id="cb6-3"><a aria-hidden="true" href="#cb6-3"></a>    FOR(i, <span class="dv">0</span>, lim - <span class="dv">1</span>)</span>
<span id="cb6-4"><a aria-hidden="true" href="#cb6-4"></a>        <span class="cf">if</span> (i &lt; rev[i])</span>
<span id="cb6-5"><a aria-hidden="true" href="#cb6-5"></a>            myswap(a[i], a[rev[i]]);<span class="co">//先预处理翻转完了的结果</span></span>
<span id="cb6-6"><a aria-hidden="true" href="#cb6-6"></a>    <span class="cf">for</span> (<span class="dt">int</span> p = <span class="dv">2</span>; p &lt;= lim; p &lt;&lt;= <span class="dv">1</span>)<span class="co">//模拟合并答案的过程，即为所谓的 n</span></span>
<span id="cb6-7"><a aria-hidden="true" href="#cb6-7"></a>    {</span>
<span id="cb6-8"><a aria-hidden="true" href="#cb6-8"></a>        <span class="dt">int</span> len = p &gt;&gt; <span class="dv">1</span>;<span class="co">//即上面的 n / 2</span></span>
<span id="cb6-9"><a aria-hidden="true" href="#cb6-9"></a>        complex Wp = complex(cos(<span class="dv">2</span> * pi / p), type * sin(<span class="dv">2</span> * pi / p));<span class="co">//处理出 p 次单位根</span></span>
<span id="cb6-10"><a aria-hidden="true" href="#cb6-10"></a>        <span class="cf">for</span> (<span class="dt">int</span> k = <span class="dv">0</span>; k &lt; lim; k += p)<span class="co">//对每一个进行合并</span></span>
<span id="cb6-11"><a aria-hidden="true" href="#cb6-11"></a>        {</span>
<span id="cb6-12"><a aria-hidden="true" href="#cb6-12"></a>            complex w = complex(<span class="dv">1</span>, <span class="dv">0</span>);<span class="co">//处理 \omega_p^0</span></span>
<span id="cb6-13"><a aria-hidden="true" href="#cb6-13"></a>            <span class="cf">for</span> (<span class="dt">int</span> l = k; l &lt; k + len; ++l, w = w * Wp)<span class="co">//开始合并</span></span>
<span id="cb6-14"><a aria-hidden="true" href="#cb6-14"></a>            {</span>
<span id="cb6-15"><a aria-hidden="true" href="#cb6-15"></a>                <span class="co">//此时的 a[l] 就是之前的 a1[i]，a[len + l] 就是之前的 a2[i]</span></span>
<span id="cb6-16"><a aria-hidden="true" href="#cb6-16"></a>                complex tmp = w * a[len + l];</span>
<span id="cb6-17"><a aria-hidden="true" href="#cb6-17"></a>                a[len + l] = a[l] - tmp;<span class="co">//相当于上面的 a[i + (lim &gt;&gt; 1)] = a1[i] - w * a2[i]</span></span>
<span id="cb6-18"><a aria-hidden="true" href="#cb6-18"></a>                a[l] = a[l] + tmp;<span class="co">//相当于上面的 a[i] = a1[i] + w * a2[i]</span></span>
<span id="cb6-19"><a aria-hidden="true" href="#cb6-19"></a>            }</span>
<span id="cb6-20"><a aria-hidden="true" href="#cb6-20"></a>        }</span>
<span id="cb6-21"><a aria-hidden="true" href="#cb6-21"></a>    }</span>
<span id="cb6-22"><a aria-hidden="true" href="#cb6-22"></a>}</span></code></pre></div>
<h3 id="多项式乘法的实现">多项式乘法的实现</h3>
<p>总的一个非递归版 FFT 的实现如下（<a href="https://www.luogu.com.cn/problem/P3803">洛谷 P3803</a>）：</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a aria-hidden="true" href="#cb7-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb7-2"><a aria-hidden="true" href="#cb7-2"></a><span class="pp">#include </span><span class="im">&lt;cctype&gt;</span></span>
<span id="cb7-3"><a aria-hidden="true" href="#cb7-3"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb7-4"><a aria-hidden="true" href="#cb7-4"></a><span class="pp">#define FOR</span>(i,<span class="pp"> </span>a,<span class="pp"> </span>b)<span class="pp"> </span><span class="cf">for</span><span class="pp"> </span>(<span class="dt">int</span><span class="pp"> </span>i<span class="pp"> </span>=<span class="pp"> </span>a;<span class="pp"> </span>i<span class="pp"> </span>&lt;=<span class="pp"> </span>b;<span class="pp"> </span>++i)</span>
<span id="cb7-5"><a aria-hidden="true" href="#cb7-5"></a></span>
<span id="cb7-6"><a aria-hidden="true" href="#cb7-6"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">3e6</span> + <span class="dv">5</span>;</span>
<span id="cb7-7"><a aria-hidden="true" href="#cb7-7"></a><span class="at">const</span> <span class="dt">double</span> pi = acos(-<span class="fl">1.0</span>);</span>
<span id="cb7-8"><a aria-hidden="true" href="#cb7-8"></a></span>
<span id="cb7-9"><a aria-hidden="true" href="#cb7-9"></a><span class="kw">inline</span> <span class="dt">int</span> read()</span>
<span id="cb7-10"><a aria-hidden="true" href="#cb7-10"></a>{</span>
<span id="cb7-11"><a aria-hidden="true" href="#cb7-11"></a>    <span class="dt">char</span> c = getchar();</span>
<span id="cb7-12"><a aria-hidden="true" href="#cb7-12"></a>    <span class="dt">int</span> s = <span class="dv">0</span>;</span>
<span id="cb7-13"><a aria-hidden="true" href="#cb7-13"></a>    <span class="cf">while</span> (!isdigit(c))</span>
<span id="cb7-14"><a aria-hidden="true" href="#cb7-14"></a>        c = getchar();</span>
<span id="cb7-15"><a aria-hidden="true" href="#cb7-15"></a>    <span class="cf">while</span> (isdigit(c))</span>
<span id="cb7-16"><a aria-hidden="true" href="#cb7-16"></a>        s = <span class="dv">10</span> * s + c - <span class="ch">'0'</span>, c = getchar();</span>
<span id="cb7-17"><a aria-hidden="true" href="#cb7-17"></a>    <span class="cf">return</span> s;</span>
<span id="cb7-18"><a aria-hidden="true" href="#cb7-18"></a>}</span>
<span id="cb7-19"><a aria-hidden="true" href="#cb7-19"></a></span>
<span id="cb7-20"><a aria-hidden="true" href="#cb7-20"></a><span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt; <span class="kw">inline</span> <span class="dt">void</span> myswap(T &amp;a, T &amp;b)</span>
<span id="cb7-21"><a aria-hidden="true" href="#cb7-21"></a>{</span>
<span id="cb7-22"><a aria-hidden="true" href="#cb7-22"></a>    T t = a;</span>
<span id="cb7-23"><a aria-hidden="true" href="#cb7-23"></a>    a = b;</span>
<span id="cb7-24"><a aria-hidden="true" href="#cb7-24"></a>    b = t;</span>
<span id="cb7-25"><a aria-hidden="true" href="#cb7-25"></a>    <span class="cf">return</span>;</span>
<span id="cb7-26"><a aria-hidden="true" href="#cb7-26"></a>}</span>
<span id="cb7-27"><a aria-hidden="true" href="#cb7-27"></a></span>
<span id="cb7-28"><a aria-hidden="true" href="#cb7-28"></a><span class="kw">struct</span> complex</span>
<span id="cb7-29"><a aria-hidden="true" href="#cb7-29"></a>{</span>
<span id="cb7-30"><a aria-hidden="true" href="#cb7-30"></a>    <span class="dt">double</span> x, y;</span>
<span id="cb7-31"><a aria-hidden="true" href="#cb7-31"></a>    complex(<span class="dt">double</span> xx = <span class="dv">0</span>, <span class="dt">double</span> yy = <span class="dv">0</span>)</span>
<span id="cb7-32"><a aria-hidden="true" href="#cb7-32"></a>    {</span>
<span id="cb7-33"><a aria-hidden="true" href="#cb7-33"></a>        x = xx, y = yy;</span>
<span id="cb7-34"><a aria-hidden="true" href="#cb7-34"></a>    }</span>
<span id="cb7-35"><a aria-hidden="true" href="#cb7-35"></a>} a[maxn], b[maxn];</span>
<span id="cb7-36"><a aria-hidden="true" href="#cb7-36"></a></span>
<span id="cb7-37"><a aria-hidden="true" href="#cb7-37"></a><span class="dt">int</span> rev[maxn];</span>
<span id="cb7-38"><a aria-hidden="true" href="#cb7-38"></a></span>
<span id="cb7-39"><a aria-hidden="true" href="#cb7-39"></a>complex <span class="kw">operator</span>+(<span class="at">const</span> complex &amp;a, <span class="at">const</span> complex &amp;b) {<span class="cf">return</span> complex(a.x + b.x, a.y + b.y);}</span>
<span id="cb7-40"><a aria-hidden="true" href="#cb7-40"></a>complex <span class="kw">operator</span>-(<span class="at">const</span> complex &amp;a, <span class="at">const</span> complex &amp;b) {<span class="cf">return</span> complex(a.x - b.x, a.y - b.y);}</span>
<span id="cb7-41"><a aria-hidden="true" href="#cb7-41"></a>complex <span class="kw">operator</span>*(<span class="at">const</span> complex &amp;a, <span class="at">const</span> complex &amp;b) {<span class="cf">return</span> complex(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);}</span>
<span id="cb7-42"><a aria-hidden="true" href="#cb7-42"></a></span>
<span id="cb7-43"><a aria-hidden="true" href="#cb7-43"></a><span class="dt">void</span> DFT(<span class="dt">int</span> lim, complex *a, <span class="dt">int</span> type)</span>
<span id="cb7-44"><a aria-hidden="true" href="#cb7-44"></a>{</span>
<span id="cb7-45"><a aria-hidden="true" href="#cb7-45"></a>    FOR(i, <span class="dv">0</span>, lim - <span class="dv">1</span>)</span>
<span id="cb7-46"><a aria-hidden="true" href="#cb7-46"></a>        <span class="cf">if</span> (i &lt; rev[i])</span>
<span id="cb7-47"><a aria-hidden="true" href="#cb7-47"></a>            myswap(a[i], a[rev[i]]);<span class="co">//先预处理翻转完了的结果</span></span>
<span id="cb7-48"><a aria-hidden="true" href="#cb7-48"></a>    <span class="cf">for</span> (<span class="dt">int</span> p = <span class="dv">2</span>; p &lt;= lim; p &lt;&lt;= <span class="dv">1</span>)<span class="co">//模拟合并答案的过程，即为所谓的 n</span></span>
<span id="cb7-49"><a aria-hidden="true" href="#cb7-49"></a>    {</span>
<span id="cb7-50"><a aria-hidden="true" href="#cb7-50"></a>        <span class="dt">int</span> len = p &gt;&gt; <span class="dv">1</span>;<span class="co">//即上面的 n / 2</span></span>
<span id="cb7-51"><a aria-hidden="true" href="#cb7-51"></a>        complex Wp = complex(cos(<span class="dv">2</span> * pi / p), type * sin(<span class="dv">2</span> * pi / p));<span class="co">//处理出 p 次单位根</span></span>
<span id="cb7-52"><a aria-hidden="true" href="#cb7-52"></a>        <span class="cf">for</span> (<span class="dt">int</span> k = <span class="dv">0</span>; k &lt; lim; k += p)<span class="co">//对每一个进行合并</span></span>
<span id="cb7-53"><a aria-hidden="true" href="#cb7-53"></a>        {</span>
<span id="cb7-54"><a aria-hidden="true" href="#cb7-54"></a>            complex w = complex(<span class="dv">1</span>, <span class="dv">0</span>);<span class="co">//处理 \omega_p^0</span></span>
<span id="cb7-55"><a aria-hidden="true" href="#cb7-55"></a>            <span class="cf">for</span> (<span class="dt">int</span> l = k; l &lt; k + len; ++l, w = w * Wp)<span class="co">//开始合并</span></span>
<span id="cb7-56"><a aria-hidden="true" href="#cb7-56"></a>            {</span>
<span id="cb7-57"><a aria-hidden="true" href="#cb7-57"></a>                <span class="co">//此时的 a[l] 就是之前的 a1[i]，a[len + l] 就是之前的 a2[i]</span></span>
<span id="cb7-58"><a aria-hidden="true" href="#cb7-58"></a>                complex tmp = w * a[len + l];</span>
<span id="cb7-59"><a aria-hidden="true" href="#cb7-59"></a>                a[len + l] = a[l] - tmp;<span class="co">//相当于上面的 a[i + (lim &gt;&gt; 1)] = a1[i] - w * a2[i]</span></span>
<span id="cb7-60"><a aria-hidden="true" href="#cb7-60"></a>                a[l] = a[l] + tmp;<span class="co">//相当于上面的 a[i] = a1[i] + w * a2[i]</span></span>
<span id="cb7-61"><a aria-hidden="true" href="#cb7-61"></a>            }</span>
<span id="cb7-62"><a aria-hidden="true" href="#cb7-62"></a>        }</span>
<span id="cb7-63"><a aria-hidden="true" href="#cb7-63"></a>    }</span>
<span id="cb7-64"><a aria-hidden="true" href="#cb7-64"></a>}</span>
<span id="cb7-65"><a aria-hidden="true" href="#cb7-65"></a></span>
<span id="cb7-66"><a aria-hidden="true" href="#cb7-66"></a><span class="dt">int</span> main()</span>
<span id="cb7-67"><a aria-hidden="true" href="#cb7-67"></a>{</span>
<span id="cb7-68"><a aria-hidden="true" href="#cb7-68"></a>    <span class="dt">int</span> n = read(), m = read();</span>
<span id="cb7-69"><a aria-hidden="true" href="#cb7-69"></a>    FOR(i, <span class="dv">0</span>, n) a[i].x = read();</span>
<span id="cb7-70"><a aria-hidden="true" href="#cb7-70"></a>    FOR(i, <span class="dv">0</span>, m) b[i].x = read();</span>
<span id="cb7-71"><a aria-hidden="true" href="#cb7-71"></a>    <span class="dt">int</span> lim = <span class="dv">1</span>;</span>
<span id="cb7-72"><a aria-hidden="true" href="#cb7-72"></a>    <span class="cf">while</span> (lim &lt;= n + m) lim &lt;&lt;= <span class="dv">1</span>;<span class="co">//补齐高位</span></span>
<span id="cb7-73"><a aria-hidden="true" href="#cb7-73"></a>    FOR(i, <span class="dv">0</span>, lim - <span class="dv">1</span>)</span>
<span id="cb7-74"><a aria-hidden="true" href="#cb7-74"></a>        rev[i] = ((rev[i &gt;&gt; <span class="dv">1</span>] &gt;&gt; <span class="dv">1</span>) | (((i &amp; <span class="dv">1</span>) ? (lim &gt;&gt; <span class="dv">1</span>) : <span class="dv">0</span>)));<span class="co">//先处理翻转完的结果</span></span>
<span id="cb7-75"><a aria-hidden="true" href="#cb7-75"></a>    DFT(lim, a, <span class="dv">1</span>);<span class="co">//DFT</span></span>
<span id="cb7-76"><a aria-hidden="true" href="#cb7-76"></a>    DFT(lim, b, <span class="dv">1</span>);<span class="co">//DFT</span></span>
<span id="cb7-77"><a aria-hidden="true" href="#cb7-77"></a>    FOR(i, <span class="dv">0</span>, lim)</span>
<span id="cb7-78"><a aria-hidden="true" href="#cb7-78"></a>        a[i] = a[i] * b[i];<span class="co">//对处理出来的点值进行乘法</span></span>
<span id="cb7-79"><a aria-hidden="true" href="#cb7-79"></a>    DFT(lim, a, -<span class="dv">1</span>);<span class="co">//IDFT</span></span>
<span id="cb7-80"><a aria-hidden="true" href="#cb7-80"></a>    FOR(i, <span class="dv">0</span>, n + m)</span>
<span id="cb7-81"><a aria-hidden="true" href="#cb7-81"></a>        printf(<span class="st">"</span><span class="sc">%d</span><span class="st"> "</span>, (<span class="dt">int</span>)(a[i].x / lim + <span class="fl">0.5</span>));</span>
<span id="cb7-82"><a aria-hidden="true" href="#cb7-82"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb7-83"><a aria-hidden="true" href="#cb7-83"></a>}</span></code></pre></div>
<p>使用 FFT 来求高精度整数乘法的实现（<a href="https://www.luogu.com.cn/problem/P1919">洛谷 P1919</a>）：</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a aria-hidden="true" href="#cb8-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb8-2"><a aria-hidden="true" href="#cb8-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb8-3"><a aria-hidden="true" href="#cb8-3"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb8-4"><a aria-hidden="true" href="#cb8-4"></a><span class="pp">#define FOR</span>(i,<span class="pp"> </span>a,<span class="pp"> </span>b)<span class="pp"> </span><span class="cf">for</span><span class="pp"> </span>(<span class="dt">int</span><span class="pp"> </span>i<span class="pp"> </span>=<span class="pp"> </span>a;<span class="pp"> </span>i<span class="pp"> </span>&lt;=<span class="pp"> </span>b;<span class="pp"> </span>++i)</span>
<span id="cb8-5"><a aria-hidden="true" href="#cb8-5"></a><span class="pp">#define DEC</span>(i,<span class="pp"> </span>a,<span class="pp"> </span>b)<span class="pp"> </span><span class="cf">for</span><span class="pp"> </span>(<span class="dt">int</span><span class="pp"> </span>i<span class="pp"> </span>=<span class="pp"> </span>a;<span class="pp"> </span>i<span class="pp"> </span>&gt;=<span class="pp"> </span>b;<span class="pp"> </span>--i)</span>
<span id="cb8-6"><a aria-hidden="true" href="#cb8-6"></a></span>
<span id="cb8-7"><a aria-hidden="true" href="#cb8-7"></a><span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt; <span class="kw">inline</span> <span class="dt">void</span> myswap(T &amp;a, T &amp;b) {T t = a; a = b; b = t; <span class="cf">return</span>;}</span>
<span id="cb8-8"><a aria-hidden="true" href="#cb8-8"></a></span>
<span id="cb8-9"><a aria-hidden="true" href="#cb8-9"></a><span class="kw">typedef</span> <span class="dt">double</span> db;</span>
<span id="cb8-10"><a aria-hidden="true" href="#cb8-10"></a></span>
<span id="cb8-11"><a aria-hidden="true" href="#cb8-11"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="dv">3000000</span> + <span class="dv">5</span>;</span>
<span id="cb8-12"><a aria-hidden="true" href="#cb8-12"></a><span class="at">const</span> db pi = acos(-<span class="fl">1.0</span>);</span>
<span id="cb8-13"><a aria-hidden="true" href="#cb8-13"></a></span>
<span id="cb8-14"><a aria-hidden="true" href="#cb8-14"></a><span class="kw">struct</span> cmplx</span>
<span id="cb8-15"><a aria-hidden="true" href="#cb8-15"></a>{</span>
<span id="cb8-16"><a aria-hidden="true" href="#cb8-16"></a>    db x, y;</span>
<span id="cb8-17"><a aria-hidden="true" href="#cb8-17"></a>    cmplx(db xx = <span class="dv">0</span>, db yy = <span class="dv">0</span>) {x = xx, y = yy;}</span>
<span id="cb8-18"><a aria-hidden="true" href="#cb8-18"></a>} a[maxn], b[maxn];</span>
<span id="cb8-19"><a aria-hidden="true" href="#cb8-19"></a></span>
<span id="cb8-20"><a aria-hidden="true" href="#cb8-20"></a>cmplx <span class="kw">operator</span>+(<span class="at">const</span> cmplx &amp;a, <span class="at">const</span> cmplx &amp;b) {<span class="cf">return</span> cmplx(a.x + b.x, a.y + b.y);}</span>
<span id="cb8-21"><a aria-hidden="true" href="#cb8-21"></a>cmplx <span class="kw">operator</span>-(<span class="at">const</span> cmplx &amp;a, <span class="at">const</span> cmplx &amp;b) {<span class="cf">return</span> cmplx(a.x - b.x, a.y - b.y);}</span>
<span id="cb8-22"><a aria-hidden="true" href="#cb8-22"></a>cmplx <span class="kw">operator</span>*(<span class="at">const</span> cmplx &amp;a, <span class="at">const</span> cmplx &amp;b) {<span class="cf">return</span> cmplx(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);}</span>
<span id="cb8-23"><a aria-hidden="true" href="#cb8-23"></a></span>
<span id="cb8-24"><a aria-hidden="true" href="#cb8-24"></a><span class="dt">char</span> s1[maxn], s2[maxn];</span>
<span id="cb8-25"><a aria-hidden="true" href="#cb8-25"></a><span class="dt">int</span> rev[maxn], ans[maxn];</span>
<span id="cb8-26"><a aria-hidden="true" href="#cb8-26"></a></span>
<span id="cb8-27"><a aria-hidden="true" href="#cb8-27"></a><span class="dt">void</span> DFT(cmplx *f, <span class="dt">int</span> lim, <span class="dt">int</span> type)</span>
<span id="cb8-28"><a aria-hidden="true" href="#cb8-28"></a>{</span>
<span id="cb8-29"><a aria-hidden="true" href="#cb8-29"></a>    FOR(i, <span class="dv">0</span>, lim - <span class="dv">1</span>)</span>
<span id="cb8-30"><a aria-hidden="true" href="#cb8-30"></a>        <span class="cf">if</span> (i &lt; rev[i])</span>
<span id="cb8-31"><a aria-hidden="true" href="#cb8-31"></a>            myswap(f[i], f[rev[i]]);</span>
<span id="cb8-32"><a aria-hidden="true" href="#cb8-32"></a>    <span class="cf">for</span> (<span class="dt">int</span> p = <span class="dv">2</span>; p &lt;= lim; p &lt;&lt;= <span class="dv">1</span>)</span>
<span id="cb8-33"><a aria-hidden="true" href="#cb8-33"></a>    {</span>
<span id="cb8-34"><a aria-hidden="true" href="#cb8-34"></a>        <span class="dt">int</span> len = p &gt;&gt; <span class="dv">1</span>;</span>
<span id="cb8-35"><a aria-hidden="true" href="#cb8-35"></a>        cmplx Wp(cos(<span class="fl">2.0</span> * pi / p), type * sin(<span class="fl">2.0</span> * pi / p));</span>
<span id="cb8-36"><a aria-hidden="true" href="#cb8-36"></a>        <span class="cf">for</span> (<span class="dt">int</span> k = <span class="dv">0</span>; k &lt; lim; k += p)</span>
<span id="cb8-37"><a aria-hidden="true" href="#cb8-37"></a>        {</span>
<span id="cb8-38"><a aria-hidden="true" href="#cb8-38"></a>            cmplx w(<span class="dv">1</span>, <span class="dv">0</span>);</span>
<span id="cb8-39"><a aria-hidden="true" href="#cb8-39"></a>            <span class="cf">for</span> (<span class="dt">int</span> l = k; l &lt; k + len; ++l, w = w * Wp)</span>
<span id="cb8-40"><a aria-hidden="true" href="#cb8-40"></a>            {</span>
<span id="cb8-41"><a aria-hidden="true" href="#cb8-41"></a>                cmplx tmp = w * f[l + len];</span>
<span id="cb8-42"><a aria-hidden="true" href="#cb8-42"></a>                f[l + len] = f[l] - tmp;</span>
<span id="cb8-43"><a aria-hidden="true" href="#cb8-43"></a>                f[l] = f[l] + tmp;</span>
<span id="cb8-44"><a aria-hidden="true" href="#cb8-44"></a>            }</span>
<span id="cb8-45"><a aria-hidden="true" href="#cb8-45"></a>        }</span>
<span id="cb8-46"><a aria-hidden="true" href="#cb8-46"></a>    }</span>
<span id="cb8-47"><a aria-hidden="true" href="#cb8-47"></a>    <span class="cf">return</span>;</span>
<span id="cb8-48"><a aria-hidden="true" href="#cb8-48"></a>}</span>
<span id="cb8-49"><a aria-hidden="true" href="#cb8-49"></a></span>
<span id="cb8-50"><a aria-hidden="true" href="#cb8-50"></a><span class="dt">int</span> main()</span>
<span id="cb8-51"><a aria-hidden="true" href="#cb8-51"></a>{</span>
<span id="cb8-52"><a aria-hidden="true" href="#cb8-52"></a>    scanf(<span class="st">"</span><span class="sc">%s\n%s</span><span class="st">"</span>, s1, s2);</span>
<span id="cb8-53"><a aria-hidden="true" href="#cb8-53"></a>    <span class="dt">int</span> n1 = -<span class="dv">1</span>, n2 = -<span class="dv">1</span>;</span>
<span id="cb8-54"><a aria-hidden="true" href="#cb8-54"></a>    DEC(i, strlen(s1) - <span class="dv">1</span>, <span class="dv">0</span>) a[++n1].x = s1[i] - <span class="ch">'0'</span>;</span>
<span id="cb8-55"><a aria-hidden="true" href="#cb8-55"></a>    DEC(i, strlen(s2) - <span class="dv">1</span>, <span class="dv">0</span>) b[++n2].x = s2[i] - <span class="ch">'0'</span>;</span>
<span id="cb8-56"><a aria-hidden="true" href="#cb8-56"></a>    <span class="dt">int</span> lim = <span class="dv">1</span>;</span>
<span id="cb8-57"><a aria-hidden="true" href="#cb8-57"></a>    <span class="cf">while</span> (lim &lt;= n1 + n2) lim &lt;&lt;= <span class="dv">1</span>;</span>
<span id="cb8-58"><a aria-hidden="true" href="#cb8-58"></a>    FOR(i, <span class="dv">0</span>, lim - <span class="dv">1</span>)</span>
<span id="cb8-59"><a aria-hidden="true" href="#cb8-59"></a>        rev[i] = ((rev[i &gt;&gt; <span class="dv">1</span>] &gt;&gt; <span class="dv">1</span>) | (((i &amp; <span class="dv">1</span>) ? (lim &gt;&gt; <span class="dv">1</span>) : <span class="dv">0</span>)));</span>
<span id="cb8-60"><a aria-hidden="true" href="#cb8-60"></a>    DFT(a, lim, <span class="dv">1</span>);</span>
<span id="cb8-61"><a aria-hidden="true" href="#cb8-61"></a>    DFT(b, lim, <span class="dv">1</span>);</span>
<span id="cb8-62"><a aria-hidden="true" href="#cb8-62"></a>    FOR(i, <span class="dv">0</span>, lim)</span>
<span id="cb8-63"><a aria-hidden="true" href="#cb8-63"></a>        a[i] = a[i] * b[i];</span>
<span id="cb8-64"><a aria-hidden="true" href="#cb8-64"></a>    DFT(a, lim, -<span class="dv">1</span>);</span>
<span id="cb8-65"><a aria-hidden="true" href="#cb8-65"></a>    FOR(i, <span class="dv">0</span>, lim)</span>
<span id="cb8-66"><a aria-hidden="true" href="#cb8-66"></a>        ans[i] = (<span class="dt">int</span>)(a[i].x / lim + <span class="fl">0.5</span>);</span>
<span id="cb8-67"><a aria-hidden="true" href="#cb8-67"></a>    FOR(i, <span class="dv">0</span>, lim)</span>
<span id="cb8-68"><a aria-hidden="true" href="#cb8-68"></a>        <span class="cf">if</span> (ans[i] &gt;= <span class="dv">10</span>) ans[i + <span class="dv">1</span>] += ans[i] / <span class="dv">10</span>, ans[i] %= <span class="dv">10</span>, lim += (i == lim);</span>
<span id="cb8-69"><a aria-hidden="true" href="#cb8-69"></a>    <span class="cf">while</span> (!ans[lim] &amp;&amp; lim &gt; -<span class="dv">1</span>) --lim;</span>
<span id="cb8-70"><a aria-hidden="true" href="#cb8-70"></a>    <span class="cf">if</span> (lim == -<span class="dv">1</span>) puts(<span class="st">"0"</span>);</span>
<span id="cb8-71"><a aria-hidden="true" href="#cb8-71"></a>    <span class="cf">else</span> DEC(i, lim, <span class="dv">0</span>) printf(<span class="st">"</span><span class="sc">%d</span><span class="st">"</span>, ans[i]);</span>
<span id="cb8-72"><a aria-hidden="true" href="#cb8-72"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb8-73"><a aria-hidden="true" href="#cb8-73"></a>}</span></code></pre></div>
<p><strong>当然，千万要记得 IDFT 还回去的时候要除以 <code>lim</code>，实在怕记不住就在 DFT 函数里面加几句话直接处理好</strong></p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a aria-hidden="true" href="#cb9-1"></a><span class="cf">if</span> (type == -<span class="dv">1</span>)</span>
<span id="cb9-2"><a aria-hidden="true" href="#cb9-2"></a>    FOR(i, <span class="dv">0</span>, lim - <span class="dv">1</span>)</span>
<span id="cb9-3"><a aria-hidden="true" href="#cb9-3"></a>        f[i].x /= lim;</span></code></pre></div>
<h3 id="针对多项式乘法三次变两次优化">针对多项式乘法：三次变两次优化</h3>
<p>我们发现我们在做多项式乘法的时候，需要先 DFT <span class="math inline">\(A(x)\)</span>，<span class="math inline">\(B(x)\)</span>，乘在一起之后再 IDFT 还回来 <span class="math inline">\(C(x)\)</span>，一共进行了三次这样的操作。考虑如何减少我们调用 DFT 的次数。</p>
<p>可以把 <span class="math inline">\(B(x)\)</span> 的系数放到 <span class="math inline">\(A(x)\)</span> 系数的虚部上面，即 <span class="math inline">\(a + b\mathrm i\)</span>，然后 DFT 一下 <span class="math inline">\(A(x)\)</span> 再求个平方，得到 <span class="math inline">\(A^2(x)\)</span>，再 IDFT 回去。我们可以发现得到的系数都是 <span class="math inline">\((a + b\mathrm i)^2 = a^2 - b^2 + 2ab\mathrm i\)</span> 的形式的，所以只需要取出虚部再除以二就得到答案了。</p>
<p>这样的写法可以减小常数，跑的比 NTT 还快。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a aria-hidden="true" href="#cb10-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb10-2"><a aria-hidden="true" href="#cb10-2"></a><span class="pp">#include </span><span class="im">&lt;cctype&gt;</span></span>
<span id="cb10-3"><a aria-hidden="true" href="#cb10-3"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb10-4"><a aria-hidden="true" href="#cb10-4"></a><span class="pp">#define FOR</span>(i,<span class="pp"> </span>a,<span class="pp"> </span>b)<span class="pp"> </span><span class="cf">for</span><span class="pp"> </span>(<span class="dt">int</span><span class="pp"> </span>i<span class="pp"> </span>=<span class="pp"> </span>a;<span class="pp"> </span>i<span class="pp"> </span>&lt;=<span class="pp"> </span>b;<span class="pp"> </span>++i)</span>
<span id="cb10-5"><a aria-hidden="true" href="#cb10-5"></a></span>
<span id="cb10-6"><a aria-hidden="true" href="#cb10-6"></a><span class="kw">typedef</span> <span class="dt">double</span> db;</span>
<span id="cb10-7"><a aria-hidden="true" href="#cb10-7"></a></span>
<span id="cb10-8"><a aria-hidden="true" href="#cb10-8"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">3e6</span> + <span class="dv">5</span>;</span>
<span id="cb10-9"><a aria-hidden="true" href="#cb10-9"></a><span class="at">const</span> db pi = acos(-<span class="fl">1.0</span>);</span>
<span id="cb10-10"><a aria-hidden="true" href="#cb10-10"></a></span>
<span id="cb10-11"><a aria-hidden="true" href="#cb10-11"></a><span class="kw">inline</span> <span class="dt">int</span> read()</span>
<span id="cb10-12"><a aria-hidden="true" href="#cb10-12"></a>{</span>
<span id="cb10-13"><a aria-hidden="true" href="#cb10-13"></a>    <span class="dt">char</span> c = getchar();</span>
<span id="cb10-14"><a aria-hidden="true" href="#cb10-14"></a>    <span class="dt">int</span> s = <span class="dv">0</span>;</span>
<span id="cb10-15"><a aria-hidden="true" href="#cb10-15"></a>    <span class="cf">while</span> (!isdigit(c))</span>
<span id="cb10-16"><a aria-hidden="true" href="#cb10-16"></a>        c = getchar();</span>
<span id="cb10-17"><a aria-hidden="true" href="#cb10-17"></a>    <span class="cf">while</span> (isdigit(c))</span>
<span id="cb10-18"><a aria-hidden="true" href="#cb10-18"></a>        s = <span class="dv">10</span> * s + c - <span class="ch">'0'</span>, c = getchar();</span>
<span id="cb10-19"><a aria-hidden="true" href="#cb10-19"></a>    <span class="cf">return</span> s;</span>
<span id="cb10-20"><a aria-hidden="true" href="#cb10-20"></a>}</span>
<span id="cb10-21"><a aria-hidden="true" href="#cb10-21"></a></span>
<span id="cb10-22"><a aria-hidden="true" href="#cb10-22"></a><span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt; <span class="kw">inline</span> <span class="dt">void</span> myswap(T &amp;a, T &amp;b)</span>
<span id="cb10-23"><a aria-hidden="true" href="#cb10-23"></a>{</span>
<span id="cb10-24"><a aria-hidden="true" href="#cb10-24"></a>    T t = a;</span>
<span id="cb10-25"><a aria-hidden="true" href="#cb10-25"></a>    a = b;</span>
<span id="cb10-26"><a aria-hidden="true" href="#cb10-26"></a>    b = t;</span>
<span id="cb10-27"><a aria-hidden="true" href="#cb10-27"></a>    <span class="cf">return</span>;</span>
<span id="cb10-28"><a aria-hidden="true" href="#cb10-28"></a>}</span>
<span id="cb10-29"><a aria-hidden="true" href="#cb10-29"></a></span>
<span id="cb10-30"><a aria-hidden="true" href="#cb10-30"></a><span class="kw">struct</span> cmplx</span>
<span id="cb10-31"><a aria-hidden="true" href="#cb10-31"></a>{</span>
<span id="cb10-32"><a aria-hidden="true" href="#cb10-32"></a>    db x, y;</span>
<span id="cb10-33"><a aria-hidden="true" href="#cb10-33"></a>    cmplx(db xx = <span class="dv">0</span>, db yy = <span class="dv">0</span>)</span>
<span id="cb10-34"><a aria-hidden="true" href="#cb10-34"></a>    {</span>
<span id="cb10-35"><a aria-hidden="true" href="#cb10-35"></a>        x = xx, y = yy;</span>
<span id="cb10-36"><a aria-hidden="true" href="#cb10-36"></a>    }</span>
<span id="cb10-37"><a aria-hidden="true" href="#cb10-37"></a>} a[maxn];</span>
<span id="cb10-38"><a aria-hidden="true" href="#cb10-38"></a></span>
<span id="cb10-39"><a aria-hidden="true" href="#cb10-39"></a><span class="dt">int</span> rev[maxn];</span>
<span id="cb10-40"><a aria-hidden="true" href="#cb10-40"></a></span>
<span id="cb10-41"><a aria-hidden="true" href="#cb10-41"></a>cmplx <span class="kw">operator</span>+(<span class="at">const</span> cmplx &amp;a, <span class="at">const</span> cmplx &amp;b) {<span class="cf">return</span> cmplx(a.x + b.x, a.y + b.y);}</span>
<span id="cb10-42"><a aria-hidden="true" href="#cb10-42"></a>cmplx <span class="kw">operator</span>-(<span class="at">const</span> cmplx &amp;a, <span class="at">const</span> cmplx &amp;b) {<span class="cf">return</span> cmplx(a.x - b.x, a.y - b.y);}</span>
<span id="cb10-43"><a aria-hidden="true" href="#cb10-43"></a>cmplx <span class="kw">operator</span>*(<span class="at">const</span> cmplx &amp;a, <span class="at">const</span> cmplx &amp;b) {<span class="cf">return</span> cmplx(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);}</span>
<span id="cb10-44"><a aria-hidden="true" href="#cb10-44"></a></span>
<span id="cb10-45"><a aria-hidden="true" href="#cb10-45"></a><span class="dt">void</span> DFT(cmplx *f, <span class="dt">int</span> lim, <span class="dt">int</span> type)</span>
<span id="cb10-46"><a aria-hidden="true" href="#cb10-46"></a>{</span>
<span id="cb10-47"><a aria-hidden="true" href="#cb10-47"></a>    FOR(i, <span class="dv">0</span>, lim - <span class="dv">1</span>)</span>
<span id="cb10-48"><a aria-hidden="true" href="#cb10-48"></a>        <span class="cf">if</span> (i &lt; rev[i])</span>
<span id="cb10-49"><a aria-hidden="true" href="#cb10-49"></a>            myswap(f[i], f[rev[i]]);</span>
<span id="cb10-50"><a aria-hidden="true" href="#cb10-50"></a>    <span class="cf">for</span> (<span class="dt">int</span> p = <span class="dv">2</span>; p &lt;= lim; p &lt;&lt;= <span class="dv">1</span>)</span>
<span id="cb10-51"><a aria-hidden="true" href="#cb10-51"></a>    {</span>
<span id="cb10-52"><a aria-hidden="true" href="#cb10-52"></a>        <span class="dt">int</span> len = p &gt;&gt; <span class="dv">1</span>;</span>
<span id="cb10-53"><a aria-hidden="true" href="#cb10-53"></a>        cmplx Wp(cos(<span class="dv">2</span> * pi / p), type * sin(<span class="dv">2</span> * pi / p));</span>
<span id="cb10-54"><a aria-hidden="true" href="#cb10-54"></a>        <span class="cf">for</span> (<span class="dt">int</span> k = <span class="dv">0</span>; k &lt; lim; k += p)</span>
<span id="cb10-55"><a aria-hidden="true" href="#cb10-55"></a>        {</span>
<span id="cb10-56"><a aria-hidden="true" href="#cb10-56"></a>            cmplx w(<span class="dv">1</span>, <span class="dv">0</span>);</span>
<span id="cb10-57"><a aria-hidden="true" href="#cb10-57"></a>            <span class="cf">for</span> (<span class="dt">int</span> l = k; l &lt; k + len; ++l, w = w * Wp)</span>
<span id="cb10-58"><a aria-hidden="true" href="#cb10-58"></a>            {</span>
<span id="cb10-59"><a aria-hidden="true" href="#cb10-59"></a>                cmplx tmp = w * f[len + l];</span>
<span id="cb10-60"><a aria-hidden="true" href="#cb10-60"></a>                f[len + l] = f[l] - tmp;</span>
<span id="cb10-61"><a aria-hidden="true" href="#cb10-61"></a>                f[l] = f[l] + tmp;</span>
<span id="cb10-62"><a aria-hidden="true" href="#cb10-62"></a>            }</span>
<span id="cb10-63"><a aria-hidden="true" href="#cb10-63"></a>        }</span>
<span id="cb10-64"><a aria-hidden="true" href="#cb10-64"></a>    }</span>
<span id="cb10-65"><a aria-hidden="true" href="#cb10-65"></a>}</span>
<span id="cb10-66"><a aria-hidden="true" href="#cb10-66"></a></span>
<span id="cb10-67"><a aria-hidden="true" href="#cb10-67"></a><span class="dt">int</span> main()</span>
<span id="cb10-68"><a aria-hidden="true" href="#cb10-68"></a>{</span>
<span id="cb10-69"><a aria-hidden="true" href="#cb10-69"></a>    <span class="dt">int</span> n = read(), m = read();</span>
<span id="cb10-70"><a aria-hidden="true" href="#cb10-70"></a>    FOR(i, <span class="dv">0</span>, n) a[i].x = read();</span>
<span id="cb10-71"><a aria-hidden="true" href="#cb10-71"></a>    FOR(i, <span class="dv">0</span>, m) a[i].y = read();</span>
<span id="cb10-72"><a aria-hidden="true" href="#cb10-72"></a>    <span class="dt">int</span> lim = <span class="dv">1</span>;</span>
<span id="cb10-73"><a aria-hidden="true" href="#cb10-73"></a>    <span class="cf">while</span> (lim &lt;= n + m) lim &lt;&lt;= <span class="dv">1</span>;</span>
<span id="cb10-74"><a aria-hidden="true" href="#cb10-74"></a>    FOR(i, <span class="dv">0</span>, lim - <span class="dv">1</span>)</span>
<span id="cb10-75"><a aria-hidden="true" href="#cb10-75"></a>        rev[i] = ((rev[i &gt;&gt; <span class="dv">1</span>] &gt;&gt; <span class="dv">1</span>) | ((i &amp; <span class="dv">1</span>) ? (lim &gt;&gt; <span class="dv">1</span>) : <span class="dv">0</span>));</span>
<span id="cb10-76"><a aria-hidden="true" href="#cb10-76"></a>    DFT(a, lim, <span class="dv">1</span>);</span>
<span id="cb10-77"><a aria-hidden="true" href="#cb10-77"></a>    FOR(i, <span class="dv">0</span>, lim - <span class="dv">1</span>)</span>
<span id="cb10-78"><a aria-hidden="true" href="#cb10-78"></a>        a[i] = a[i] * a[i];</span>
<span id="cb10-79"><a aria-hidden="true" href="#cb10-79"></a>    DFT(a, lim, -<span class="dv">1</span>);</span>
<span id="cb10-80"><a aria-hidden="true" href="#cb10-80"></a>    FOR(i, <span class="dv">0</span>, n + m)</span>
<span id="cb10-81"><a aria-hidden="true" href="#cb10-81"></a>        printf(<span class="st">"</span><span class="sc">%d</span><span class="st"> "</span>, (<span class="dt">int</span>)(a[i].y / lim / <span class="fl">2.0</span> + <span class="fl">0.5</span>));</span>
<span id="cb10-82"><a aria-hidden="true" href="#cb10-82"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb10-83"><a aria-hidden="true" href="#cb10-83"></a>}</span></code></pre></div>
<h2 id="快速数论变换ntt">快速数论变换（NTT）</h2>
<p>有了 FFT，我们已经有能力在 <span class="math inline">\(O(n\log n)\)</span> 的时间内求出两个多项式的卷积了。但是 FFT 也有它的缺点：复数采用的浮点运算不仅造成精度的问题，还会增大常数。遗憾的是数学家们已经证明了 <span class="math inline">\(\mathbb C\)</span> 中只有单位复数根满足 FFT 的要求。</p>
<p>考虑到利用多项式的计数题很多都是模意义下的，所以自然希望为单位复数根找一个模意义下的替代品。此时就进入下面的前置知识：原根。</p>
<h3 id="原根">原根</h3>
<p>设整数 <span class="math inline">\(r,n\)</span> 满足 <span class="math inline">\(r\perp n\land r \not= 0 \land n &gt; 0\)</span>，使得 <span class="math inline">\(r^x \equiv 1\pmod n\)</span> 的<strong>最小正整数</strong> <span class="math inline">\(x\)</span> 称为 <span class="math inline">\(r\)</span> 模 <span class="math inline">\(n\)</span> 的<strong>阶</strong>，记为 <span class="math inline">\(\mathrm{ord}_nr\)</span> 或 <span class="math inline">\(\delta_n(r)\)</span>。</p>
<p>若 <span class="math inline">\(r,n\in\mathbb N^+\land r\perp n\)</span>，当 <span class="math inline">\(\operatorname{ord}_nr = \phi(n)\)</span> 时，称 <span class="math inline">\(r\)</span> 是模 <span class="math inline">\(n\)</span> 的原根或者 <span class="math inline">\(n\)</span> 的原根。</p>
<h3 id="ntt">NTT</h3>
<p>对于质数 <span class="math inline">\(p = qn + 1\:(n = 2^m)\)</span>，原根 <span class="math inline">\(g\)</span> 满足 <span class="math inline">\(g^{qn}\equiv 1\pmod p\)</span>，将 <span class="math inline">\(g_n = g^q\pmod p\)</span> 看作 <span class="math inline">\(\omega_n\)</span> 的等价，其满足相似的性质，比如 <span class="math inline">\(g_n^n\equiv 1\pmod p,g_n^{n/2} \equiv -1\pmod p\)</span>。</p>
<p>常见的质数 <span class="math display">\[
\begin{aligned}
p &amp;= 998244353 = 7\times17\times2^{23} + 1,&amp;g = 3\\
p &amp;= 1004535809 = 479\times 2^{21} + 1,&amp;g =  3
\end{aligned}
\]</span> 迭代到长度为 <span class="math inline">\(l\)</span> 时，<span class="math inline">\(g_l = g^{\frac{p - 1}{l}}\)</span></p>
<p>直接看代码：</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a aria-hidden="true" href="#cb11-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb11-2"><a aria-hidden="true" href="#cb11-2"></a><span class="pp">#include </span><span class="im">&lt;cctype&gt;</span></span>
<span id="cb11-3"><a aria-hidden="true" href="#cb11-3"></a><span class="pp">#define FOR</span>(i,<span class="pp"> </span>a,<span class="pp"> </span>b)<span class="pp"> </span><span class="cf">for</span><span class="pp"> </span>(<span class="dt">int</span><span class="pp"> </span>i<span class="pp"> </span>=<span class="pp"> </span>a;<span class="pp"> </span>i<span class="pp"> </span>&lt;=<span class="pp"> </span>b;<span class="pp"> </span>++i)</span>
<span id="cb11-4"><a aria-hidden="true" href="#cb11-4"></a></span>
<span id="cb11-5"><a aria-hidden="true" href="#cb11-5"></a><span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> ll;</span>
<span id="cb11-6"><a aria-hidden="true" href="#cb11-6"></a></span>
<span id="cb11-7"><a aria-hidden="true" href="#cb11-7"></a><span class="at">const</span> ll G = <span class="dv">3</span>;</span>
<span id="cb11-8"><a aria-hidden="true" href="#cb11-8"></a><span class="at">const</span> ll mod = <span class="dv">998244353</span>;</span>
<span id="cb11-9"><a aria-hidden="true" href="#cb11-9"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">3e6</span> + <span class="dv">5</span>;</span>
<span id="cb11-10"><a aria-hidden="true" href="#cb11-10"></a></span>
<span id="cb11-11"><a aria-hidden="true" href="#cb11-11"></a><span class="kw">inline</span> <span class="dt">int</span> read()</span>
<span id="cb11-12"><a aria-hidden="true" href="#cb11-12"></a>{</span>
<span id="cb11-13"><a aria-hidden="true" href="#cb11-13"></a>    <span class="dt">char</span> c = getchar();</span>
<span id="cb11-14"><a aria-hidden="true" href="#cb11-14"></a>    <span class="dt">int</span> s = <span class="dv">0</span>;</span>
<span id="cb11-15"><a aria-hidden="true" href="#cb11-15"></a>    <span class="cf">while</span> (!isdigit(c))</span>
<span id="cb11-16"><a aria-hidden="true" href="#cb11-16"></a>        c = getchar();</span>
<span id="cb11-17"><a aria-hidden="true" href="#cb11-17"></a>    <span class="cf">while</span> (isdigit(c))</span>
<span id="cb11-18"><a aria-hidden="true" href="#cb11-18"></a>        s = <span class="dv">10</span> * s + c - <span class="ch">'0'</span>, c = getchar();</span>
<span id="cb11-19"><a aria-hidden="true" href="#cb11-19"></a>    <span class="cf">return</span> s;</span>
<span id="cb11-20"><a aria-hidden="true" href="#cb11-20"></a>}</span>
<span id="cb11-21"><a aria-hidden="true" href="#cb11-21"></a></span>
<span id="cb11-22"><a aria-hidden="true" href="#cb11-22"></a><span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt; <span class="kw">inline</span> <span class="dt">void</span> myswap(T &amp;a, T &amp;b)</span>
<span id="cb11-23"><a aria-hidden="true" href="#cb11-23"></a>{</span>
<span id="cb11-24"><a aria-hidden="true" href="#cb11-24"></a>    T t = a;</span>
<span id="cb11-25"><a aria-hidden="true" href="#cb11-25"></a>    a = b;</span>
<span id="cb11-26"><a aria-hidden="true" href="#cb11-26"></a>    b = t;</span>
<span id="cb11-27"><a aria-hidden="true" href="#cb11-27"></a>    <span class="cf">return</span>;</span>
<span id="cb11-28"><a aria-hidden="true" href="#cb11-28"></a>}</span>
<span id="cb11-29"><a aria-hidden="true" href="#cb11-29"></a></span>
<span id="cb11-30"><a aria-hidden="true" href="#cb11-30"></a>ll pow(ll base, ll p = mod - <span class="dv">2</span>)</span>
<span id="cb11-31"><a aria-hidden="true" href="#cb11-31"></a>{</span>
<span id="cb11-32"><a aria-hidden="true" href="#cb11-32"></a>    ll ret = <span class="dv">1</span>;</span>
<span id="cb11-33"><a aria-hidden="true" href="#cb11-33"></a>    <span class="cf">for</span> (; p; p &gt;&gt;= <span class="dv">1</span>)</span>
<span id="cb11-34"><a aria-hidden="true" href="#cb11-34"></a>    {</span>
<span id="cb11-35"><a aria-hidden="true" href="#cb11-35"></a>        <span class="cf">if</span> (p &amp; <span class="dv">1</span>)</span>
<span id="cb11-36"><a aria-hidden="true" href="#cb11-36"></a>            ret = ret * base % mod;</span>
<span id="cb11-37"><a aria-hidden="true" href="#cb11-37"></a>        base = base * base % mod;</span>
<span id="cb11-38"><a aria-hidden="true" href="#cb11-38"></a>    }</span>
<span id="cb11-39"><a aria-hidden="true" href="#cb11-39"></a>    <span class="cf">return</span> ret;</span>
<span id="cb11-40"><a aria-hidden="true" href="#cb11-40"></a>}</span>
<span id="cb11-41"><a aria-hidden="true" href="#cb11-41"></a></span>
<span id="cb11-42"><a aria-hidden="true" href="#cb11-42"></a><span class="dt">int</span> rev[maxn];</span>
<span id="cb11-43"><a aria-hidden="true" href="#cb11-43"></a>ll f[maxn], g[maxn];</span>
<span id="cb11-44"><a aria-hidden="true" href="#cb11-44"></a><span class="at">const</span> ll invG = pow(G);</span>
<span id="cb11-45"><a aria-hidden="true" href="#cb11-45"></a></span>
<span id="cb11-46"><a aria-hidden="true" href="#cb11-46"></a><span class="dt">void</span> NTT(ll *f, <span class="dt">int</span> lim, <span class="dt">int</span> type)</span>
<span id="cb11-47"><a aria-hidden="true" href="#cb11-47"></a>{</span>
<span id="cb11-48"><a aria-hidden="true" href="#cb11-48"></a>    FOR(i, <span class="dv">0</span>, lim - <span class="dv">1</span>)</span>
<span id="cb11-49"><a aria-hidden="true" href="#cb11-49"></a>        <span class="cf">if</span> (i &lt; rev[i])</span>
<span id="cb11-50"><a aria-hidden="true" href="#cb11-50"></a>            myswap(f[i], f[rev[i]]);</span>
<span id="cb11-51"><a aria-hidden="true" href="#cb11-51"></a>    <span class="cf">for</span> (<span class="dt">int</span> p = <span class="dv">2</span>; p &lt;= lim; p &lt;&lt;= <span class="dv">1</span>)</span>
<span id="cb11-52"><a aria-hidden="true" href="#cb11-52"></a>    {</span>
<span id="cb11-53"><a aria-hidden="true" href="#cb11-53"></a>        <span class="dt">int</span> len = p &gt;&gt; <span class="dv">1</span>;</span>
<span id="cb11-54"><a aria-hidden="true" href="#cb11-54"></a>        ll tG = pow(type ? G : invG, (mod - <span class="dv">1</span>) / p);</span>
<span id="cb11-55"><a aria-hidden="true" href="#cb11-55"></a>        <span class="cf">for</span> (<span class="dt">int</span> k = <span class="dv">0</span>; k &lt; lim; k += p)</span>
<span id="cb11-56"><a aria-hidden="true" href="#cb11-56"></a>        {</span>
<span id="cb11-57"><a aria-hidden="true" href="#cb11-57"></a>            ll buf = <span class="dv">1</span>;</span>
<span id="cb11-58"><a aria-hidden="true" href="#cb11-58"></a>            <span class="cf">for</span> (<span class="dt">int</span> l = k; l &lt; k + len; ++l, buf = buf * tG % mod)</span>
<span id="cb11-59"><a aria-hidden="true" href="#cb11-59"></a>            {</span>
<span id="cb11-60"><a aria-hidden="true" href="#cb11-60"></a>                ll tmp = buf * f[len + l] % mod;</span>
<span id="cb11-61"><a aria-hidden="true" href="#cb11-61"></a>                f[len + l] = f[l] - tmp;</span>
<span id="cb11-62"><a aria-hidden="true" href="#cb11-62"></a>                <span class="cf">if</span> (f[len + l] &lt; <span class="dv">0</span>) f[len + l] += mod;<span class="co">//及时取模</span></span>
<span id="cb11-63"><a aria-hidden="true" href="#cb11-63"></a>                f[l] = f[l] + tmp;</span>
<span id="cb11-64"><a aria-hidden="true" href="#cb11-64"></a>                <span class="cf">if</span> (f[l] &gt; mod) f[l] -= mod;<span class="co">//及时取模</span></span>
<span id="cb11-65"><a aria-hidden="true" href="#cb11-65"></a>            }</span>
<span id="cb11-66"><a aria-hidden="true" href="#cb11-66"></a>        }</span>
<span id="cb11-67"><a aria-hidden="true" href="#cb11-67"></a>    }</span>
<span id="cb11-68"><a aria-hidden="true" href="#cb11-68"></a>    ll invlim = pow(lim);<span class="co">//最后还回去，除以lim相当于乘上lim的逆元</span></span>
<span id="cb11-69"><a aria-hidden="true" href="#cb11-69"></a>    <span class="cf">if</span> (!type)</span>
<span id="cb11-70"><a aria-hidden="true" href="#cb11-70"></a>        FOR(i, <span class="dv">0</span>, lim - <span class="dv">1</span>)</span>
<span id="cb11-71"><a aria-hidden="true" href="#cb11-71"></a>            f[i] = (f[i] * invlim % mod);</span>
<span id="cb11-72"><a aria-hidden="true" href="#cb11-72"></a>    <span class="cf">return</span>;</span>
<span id="cb11-73"><a aria-hidden="true" href="#cb11-73"></a>}</span>
<span id="cb11-74"><a aria-hidden="true" href="#cb11-74"></a></span>
<span id="cb11-75"><a aria-hidden="true" href="#cb11-75"></a><span class="dt">int</span> main()</span>
<span id="cb11-76"><a aria-hidden="true" href="#cb11-76"></a>{</span>
<span id="cb11-77"><a aria-hidden="true" href="#cb11-77"></a>    <span class="dt">int</span> n = read(), m = read();</span>
<span id="cb11-78"><a aria-hidden="true" href="#cb11-78"></a>    FOR(i, <span class="dv">0</span>, n) f[i] = read();</span>
<span id="cb11-79"><a aria-hidden="true" href="#cb11-79"></a>    FOR(i, <span class="dv">0</span>, m) g[i] = read();</span>
<span id="cb11-80"><a aria-hidden="true" href="#cb11-80"></a>    <span class="dt">int</span> lim = <span class="dv">1</span>;</span>
<span id="cb11-81"><a aria-hidden="true" href="#cb11-81"></a>    <span class="cf">while</span> (lim &lt;= n + m) lim &lt;&lt;= <span class="dv">1</span>;</span>
<span id="cb11-82"><a aria-hidden="true" href="#cb11-82"></a>    FOR(i, <span class="dv">0</span>, lim - <span class="dv">1</span>)</span>
<span id="cb11-83"><a aria-hidden="true" href="#cb11-83"></a>        rev[i] = (rev[i &gt;&gt; <span class="dv">1</span>] &gt;&gt; <span class="dv">1</span>) | ((i &amp; <span class="dv">1</span>) ? (lim &gt;&gt; <span class="dv">1</span>) : <span class="dv">0</span>);</span>
<span id="cb11-84"><a aria-hidden="true" href="#cb11-84"></a>    NTT(f, lim, <span class="dv">1</span>), NTT(g, lim, <span class="dv">1</span>);</span>
<span id="cb11-85"><a aria-hidden="true" href="#cb11-85"></a>    FOR(i, <span class="dv">0</span>, lim - <span class="dv">1</span>)</span>
<span id="cb11-86"><a aria-hidden="true" href="#cb11-86"></a>        f[i] = f[i] * g[i] % mod;</span>
<span id="cb11-87"><a aria-hidden="true" href="#cb11-87"></a>    NTT(f, lim, <span class="dv">0</span>);</span>
<span id="cb11-88"><a aria-hidden="true" href="#cb11-88"></a>    FOR(i, <span class="dv">0</span>, n + m)</span>
<span id="cb11-89"><a aria-hidden="true" href="#cb11-89"></a>        printf(<span class="st">"</span><span class="sc">%d</span><span class="st"> "</span>, (<span class="dt">int</span>)f[i]);</span>
<span id="cb11-90"><a aria-hidden="true" href="#cb11-90"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb11-91"><a aria-hidden="true" href="#cb11-91"></a>}</span></code></pre></div>
<h2 id="任意模数多项式乘法">任意模数多项式乘法</h2>
<h3 id="问题描述">问题描述</h3>
<p>有些毒瘤题目里面，模数不一定是满足 <span class="math inline">\(p = a\times2^k + 1\)</span> 的形式，这就意味着 NTT 是不能用的，而普通的 FFT 精度又不够，怎么办呢？</p>
<p>一般的问题形式：给定 <span class="math inline">\(f(x)\)</span> 和 <span class="math inline">\(g(x)\)</span>，求 <span class="math inline">\(h(x) = f(x)\times g(x)\)</span>，系数对 <span class="math inline">\(10^9 + 7\)</span> 取模。</p>
<h3 id="法-1三模-ntt">法 1：三模 NTT</h3>
<p>分析可得最大的数应该是 <span class="math inline">\(p^2\times\max\{\deg f, \deg g\}\)</span>，是 <span class="math inline">\(10^{23}\)</span> 级别的。所以选三个模数分别做 NTT 然后用 CRT 合并即可。需要做 <span class="math inline">\(9\)</span> 次 DFT，常数较大，暂不考虑。</p>
<h3 id="法-2拆系数-fftmtt">法 2：拆系数 FFT（MTT）</h3>
<p>考虑把多项式的系数拆成形如 <span class="math inline">\(a\times 2^{15} + b\)</span> 的形式，那么 <span class="math inline">\(a, b\le 2^{15}\)</span>。这样子相乘的值域大概是 <span class="math inline">\(10^{14}\)</span> 级别的。</p>
<p>于是有 <span class="math inline">\(c_1c_2 = (a_1\times 2^{15} + b_1)(a_2\times 2^{15}+b_2) = a_1a_2\times 2^{30} + (a_1b_2 + a_2b_1)2^{15} + b_1b_2\)</span>。然而这样看似要求四次多项式乘法，<span class="math inline">\(12\)</span> 次 DFT，似乎更加屑了。</p>
<p>冷静分析一下：现在的问题是有四个多项式 <span class="math inline">\(A_1\)</span>，<span class="math inline">\(A_2\)</span>，<span class="math inline">\(B_1\)</span> 和 <span class="math inline">\(B_2\)</span>，要求这些多项式的两两乘积。</p>
<p>利用复数的性质：考虑 <span class="math inline">\((a + bi)(c + di) = ac - bd + (ad + bc)i\)</span>。那么令复多项式 <span class="math inline">\(P = A_1 + iA_2\)</span>，<span class="math inline">\(Q = B_1 + iB_2\)</span>。</p>
<p>有 <span class="math inline">\(T_1 = P\times Q = A_1B_1 - A_2B_2 + (A_1B_2 + A_2B_1)i\)</span>。</p>
<p>再设 <span class="math inline">\(P' = A_1 - iA_2\)</span>，那么有 <span class="math inline">\(T_2 = P'\times Q = A_1B_1 + A_2B_2 + (A_1B_2 - A_2B_1)i\)</span>。</p>
<p>两式相加可以得到 <span class="math inline">\(2A_1B_1 + 2A_1B_2i\)</span>，两式相减可以得到 <span class="math inline">\(2A_2B_2 - 2A_2B_1i\)</span>。把这两个多项式的实部虚部拆出来就得到我们想要的结果了。</p>
<p>这样子需要做 <span class="math inline">\(5\)</span> 次 DFT，常数不小但比 <span class="math inline">\(9\)</span> 次 NTT 优。</p>
<h3 id="实现">实现</h3>
<p>可以直接配合后面的 <code>vector</code> 版多项式板子食用。</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a aria-hidden="true" href="#cb12-1"></a><span class="kw">namespace</span> complex {</span>
<span id="cb12-2"><a aria-hidden="true" href="#cb12-2"></a>    <span class="kw">struct</span> cmplx {</span>
<span id="cb12-3"><a aria-hidden="true" href="#cb12-3"></a>        db x, y;</span>
<span id="cb12-4"><a aria-hidden="true" href="#cb12-4"></a>        cmplx(db xx = <span class="dv">0</span>, db yy = <span class="dv">0</span>) : x(xx), y(yy) {}</span>
<span id="cb12-5"><a aria-hidden="true" href="#cb12-5"></a>    };</span>
<span id="cb12-6"><a aria-hidden="true" href="#cb12-6"></a>    il cmplx <span class="kw">operator</span>+(<span class="at">const</span> cmplx &amp;a, <span class="at">const</span> cmplx &amp;b) {<span class="cf">return</span> cmplx(a.x + b.x, a.y + b.y);}</span>
<span id="cb12-7"><a aria-hidden="true" href="#cb12-7"></a>    il cmplx <span class="kw">operator</span>-(<span class="at">const</span> cmplx &amp;a, <span class="at">const</span> cmplx &amp;b) {<span class="cf">return</span> cmplx(a.x - b.x, a.y - b.y);}</span>
<span id="cb12-8"><a aria-hidden="true" href="#cb12-8"></a>    il cmplx <span class="kw">operator</span>*(<span class="at">const</span> cmplx &amp;a, <span class="at">const</span> cmplx &amp;b) {<span class="cf">return</span> cmplx(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);}</span>
<span id="cb12-9"><a aria-hidden="true" href="#cb12-9"></a>} <span class="kw">using</span> <span class="kw">namespace</span> complex;</span>
<span id="cb12-10"><a aria-hidden="true" href="#cb12-10"></a></span>
<span id="cb12-11"><a aria-hidden="true" href="#cb12-11"></a><span class="kw">namespace</span> MTT {</span>
<span id="cb12-12"><a aria-hidden="true" href="#cb12-12"></a>    <span class="kw">using</span> <span class="bu">std::</span>sin;</span>
<span id="cb12-13"><a aria-hidden="true" href="#cb12-13"></a>    <span class="kw">using</span> <span class="bu">std::</span>cos;</span>
<span id="cb12-14"><a aria-hidden="true" href="#cb12-14"></a>    <span class="kw">using</span> <span class="bu">std::</span>acos;</span>
<span id="cb12-15"><a aria-hidden="true" href="#cb12-15"></a>    <span class="kw">using</span> <span class="bu">std::</span>floor;</span>
<span id="cb12-16"><a aria-hidden="true" href="#cb12-16"></a>    <span class="at">const</span> db PI = acos(-<span class="fl">1.0</span>);</span>
<span id="cb12-17"><a aria-hidden="true" href="#cb12-17"></a>    <span class="at">const</span> <span class="dt">int</span> DIV = <span class="dv">32768</span>;</span>
<span id="cb12-18"><a aria-hidden="true" href="#cb12-18"></a>    <span class="dt">int</span> mod;</span>
<span id="cb12-19"><a aria-hidden="true" href="#cb12-19"></a></span>
<span id="cb12-20"><a aria-hidden="true" href="#cb12-20"></a>    <span class="pp">#define clr2</span>(f,<span class="pp"> </span>n)<span class="pp"> </span>memset(f,<span class="pp"> </span><span class="dv">0</span>,<span class="pp"> </span>(<span class="kw">sizeof</span>(cmplx))<span class="pp"> </span>*<span class="pp"> </span>n)</span>
<span id="cb12-21"><a aria-hidden="true" href="#cb12-21"></a></span>
<span id="cb12-22"><a aria-hidden="true" href="#cb12-22"></a>    <span class="dt">void</span> DFT(cmplx *g, <span class="dt">int</span> type, <span class="dt">int</span> lim) {</span>
<span id="cb12-23"><a aria-hidden="true" href="#cb12-23"></a>        <span class="at">static</span> cmplx f[maxn &lt;&lt; <span class="dv">1</span>];</span>
<span id="cb12-24"><a aria-hidden="true" href="#cb12-24"></a>        getTr(lim);</span>
<span id="cb12-25"><a aria-hidden="true" href="#cb12-25"></a>        FOR(i, <span class="dv">0</span>, lim - <span class="dv">1</span>) f[i] = g[<span class="fu">tr</span>[i]];</span>
<span id="cb12-26"><a aria-hidden="true" href="#cb12-26"></a>        <span class="cf">for</span> (<span class="dt">int</span> p = <span class="dv">2</span>; p &lt;= lim; p &lt;&lt;= <span class="dv">1</span>) {</span>
<span id="cb12-27"><a aria-hidden="true" href="#cb12-27"></a>            <span class="dt">int</span> len = p &gt;&gt; <span class="dv">1</span>;</span>
<span id="cb12-28"><a aria-hidden="true" href="#cb12-28"></a>            cmplx Wp(<span class="bu">std::</span>cos(PI / len), type * <span class="bu">std::</span>sin(PI / len));</span>
<span id="cb12-29"><a aria-hidden="true" href="#cb12-29"></a>            <span class="cf">for</span> (<span class="dt">int</span> k = <span class="dv">0</span>; k &lt; lim; k += p) {</span>
<span id="cb12-30"><a aria-hidden="true" href="#cb12-30"></a>                cmplx w(<span class="dv">1</span>, <span class="dv">0</span>);</span>
<span id="cb12-31"><a aria-hidden="true" href="#cb12-31"></a>                <span class="cf">for</span> (<span class="dt">int</span> l = k; l &lt; k + len; ++l, w = w * Wp) {</span>
<span id="cb12-32"><a aria-hidden="true" href="#cb12-32"></a>                    cmplx tmp = w * f[len + l];</span>
<span id="cb12-33"><a aria-hidden="true" href="#cb12-33"></a>                    f[len + l] = f[l] - tmp;</span>
<span id="cb12-34"><a aria-hidden="true" href="#cb12-34"></a>                    f[l] = f[l] + tmp;</span>
<span id="cb12-35"><a aria-hidden="true" href="#cb12-35"></a>                }</span>
<span id="cb12-36"><a aria-hidden="true" href="#cb12-36"></a>            }</span>
<span id="cb12-37"><a aria-hidden="true" href="#cb12-37"></a>        }</span>
<span id="cb12-38"><a aria-hidden="true" href="#cb12-38"></a>        FOR(i, <span class="dv">0</span>, lim - <span class="dv">1</span>)</span>
<span id="cb12-39"><a aria-hidden="true" href="#cb12-39"></a>            <span class="cf">if</span> (type == -<span class="dv">1</span>) g[i] = cmplx(f[i].x / lim, f[i].y / lim);</span>
<span id="cb12-40"><a aria-hidden="true" href="#cb12-40"></a>            <span class="cf">else</span> g[i] = f[i];</span>
<span id="cb12-41"><a aria-hidden="true" href="#cb12-41"></a>        <span class="cf">return</span>;</span>
<span id="cb12-42"><a aria-hidden="true" href="#cb12-42"></a>    }</span>
<span id="cb12-43"><a aria-hidden="true" href="#cb12-43"></a></span>
<span id="cb12-44"><a aria-hidden="true" href="#cb12-44"></a>    Poly <span class="kw">operator</span>*(<span class="at">const</span> Poly &amp;A, <span class="at">const</span> Poly &amp;B) {</span>
<span id="cb12-45"><a aria-hidden="true" href="#cb12-45"></a>        <span class="at">static</span> cmplx p1[maxn &lt;&lt; <span class="dv">1</span>], p2[maxn &lt;&lt; <span class="dv">1</span>], q[maxn &lt;&lt; <span class="dv">1</span>], t1[maxn &lt;&lt; <span class="dv">1</span>], t2[maxn &lt;&lt; <span class="dv">1</span>];</span>
<span id="cb12-46"><a aria-hidden="true" href="#cb12-46"></a>        VEC(i, A) p1[i] = cmplx(A[i] / DIV, A[i] % DIV), p2[i] = cmplx(A[i] / DIV, -p1[i].y);</span>
<span id="cb12-47"><a aria-hidden="true" href="#cb12-47"></a>        VEC(i, B) q[i] = cmplx(B[i] / DIV, B[i] % DIV);</span>
<span id="cb12-48"><a aria-hidden="true" href="#cb12-48"></a>        Poly C; C.resize(min(lim, (<span class="dt">int</span>)A.size() + (<span class="dt">int</span>)B.size() - <span class="dv">1</span>));</span>
<span id="cb12-49"><a aria-hidden="true" href="#cb12-49"></a>        <span class="dt">int</span> n; <span class="cf">for</span> (n = <span class="dv">1</span>; n &lt; (<span class="dt">int</span>)(A.size() + B.size() - <span class="dv">1</span>); n &lt;&lt;= <span class="dv">1</span>);</span>
<span id="cb12-50"><a aria-hidden="true" href="#cb12-50"></a></span>
<span id="cb12-51"><a aria-hidden="true" href="#cb12-51"></a>        DFT(p1, <span class="dv">1</span>, n), DFT(p2, <span class="dv">1</span>, n), DFT(q, <span class="dv">1</span>, n);</span>
<span id="cb12-52"><a aria-hidden="true" href="#cb12-52"></a>        FOR(i, <span class="dv">0</span>, n - <span class="dv">1</span>) t1[i] = p1[i] * q[i], t2[i] = p2[i] * q[i];</span>
<span id="cb12-53"><a aria-hidden="true" href="#cb12-53"></a>        DFT(t1, -<span class="dv">1</span>, n), DFT(t2, -<span class="dv">1</span>, n);</span>
<span id="cb12-54"><a aria-hidden="true" href="#cb12-54"></a></span>
<span id="cb12-55"><a aria-hidden="true" href="#cb12-55"></a>        VEC(i, C) {</span>
<span id="cb12-56"><a aria-hidden="true" href="#cb12-56"></a>            ll a1b1, a1b2, a2b1, a2b2;</span>
<span id="cb12-57"><a aria-hidden="true" href="#cb12-57"></a>            a1b1 = (ll)floor((t1[i].x + t2[i].x) / <span class="fl">2.0</span> + <span class="fl">0.49</span>) % mod;</span>
<span id="cb12-58"><a aria-hidden="true" href="#cb12-58"></a>            a1b2 = (ll)floor((t1[i].y + t2[i].y) / <span class="fl">2.0</span> + <span class="fl">0.49</span>) % mod;</span>
<span id="cb12-59"><a aria-hidden="true" href="#cb12-59"></a>            a2b1 = ((ll)floor(t1[i].y + <span class="fl">0.49</span>) - a1b2) % mod;</span>
<span id="cb12-60"><a aria-hidden="true" href="#cb12-60"></a>            a2b2 = ((ll)floor(t2[i].x + <span class="fl">0.49</span>) - a1b1) % mod;</span>
<span id="cb12-61"><a aria-hidden="true" href="#cb12-61"></a>            C[i] = ((((a1b1 &lt;&lt; <span class="dv">15</span>) + (a1b2 + a2b1)) &lt;&lt; <span class="dv">15</span>) + a2b2) % mod;</span>
<span id="cb12-62"><a aria-hidden="true" href="#cb12-62"></a>            C[i] = (C[i] + mod) % mod;</span>
<span id="cb12-63"><a aria-hidden="true" href="#cb12-63"></a>        }</span>
<span id="cb12-64"><a aria-hidden="true" href="#cb12-64"></a></span>
<span id="cb12-65"><a aria-hidden="true" href="#cb12-65"></a>        clr2(p1, n), clr2(p2, n), clr2(q, n), clr2(t1, n), clr2(t2, n);</span>
<span id="cb12-66"><a aria-hidden="true" href="#cb12-66"></a>        <span class="cf">return</span> C;</span>
<span id="cb12-67"><a aria-hidden="true" href="#cb12-67"></a>    }</span>
<span id="cb12-68"><a aria-hidden="true" href="#cb12-68"></a>} <span class="kw">using</span> <span class="kw">namespace</span> MTT;</span></code></pre></div>
<h2 id="fftntt-优化卷积的一些例子">FFT/NTT 优化卷积的一些例子</h2>
<p>在继续之前，我们先来看看 FFT/NTT 的一些应用。（高精度乘法就不说了，记得最后进位就可以了）</p>
<ul>
<li>优化一般的卷积</li>
<li>和生成函数一起食用</li>
<li>字符串匹配（你没看错）</li>
</ul>
<h3 id="洛谷-p3338-zjoi2014力"><a href="https://www.luogu.com.cn/problem/P3338">洛谷 P3338 [ZJOI2014]力</a></h3>
<p>题意：给定 <span class="math inline">\(\{q\}\)</span>，定义 <span class="math display">\[
F_i = \sum_{j = 1}^{i - 1}\frac{q_iq_j}{(i - j)^2} - \sum_{j = i + 1}^n\frac{q_iq_j}{(i - j)^2}
\]</span> 求 <span class="math display">\[
E_i=\frac{F_i}{q_i}
\]</span> 考虑暴力的话，这道题是 <span class="math inline">\(O(n^2)\)</span> 的，过不去，考虑转化式子： <span class="math display">\[
\begin{aligned}
E_i &amp;= \frac{F_i}{q_i}\\
&amp;=\sum_{j = 1}^{i - 1}\frac{q_j}{(i - j)^2} - \sum_{j = i + 1}^n\frac{q_j}{(i - j)^2}\\
\end{aligned}
\]</span> 我们尝试将其化为卷积的形式，令 <span class="math inline">\(f_i = q_i\)</span>，且 <span class="math inline">\(f_0 = 0\)</span>；<span class="math inline">\(g_i =\dfrac{1}{i^2}\)</span>，且 <span class="math inline">\(g_0 = 0\)</span>，回代： <span class="math display">\[
\begin{aligned}
E_i &amp;= \sum_{j = 0}^{i}f_jg_{i - j} - \sum_{j = i}^nf_jg_{j - i}
\end{aligned}
\]</span> 左边的部分已经是一个卷积的形式了，考虑继续化简右边。此时我们可以使用一个翻转的技巧，令 <span class="math inline">\(f'_i = f_{n - i}\)</span>，<span class="math inline">\(t = n - i\)</span>，则右半边的式子可以化为 <span class="math inline">\(\displaystyle\sum_{j = 0}^{t}f'_{t - j}g_j\)</span>。现在两边都化为卷积的形式了，可以愉快的使用 FFT 加速了。</p>
<p>即我们设多项式 <span class="math inline">\(A(x) =\displaystyle\sum_{i = 0}^nf_ix^n\)</span>，<span class="math inline">\(B(x) = \displaystyle\sum_{i = 0}^ng_ix^n\)</span>，<span class="math inline">\(C(x) = \displaystyle\sum_{i = 0}^nf'_i\)</span>。再令 <span class="math inline">\(L(x) = A(x)B(x)\)</span>，<span class="math inline">\(R(x) = B(x)C(x)\)</span>，不难发现答案 <span class="math inline">\(E_i = l_i - r_{n - i}\)</span>，其中 <span class="math inline">\(l_i\)</span> 和 <span class="math inline">\(r_i\)</span> 分别为 <span class="math inline">\(L(x)\)</span> 和 <span class="math inline">\(R(x)\)</span> 中 <span class="math inline">\(x^i\)</span> 的系数。</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a aria-hidden="true" href="#cb13-1"></a><span class="dt">int</span> main()</span>
<span id="cb13-2"><a aria-hidden="true" href="#cb13-2"></a>{</span>
<span id="cb13-3"><a aria-hidden="true" href="#cb13-3"></a>    <span class="dt">int</span> n; scanf(<span class="st">"</span><span class="sc">%d</span><span class="st">"</span>, &amp;n);</span>
<span id="cb13-4"><a aria-hidden="true" href="#cb13-4"></a>    FOR(i, <span class="dv">1</span>, n)</span>
<span id="cb13-5"><a aria-hidden="true" href="#cb13-5"></a>    {</span>
<span id="cb13-6"><a aria-hidden="true" href="#cb13-6"></a>        scanf(<span class="st">"</span><span class="sc">%lf</span><span class="st">"</span>, &amp;a[i].x);</span>
<span id="cb13-7"><a aria-hidden="true" href="#cb13-7"></a>        b[i].x = (<span class="fl">1.0</span> / i / i);</span>
<span id="cb13-8"><a aria-hidden="true" href="#cb13-8"></a>        c[n - i].x = a[i].x;</span>
<span id="cb13-9"><a aria-hidden="true" href="#cb13-9"></a>    }</span>
<span id="cb13-10"><a aria-hidden="true" href="#cb13-10"></a>    <span class="dt">int</span> lim = <span class="dv">1</span>;</span>
<span id="cb13-11"><a aria-hidden="true" href="#cb13-11"></a>    <span class="cf">while</span> (lim &lt;= (n &lt;&lt; <span class="dv">1</span>)) lim &lt;&lt;= <span class="dv">1</span>;</span>
<span id="cb13-12"><a aria-hidden="true" href="#cb13-12"></a>    FOR(i, <span class="dv">0</span>, lim)</span>
<span id="cb13-13"><a aria-hidden="true" href="#cb13-13"></a>        rev[i] = ((rev[i &gt;&gt; <span class="dv">1</span>] &gt;&gt; <span class="dv">1</span>) | ((i &amp; <span class="dv">1</span>) ? (lim &gt;&gt; <span class="dv">1</span>) : <span class="dv">0</span>));</span>
<span id="cb13-14"><a aria-hidden="true" href="#cb13-14"></a>    DFT(a, lim, <span class="dv">1</span>), DFT(b, lim, <span class="dv">1</span>), DFT(c, lim, <span class="dv">1</span>);</span>
<span id="cb13-15"><a aria-hidden="true" href="#cb13-15"></a>    FOR(i, <span class="dv">0</span>, lim)</span>
<span id="cb13-16"><a aria-hidden="true" href="#cb13-16"></a>        a[i] = a[i] * b[i], c[i] = b[i] * c[i];</span>
<span id="cb13-17"><a aria-hidden="true" href="#cb13-17"></a>    DFT(a, lim, -<span class="dv">1</span>), DFT(c, lim, -<span class="dv">1</span>);</span>
<span id="cb13-18"><a aria-hidden="true" href="#cb13-18"></a>    FOR(i, <span class="dv">1</span>, n)</span>
<span id="cb13-19"><a aria-hidden="true" href="#cb13-19"></a>        printf(<span class="st">"</span><span class="sc">%.3lf\n</span><span class="st">"</span>, a[i].x - c[n - i].x);</span>
<span id="cb13-20"><a aria-hidden="true" href="#cb13-20"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb13-21"><a aria-hidden="true" href="#cb13-21"></a>}</span></code></pre></div>
<h3 id="洛谷-p3723-ah2017hnoi2017礼物"><a href="https://www.luogu.com.cn/problem/P3723">洛谷 P3723 [AH2017/HNOI2017]礼物</a></h3>
<p>题意：给定两个序列 <span class="math inline">\(\{x\}\)</span> 和 <span class="math inline">\(\{y\}\)</span>，可以整体平移序列或者整体加/减某个数，求最终序列</p>
<p><span class="math display">\[
\sum_{i = 1}^n(x_i - y_i)^2
\]</span></p>
<p>的最小值。</p>
<p>分析：设整体加减的数为 <span class="math inline">\(c\)</span>（<span class="math inline">\(c\)</span> 可正可负），我们需要最小化的就是下面这个式子：</p>
<p><span class="math display">\[
\sum_{i = 1}^n(x_i - y_i + c)^2
\]</span></p>
<p>展开上面的式子，由 <span class="math inline">\((x_i - y_i +c)^2 = x_i^2 + y_i^2 + c^2 + 2x_ic - 2y_ic - 2x_iy_i\)</span> 可以得到原式可化简为</p>
<p><span class="math display">\[
\sum x_i^2 + \sum y_i^2 + nc^2 + 2c\sum x_i - 2c\sum y_i - 2\sum x_iy_i
\]</span></p>
<p>（下标省略）</p>
<p>不难发现我们只需要最大化 <span class="math inline">\(\sum x_iy_i\)</span> 就可以啦。</p>
<p>设 <span class="math inline">\(f_k\)</span> 为旋转了 <span class="math inline">\(k\)</span> 个单位后 <span class="math inline">\(\sum x_iy_i\)</span> 的取值，先把 <span class="math inline">\(\{x\}\)</span> 倍长一波，则</p>
<p><span class="math display">\[
f_k = \sum_{i = 1}^nx_{i + k}y_k
\]</span></p>
<p>翻转 <span class="math inline">\(y\)</span>：</p>
<p><span class="math display">\[
f_k = \sum_{i = 1}^nx_{i + k}y_{n - i + 1}'
\]</span></p>
<p>考虑多项式 <span class="math inline">\(f(t) = \sum_{i = 1}^n x_it^i\)</span>，<span class="math inline">\(g(t) = \sum_{i = 1}^n y_it^i\)</span>，令 <span class="math inline">\(h(t) = f(t) * g(t)\)</span>，不难发现其 <span class="math inline">\(t^{n + k + 1}\)</span> 的系数即为 <span class="math inline">\(f_k\)</span>。因此可以使用 FFT/NTT 将倍长过的 <span class="math inline">\(\{x\}\)</span> 与翻转过的 <span class="math inline">\(\{y\}\)</span> 卷起来，然后把结果从第 <span class="math inline">\(n + 1\)</span> 到第 <span class="math inline">\(2n\)</span> 处找最值就可以了</p>
<p>NTT 的实现：</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a aria-hidden="true" href="#cb14-1"></a>ll a[maxn], b[maxn];</span>
<span id="cb14-2"><a aria-hidden="true" href="#cb14-2"></a>ll suma, sumb, suma2, sumb2, n, m;</span>
<span id="cb14-3"><a aria-hidden="true" href="#cb14-3"></a><span class="dt">int</span> rev[maxn];</span>
<span id="cb14-4"><a aria-hidden="true" href="#cb14-4"></a></span>
<span id="cb14-5"><a aria-hidden="true" href="#cb14-5"></a><span class="dt">void</span> NTT(ll *f, <span class="dt">int</span> lim, <span class="dt">int</span> type)</span>
<span id="cb14-6"><a aria-hidden="true" href="#cb14-6"></a>{</span>
<span id="cb14-7"><a aria-hidden="true" href="#cb14-7"></a>    FOR(i, <span class="dv">0</span>, lim - <span class="dv">1</span>)</span>
<span id="cb14-8"><a aria-hidden="true" href="#cb14-8"></a>        <span class="cf">if</span> (i &lt; rev[i])</span>
<span id="cb14-9"><a aria-hidden="true" href="#cb14-9"></a>            swap(f[i], f[rev[i]]);</span>
<span id="cb14-10"><a aria-hidden="true" href="#cb14-10"></a>    <span class="cf">for</span> (<span class="dt">int</span> p = <span class="dv">2</span>; p &lt;= lim; p &lt;&lt;= <span class="dv">1</span>)</span>
<span id="cb14-11"><a aria-hidden="true" href="#cb14-11"></a>    {</span>
<span id="cb14-12"><a aria-hidden="true" href="#cb14-12"></a>        <span class="dt">int</span> len = p &gt;&gt; <span class="dv">1</span>;</span>
<span id="cb14-13"><a aria-hidden="true" href="#cb14-13"></a>        ll Gp = pow(type ? G : invG, (mod - <span class="dv">1</span>) / p);</span>
<span id="cb14-14"><a aria-hidden="true" href="#cb14-14"></a>        <span class="cf">for</span> (<span class="dt">int</span> k = <span class="dv">0</span>; k &lt; lim; k += p)</span>
<span id="cb14-15"><a aria-hidden="true" href="#cb14-15"></a>        {</span>
<span id="cb14-16"><a aria-hidden="true" href="#cb14-16"></a>            ll buf = <span class="dv">1</span>;</span>
<span id="cb14-17"><a aria-hidden="true" href="#cb14-17"></a>            <span class="cf">for</span> (<span class="dt">int</span> l = k; l &lt; k + len; ++l, buf = buf * Gp % mod)</span>
<span id="cb14-18"><a aria-hidden="true" href="#cb14-18"></a>            {</span>
<span id="cb14-19"><a aria-hidden="true" href="#cb14-19"></a>                ll tmp = buf * f[l + len] % mod;</span>
<span id="cb14-20"><a aria-hidden="true" href="#cb14-20"></a>                f[l + len] = f[l] - tmp;</span>
<span id="cb14-21"><a aria-hidden="true" href="#cb14-21"></a>                <span class="cf">if</span> (f[l + len] &lt; <span class="dv">0</span>) f[l + len] += mod;</span>
<span id="cb14-22"><a aria-hidden="true" href="#cb14-22"></a>                f[l] = f[l] + tmp;</span>
<span id="cb14-23"><a aria-hidden="true" href="#cb14-23"></a>                <span class="cf">if</span> (f[l] &gt; mod) f[l] -= mod;</span>
<span id="cb14-24"><a aria-hidden="true" href="#cb14-24"></a>            }</span>
<span id="cb14-25"><a aria-hidden="true" href="#cb14-25"></a>        }</span>
<span id="cb14-26"><a aria-hidden="true" href="#cb14-26"></a>    }</span>
<span id="cb14-27"><a aria-hidden="true" href="#cb14-27"></a>    ll invlim = pow(lim);</span>
<span id="cb14-28"><a aria-hidden="true" href="#cb14-28"></a>    <span class="cf">if</span> (!type)</span>
<span id="cb14-29"><a aria-hidden="true" href="#cb14-29"></a>        FOR(i, <span class="dv">0</span>, lim - <span class="dv">1</span>)</span>
<span id="cb14-30"><a aria-hidden="true" href="#cb14-30"></a>            f[i] = f[i] * invlim % mod;</span>
<span id="cb14-31"><a aria-hidden="true" href="#cb14-31"></a>    <span class="cf">return</span>;</span>
<span id="cb14-32"><a aria-hidden="true" href="#cb14-32"></a>}</span>
<span id="cb14-33"><a aria-hidden="true" href="#cb14-33"></a></span>
<span id="cb14-34"><a aria-hidden="true" href="#cb14-34"></a><span class="dt">int</span> main()</span>
<span id="cb14-35"><a aria-hidden="true" href="#cb14-35"></a>{</span>
<span id="cb14-36"><a aria-hidden="true" href="#cb14-36"></a>    n = read(), m = read();</span>
<span id="cb14-37"><a aria-hidden="true" href="#cb14-37"></a>    FOR(i, <span class="dv">1</span>, n)</span>
<span id="cb14-38"><a aria-hidden="true" href="#cb14-38"></a>        a[i] = a[i + n] = read(), suma += a[i], suma2 += a[i] * a[i];</span>
<span id="cb14-39"><a aria-hidden="true" href="#cb14-39"></a>    FOR(i, <span class="dv">1</span>, n)</span>
<span id="cb14-40"><a aria-hidden="true" href="#cb14-40"></a>        b[n - i + <span class="dv">1</span>] = read(), sumb += b[n - i + <span class="dv">1</span>], sumb2 += b[n - i + <span class="dv">1</span>] * b[n - i + <span class="dv">1</span>];</span>
<span id="cb14-41"><a aria-hidden="true" href="#cb14-41"></a>    <span class="dt">int</span> lim = <span class="dv">1</span>;</span>
<span id="cb14-42"><a aria-hidden="true" href="#cb14-42"></a>    <span class="cf">while</span> (lim &lt;= <span class="dv">3</span> * n) lim &lt;&lt;= <span class="dv">1</span>;</span>
<span id="cb14-43"><a aria-hidden="true" href="#cb14-43"></a>    FOR(i, <span class="dv">0</span>, lim - <span class="dv">1</span>)</span>
<span id="cb14-44"><a aria-hidden="true" href="#cb14-44"></a>        rev[i] = (rev[i &gt;&gt; <span class="dv">1</span>] &gt;&gt; <span class="dv">1</span>) | ((i &amp; <span class="dv">1</span>) ? (lim &gt;&gt; <span class="dv">1</span>) : <span class="dv">0</span>);</span>
<span id="cb14-45"><a aria-hidden="true" href="#cb14-45"></a>    NTT(a, lim, <span class="dv">1</span>), NTT(b, lim, <span class="dv">1</span>);</span>
<span id="cb14-46"><a aria-hidden="true" href="#cb14-46"></a>    FOR(i, <span class="dv">0</span>, lim)</span>
<span id="cb14-47"><a aria-hidden="true" href="#cb14-47"></a>        a[i] = a[i] * b[i] % mod;<span class="co">//千万不要忘记取模</span></span>
<span id="cb14-48"><a aria-hidden="true" href="#cb14-48"></a>    NTT(a, lim, <span class="dv">0</span>);</span>
<span id="cb14-49"><a aria-hidden="true" href="#cb14-49"></a>    ll ans = <span class="fl">1e18</span>;</span>
<span id="cb14-50"><a aria-hidden="true" href="#cb14-50"></a>    FOR(i, <span class="dv">1</span>, n)</span>
<span id="cb14-51"><a aria-hidden="true" href="#cb14-51"></a>        FOR(j, -m, m)</span>
<span id="cb14-52"><a aria-hidden="true" href="#cb14-52"></a>            ans = min(ans, suma2 + sumb2 + j * j * n + <span class="dv">2</span> * j * (suma - sumb) - <span class="dv">2</span> * a[i + n]);</span>
<span id="cb14-53"><a aria-hidden="true" href="#cb14-53"></a>    printf(<span class="st">"</span><span class="sc">%lld\n</span><span class="st">"</span>, ans);</span>
<span id="cb14-54"><a aria-hidden="true" href="#cb14-54"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb14-55"><a aria-hidden="true" href="#cb14-55"></a>}</span></code></pre></div>
<h3 id="bzoj3771-triple">BZOJ3771 Triple</h3>
<p>题意：有 <span class="math inline">\(n\)</span> 把价值分别为 <span class="math inline">\(a_i\)</span> 的斧子，河神可能拿走 1 - 3 把，问每种可能的损失价值及其对应方案数。（不计顺序）</p>
<p>思路：这是一道生成函数的入门题。</p>
<p>考虑设出多项式 <span class="math inline">\(A(x)\)</span>，其系数有 <span class="math inline">\(A[a_i] = 1\)</span>，代表选一把的。则你可能会觉得答案为 <span class="math inline">\(A(x) + A^2(x) + A^3(x)\)</span>。但是这样是显然不对的。为什么？</p>
<p>因为这样的话同一个元素可能被选两次或三次，对于这种情况定义 <span class="math inline">\(B(x)\)</span> 和 <span class="math inline">\(C(x)\)</span> 满足 <span class="math inline">\(B[2a_i] = 1\)</span> 和 <span class="math inline">\(C[3a_i] = 1\)</span>，代表同时选两次/三次的，减掉这些方案数就可以了。然后需要注意顺序问题：</p>
<p>选一把的答案为 <span class="math inline">\(A(x)\)</span>，不难发现选两种的即为 <span class="math inline">\(\dfrac{A^2(x) - B(x)}{2}\)</span>，选三种的比较麻烦：不能同时选两种一样的，即减去 <span class="math inline">\(3A(x)B(x)\)</span>，，但是选三种同样的又会被多减两次，最后除以 <span class="math inline">\(3!\)</span> 去掉顺序问题，所以最终答案为：</p>
<p><span class="math display">\[
A(x) + \frac{A^2(x) - B(x)}{2} + \frac{A^3(x) - 3A(x)B(x) + 2C(x)}{6}
\]</span></p>
<p>生成函数的卷积使用 NTT 或 FFT 优化即可。注意此时 NTT 模数要取一个更大的质数。<strong>不知道为什么生成函数能这样对应的可以意会一下多项式卷积的定义式以及这些系数的组合意义</strong>。</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a aria-hidden="true" href="#cb15-1"></a>ll f1[maxn], f2[maxn], f3[maxn], ans[maxn];</span>
<span id="cb15-2"><a aria-hidden="true" href="#cb15-2"></a>ll g[maxn], t[maxn];</span>
<span id="cb15-3"><a aria-hidden="true" href="#cb15-3"></a></span>
<span id="cb15-4"><a aria-hidden="true" href="#cb15-4"></a><span class="dt">int</span> main()</span>
<span id="cb15-5"><a aria-hidden="true" href="#cb15-5"></a>{</span>
<span id="cb15-6"><a aria-hidden="true" href="#cb15-6"></a>    <span class="dt">int</span> n = read();</span>
<span id="cb15-7"><a aria-hidden="true" href="#cb15-7"></a>    <span class="cf">while</span> (n--)</span>
<span id="cb15-8"><a aria-hidden="true" href="#cb15-8"></a>    {</span>
<span id="cb15-9"><a aria-hidden="true" href="#cb15-9"></a>        <span class="dt">int</span> tmp = read();</span>
<span id="cb15-10"><a aria-hidden="true" href="#cb15-10"></a>        ++f1[tmp], ++g[tmp], ++ans[tmp];</span>
<span id="cb15-11"><a aria-hidden="true" href="#cb15-11"></a>        ++f2[tmp &lt;&lt; <span class="dv">1</span>], ++f3[tmp * <span class="dv">3</span>];</span>
<span id="cb15-12"><a aria-hidden="true" href="#cb15-12"></a>    }</span>
<span id="cb15-13"><a aria-hidden="true" href="#cb15-13"></a>    <span class="dt">int</span> lim = <span class="dv">1</span>;</span>
<span id="cb15-14"><a aria-hidden="true" href="#cb15-14"></a>    <span class="cf">while</span> (lim &lt;= (<span class="dv">40000</span> * <span class="dv">3</span> + <span class="dv">5</span>)) lim &lt;&lt;= <span class="dv">1</span>;</span>
<span id="cb15-15"><a aria-hidden="true" href="#cb15-15"></a>    FOR(i, <span class="dv">0</span>, lim - <span class="dv">1</span>)</span>
<span id="cb15-16"><a aria-hidden="true" href="#cb15-16"></a>        rev[i] = (rev[i &gt;&gt; <span class="dv">1</span>] &gt;&gt; <span class="dv">1</span>) | ((i &amp; <span class="dv">1</span>) ? (lim &gt;&gt; <span class="dv">1</span>) : <span class="dv">0</span>);</span>
<span id="cb15-17"><a aria-hidden="true" href="#cb15-17"></a>    NTT(f1, lim, <span class="dv">1</span>), NTT(g, lim, <span class="dv">1</span>);</span>
<span id="cb15-18"><a aria-hidden="true" href="#cb15-18"></a>    FOR(i, <span class="dv">0</span>, lim - <span class="dv">1</span>)</span>
<span id="cb15-19"><a aria-hidden="true" href="#cb15-19"></a>        g[i] = f1[i] * g[i] % mod;</span>
<span id="cb15-20"><a aria-hidden="true" href="#cb15-20"></a>    NTT(g, lim, <span class="dv">0</span>);</span>
<span id="cb15-21"><a aria-hidden="true" href="#cb15-21"></a>    FOR(i, <span class="dv">0</span>, lim - <span class="dv">1</span>)</span>
<span id="cb15-22"><a aria-hidden="true" href="#cb15-22"></a>        ans[i] += (g[i] - f2[i]) / <span class="dv">2</span>;</span>
<span id="cb15-23"><a aria-hidden="true" href="#cb15-23"></a>    NTT(g, lim, <span class="dv">1</span>);</span>
<span id="cb15-24"><a aria-hidden="true" href="#cb15-24"></a>    FOR(i, <span class="dv">0</span>, lim - <span class="dv">1</span>)</span>
<span id="cb15-25"><a aria-hidden="true" href="#cb15-25"></a>        g[i] = f1[i] * g[i] % mod;</span>
<span id="cb15-26"><a aria-hidden="true" href="#cb15-26"></a>    NTT(g, lim, <span class="dv">0</span>);</span>
<span id="cb15-27"><a aria-hidden="true" href="#cb15-27"></a>    NTT(f2, lim, <span class="dv">1</span>);</span>
<span id="cb15-28"><a aria-hidden="true" href="#cb15-28"></a>    FOR(i, <span class="dv">0</span>, lim - <span class="dv">1</span>)</span>
<span id="cb15-29"><a aria-hidden="true" href="#cb15-29"></a>        f2[i] = f2[i] * f1[i] % mod;</span>
<span id="cb15-30"><a aria-hidden="true" href="#cb15-30"></a>    NTT(f2, lim, <span class="dv">0</span>);</span>
<span id="cb15-31"><a aria-hidden="true" href="#cb15-31"></a>    FOR(i, <span class="dv">0</span>, lim - <span class="dv">1</span>)</span>
<span id="cb15-32"><a aria-hidden="true" href="#cb15-32"></a>    {</span>
<span id="cb15-33"><a aria-hidden="true" href="#cb15-33"></a>        ans[i] += (g[i] - <span class="dv">3</span> * f2[i] + <span class="dv">2</span> * f3[i]) / <span class="dv">6</span>;</span>
<span id="cb15-34"><a aria-hidden="true" href="#cb15-34"></a>        <span class="cf">if</span> (ans[i]) printf(<span class="st">"</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%lld\n</span><span class="st">"</span>, i, ans[i]);</span>
<span id="cb15-35"><a aria-hidden="true" href="#cb15-35"></a>    }</span>
<span id="cb15-36"><a aria-hidden="true" href="#cb15-36"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb15-37"><a aria-hidden="true" href="#cb15-37"></a>}</span></code></pre></div>
<h3 id="fftntt-与字符串匹配">FFT/NTT 与字符串匹配</h3>
<p><strong>字符串下标从 <span class="math inline">\(1\)</span> 开始</strong></p>
<h4 id="最一般的情况">最一般的情况</h4>
<p>考虑文本串 <span class="math inline">\(S\)</span> 和模式串 <span class="math inline">\(T\)</span>，串长 <span class="math inline">\(n = |S|\)</span>，<span class="math inline">\(m = |T|\)</span>，保证 <span class="math inline">\(n \ge m\)</span>，现在需要找出 <span class="math inline">\(T\)</span> 在 <span class="math inline">\(S\)</span> 中出现的每个位置。直接跑 KMP 就可以了，但是这个不是要提的重点。考虑串 <span class="math inline">\(S\)</span> 的第 <span class="math inline">\(i\)</span> 个字符为 <span class="math inline">\(S[i]\)</span>，那么匹配就可以写成 <span class="math inline">\(S[i] - T[j] = 0\)</span>，这个应该是比较好想的。</p>
<p>假设 <span class="math inline">\(T\)</span> 在 <span class="math inline">\(S\)</span> 的第 <span class="math inline">\(i\)</span> 位开始成功匹配，则我们有</p>
<p><span class="math display">\[
\sum_{j = 1}^{m} (S[i + j - 1] - T[j])^2 = 0
\]</span></p>
<p>为了防止正负号相互抵消，所以需要平方。由于 <span class="math inline">\(i + j - 1 + j\)</span> 不是定值，不符合我们需要的卷积的形式，所以翻转一下 <span class="math inline">\(T\)</span> 让其变为 <span class="math inline">\(T'\)</span>：</p>
<p><span class="math display">\[
\sum_{j = 1}^{m} (S[i + j - 1] - T[m - j + 1])^2 = 0
\]</span></p>
<p>打开来我们就会发现</p>
<p><span class="math display">\[
\sum_{j = 1}^{m} (S[i + j - 1]^2 + T[j]^2 - 2S[i + j - 1]T[m - j + 1]) = 0
\]</span></p>
<p><span class="math inline">\(i + j - 1 + m - j + 1 = i + m\)</span>，为定值。</p>
<p>所以上面的式子就可以化成</p>
<p><span class="math display">\[
\sum_{j = 1}^m S[i + j - 1]^2 + \sum_{j = 1}^m T[j]^2 - 2\sum_{x + y = i + m}S[x]T[y]
\]</span></p>
<p>第一项直接前缀和就可以解决，第二项常数，第三项使用 FFT/NTT。</p>
<p>更加好理解地，设 <span class="math inline">\(f(x) = \sum_{i + j = x + m}S[i]T[j]\)</span>，我们只需要求出这个 <span class="math inline">\(f(x)\)</span> 就可以了。</p>
<p>问题来了，这样难写复杂度高常数大全方位被 KMP 吊打的算法有什么存在的意义吗？对不起还真的有：</p>
<h4 id="带通配符的字符串匹配">带通配符的字符串匹配</h4>
<p>请看例题 <a href="https://www.luogu.com.cn/problem/P4173">洛谷 P4173 残缺的字符串</a>。仍然是字符串匹配，但是每个串都有<strong>通配符</strong>，这个时候 KMP 就显得无能为力了。怎么办呢？好好思考一下两个字符如何才能匹配：</p>
<ul>
<li>两个字符完全一样</li>
<li>其中至少一个为通配符</li>
</ul>
<p>两者是逻辑或的关系，我们魔改一下上面的式子，不难发现我们只需要把通配符的值设为 <span class="math inline">\(0\)</span> 就可以解决了：</p>
<p>定义匹配函数 <span class="math inline">\(F(x)\)</span> 表示 <span class="math inline">\(S\)</span> 的第 <span class="math inline">\(x\)</span> 位开始和 <span class="math inline">\(T\)</span> 是否匹配，匹配的话 <span class="math inline">\(F(x) = 0\)</span>。</p>
<p><span class="math display">\[
F(x) = \sum_{j = 1}^m(S[x + j - 1] - T[j])^2S[x + j - 1]T[j]
\]</span></p>
<p>化简：</p>
<p><span class="math display">\[
\begin{aligned}
F(x) &amp;= \sum_{j = 1}^m(S[x + j - 1] - T[j])^2S[x + j - 1]T[j]\\
&amp;= \sum_{j = 1}^m(S[x + j - 1] - T'[m - j + 1])^2S[x + j - 1]T'[m - j + 1]\\
&amp;= \sum_{j = 1}^m(S[x + j - 1]^2 + T'[m - j + 1]^2 - 2S[x + j - 1]T'[m - j + 1])S[x + j - 1]T'[m - j + 1]\\
&amp;= \sum_{j = 1}^m S[x + j - 1]^3T'[m - j + 1] + \sum_{j = 1}^m S[x + j - 1]T'[m - j + 1]^3- 2\sum_{j = 1}^m S[x + j - 1]^2T'[m - j + 1]^2\\
&amp;= \sum_{i + j = x + m}S[i]^3T'[j] + \sum_{i + j = x + m}S[i]T'[j]^3 - 2\sum_{i + j = x + m}S[i]^2T[j]^2
\end{aligned}
\]</span></p>
<p>于是问题就解决了，只需要用 NTT/FFT 计算出上面三项恶心的东西出来就 OK 了。一共进行 <span class="math inline">\(7\)</span> 次 NTT 即可。</p>
<p>需要注意的是最后枚举答案的时候只能枚举到 <span class="math inline">\(n - m + 1\)</span> 处，否则只有 <span class="math inline">\(35\)</span> 分。</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a aria-hidden="true" href="#cb16-1"></a><span class="dt">int</span> f[maxn &lt;&lt; <span class="dv">1</span>], g[maxn &lt;&lt; <span class="dv">1</span>], f2[maxn &lt;&lt; <span class="dv">1</span>], g2[maxn &lt;&lt; <span class="dv">1</span>], f3[maxn &lt;&lt; <span class="dv">1</span>], g3[maxn &lt;&lt; <span class="dv">1</span>];</span>
<span id="cb16-2"><a aria-hidden="true" href="#cb16-2"></a><span class="dt">int</span> ans[maxn &lt;&lt; <span class="dv">1</span>], vec[maxn &lt;&lt; <span class="dv">1</span>], tot;</span>
<span id="cb16-3"><a aria-hidden="true" href="#cb16-3"></a></span>
<span id="cb16-4"><a aria-hidden="true" href="#cb16-4"></a><span class="dt">int</span> n, m;</span>
<span id="cb16-5"><a aria-hidden="true" href="#cb16-5"></a><span class="dt">char</span> a[maxn], b[maxn];</span>
<span id="cb16-6"><a aria-hidden="true" href="#cb16-6"></a></span>
<span id="cb16-7"><a aria-hidden="true" href="#cb16-7"></a><span class="dt">int</span> main()</span>
<span id="cb16-8"><a aria-hidden="true" href="#cb16-8"></a>{</span>
<span id="cb16-9"><a aria-hidden="true" href="#cb16-9"></a>    m = readInt(), n = readInt();</span>
<span id="cb16-10"><a aria-hidden="true" href="#cb16-10"></a>    scanf(<span class="st">"</span><span class="sc">%s</span><span class="st">"</span>, a + <span class="dv">1</span>);</span>
<span id="cb16-11"><a aria-hidden="true" href="#cb16-11"></a>    scanf(<span class="st">"</span><span class="sc">%s</span><span class="st">"</span>, b + <span class="dv">1</span>);</span>
<span id="cb16-12"><a aria-hidden="true" href="#cb16-12"></a>    FOR(i, <span class="dv">1</span>, m)</span>
<span id="cb16-13"><a aria-hidden="true" href="#cb16-13"></a>    {</span>
<span id="cb16-14"><a aria-hidden="true" href="#cb16-14"></a>        g[i] = (a[m - i + <span class="dv">1</span>] == <span class="ch">'*'</span>) ? <span class="dv">0</span> : a[m - i + <span class="dv">1</span>] - <span class="ch">'a'</span> + <span class="dv">1</span>;</span>
<span id="cb16-15"><a aria-hidden="true" href="#cb16-15"></a>        g2[i] = g[i] * g[i], g3[i] = g2[i] * g[i];</span>
<span id="cb16-16"><a aria-hidden="true" href="#cb16-16"></a>    }</span>
<span id="cb16-17"><a aria-hidden="true" href="#cb16-17"></a>    FOR(i, <span class="dv">1</span>, n)</span>
<span id="cb16-18"><a aria-hidden="true" href="#cb16-18"></a>    {</span>
<span id="cb16-19"><a aria-hidden="true" href="#cb16-19"></a>        f[i] = (b[i] == <span class="ch">'*'</span>) ? <span class="dv">0</span> : b[i] - <span class="ch">'a'</span> + <span class="dv">1</span>;</span>
<span id="cb16-20"><a aria-hidden="true" href="#cb16-20"></a>        f2[i] = f[i] * f[i], f3[i] = f2[i] * f[i];</span>
<span id="cb16-21"><a aria-hidden="true" href="#cb16-21"></a>    }</span>
<span id="cb16-22"><a aria-hidden="true" href="#cb16-22"></a>    <span class="dt">int</span> lim = <span class="dv">1</span>;</span>
<span id="cb16-23"><a aria-hidden="true" href="#cb16-23"></a>    <span class="cf">while</span> (lim &lt;= n + m) lim &lt;&lt;= <span class="dv">1</span>;</span>
<span id="cb16-24"><a aria-hidden="true" href="#cb16-24"></a>    NTT(f, lim, <span class="dv">1</span>), NTT(f2, lim, <span class="dv">1</span>), NTT(f3, lim, <span class="dv">1</span>);</span>
<span id="cb16-25"><a aria-hidden="true" href="#cb16-25"></a>    NTT(g, lim, <span class="dv">1</span>), NTT(g2, lim, <span class="dv">1</span>), NTT(g3, lim, <span class="dv">1</span>);</span>
<span id="cb16-26"><a aria-hidden="true" href="#cb16-26"></a>    FOR(i, <span class="dv">0</span>, lim - <span class="dv">1</span>)</span>
<span id="cb16-27"><a aria-hidden="true" href="#cb16-27"></a>        ans[i] = (<span class="dv">1</span><span class="bu">ll</span> * f3[i] * g[i] % mod + <span class="dv">1</span><span class="bu">ll</span> * f[i] * g3[i] % mod - <span class="dv">2</span><span class="bu">ll</span> * f2[i] * g2[i] % mod) % mod;</span>
<span id="cb16-28"><a aria-hidden="true" href="#cb16-28"></a>    NTT(ans, lim, <span class="dv">0</span>);</span>
<span id="cb16-29"><a aria-hidden="true" href="#cb16-29"></a>    <span class="dt">int</span> cnt = <span class="dv">0</span>;</span>
<span id="cb16-30"><a aria-hidden="true" href="#cb16-30"></a>    FOR(i, <span class="dv">1</span>, n - m + <span class="dv">1</span>)</span>
<span id="cb16-31"><a aria-hidden="true" href="#cb16-31"></a>        <span class="cf">if</span> (ans[i + m] == <span class="dv">0</span>)</span>
<span id="cb16-32"><a aria-hidden="true" href="#cb16-32"></a>            ++cnt, vec[++tot] = i;</span>
<span id="cb16-33"><a aria-hidden="true" href="#cb16-33"></a>    printf(<span class="st">"</span><span class="sc">%d\n</span><span class="st">"</span>, cnt);</span>
<span id="cb16-34"><a aria-hidden="true" href="#cb16-34"></a>    FOR(i, <span class="dv">1</span>, tot) printf(<span class="st">"</span><span class="sc">%d</span><span class="st"> "</span>, vec[i]);</span>
<span id="cb16-35"><a aria-hidden="true" href="#cb16-35"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb16-36"><a aria-hidden="true" href="#cb16-36"></a>}</span></code></pre></div>
<h4 id="另外一道例题">另外一道例题</h4>
<p>请看 <a href="https://www.luogu.com.cn/problem/CF528D">CF528D Fuzzy Search</a>。题意：字符串匹配，<span class="math inline">\(1\le |T| \le |S| \le 2\times 10^5\)</span>，字符集只有 <span class="math inline">\(\texttt{ATCG}\)</span>。<span class="math inline">\(T\)</span> 在 <span class="math inline">\(S\)</span> 中的第 <span class="math inline">\(i\)</span> 个位置出现当且仅当 <span class="math inline">\(\forall j\in [1,T]\)</span>，<span class="math inline">\(\exists p\)</span> 使得 <span class="math inline">\(|i + j - 1 - p|\le k \land S[p] = T[j]\)</span>。即偏移量不能超过 <span class="math inline">\(k\)</span>。</p>
<p>注意到字符集很小，只有 <span class="math inline">\(4\)</span> 个字符，所以我们可以把字符串 01 化，分开考虑每个字母。比如 <span class="math inline">\(S = \texttt{ATCGAA}\)</span>，<span class="math inline">\(T = \texttt{ACAA}\)</span>，现在只考虑字母 <span class="math inline">\(\texttt A\)</span>，把 <span class="math inline">\(\texttt A\)</span> 化成 <span class="math inline">\(1\)</span> 而其他的化为 <span class="math inline">\(0\)</span>，则 <span class="math inline">\(S = \texttt{100011}\)</span>，<span class="math inline">\(T= \texttt{1011}\)</span>。然后假设 <span class="math inline">\(k = 1\)</span>，把能扩展的都往两边扩展，则 <span class="math inline">\(S = \texttt{110111}\)</span>。</p>
<p>这个时候，我们就可以设匹配 <span class="math inline">\(F(x, c)\)</span> 表示 <span class="math inline">\(T\)</span> 从 <span class="math inline">\(S\)</span> 的第 <span class="math inline">\(x\)</span> 位开始字符 <span class="math inline">\(c\)</span> 能匹配的数量，最终答案为 <span class="math inline">\(A(x) = \sum_{c\in\lbrace\texttt{A,T,C,G}\rbrace}F(x,c)\)</span>，<span class="math inline">\(T\)</span> 匹配成功当且仅当 <span class="math inline">\(A(x) = m\)</span>，即所有字符都匹配到了，否则失败。</p>
<p>不难发现 <span class="math inline">\(F(x, c) = \sum_{j = 1}^mS[x + j - 1]T[j]\)</span>，老套路翻转一下变为 <span class="math inline">\(F(x, c) = \sum_{j = 1}^m S[x + j - 1]T[m - j + 1] = \sum_{i + j = x + m}S[i]T[j]\)</span>。这就是喜闻乐见的卷积形式了。NTT 直接上就完了。</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a aria-hidden="true" href="#cb17-1"></a><span class="dt">int</span> f[maxn &lt;&lt; <span class="dv">1</span>], g[maxn &lt;&lt; <span class="dv">1</span>];</span>
<span id="cb17-2"><a aria-hidden="true" href="#cb17-2"></a><span class="dt">int</span> ans[maxn &lt;&lt; <span class="dv">1</span>];</span>
<span id="cb17-3"><a aria-hidden="true" href="#cb17-3"></a></span>
<span id="cb17-4"><a aria-hidden="true" href="#cb17-4"></a><span class="dt">int</span> n, m, k, lim = <span class="dv">1</span>;</span>
<span id="cb17-5"><a aria-hidden="true" href="#cb17-5"></a><span class="dt">char</span> s[maxn &lt;&lt; <span class="dv">1</span>], t[maxn &lt;&lt; <span class="dv">1</span>];</span>
<span id="cb17-6"><a aria-hidden="true" href="#cb17-6"></a></span>
<span id="cb17-7"><a aria-hidden="true" href="#cb17-7"></a><span class="dt">void</span> proc(<span class="dt">char</span> c)</span>
<span id="cb17-8"><a aria-hidden="true" href="#cb17-8"></a>{</span>
<span id="cb17-9"><a aria-hidden="true" href="#cb17-9"></a>    clr(f, lim), clr(g, lim);</span>
<span id="cb17-10"><a aria-hidden="true" href="#cb17-10"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>, lst = -<span class="fl">1e9</span>; i &lt;= n; ++i)</span>
<span id="cb17-11"><a aria-hidden="true" href="#cb17-11"></a>    {</span>
<span id="cb17-12"><a aria-hidden="true" href="#cb17-12"></a>        <span class="cf">if</span> (s[i] == c)</span>
<span id="cb17-13"><a aria-hidden="true" href="#cb17-13"></a>            lst = i;</span>
<span id="cb17-14"><a aria-hidden="true" href="#cb17-14"></a>        <span class="cf">if</span> (i - lst &lt;= k)</span>
<span id="cb17-15"><a aria-hidden="true" href="#cb17-15"></a>            f[i] = <span class="dv">1</span>;</span>
<span id="cb17-16"><a aria-hidden="true" href="#cb17-16"></a>    }</span>
<span id="cb17-17"><a aria-hidden="true" href="#cb17-17"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = n, lst = <span class="fl">1e9</span>; i; --i)</span>
<span id="cb17-18"><a aria-hidden="true" href="#cb17-18"></a>    {</span>
<span id="cb17-19"><a aria-hidden="true" href="#cb17-19"></a>        <span class="cf">if</span> (s[i] == c)</span>
<span id="cb17-20"><a aria-hidden="true" href="#cb17-20"></a>            lst = i;</span>
<span id="cb17-21"><a aria-hidden="true" href="#cb17-21"></a>        <span class="cf">if</span> (lst - i &lt;= k)</span>
<span id="cb17-22"><a aria-hidden="true" href="#cb17-22"></a>            f[i] = <span class="dv">1</span>;</span>
<span id="cb17-23"><a aria-hidden="true" href="#cb17-23"></a>    }</span>
<span id="cb17-24"><a aria-hidden="true" href="#cb17-24"></a>    FOR(i, <span class="dv">1</span>, m)</span>
<span id="cb17-25"><a aria-hidden="true" href="#cb17-25"></a>        g[i] = (t[m - i + <span class="dv">1</span>] == c);</span>
<span id="cb17-26"><a aria-hidden="true" href="#cb17-26"></a>    NTT(f, lim, <span class="dv">1</span>), NTT(g, lim, <span class="dv">1</span>);</span>
<span id="cb17-27"><a aria-hidden="true" href="#cb17-27"></a>    FOR(i, <span class="dv">0</span>, lim - <span class="dv">1</span>)</span>
<span id="cb17-28"><a aria-hidden="true" href="#cb17-28"></a>        f[i] = <span class="dv">1</span><span class="bu">ll</span> * f[i] * g[i] % mod;</span>
<span id="cb17-29"><a aria-hidden="true" href="#cb17-29"></a>    NTT(f, lim, <span class="dv">0</span>);</span>
<span id="cb17-30"><a aria-hidden="true" href="#cb17-30"></a>    FOR(i, <span class="dv">1</span>, n)</span>
<span id="cb17-31"><a aria-hidden="true" href="#cb17-31"></a>        ans[i] += f[i + m];</span>
<span id="cb17-32"><a aria-hidden="true" href="#cb17-32"></a>}</span>
<span id="cb17-33"><a aria-hidden="true" href="#cb17-33"></a></span>
<span id="cb17-34"><a aria-hidden="true" href="#cb17-34"></a><span class="dt">int</span> main()</span>
<span id="cb17-35"><a aria-hidden="true" href="#cb17-35"></a>{</span>
<span id="cb17-36"><a aria-hidden="true" href="#cb17-36"></a>    n = readInt(), m = readInt(), k = readInt();</span>
<span id="cb17-37"><a aria-hidden="true" href="#cb17-37"></a>    scanf(<span class="st">"</span><span class="sc">%s</span><span class="st">"</span>, s + <span class="dv">1</span>);</span>
<span id="cb17-38"><a aria-hidden="true" href="#cb17-38"></a>    scanf(<span class="st">"</span><span class="sc">%s</span><span class="st">"</span>, t + <span class="dv">1</span>);</span>
<span id="cb17-39"><a aria-hidden="true" href="#cb17-39"></a>    <span class="cf">while</span> (lim &lt;= n + m) lim &lt;&lt;= <span class="dv">1</span>;</span>
<span id="cb17-40"><a aria-hidden="true" href="#cb17-40"></a>    FOR(i, <span class="dv">0</span>, <span class="dv">3</span>) proc(<span class="st">"ATCG"</span>[i]);</span>
<span id="cb17-41"><a aria-hidden="true" href="#cb17-41"></a>    <span class="dt">int</span> cnt = <span class="dv">0</span>;</span>
<span id="cb17-42"><a aria-hidden="true" href="#cb17-42"></a>    FOR(i, <span class="dv">1</span>, n)</span>
<span id="cb17-43"><a aria-hidden="true" href="#cb17-43"></a>        cnt += (ans[i] == m);</span>
<span id="cb17-44"><a aria-hidden="true" href="#cb17-44"></a>    printf(<span class="st">"</span><span class="sc">%d\n</span><span class="st">"</span>, cnt);</span>
<span id="cb17-45"><a aria-hidden="true" href="#cb17-45"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb17-46"><a aria-hidden="true" href="#cb17-46"></a>}</span></code></pre></div>
<h2 id="关于封装">关于封装</h2>
<p>以后的全家桶会大量使用 NTT 等基础操作，考虑实现一个常数较小的且方便阅读的封装：</p>
<p>首先是各种 <code>#define</code>。由于我们在进行多项式运算的时候需要考虑界的问题，<strong>因此一定要把超过界了的给清零</strong>，不然可能出现各种奇奇怪怪的问题比如多卷了之类的：</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a aria-hidden="true" href="#cb18-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb18-2"><a aria-hidden="true" href="#cb18-2"></a><span class="pp">#include </span><span class="im">&lt;cctype&gt;</span></span>
<span id="cb18-3"><a aria-hidden="true" href="#cb18-3"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb18-4"><a aria-hidden="true" href="#cb18-4"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb18-5"><a aria-hidden="true" href="#cb18-5"></a><span class="pp">#define FOR</span>(i,<span class="pp"> </span>a,<span class="pp"> </span>b)<span class="pp"> </span><span class="cf">for</span><span class="pp"> </span>(<span class="dt">int</span><span class="pp"> </span>i<span class="pp"> </span>=<span class="pp"> </span>(a);<span class="pp"> </span>i<span class="pp"> </span>&lt;=<span class="pp"> </span>(b);<span class="pp"> </span>++i)</span>
<span id="cb18-6"><a aria-hidden="true" href="#cb18-6"></a><span class="pp">#define DEC</span>(i,<span class="pp"> </span>a,<span class="pp"> </span>b)<span class="pp"> </span><span class="cf">for</span><span class="pp"> </span>(<span class="dt">int</span><span class="pp"> </span>i<span class="pp"> </span>=<span class="pp"> </span>(a);<span class="pp"> </span>i<span class="pp"> </span>&gt;=<span class="pp"> </span>(b);<span class="pp"> </span>--i)</span>
<span id="cb18-7"><a aria-hidden="true" href="#cb18-7"></a><span class="pp">#define VEC</span>(i,<span class="pp"> </span>v)<span class="pp"> </span><span class="cf">for</span><span class="pp"> </span>(<span class="dt">int</span><span class="pp"> </span>i<span class="pp"> </span>=<span class="pp"> </span><span class="dv">0</span>;<span class="pp"> </span>i<span class="pp"> </span>&lt;<span class="pp"> </span>(<span class="dt">int</span>)v.size();<span class="pp"> </span>++i)</span>
<span id="cb18-8"><a aria-hidden="true" href="#cb18-8"></a><span class="pp">#define il </span><span class="kw">inline</span></span>
<span id="cb18-9"><a aria-hidden="true" href="#cb18-9"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb18-10"><a aria-hidden="true" href="#cb18-10"></a><span class="pp">#define ull </span><span class="dt">unsigned</span><span class="pp"> </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb18-11"><a aria-hidden="true" href="#cb18-11"></a><span class="pp">#define clr</span>(f,<span class="pp"> </span>n)<span class="pp"> </span>memset(f,<span class="pp"> </span><span class="dv">0</span>,<span class="pp"> </span>(<span class="kw">sizeof</span>(<span class="dt">int</span>))<span class="pp"> </span>*<span class="pp"> </span>(n))</span>
<span id="cb18-12"><a aria-hidden="true" href="#cb18-12"></a><span class="pp">#define cpy</span>(f,<span class="pp"> </span>g,<span class="pp"> </span>n)<span class="pp"> </span>memcpy(f,<span class="pp"> </span>g,<span class="pp"> </span>(<span class="kw">sizeof</span>(<span class="dt">int</span>))<span class="pp"> </span>*<span class="pp"> </span>(n))</span>
<span id="cb18-13"><a aria-hidden="true" href="#cb18-13"></a><span class="pp">#define MOD </span><span class="dv">998244353</span></span></code></pre></div>
<p><code>memset</code> 和 <code>memcpy</code> 的用法建议自己去查。</p>
<p>接下来是一些基本的东西，下面我们使用 <code>vector</code> 来实现多项式，这样子的好处是常数不大而且方便好写：</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a aria-hidden="true" href="#cb19-1"></a><span class="at">const</span> <span class="dt">int</span> G = <span class="dv">3</span>, mod = MOD, maxn = <span class="dv">1</span> &lt;&lt; <span class="dv">17</span> | <span class="dv">500</span>;</span>
<span id="cb19-2"><a aria-hidden="true" href="#cb19-2"></a><span class="kw">typedef</span> <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; Poly;</span>
<span id="cb19-3"><a aria-hidden="true" href="#cb19-3"></a>ll qPow(ll a, ll b = mod - <span class="dv">2</span>) {</span>
<span id="cb19-4"><a aria-hidden="true" href="#cb19-4"></a>    ll ret = <span class="dv">1</span>;</span>
<span id="cb19-5"><a aria-hidden="true" href="#cb19-5"></a>    <span class="cf">for</span> (; b; b &gt;&gt;= <span class="dv">1</span>, a = a * a % mod)</span>
<span id="cb19-6"><a aria-hidden="true" href="#cb19-6"></a>        <span class="cf">if</span> (b &amp; <span class="dv">1</span>) ret = a * ret % mod;</span>
<span id="cb19-7"><a aria-hidden="true" href="#cb19-7"></a>    <span class="cf">return</span> ret;</span>
<span id="cb19-8"><a aria-hidden="true" href="#cb19-8"></a>}</span>
<span id="cb19-9"><a aria-hidden="true" href="#cb19-9"></a><span class="at">const</span> <span class="dt">int</span> invG = qPow(G);</span></code></pre></div>
<p>NTT 时需要用到的位逆序置换：</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a aria-hidden="true" href="#cb20-1"></a><span class="dt">int</span> <span class="fu">tr</span>[maxn &lt;&lt; <span class="dv">1</span>], revLim;</span>
<span id="cb20-2"><a aria-hidden="true" href="#cb20-2"></a></span>
<span id="cb20-3"><a aria-hidden="true" href="#cb20-3"></a><span class="dt">void</span> getTr(<span class="dt">int</span> n) {</span>
<span id="cb20-4"><a aria-hidden="true" href="#cb20-4"></a>    <span class="cf">if</span> (revLim == n) <span class="cf">return</span>;</span>
<span id="cb20-5"><a aria-hidden="true" href="#cb20-5"></a>    revLim = n;</span>
<span id="cb20-6"><a aria-hidden="true" href="#cb20-6"></a>    FOR(i, <span class="dv">0</span>, n - <span class="dv">1</span>)</span>
<span id="cb20-7"><a aria-hidden="true" href="#cb20-7"></a>        <span class="fu">tr</span>[i] = (<span class="fu">tr</span>[i &gt;&gt; <span class="dv">1</span>] &gt;&gt; <span class="dv">1</span>) | ((i &amp; <span class="dv">1</span>) ? (n &gt;&gt; <span class="dv">1</span>) : <span class="dv">0</span>);</span>
<span id="cb20-8"><a aria-hidden="true" href="#cb20-8"></a>}</span></code></pre></div>
<p>这样子可以在需要进行很多次 NTT 的时候智能的求出对应需要的 <code>tr</code>。</p>
<p>NTT：<strong>关于 <code>static</code> 关键字相关的建议自己查一下。</strong></p>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a aria-hidden="true" href="#cb21-1"></a><span class="dt">void</span> NTT(<span class="dt">int</span> *g, <span class="dt">bool</span> op, <span class="dt">int</span> n) {</span>
<span id="cb21-2"><a aria-hidden="true" href="#cb21-2"></a>    getTr(n);</span>
<span id="cb21-3"><a aria-hidden="true" href="#cb21-3"></a>    <span class="at">static</span> ull f[maxn &lt;&lt; <span class="dv">1</span>], w[maxn &lt;&lt; <span class="dv">1</span>];</span>
<span id="cb21-4"><a aria-hidden="true" href="#cb21-4"></a>    w[<span class="dv">0</span>] = <span class="dv">1</span>;</span>
<span id="cb21-5"><a aria-hidden="true" href="#cb21-5"></a>    FOR(i, <span class="dv">0</span>, n - <span class="dv">1</span>) f[i] = (((ll)mod &lt;&lt; <span class="dv">5</span><span class="bu">ll</span>) + g[<span class="fu">tr</span>[i]]) % mod;</span>
<span id="cb21-6"><a aria-hidden="true" href="#cb21-6"></a>    <span class="cf">for</span> (<span class="dt">int</span> l = <span class="dv">1</span>; l &lt; n; l &lt;&lt;= <span class="dv">1</span>) {</span>
<span id="cb21-7"><a aria-hidden="true" href="#cb21-7"></a>        ull tG = qPow(op ? G : invG, (mod - <span class="dv">1</span>) / (l &lt;&lt; <span class="dv">1</span>));</span>
<span id="cb21-8"><a aria-hidden="true" href="#cb21-8"></a>        FOR(i, <span class="dv">1</span>, l - <span class="dv">1</span>) w[i] = w[i - <span class="dv">1</span>] * tG % mod;</span>
<span id="cb21-9"><a aria-hidden="true" href="#cb21-9"></a>        <span class="cf">for</span> (<span class="dt">int</span> k = <span class="dv">0</span>; k &lt; n; k += (l &lt;&lt; <span class="dv">1</span>))</span>
<span id="cb21-10"><a aria-hidden="true" href="#cb21-10"></a>            <span class="cf">for</span> (<span class="dt">int</span> p = <span class="dv">0</span>; p &lt; l; ++p) {</span>
<span id="cb21-11"><a aria-hidden="true" href="#cb21-11"></a>                <span class="dt">int</span> tt = w[p] * f[k | l | p] % mod;</span>
<span id="cb21-12"><a aria-hidden="true" href="#cb21-12"></a>                f[k | l | p] = f[k | p] + mod - tt;</span>
<span id="cb21-13"><a aria-hidden="true" href="#cb21-13"></a>                f[k | p] += tt;</span>
<span id="cb21-14"><a aria-hidden="true" href="#cb21-14"></a>            }</span>
<span id="cb21-15"><a aria-hidden="true" href="#cb21-15"></a>        <span class="cf">if</span> (l == (<span class="dv">1</span> &lt;&lt; <span class="dv">10</span>))</span>
<span id="cb21-16"><a aria-hidden="true" href="#cb21-16"></a>            FOR(i, <span class="dv">0</span>, n - <span class="dv">1</span>) f[i] %= mod;</span>
<span id="cb21-17"><a aria-hidden="true" href="#cb21-17"></a>    }</span>
<span id="cb21-18"><a aria-hidden="true" href="#cb21-18"></a>    <span class="cf">if</span> (!op) {</span>
<span id="cb21-19"><a aria-hidden="true" href="#cb21-19"></a>        ull invn = qPow(n);</span>
<span id="cb21-20"><a aria-hidden="true" href="#cb21-20"></a>        FOR(i, <span class="dv">0</span>, n - <span class="dv">1</span>) g[i] = f[i] % mod * invn % mod;</span>
<span id="cb21-21"><a aria-hidden="true" href="#cb21-21"></a>    } <span class="cf">else</span> FOR(i, <span class="dv">0</span>, n - <span class="dv">1</span>) g[i] = f[i] % mod;</span>
<span id="cb21-22"><a aria-hidden="true" href="#cb21-22"></a>}</span></code></pre></div>
<p>其中有几个需要注意的点。使用 <code>ull</code> 是因为 <code>ull</code> 可以大幅减少需要的取模操作，我们可以在迭代 <span class="math inline">\(10\)</span> 次再取模，减少常数。而第五行则为去掉传进来的 <span class="math inline">\([x^i]g(x)\)</span> 为负数时可能产生的影响。</p>
<p>然后是 <code>poly</code> 的常见运算，重载了之后会非常方便。</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a aria-hidden="true" href="#cb22-1"></a><span class="dt">void</span> mul(<span class="dt">int</span> *f, <span class="dt">int</span> *g, <span class="dt">int</span> n) {</span>
<span id="cb22-2"><a aria-hidden="true" href="#cb22-2"></a>    FOR(i, <span class="dv">0</span>, n - <span class="dv">1</span>) f[i] = <span class="dv">1</span><span class="bu">ll</span> * f[i] * g[i] % mod;</span>
<span id="cb22-3"><a aria-hidden="true" href="#cb22-3"></a>    <span class="cf">return</span>;</span>
<span id="cb22-4"><a aria-hidden="true" href="#cb22-4"></a>}</span>
<span id="cb22-5"><a aria-hidden="true" href="#cb22-5"></a></span>
<span id="cb22-6"><a aria-hidden="true" href="#cb22-6"></a>Poly <span class="kw">operator</span>+(<span class="at">const</span> Poly &amp;A, <span class="at">const</span> Poly &amp;B) {</span>
<span id="cb22-7"><a aria-hidden="true" href="#cb22-7"></a>    Poly C = A; C.resize(max(A.size(), B.size()));</span>
<span id="cb22-8"><a aria-hidden="true" href="#cb22-8"></a>    VEC(i, B) C[i] = (C[i] + B[i]) % mod;</span>
<span id="cb22-9"><a aria-hidden="true" href="#cb22-9"></a>    <span class="cf">return</span> C;</span>
<span id="cb22-10"><a aria-hidden="true" href="#cb22-10"></a>}</span>
<span id="cb22-11"><a aria-hidden="true" href="#cb22-11"></a>Poly <span class="kw">operator</span>-(<span class="at">const</span> Poly &amp;A, <span class="at">const</span> Poly &amp;B) {</span>
<span id="cb22-12"><a aria-hidden="true" href="#cb22-12"></a>    Poly C = A; C.resize(max(A.size(), B.size()));</span>
<span id="cb22-13"><a aria-hidden="true" href="#cb22-13"></a>    VEC(i, B) C[i] = (C[i] + mod - B[i]) % mod;</span>
<span id="cb22-14"><a aria-hidden="true" href="#cb22-14"></a>    <span class="cf">return</span> C;</span>
<span id="cb22-15"><a aria-hidden="true" href="#cb22-15"></a>}</span>
<span id="cb22-16"><a aria-hidden="true" href="#cb22-16"></a>Poly <span class="kw">operator</span>*(<span class="at">const</span> <span class="dt">int</span> c, <span class="at">const</span> Poly &amp;A) {</span>
<span id="cb22-17"><a aria-hidden="true" href="#cb22-17"></a>    Poly C = A;</span>
<span id="cb22-18"><a aria-hidden="true" href="#cb22-18"></a>    VEC(i, A) C[i] = <span class="dv">1</span><span class="bu">ll</span> * c * C[i] % mod;</span>
<span id="cb22-19"><a aria-hidden="true" href="#cb22-19"></a>    <span class="cf">return</span> C;</span>
<span id="cb22-20"><a aria-hidden="true" href="#cb22-20"></a>}</span>
<span id="cb22-21"><a aria-hidden="true" href="#cb22-21"></a></span>
<span id="cb22-22"><a aria-hidden="true" href="#cb22-22"></a><span class="dt">int</span> lim;<span class="co">//代表多项式运算时的界</span></span>
<span id="cb22-23"><a aria-hidden="true" href="#cb22-23"></a></span>
<span id="cb22-24"><a aria-hidden="true" href="#cb22-24"></a>Poly <span class="kw">operator</span>*(<span class="at">const</span> Poly &amp;A, <span class="at">const</span> Poly &amp;B) {</span>
<span id="cb22-25"><a aria-hidden="true" href="#cb22-25"></a>    <span class="at">static</span> <span class="dt">int</span> a[maxn &lt;&lt; <span class="dv">1</span>], b[maxn &lt;&lt; <span class="dv">1</span>];</span>
<span id="cb22-26"><a aria-hidden="true" href="#cb22-26"></a>    cpy(a, &amp;A[<span class="dv">0</span>], A.size());</span>
<span id="cb22-27"><a aria-hidden="true" href="#cb22-27"></a>    cpy(b, &amp;B[<span class="dv">0</span>], B.size());</span>
<span id="cb22-28"><a aria-hidden="true" href="#cb22-28"></a>    Poly C; C.resize(min(lim, (<span class="dt">int</span>)(A.size() + B.size() - <span class="dv">1</span>)));</span>
<span id="cb22-29"><a aria-hidden="true" href="#cb22-29"></a>    <span class="dt">int</span> n = <span class="dv">1</span>; <span class="cf">for</span> (n = <span class="dv">1</span>; n &lt; (<span class="dt">int</span>)(A.size() + B.size() - <span class="dv">1</span>); n &lt;&lt;= <span class="dv">1</span>);</span>
<span id="cb22-30"><a aria-hidden="true" href="#cb22-30"></a>    NTT(a, <span class="dv">1</span>, n), NTT(b, <span class="dv">1</span>, n);</span>
<span id="cb22-31"><a aria-hidden="true" href="#cb22-31"></a>    mul(a, b, n), NTT(a, <span class="dv">0</span>, n);</span>
<span id="cb22-32"><a aria-hidden="true" href="#cb22-32"></a>    cpy(&amp;C[<span class="dv">0</span>], a, C.size());</span>
<span id="cb22-33"><a aria-hidden="true" href="#cb22-33"></a>    clr(a, n), clr(b, n);</span>
<span id="cb22-34"><a aria-hidden="true" href="#cb22-34"></a>    <span class="cf">return</span> C;</span>
<span id="cb22-35"><a aria-hidden="true" href="#cb22-35"></a>}</span></code></pre></div>
<h2 id="多项式乘法逆">多项式乘法逆</h2>
<h3 id="定义">定义</h3>
<p>当两个多项式 <span class="math inline">\(F(x)\)</span> 与 <span class="math inline">\(G(x)\)</span> 在每一项系数模 <span class="math inline">\(p\)</span> 时有 <span class="math inline">\(F(x)*G(x)\equiv 1\pmod{x^n}\)</span> 时，称 <span class="math inline">\(F(x)\)</span> 与 <span class="math inline">\(G(x)\)</span> 互为乘法逆元。此处 <span class="math inline">\(\pmod{x^n}\)</span> 代表次数高于 <span class="math inline">\(n\)</span> 的项都不考虑。</p>
<p>需要的前置知识：NTT。</p>
<h3 id="求法">求法</h3>
<p>考虑倍增。假设我们要求满足 <span class="math inline">\(F(x)*G(x)\equiv 1\pmod{x^k}\)</span> 的 <span class="math inline">\(G(x)\)</span>，并且已经求出了满足 <span class="math inline">\(F(x)*G'(x)\equiv1\pmod{x^{\lceil\frac x 2\rceil}}\)</span> 的 <span class="math inline">\(G'(x)\)</span>。那么我们由 <span class="math display">\[
F(x)*G'(x)\equiv1\pmod{x^{\lceil\frac x 2\rceil}}
\]</span> 必然可以推出 <span class="math display">\[
F(x)*G(x)\equiv1\pmod{x^{\lceil\frac x 2\rceil}}
\]</span> 那么 <span class="math display">\[
G(x) \equiv G'(x)\pmod{x^{\lceil\frac x 2\rceil}}
\]</span> 作差， <span class="math display">\[
G(x) - G'(x)\equiv 0\pmod{x^{\lceil\frac x2\rceil}}
\]</span> 将两边同时平方，不难发现界会从 <span class="math inline">\(\lceil\frac n2\rceil\)</span> 变为 <span class="math inline">\(n\)</span>。 <span class="math display">\[
G^2(x) - 2G(x)G'(x) + G'^2(x)\equiv 0\pmod{x^n}
\]</span> 现在要求的是 <span class="math inline">\(G(x)\)</span>，而我们发现 <span class="math inline">\(G^2(x)\)</span> 不好处理，怎么办？同时乘以 <span class="math inline">\(F(x)\)</span> 就可以消掉一个 <span class="math inline">\(G(x)\)</span>： <span class="math display">\[
G(x) - 2G'(x) + G'^2(x)F(x)\equiv 0\pmod{x^n}
\]</span> 所以我们得到了 <span class="math display">\[
G(x)\equiv 2G'(x) - G'^2(x)F(x)\pmod{x^n}
\]</span> 根据这个，我们就可以从 <span class="math inline">\(G'(x)\)</span> 推出 <span class="math inline">\(G(x)\)</span> 的值出来了。从上往下递归求解，到常数项的时候直接费马小定理求逆元然后一步步回溯上去。不难发现复杂度为 <span class="math inline">\(T(n) = T(n/2) + O(n\log n)\)</span>，由主定理知总复杂度为 <span class="math inline">\(O(n\log n)\)</span>。</p>
<h3 id="实现-1">实现</h3>
<p>递归版多项式求逆，套用上面的板子：</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a aria-hidden="true" href="#cb23-1"></a><span class="dt">void</span> polyInv(<span class="at">const</span> Poly &amp;A, Poly &amp;B, <span class="dt">int</span> n) {</span>
<span id="cb23-2"><a aria-hidden="true" href="#cb23-2"></a>    <span class="cf">if</span> (!n) <span class="cf">return</span>;</span>
<span id="cb23-3"><a aria-hidden="true" href="#cb23-3"></a>    <span class="cf">if</span> (n == <span class="dv">1</span>) B.push_back(qPow(A[<span class="dv">0</span>]));</span>
<span id="cb23-4"><a aria-hidden="true" href="#cb23-4"></a>    <span class="cf">else</span> <span class="cf">if</span> (n &amp; <span class="dv">1</span>) {</span>
<span id="cb23-5"><a aria-hidden="true" href="#cb23-5"></a>        polyInv(A, B, --n);</span>
<span id="cb23-6"><a aria-hidden="true" href="#cb23-6"></a>        <span class="dt">int</span> sav = <span class="dv">0</span>;</span>
<span id="cb23-7"><a aria-hidden="true" href="#cb23-7"></a>        FOR(i, <span class="dv">0</span>, n - <span class="dv">1</span>) sav = (sav + <span class="dv">1</span><span class="bu">ll</span> * B[i] * A[n - i]) % mod;</span>
<span id="cb23-8"><a aria-hidden="true" href="#cb23-8"></a>        B.push_back(<span class="dv">1</span><span class="bu">ll</span> * sav * qPow(mod - A[<span class="dv">0</span>]) % mod);</span>
<span id="cb23-9"><a aria-hidden="true" href="#cb23-9"></a>    } <span class="cf">else</span> {</span>
<span id="cb23-10"><a aria-hidden="true" href="#cb23-10"></a>        polyInv(A, B, n &gt;&gt; <span class="dv">1</span>);</span>
<span id="cb23-11"><a aria-hidden="true" href="#cb23-11"></a>        Poly sA; sA.resize(n);</span>
<span id="cb23-12"><a aria-hidden="true" href="#cb23-12"></a>        cpy(&amp;sA[<span class="dv">0</span>], &amp;A[<span class="dv">0</span>], n);</span>
<span id="cb23-13"><a aria-hidden="true" href="#cb23-13"></a>        B = <span class="dv">2</span> * B - B * B * sA;</span>
<span id="cb23-14"><a aria-hidden="true" href="#cb23-14"></a>        B.resize(n);</span>
<span id="cb23-15"><a aria-hidden="true" href="#cb23-15"></a>    }</span>
<span id="cb23-16"><a aria-hidden="true" href="#cb23-16"></a>    <span class="cf">return</span>;</span>
<span id="cb23-17"><a aria-hidden="true" href="#cb23-17"></a>}</span>
<span id="cb23-18"><a aria-hidden="true" href="#cb23-18"></a>Poly polyInv(<span class="at">const</span> Poly &amp;A) {</span>
<span id="cb23-19"><a aria-hidden="true" href="#cb23-19"></a>    Poly C; polyInv(A, C, A.size());</span>
<span id="cb23-20"><a aria-hidden="true" href="#cb23-20"></a>    <span class="cf">return</span> C;</span>
<span id="cb23-21"><a aria-hidden="true" href="#cb23-21"></a>}</span></code></pre></div>
<p>其中把 <span class="math inline">\(n\)</span> 为奇数的情况进行了特判优化，调用就直接对下面的 <code>polyInv</code> 函数传入一个 <code>vector</code> 即可。</p>
<h2 id="多项式的导数积分复合">多项式的导数/积分/复合</h2>
<p>回顾一下一些基础的导数公式： <span class="math display">\[
\begin{aligned}
f(x) = e^x&amp;\implies f'(x) = e^x\\
f(x) = \ln x&amp;\implies f'(x) = \frac1x\\
f(x) = ax^k&amp;\implies f'(x) = akx^{k - 1}\\
(f(x)\pm g(x))'&amp;= f'(x)\pm g'(x)\\
(f(g(x)))' &amp;=f'(g(x))\times g'(x)
\end{aligned}
\]</span> 我们在这里定义一下多项式的求导： <span class="math display">\[
f(x) = \sum_{i = 0}^na_ix^i\implies f'(x) = \sum_{i = 0}^{n - 1}(i + 1)a_{i + 1}x^i
\]</span> 积分为求导的逆运算： <span class="math display">\[
f(x) = \sum_{i = 0}^na_ix_i\implies\int f(x) \mathrm dx= \sum_{i = 1}^{n + 1}\frac{a_{i - 1}x^i}{i}
\]</span> 所以多项式求导和求积分的代码就很容易写出来了，当然需要一开始线性预处理一下逆元。</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb24-1"><a aria-hidden="true" href="#cb24-1"></a><span class="dt">int</span> inv[maxn];</span>
<span id="cb24-2"><a aria-hidden="true" href="#cb24-2"></a><span class="dt">void</span> initInv() {</span>
<span id="cb24-3"><a aria-hidden="true" href="#cb24-3"></a>    inv[<span class="dv">1</span>] = <span class="dv">1</span>;</span>
<span id="cb24-4"><a aria-hidden="true" href="#cb24-4"></a>    FOR(i, <span class="dv">2</span>, lim) inv[i] = <span class="dv">1</span><span class="bu">ll</span> * inv[mod % i] * (mod - mod / i) % mod;</span>
<span id="cb24-5"><a aria-hidden="true" href="#cb24-5"></a>    <span class="cf">return</span>;</span>
<span id="cb24-6"><a aria-hidden="true" href="#cb24-6"></a>}</span>
<span id="cb24-7"><a aria-hidden="true" href="#cb24-7"></a></span>
<span id="cb24-8"><a aria-hidden="true" href="#cb24-8"></a>Poly deri(<span class="at">const</span> Poly &amp;A) {</span>
<span id="cb24-9"><a aria-hidden="true" href="#cb24-9"></a>    Poly C = A;</span>
<span id="cb24-10"><a aria-hidden="true" href="#cb24-10"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt; (<span class="dt">int</span>)C.size(); ++i) C[i - <span class="dv">1</span>] = <span class="dv">1</span><span class="bu">ll</span> * C[i] * i % mod;</span>
<span id="cb24-11"><a aria-hidden="true" href="#cb24-11"></a>    <span class="cf">if</span> (!C.empty()) C.pop_back();</span>
<span id="cb24-12"><a aria-hidden="true" href="#cb24-12"></a>    <span class="cf">return</span> C;</span>
<span id="cb24-13"><a aria-hidden="true" href="#cb24-13"></a>}</span>
<span id="cb24-14"><a aria-hidden="true" href="#cb24-14"></a></span>
<span id="cb24-15"><a aria-hidden="true" href="#cb24-15"></a>Poly ints(<span class="at">const</span> Poly &amp;A) {</span>
<span id="cb24-16"><a aria-hidden="true" href="#cb24-16"></a>    Poly C = A;</span>
<span id="cb24-17"><a aria-hidden="true" href="#cb24-17"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = (<span class="dt">int</span>)C.size() - <span class="dv">1</span>; i &gt; <span class="dv">0</span>; --i)</span>
<span id="cb24-18"><a aria-hidden="true" href="#cb24-18"></a>        C[i] = <span class="dv">1</span><span class="bu">ll</span> * C[i - <span class="dv">1</span>] * inv[i] % mod;</span>
<span id="cb24-19"><a aria-hidden="true" href="#cb24-19"></a>    <span class="cf">if</span> (!C.empty()) C[<span class="dv">0</span>] = <span class="dv">0</span>;</span>
<span id="cb24-20"><a aria-hidden="true" href="#cb24-20"></a>    <span class="cf">return</span> C;</span>
<span id="cb24-21"><a aria-hidden="true" href="#cb24-21"></a>}</span></code></pre></div>
<p>需要非常注意传进来的多项式为空的情况，对空 <code>vector</code> 进行调用 <code>pop_back()</code> 和访问元素会直接 RE，需要注意。</p>
<p>定义多项式的复合：</p>
<p><span class="math display">\[
f(g(x)) = \sum_{i = 0}f_i(g(x))^i
\]</span></p>
<p>应该比较好理解，直接把 <span class="math inline">\(g(x)\)</span> 代入即可。后面学习牛顿迭代的时候需要用到。</p>
<h2 id="牛顿迭代法">牛顿迭代法</h2>
<p>这节内容相当重要，是后面学习开根和 <span class="math inline">\(\exp\)</span> 的基础，建议掌握好。</p>
<h3 id="牛迭求函数零点">牛迭求函数零点</h3>
<p>首先各位如果学过旧人教版选修 2-2 的话应该都有看到过牛顿迭代。</p>
<p>牛顿迭代是一种求函数零点的方法。设初始近似值为 <span class="math inline">\(x_0\)</span>，则我们有这点的切线方程 <span class="math display">\[
y = f'(x_0)(x - x_0) + f(x_0)
\]</span> 令 <span class="math inline">\(y = 0\)</span>，得 <span class="math inline">\(x = x_0 - \dfrac{f(x_0)}{f'(x_0)}\)</span>。这样子我们就可以一直迭代下去，令 <span class="math inline">\(x_0\leftarrow x\)</span>，就可以在很短的时间内很接近地得到 <span class="math inline">\(f(x)\)</span> 的零点。</p>
<h3 id="泰勒展开">泰勒展开</h3>
<p>简单扯一扯吧，实际上就是使用多项式函数来拟合 <span class="math inline">\(\ln\)</span> 啊 <span class="math inline">\(\sin\)</span> 啊这类的函数（因为多项式真的方便啊），其原理就是在要求的函数 <span class="math inline">\(f(x)\)</span> 上找一个点 <span class="math inline">\(x_0\)</span>，构造一个多项式 <span class="math inline">\(g(x)\)</span> 使得这个多项式在 <span class="math inline">\(x_0\)</span> 处的 <span class="math inline">\(n\)</span> 阶导数都相等，随着 <span class="math inline">\(n\)</span> 越来越大，拟合的效果就越来越好。</p>
<p>泰勒展开的公式是长这样的：</p>
<p><span class="math display">\[
f(x) = \frac{f(x_0)}{0!}(x - x_0)^0 + \frac{f'(x_0)}{1!}(x - x_0)^1 + \frac{f''(x_0)}{2!}(x - x_0)^2 + \cdots + \frac{f^{(n)}(x_0)}{n!}(x - x_0)^n + R_n(x)
\]</span></p>
<p>或者写成</p>
<p><span class="math display">\[
f(x) \approx \sum_{i = 0}^n\frac{f^{(i)}(x_0)}{i!}(x - x_0)^i
\]</span></p>
<p>其中 <span class="math inline">\(f^{(i)}(x_0)\)</span> 表示 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\(x_0\)</span> 处的 <span class="math inline">\(i\)</span> 阶导数。</p>
<p><span class="math inline">\(x_0 = 0\)</span> 时得到的级数就是麦克劳林级数，下面的东西需要牢记：</p>
<p><span class="math display">\[
\begin{aligned}
\mathrm e^x &amp;= \sum_{k = 0}^\infty\frac{x^k}{k!}\\
\sin x &amp;= x - \frac{x^3}{3!} + \frac{x^5}{5!} - \cdots + (-1)^n\frac{x^{2n - 1}}{(2n - 1)!} + \cdots\\
&amp;= \sum_{i = 0}^\infty(-1)^i\frac{x^{2i - 1}}{(2i - 1)!}\\
\cos x &amp;= 1 - \frac{x^2}{2!} + \frac{x^4}{4!} - \cdots + (-1)^n\frac{x^{2n}}{(2n)!}+\cdots\\
&amp;= \sum_{i = 0}^\infty(-1)^i\frac{x^{2i}}{(2i)!}\\
\ln(1 + x) &amp;= \sum_{i = 1}^\infty(-1)^{i - 1}\frac{x^i}{i}\\
\ln(1 - x) &amp;= -\sum_{i = 1}^\infty\frac{x^i}{i}
\end{aligned}
\]</span></p>
<p>多项式的 <span class="math inline">\(\ln\)</span> 是如是定义的： <span class="math display">\[
\ln(1 - f(x)) = -\sum_{i = 1}^{+\infty}\frac{f^i(x)}{i}\\\ln(1 + f(x)) = \sum_{i = 1}^{+\infty}\frac{(-1)^{i - 1}f^i(x)}{i}
\]</span> 多项式的 <span class="math inline">\(\exp\)</span> 则是这样： <span class="math display">\[
\exp f(x) = e^{f(x)}=\sum_{i = 0}^{+\infty}\frac{f^i(x)}{i!}
\]</span></p>
<h3 id="多项式牛迭">多项式牛迭</h3>
<p>现在要解决的是给定 <span class="math inline">\(g(x)\)</span>，求满足 <span class="math inline">\(g(f(x))\equiv 0\pmod{x^n}\)</span> 的 <span class="math inline">\(f(x)\)</span>（模 <span class="math inline">\(x^n\)</span> 意义下）。</p>
<p>考虑倍增。</p>
<p>当 <span class="math inline">\(n = 1\)</span> 的时候，<span class="math inline">\([x^0]g(f(x)) = 0\)</span> 的解要单独的算。</p>
<p>假设已经求出了模 <span class="math inline">\(x^{\left\lceil\frac n 2\right\rceil}\)</span> 意义下的解 <span class="math inline">\(f_0(x)\)</span>，要求模 <span class="math inline">\(x^n\)</span> 意义下的 <span class="math inline">\(f(x)\)</span>。</p>
<p>将 <span class="math inline">\(g(f(x))\)</span> 在 <span class="math inline">\(f_0(x)\)</span> 处泰勒展开，有： <span class="math display">\[
\sum_{i = 0}^{+\infty}\frac{g^{(i)}(f_0(x))}{i!}(f(x) - f_0(x))^i\equiv 0\pmod{x^n}
\]</span> 因为 <span class="math inline">\(f(x) - f_0(x)\)</span> 的最低非零项次数最低为 <span class="math inline">\(\left\lceil\frac n 2\right\rceil\)</span>，所以当 <span class="math inline">\(i\ge 2\)</span> 时有 <span class="math display">\[
(f(x) - f_0(x))^i\equiv 0\pmod{x^n}
\]</span> 所以泰勒展开的结果为 <span class="math display">\[
g(f_0(x)) + g'(f_0(x))(f(x) - f_0(x))\equiv 0\pmod{x^n}
\]</span> 化简下来就是 <span class="math display">\[
f(x)\equiv f_0(x) - \frac{g(f_0(x))}{g'(f_0(x))}\pmod{x^n}
\]</span></p>
<h3 id="应用">应用</h3>
<p>这个形式可能暂时看不出来有什么用，但是等一下涉及到 <span class="math inline">\(\exp\)</span> 和多项式开根等操作时其就会发挥大作用。</p>
<h2 id="多项式对指开根">多项式对指开根</h2>
<p>建议先了解清楚高中数学必修 1 中的对数函数/指数函数/幂函数以及一些最基础的微积分知识（基础导数公式，泰勒展开）</p>
<h3 id="多项式-ln">多项式 ln</h3>
<h4 id="问题描述-1">问题描述</h4>
<p>给定 <span class="math inline">\(A(x)\)</span>，求 <span class="math inline">\(B(x)\)</span> 满足 <span class="math inline">\(B(x)\equiv \ln A(x) \pmod{x^n}\)</span>。</p>
<p>由上文多项式对数的定义，<strong>多项式的对数仅在常数项为 <span class="math inline">\(1\)</span> 时才有意义。</strong></p>
<h4 id="求法-1">求法</h4>
<p>不管那么多了，直接求导再积分积回去就可以了：</p>
<p><span class="math display">\[
\begin{aligned}
(\ln A(x))' &amp;= \frac{A'(x)}{A(x)}\\
\ln A(x) &amp;= \int \frac{A'(x)}{A(x)}\mathrm{d}x
\end{aligned}
\]</span></p>
<p>均在 <span class="math inline">\(\pmod{x^n}\)</span> 意义下进行。所以我们只需求导，求逆，乘起来再积个分就可以了。</p>
<h4 id="实现-2">实现</h4>
<p>就一行，超级短。</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a aria-hidden="true" href="#cb25-1"></a>Poly polyLn(<span class="at">const</span> Poly &amp;A) {</span>
<span id="cb25-2"><a aria-hidden="true" href="#cb25-2"></a>    <span class="cf">return</span> ints(deri(A) * polyInv(A));</span>
<span id="cb25-3"><a aria-hidden="true" href="#cb25-3"></a>}</span></code></pre></div>
<p><a href="https://www.luogu.com.cn/problem/P4725">洛谷 4725</a> 的实现：</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb26-1"><a aria-hidden="true" href="#cb26-1"></a><span class="dt">int</span> n;</span>
<span id="cb26-2"><a aria-hidden="true" href="#cb26-2"></a>Poly f;</span>
<span id="cb26-3"><a aria-hidden="true" href="#cb26-3"></a></span>
<span id="cb26-4"><a aria-hidden="true" href="#cb26-4"></a><span class="dt">int</span> main() {</span>
<span id="cb26-5"><a aria-hidden="true" href="#cb26-5"></a>    read(n);</span>
<span id="cb26-6"><a aria-hidden="true" href="#cb26-6"></a>    lim = n; initInv();</span>
<span id="cb26-7"><a aria-hidden="true" href="#cb26-7"></a>    f.resize(n);</span>
<span id="cb26-8"><a aria-hidden="true" href="#cb26-8"></a>    FOR(i, <span class="dv">0</span>, n - <span class="dv">1</span>) read(f[i]);</span>
<span id="cb26-9"><a aria-hidden="true" href="#cb26-9"></a>    f = polyLn(f);</span>
<span id="cb26-10"><a aria-hidden="true" href="#cb26-10"></a>    print(f);</span>
<span id="cb26-11"><a aria-hidden="true" href="#cb26-11"></a>    <span class="cf">return</span> output(), <span class="dv">0</span>;</span>
<span id="cb26-12"><a aria-hidden="true" href="#cb26-12"></a>}</span></code></pre></div>
<h3 id="多项式-exp">多项式 exp</h3>
<h4 id="问题描述-2">问题描述</h4>
<p>给定多项式 <span class="math inline">\(A(x)\)</span>，求 <span class="math inline">\(B(x)\)</span> 满足 <span class="math inline">\(B(x)\equiv \exp A(x)\pmod{x^n}\)</span>。</p>
<p><strong>多项式的指数函数仅在常数项为 <span class="math inline">\(0\)</span> 时才有意义，</strong>否则常数项将不收敛。</p>
<h4 id="求法-1-牛顿迭代">求法 1 牛顿迭代</h4>
<p>考虑使用牛顿迭代。 <span class="math display">\[
\begin{aligned}B(x)&amp;\equiv \exp A(x)&amp;\pmod{x^n}\\\ln B(x) - A(x)&amp;\equiv 0&amp;\pmod{x^n}\\\end{aligned}
\]</span> 现在我们把 <span class="math inline">\(A(x)\)</span> 看成一个常数，<span class="math inline">\(B(x)\)</span> 看成一个变量，则我们就是要求这个勾八东西的零点。令 <span class="math inline">\(G(B(x)) \equiv \ln B(x) - A(x)\pmod{x^n}\)</span>，这个东西求导是 <span class="math inline">\(G'(B(x))\equiv \dfrac{1}{B(x)}\)</span>。</p>
<p>套用一下上面的牛迭式子，假设我们已经搞定了模 <span class="math inline">\(x^{\left\lceil\frac n 2\right\rceil}\)</span> 意义下的解 <span class="math inline">\(B_0(x)\)</span>，要求模 <span class="math inline">\(x^n\)</span> 意义下的 <span class="math inline">\(B(x)\)</span>。然后就有了 <span class="math display">\[
\begin{aligned}B(x) &amp;\equiv B_0(x) - \frac{G(B_0(x))}{G'(B_0(x))}\\&amp;\equiv B_0(x) - (\ln B_0(x) - A(x))B_0(x)\\&amp;\equiv B_0(x)(1 - \ln B_0(x) + A(x))\pmod{x^n}\end{aligned}
\]</span> 这样子我们就成功的把递推式写出来了。</p>
<h4 id="实现-1-1">实现 1</h4>
<p>这种递归写起方便的就写递归好一点。</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb27-1"><a aria-hidden="true" href="#cb27-1"></a><span class="dt">void</span> polyExp(<span class="at">const</span> Poly &amp;A, Poly &amp;B, <span class="dt">int</span> n) {</span>
<span id="cb27-2"><a aria-hidden="true" href="#cb27-2"></a>    <span class="cf">if</span> (!n) <span class="cf">return</span>;</span>
<span id="cb27-3"><a aria-hidden="true" href="#cb27-3"></a>    <span class="cf">if</span> (n == <span class="dv">1</span>) B.push_back(<span class="dv">1</span>);</span>
<span id="cb27-4"><a aria-hidden="true" href="#cb27-4"></a>    <span class="cf">else</span> <span class="cf">if</span> (n &amp; <span class="dv">1</span>) {</span>
<span id="cb27-5"><a aria-hidden="true" href="#cb27-5"></a>        polyExp(A, B, n - <span class="dv">1</span>); n -= <span class="dv">2</span>;</span>
<span id="cb27-6"><a aria-hidden="true" href="#cb27-6"></a>        <span class="dt">int</span> sav = <span class="dv">0</span>;</span>
<span id="cb27-7"><a aria-hidden="true" href="#cb27-7"></a>        FOR(i, <span class="dv">0</span>, n) sav = (sav + <span class="dv">1</span><span class="bu">ll</span> * (i + <span class="dv">1</span>) * A[i + <span class="dv">1</span>] % mod * B[n - i]) % mod;</span>
<span id="cb27-8"><a aria-hidden="true" href="#cb27-8"></a>        B.push_back(<span class="dv">1</span><span class="bu">ll</span> * sav * inv[n + <span class="dv">1</span>] % mod);</span>
<span id="cb27-9"><a aria-hidden="true" href="#cb27-9"></a>    } <span class="cf">else</span> {</span>
<span id="cb27-10"><a aria-hidden="true" href="#cb27-10"></a>        polyExp(A, B, n / <span class="dv">2</span>);</span>
<span id="cb27-11"><a aria-hidden="true" href="#cb27-11"></a>        Poly lnB = B;</span>
<span id="cb27-12"><a aria-hidden="true" href="#cb27-12"></a>        lnB.resize(n); lnB = polyLn(lnB);</span>
<span id="cb27-13"><a aria-hidden="true" href="#cb27-13"></a>        VEC(i, lnB) lnB[i] = (mod + A[i] - lnB[i]) % mod;</span>
<span id="cb27-14"><a aria-hidden="true" href="#cb27-14"></a>        ++lnB[<span class="dv">0</span>];</span>
<span id="cb27-15"><a aria-hidden="true" href="#cb27-15"></a>        B = B * lnB;</span>
<span id="cb27-16"><a aria-hidden="true" href="#cb27-16"></a>        B.resize(n);</span>
<span id="cb27-17"><a aria-hidden="true" href="#cb27-17"></a>    }</span>
<span id="cb27-18"><a aria-hidden="true" href="#cb27-18"></a>    <span class="cf">return</span>;</span>
<span id="cb27-19"><a aria-hidden="true" href="#cb27-19"></a>}</span>
<span id="cb27-20"><a aria-hidden="true" href="#cb27-20"></a></span>
<span id="cb27-21"><a aria-hidden="true" href="#cb27-21"></a>Poly polyExp(<span class="at">const</span> Poly &amp;f) {</span>
<span id="cb27-22"><a aria-hidden="true" href="#cb27-22"></a>    Poly ret;</span>
<span id="cb27-23"><a aria-hidden="true" href="#cb27-23"></a>    polyExp(f, ret, f.size());</span>
<span id="cb27-24"><a aria-hidden="true" href="#cb27-24"></a>    <span class="cf">return</span> ret;</span>
<span id="cb27-25"><a aria-hidden="true" href="#cb27-25"></a>}</span></code></pre></div>
<p>但是需要注意的是，这个多项式 <span class="math inline">\(\exp\)</span> 的常数还是比较大的，需要尽量减少其调用。</p>
<h4 id="求法-2-分治-fft">求法 2 分治 FFT</h4>
<p>分治 FFT 可以在 <span class="math inline">\(O(n\log^2n)\)</span> 的复杂度下以极优的常数（比一个 <span class="math inline">\(\log\)</span> 快）求出结果。暂时不想写，咕咕咕。</p>
<h3 id="多项式开根">多项式开根</h3>
<h4 id="问题描述-3">问题描述</h4>
<p>给定一个多项式 <span class="math inline">\(A(x)\)</span>，求 <span class="math inline">\(B(x)\)</span> 使得 <span class="math inline">\(B^2(x)\equiv A(x)\pmod{x^n}\)</span></p>
<h4 id="求解">求解</h4>
<p>考虑使用牛顿迭代，令 <span class="math inline">\(f(B(x)) = B^2(x) - A(x)\pmod{x^n}\)</span>。则 <span class="math inline">\(f'(B(x)) = 2B(x)\)</span>，套牛迭式子： <span class="math display">\[
\begin{aligned}B(x) &amp;\equiv B_0(x) - \frac{f(B_0(x))}{f'(B_0(x))}\\&amp;\equiv B_0(x) - \frac{B_0^2(x) - A(x)}{2B_0(x)}\\&amp;\equiv \frac{B_0^2(x) + A(x)}{2B_0(x)}\end{aligned}
\]</span> 时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<p>注意一下如果常数项不为 <span class="math inline">\(0\)</span> 的话是需要二次剩余来求出答案的常数项的。</p>
<h4 id="实现-3">实现</h4>
<div class="sourceCode" id="cb28"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb28-1"><a aria-hidden="true" href="#cb28-1"></a><span class="dt">void</span> polySqrt(<span class="at">const</span> Poly &amp;A, Poly &amp;B, <span class="dt">int</span> m) {</span>
<span id="cb28-2"><a aria-hidden="true" href="#cb28-2"></a>    <span class="cf">if</span> (m == <span class="dv">1</span>) {</span>
<span id="cb28-3"><a aria-hidden="true" href="#cb28-3"></a>        B.push_back(QuadResidue::cipolla(A[<span class="dv">0</span>]));</span>
<span id="cb28-4"><a aria-hidden="true" href="#cb28-4"></a>        <span class="cf">return</span>;</span>
<span id="cb28-5"><a aria-hidden="true" href="#cb28-5"></a>    }</span>
<span id="cb28-6"><a aria-hidden="true" href="#cb28-6"></a>    polySqrt(A, B, (m + <span class="dv">1</span>) &gt;&gt; <span class="dv">1</span>);</span>
<span id="cb28-7"><a aria-hidden="true" href="#cb28-7"></a>    B.resize(m);</span>
<span id="cb28-8"><a aria-hidden="true" href="#cb28-8"></a>    Poly invB = polyInv(<span class="dv">2</span> * B), sA(A.begin(), A.begin() + m);</span>
<span id="cb28-9"><a aria-hidden="true" href="#cb28-9"></a>    B = qPow(<span class="dv">2</span>) * B + invB * sA;</span>
<span id="cb28-10"><a aria-hidden="true" href="#cb28-10"></a>    <span class="cf">return</span>;</span>
<span id="cb28-11"><a aria-hidden="true" href="#cb28-11"></a>}</span>
<span id="cb28-12"><a aria-hidden="true" href="#cb28-12"></a></span>
<span id="cb28-13"><a aria-hidden="true" href="#cb28-13"></a>Poly polySqrt(<span class="at">const</span> Poly &amp;A) {</span>
<span id="cb28-14"><a aria-hidden="true" href="#cb28-14"></a>    Poly C; polySqrt(A, C, A.size());</span>
<span id="cb28-15"><a aria-hidden="true" href="#cb28-15"></a>    <span class="cf">return</span> C;</span>
<span id="cb28-16"><a aria-hidden="true" href="#cb28-16"></a>}</span></code></pre></div>
<h3 id="应用-1-多项式快速幂">应用 1 多项式快速幂</h3>
<p>分两种情况。第一种 <span class="math inline">\([x^0]f(x) = 1\)</span>，此时我们不难发现 <span class="math display">\[
\begin{aligned}g(x) &amp;\equiv f^k(x)\\\ln g(x) &amp;\equiv k\ln f(x)\\g(x) &amp;\equiv \exp(k\ln f(x))\pmod{x^n}\end{aligned}
\]</span> 然后就一个 <span class="math inline">\(\ln\)</span>，乘上 <span class="math inline">\(k\)</span>，再 <span class="math inline">\(\exp\)</span> 一下，这题就做完了。</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb29-1"><a aria-hidden="true" href="#cb29-1"></a>Poly f;</span>
<span id="cb29-2"><a aria-hidden="true" href="#cb29-2"></a><span class="dt">int</span> n, k;</span>
<span id="cb29-3"><a aria-hidden="true" href="#cb29-3"></a><span class="dt">char</span> s[maxn];</span>
<span id="cb29-4"><a aria-hidden="true" href="#cb29-4"></a></span>
<span id="cb29-5"><a aria-hidden="true" href="#cb29-5"></a><span class="dt">int</span> main() {</span>
<span id="cb29-6"><a aria-hidden="true" href="#cb29-6"></a>    read(n), read(s); f.resize(lim = n);</span>
<span id="cb29-7"><a aria-hidden="true" href="#cb29-7"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; s[i]; ++i) k = (<span class="dv">10</span><span class="bu">ll</span> * k + s[i] - <span class="ch">'0'</span>) % mod;</span>
<span id="cb29-8"><a aria-hidden="true" href="#cb29-8"></a>    FOR(i, <span class="dv">0</span>, n - <span class="dv">1</span>) read(f[i]);</span>
<span id="cb29-9"><a aria-hidden="true" href="#cb29-9"></a>    initInv();</span>
<span id="cb29-10"><a aria-hidden="true" href="#cb29-10"></a>    f = polyExp(k * polyLn(f));</span>
<span id="cb29-11"><a aria-hidden="true" href="#cb29-11"></a>    print(f);</span>
<span id="cb29-12"><a aria-hidden="true" href="#cb29-12"></a>    <span class="cf">return</span> output(), <span class="dv">0</span>;</span>
<span id="cb29-13"><a aria-hidden="true" href="#cb29-13"></a>}</span></code></pre></div>
<p>第二种情况 <span class="math inline">\([x^0]f(x) \not= 1\)</span>，此时我们应该做的，就是创造条件强上。</p>
<p>怎么上呢？当 <span class="math inline">\([x^0]f(x)\not= 0\)</span> 时，我们就直接： <span class="math display">\[
f^k(x)\equiv \left(\frac{f(x)}{[x^0]f(x)} \right)^k\times \left([x^0]f(x)\right)^k
\]</span> 当 <span class="math inline">\([x^0]f(x) = 0\)</span> 时，我们就把多项式平移一下，然后强行按上面上，最后平移回去就可以了。</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb30-1"><a aria-hidden="true" href="#cb30-1"></a>Poly f;</span>
<span id="cb30-2"><a aria-hidden="true" href="#cb30-2"></a><span class="dt">int</span> n, k, k2;</span>
<span id="cb30-3"><a aria-hidden="true" href="#cb30-3"></a><span class="dt">char</span> s[maxn];</span>
<span id="cb30-4"><a aria-hidden="true" href="#cb30-4"></a></span>
<span id="cb30-5"><a aria-hidden="true" href="#cb30-5"></a><span class="dt">int</span> main() {</span>
<span id="cb30-6"><a aria-hidden="true" href="#cb30-6"></a>    read(n), read(s);</span>
<span id="cb30-7"><a aria-hidden="true" href="#cb30-7"></a>    f.resize(n);</span>
<span id="cb30-8"><a aria-hidden="true" href="#cb30-8"></a>    FOR(i, <span class="dv">0</span>, n - <span class="dv">1</span>) read(f[i]);</span>
<span id="cb30-9"><a aria-hidden="true" href="#cb30-9"></a></span>
<span id="cb30-10"><a aria-hidden="true" href="#cb30-10"></a>    <span class="dt">int</span> p = <span class="dv">0</span>;</span>
<span id="cb30-11"><a aria-hidden="true" href="#cb30-11"></a>    <span class="cf">while</span> (f[p] == <span class="dv">0</span> &amp;&amp; p &lt; n) ++p;</span>
<span id="cb30-12"><a aria-hidden="true" href="#cb30-12"></a></span>
<span id="cb30-13"><a aria-hidden="true" href="#cb30-13"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; s[i]; ++i) {</span>
<span id="cb30-14"><a aria-hidden="true" href="#cb30-14"></a>        k = (<span class="dv">10</span><span class="bu">ll</span> * k + s[i] - <span class="ch">'0'</span>) % mod;</span>
<span id="cb30-15"><a aria-hidden="true" href="#cb30-15"></a>        k2 = (<span class="dv">10</span><span class="bu">ll</span> * k2 + s[i] - <span class="ch">'0'</span>) % (mod - <span class="dv">1</span>);</span>
<span id="cb30-16"><a aria-hidden="true" href="#cb30-16"></a>        <span class="cf">if</span> (<span class="dv">1</span><span class="bu">ll</span> * k * p &gt; n) {</span>
<span id="cb30-17"><a aria-hidden="true" href="#cb30-17"></a>            FOR(i, <span class="dv">0</span>, n - <span class="dv">1</span>) putchar(<span class="ch">'0'</span>), putchar(<span class="ch">' '</span>);</span>
<span id="cb30-18"><a aria-hidden="true" href="#cb30-18"></a>            <span class="cf">return</span> output(), <span class="dv">0</span>;</span>
<span id="cb30-19"><a aria-hidden="true" href="#cb30-19"></a>        }</span>
<span id="cb30-20"><a aria-hidden="true" href="#cb30-20"></a>    }</span>
<span id="cb30-21"><a aria-hidden="true" href="#cb30-21"></a></span>
<span id="cb30-22"><a aria-hidden="true" href="#cb30-22"></a>    lim = n = n - p * k, initInv();</span>
<span id="cb30-23"><a aria-hidden="true" href="#cb30-23"></a></span>
<span id="cb30-24"><a aria-hidden="true" href="#cb30-24"></a>    <span class="dt">int</span> u = qPow(f[p], MOD - <span class="dv">2</span>), v = qPow(f[p], k2);</span>
<span id="cb30-25"><a aria-hidden="true" href="#cb30-25"></a>    FOR(i, <span class="dv">0</span>, n - <span class="dv">1</span>) f[i] = <span class="dv">1</span><span class="bu">ll</span> * f[i + p] * u % mod;</span>
<span id="cb30-26"><a aria-hidden="true" href="#cb30-26"></a>    clr(&amp;f[<span class="dv">0</span>] + n, p * k);</span>
<span id="cb30-27"><a aria-hidden="true" href="#cb30-27"></a>    f = v * polyExp(k * polyLn(f));</span>
<span id="cb30-28"><a aria-hidden="true" href="#cb30-28"></a>    FOR(i, <span class="dv">0</span>, p * k - <span class="dv">1</span>) putchar(<span class="ch">'0'</span>), putchar(<span class="ch">' '</span>);</span>
<span id="cb30-29"><a aria-hidden="true" href="#cb30-29"></a>    print(f);</span>
<span id="cb30-30"><a aria-hidden="true" href="#cb30-30"></a>    <span class="cf">return</span> output(), <span class="dv">0</span>;</span>
<span id="cb30-31"><a aria-hidden="true" href="#cb30-31"></a>}</span></code></pre></div>
<h3 id="应用-2-ln-的组合意义">应用 2 ln 的组合意义</h3>
<p>看例题：<a href="https://www.luogu.com.cn/problem/P4841">洛谷 P4841 [集训队作业2013]城市规划</a></p>
<p>求 <span class="math inline">\(n\)</span> 个点的有标号无向连通图的个数 <span class="math inline">\(\bmod 1004535809\)</span> 的值。</p>
<p>可以先不考虑标号，最后得到的答案乘以 <span class="math inline">\(n!\)</span> 就可以了。</p>
<p>然后不考虑联通的话，<span class="math inline">\(g_n = 2^{\binom n 2}\)</span>，即考虑每条边选还是不选，设联通的情况的方案数为 <span class="math inline">\(f_n\)</span>。</p>
<p>构造一下联通的 EGF：<span class="math inline">\(F(x) = \displaystyle\sum_{i = 0}^\infty f_i\frac{x^i}{i!}\)</span>，不连通的类似：<span class="math inline">\(G(x) = \displaystyle\sum_{i = 0}^\infty g_i\frac{x^i}{i!}\)</span>。根据 EGF 的性质发现 <span class="math inline">\(G(x) = \mathrm e^{F(x)}\)</span>。</p>
<p>所以求个 <span class="math inline">\(\ln\)</span> 就可以了。</p>
<p>配合封装过的 <span class="math inline">\(\ln\)</span> 是这样的：（upd：下面的代码未更新新的封装，请看准了食用）</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb31-1"><a aria-hidden="true" href="#cb31-1"></a><span class="dt">void</span> polyln(<span class="dt">int</span> *f, <span class="dt">int</span> m)</span>
<span id="cb31-2"><a aria-hidden="true" href="#cb31-2"></a>{</span>
<span id="cb31-3"><a aria-hidden="true" href="#cb31-3"></a>    <span class="at">static</span> <span class="dt">int</span> invf[maxn &lt;&lt; <span class="dv">1</span>];</span>
<span id="cb31-4"><a aria-hidden="true" href="#cb31-4"></a>    <span class="dt">int</span> lim = <span class="dv">1</span>;</span>
<span id="cb31-5"><a aria-hidden="true" href="#cb31-5"></a>    <span class="cf">while</span> (lim &lt; m &lt;&lt; <span class="dv">1</span>) lim &lt;&lt;= <span class="dv">1</span>;</span>
<span id="cb31-6"><a aria-hidden="true" href="#cb31-6"></a>    initinv(lim);</span>
<span id="cb31-7"><a aria-hidden="true" href="#cb31-7"></a>    cpy(invf, f, m);</span>
<span id="cb31-8"><a aria-hidden="true" href="#cb31-8"></a>    invpoly(invf, m);</span>
<span id="cb31-9"><a aria-hidden="true" href="#cb31-9"></a>    derivate(f, m);</span>
<span id="cb31-10"><a aria-hidden="true" href="#cb31-10"></a>    NTT(f, lim, <span class="dv">1</span>), NTT(invf, lim, <span class="dv">1</span>);</span>
<span id="cb31-11"><a aria-hidden="true" href="#cb31-11"></a>    FOR(i, <span class="dv">0</span>, lim - <span class="dv">1</span>)</span>
<span id="cb31-12"><a aria-hidden="true" href="#cb31-12"></a>        f[i] = <span class="dv">1</span><span class="bu">ll</span> * f[i] * invf[i] % mod;</span>
<span id="cb31-13"><a aria-hidden="true" href="#cb31-13"></a>    NTT(f, lim, <span class="dv">0</span>);</span>
<span id="cb31-14"><a aria-hidden="true" href="#cb31-14"></a>    intergrate(f, m);</span>
<span id="cb31-15"><a aria-hidden="true" href="#cb31-15"></a>    clr(invf, lim);</span>
<span id="cb31-16"><a aria-hidden="true" href="#cb31-16"></a>    clr(f + m, lim - m);</span>
<span id="cb31-17"><a aria-hidden="true" href="#cb31-17"></a>}</span>
<span id="cb31-18"><a aria-hidden="true" href="#cb31-18"></a></span>
<span id="cb31-19"><a aria-hidden="true" href="#cb31-19"></a><span class="dt">int</span> f[maxn &lt;&lt; <span class="dv">1</span>], invf[maxn &lt;&lt; <span class="dv">1</span>];</span>
<span id="cb31-20"><a aria-hidden="true" href="#cb31-20"></a><span class="dt">int</span> fact[maxn &lt;&lt; <span class="dv">1</span>];</span>
<span id="cb31-21"><a aria-hidden="true" href="#cb31-21"></a></span>
<span id="cb31-22"><a aria-hidden="true" href="#cb31-22"></a><span class="dt">int</span> n;</span>
<span id="cb31-23"><a aria-hidden="true" href="#cb31-23"></a></span>
<span id="cb31-24"><a aria-hidden="true" href="#cb31-24"></a><span class="dt">int</span> main()</span>
<span id="cb31-25"><a aria-hidden="true" href="#cb31-25"></a>{</span>
<span id="cb31-26"><a aria-hidden="true" href="#cb31-26"></a>    n = readInt();</span>
<span id="cb31-27"><a aria-hidden="true" href="#cb31-27"></a>    fact[<span class="dv">0</span>] = <span class="dv">1</span>, f[<span class="dv">0</span>] = <span class="dv">1</span>;</span>
<span id="cb31-28"><a aria-hidden="true" href="#cb31-28"></a>    FOR(i, <span class="dv">1</span>, n)</span>
<span id="cb31-29"><a aria-hidden="true" href="#cb31-29"></a>        fact[i] = <span class="dv">1</span><span class="bu">ll</span> * fact[i - <span class="dv">1</span>] * i % mod,</span>
<span id="cb31-30"><a aria-hidden="true" href="#cb31-30"></a>        f[i] = <span class="dv">1</span><span class="bu">ll</span> * qpow(<span class="dv">2</span>, <span class="dv">1</span><span class="bu">ll</span> * i * (i - <span class="dv">1</span><span class="bu">ll</span>) &gt;&gt; <span class="dv">1</span>) % mod * qpow(fact[i]) % mod;</span>
<span id="cb31-31"><a aria-hidden="true" href="#cb31-31"></a>    polyln(f, n + <span class="dv">1</span>);</span>
<span id="cb31-32"><a aria-hidden="true" href="#cb31-32"></a>    printf(<span class="st">"</span><span class="sc">%d\n</span><span class="st">"</span>, <span class="dv">1</span><span class="bu">ll</span> * f[n] * fact[n] % mod);</span>
<span id="cb31-33"><a aria-hidden="true" href="#cb31-33"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb31-34"><a aria-hidden="true" href="#cb31-34"></a>}</span></code></pre></div>
<h3 id="应用-3-配合生成函数推式子">应用 3 配合生成函数推式子</h3>
<p>请看 <a href="https://www.luogu.com.cn/problem/P4389">P4389 付公主的背包</a>。</p>
<p>设容量为 <span class="math inline">\(i\)</span> 的物品的个数为 <span class="math inline">\(k_i\)</span> 个，则其生成函数为 <span class="math display">\[
A_i(x) =  \left(\sum_{j = 0}^{+\infty}x^{ji}\right)^{k_i} =\left(\frac{1}{1 - x^i}\right)^{k_i}
\]</span> 所以我们要求的就是 <span class="math display">\[
f(x) = \prod_{i = 1}^n A_i(x)
\]</span> 的每项系数。暴力乘起来是 <span class="math inline">\(O(nm\log n)\)</span> 的，无法通过本题。</p>
<p>我们试一下求个 <span class="math inline">\(\ln\)</span>，则我们有 <span class="math display">\[
\begin{aligned}
f(x) &amp;= \prod_{i = 1}^nA_i(x)\\
\ln f(x) &amp;= \sum_{i = 1}^n\ln A_i(x)\\
\ln f(x) &amp;= \sum_{i = 1}^nk_i(\ln 1 - \ln(1 - x^i))\\
\ln f(x) &amp;= -\sum_{i = 1}^nk_i\ln(1 - x^i)
\end{aligned}
\]</span> 然后我们注意到这个 <span class="math inline">\(\ln\)</span> 的形式，回顾一下上面讲过的一个式子： <span class="math display">\[
\ln(1 - x) = -\sum_{m = 1}^{+\infty}\frac{x^{m}}{m}
\]</span> 所以 <span class="math display">\[
\begin{aligned}
\ln f(x) &amp;= \sum_{i = 1}^nk_i\sum_{j = 1}^{+\infty}\frac{x^{ij}}{j}
\end{aligned}
\]</span> 然后问题就转化为了求 <span class="math display">\[
\exp\left(\sum_{i = 1}^nk_i\sum_{j = 1}^{+\infty}\frac{x^{ij}}{j} \right)
\]</span> 里面的东西可以 <span class="math inline">\(O(m\log m)\)</span> 算，总时间复杂度 <span class="math inline">\(O(m\log m)\)</span>。</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb32-1"><a aria-hidden="true" href="#cb32-1"></a><span class="dt">int</span> n, m, cnt[maxn];</span>
<span id="cb32-2"><a aria-hidden="true" href="#cb32-2"></a>Poly f;</span>
<span id="cb32-3"><a aria-hidden="true" href="#cb32-3"></a></span>
<span id="cb32-4"><a aria-hidden="true" href="#cb32-4"></a><span class="dt">int</span> main() {</span>
<span id="cb32-5"><a aria-hidden="true" href="#cb32-5"></a>    read(n), read(m);</span>
<span id="cb32-6"><a aria-hidden="true" href="#cb32-6"></a>    f.resize(lim = m + <span class="dv">1</span>);</span>
<span id="cb32-7"><a aria-hidden="true" href="#cb32-7"></a>    initInv();</span>
<span id="cb32-8"><a aria-hidden="true" href="#cb32-8"></a>    FOR(i, <span class="dv">1</span>, n) {</span>
<span id="cb32-9"><a aria-hidden="true" href="#cb32-9"></a>        <span class="dt">int</span> tmp; read(tmp);</span>
<span id="cb32-10"><a aria-hidden="true" href="#cb32-10"></a>        ++cnt[tmp];</span>
<span id="cb32-11"><a aria-hidden="true" href="#cb32-11"></a>    }</span>
<span id="cb32-12"><a aria-hidden="true" href="#cb32-12"></a>    FOR(i, <span class="dv">1</span>, m) {</span>
<span id="cb32-13"><a aria-hidden="true" href="#cb32-13"></a>        <span class="cf">if</span> (cnt[i]) {</span>
<span id="cb32-14"><a aria-hidden="true" href="#cb32-14"></a>            <span class="cf">for</span> (<span class="dt">int</span> j = i; j &lt;= m; j += i) {</span>
<span id="cb32-15"><a aria-hidden="true" href="#cb32-15"></a>                f[j] += <span class="dv">1</span><span class="bu">ll</span> * cnt[i] * inv[j / i] % mod;</span>
<span id="cb32-16"><a aria-hidden="true" href="#cb32-16"></a>                <span class="cf">if</span> (f[j] &gt; mod) f[j] -= mod;</span>
<span id="cb32-17"><a aria-hidden="true" href="#cb32-17"></a>            }</span>
<span id="cb32-18"><a aria-hidden="true" href="#cb32-18"></a>        }</span>
<span id="cb32-19"><a aria-hidden="true" href="#cb32-19"></a>    }</span>
<span id="cb32-20"><a aria-hidden="true" href="#cb32-20"></a>    f = polyExp(f);</span>
<span id="cb32-21"><a aria-hidden="true" href="#cb32-21"></a>    FOR(i, <span class="dv">1</span>, m) print(f[i]), putchar(<span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span>);</span>
<span id="cb32-22"><a aria-hidden="true" href="#cb32-22"></a>    <span class="cf">return</span> output(), <span class="dv">0</span>;</span>
<span id="cb32-23"><a aria-hidden="true" href="#cb32-23"></a>}</span></code></pre></div>
<h2 id="多项式带余除法">多项式带余除法</h2>
<h3 id="问题描述-4">问题描述</h3>
<p>给定多项式 <span class="math inline">\(f(x)\)</span> 和 <span class="math inline">\(g(x)\)</span>。求 <span class="math inline">\(f(x)\)</span> 除以 <span class="math inline">\(g(x)\)</span> 的商 <span class="math inline">\(Q(x)\)</span> 和余数 <span class="math inline">\(R(x)\)</span>。</p>
<p>若令 <span class="math inline">\(n = \deg f\)</span>，<span class="math inline">\(m = \deg g\)</span>，则要求满足 <span class="math inline">\(\deg Q = n - m\)</span>，<span class="math inline">\(\deg R &lt; m\)</span>。</p>
<h3 id="问题求解">问题求解</h3>
<p>最关键的问题就是 <span class="math inline">\(R(x)\)</span>，如果我们能把 <span class="math inline">\(R(x)\)</span> 的影响消去，那么就可以直接求逆来求出 <span class="math inline">\(Q(x)\)</span>。</p>
<p>令 <span class="math inline">\(n = \deg f\)</span>，<span class="math inline">\(m = \deg g\)</span>。主要思想是构造 <span class="math display">\[
f^R(x) = x^nf\left(\frac1x\right)
\]</span> 然后不难发现这个东西的实质就是反转 <span class="math inline">\(f(x)\)</span> 的系数。</p>
<p>将 <span class="math inline">\(f(x) = Q(x)g(x) + R(x)\)</span> 中的 <span class="math inline">\(x\)</span> 换成 <span class="math inline">\(\dfrac 1x\)</span> 进行化简： <span class="math display">\[
\begin{aligned}f\left(\frac1x\right) &amp;= Q\left(\frac1x\right)g\left(\frac1x\right) + R\left(\frac1x\right)\\x^nf\left(\frac1x\right) &amp;= x^{n - m}Q\left(\frac1x\right)x^mg\left(\frac1x\right) + x^{n - m + 1}x^{m - 1}R\left(\frac1x\right)\\f^R(x)&amp;=Q^R(x)g^R(x) + x^{n - m + 1}R^R(x)\\f^R(x)&amp;\equiv Q^R(x)g^R(x)\pmod{x^{n - m + 1}}\end{aligned}
\]</span> 所以我们可以用求逆求出 <span class="math inline">\(Q(x)\)</span>，然后回代就可以求出 <span class="math inline">\(R(x)\)</span> 了。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<h3 id="实现-4">实现</h3>
<div class="sourceCode" id="cb33"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb33-1"><a aria-hidden="true" href="#cb33-1"></a><span class="dt">void</span> polyDiv(<span class="at">const</span> Poly &amp;A, <span class="at">const</span> Poly &amp;B, Poly &amp;Q, Poly &amp;R) {</span>
<span id="cb33-2"><a aria-hidden="true" href="#cb33-2"></a>    Poly rA = A, rB = B;</span>
<span id="cb33-3"><a aria-hidden="true" href="#cb33-3"></a>    reverse(rA), reverse(rB);</span>
<span id="cb33-4"><a aria-hidden="true" href="#cb33-4"></a>    <span class="dt">int</span> n = A.size(), m = B.size();</span>
<span id="cb33-5"><a aria-hidden="true" href="#cb33-5"></a>    rA.resize(n - m + <span class="dv">1</span>), rB.resize(n - m + <span class="dv">1</span>);</span>
<span id="cb33-6"><a aria-hidden="true" href="#cb33-6"></a>    Q = rA * polyInv(rB), Q.resize(n - m + <span class="dv">1</span>), reverse(Q);</span>
<span id="cb33-7"><a aria-hidden="true" href="#cb33-7"></a>    R = A - B * Q, R.resize(m - <span class="dv">1</span>);</span>
<span id="cb33-8"><a aria-hidden="true" href="#cb33-8"></a>    <span class="cf">return</span>;</span>
<span id="cb33-9"><a aria-hidden="true" href="#cb33-9"></a>}</span></code></pre></div>
<p>主函数调用：</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb34-1"><a aria-hidden="true" href="#cb34-1"></a><span class="dt">int</span> n, m;</span>
<span id="cb34-2"><a aria-hidden="true" href="#cb34-2"></a>Poly f, g, R, Q;</span>
<span id="cb34-3"><a aria-hidden="true" href="#cb34-3"></a></span>
<span id="cb34-4"><a aria-hidden="true" href="#cb34-4"></a><span class="dt">int</span> main() {</span>
<span id="cb34-5"><a aria-hidden="true" href="#cb34-5"></a>    read(n), read(m);</span>
<span id="cb34-6"><a aria-hidden="true" href="#cb34-6"></a>    f.resize(++n), g.resize(++m);</span>
<span id="cb34-7"><a aria-hidden="true" href="#cb34-7"></a>    lim = n;</span>
<span id="cb34-8"><a aria-hidden="true" href="#cb34-8"></a>    FOR(i, <span class="dv">0</span>, n - <span class="dv">1</span>) read(f[i]);</span>
<span id="cb34-9"><a aria-hidden="true" href="#cb34-9"></a>    FOR(i, <span class="dv">0</span>, m - <span class="dv">1</span>) read(g[i]);</span>
<span id="cb34-10"><a aria-hidden="true" href="#cb34-10"></a>    polyDiv(f, g, Q, R);</span>
<span id="cb34-11"><a aria-hidden="true" href="#cb34-11"></a>    print(Q);</span>
<span id="cb34-12"><a aria-hidden="true" href="#cb34-12"></a>    print(R);</span>
<span id="cb34-13"><a aria-hidden="true" href="#cb34-13"></a>    <span class="cf">return</span> output(), <span class="dv">0</span>;</span>
<span id="cb34-14"><a aria-hidden="true" href="#cb34-14"></a>}</span></code></pre></div>
<h2 id="多项式三角函数反三角函数">多项式三角函数/反三角函数</h2>
<p>感觉这东西没什么用。。。</p>
<h3 id="多项式三角函数">多项式三角函数</h3>
<h4 id="问题描述-5">问题描述</h4>
<p>给定多项式 <span class="math inline">\(f(x)\)</span>，求模 <span class="math inline">\(998244353\)</span> 意义下的 <span class="math inline">\(\sin f(x)\)</span> 和 <span class="math inline">\(\cos f(x)\)</span>。</p>
<h4 id="式子推导">式子推导</h4>
<p>欧拉公式： <span class="math display">\[
e^{i\theta} = \cos \theta + i\sin\theta
\]</span> 用诱导公式日一通之后可以得到 <span class="math display">\[
e^{i(-\theta)} = \cos\theta - i\sin\theta
\]</span> 由上面两个式子就可以得到 <span class="math display">\[
\begin{aligned}
\sin\theta &amp;= \frac{e^{i\theta} - e^{-i\theta}}{2i}\\
\cos\theta &amp;= \frac{e^{i\theta} + e^{-i\theta}}{2}
\end{aligned}
\]</span> 把 <span class="math inline">\(f(x)\)</span> 带进去： <span class="math display">\[
\begin{aligned}
\sin f(x) &amp;= \frac{\exp(if(x)) - \exp(-if(x))}{2i}\\
\cos f(x) &amp;= \frac{\exp(if(x)) + \exp(-if(x))}{2}
\end{aligned}
\]</span> 现在看来似乎直接 <span class="math inline">\(\exp\)</span> 就可以做完了，然而 <span class="math inline">\(i\)</span> 是什么东西呢？</p>
<p>回顾一下在复数域下，我们有 <span class="math inline">\(i^2 = -1\)</span>。放在 <span class="math inline">\(\mathbb Z_{998244353}\)</span> 下不就是 <span class="math inline">\(i^2\equiv 998244352\pmod{998244353}\)</span>。取 <span class="math inline">\(998244352\)</span> 的一个二次剩余 <span class="math inline">\(86583718\)</span> 即可。</p>
<h4 id="实现-5">实现</h4>
<p>注意一下我们能尽量少求 <span class="math inline">\(\exp\)</span> 就少求 <span class="math inline">\(\exp\)</span>（有 <span class="math inline">\(\exp(-if(x)) = (\exp(if(x)))^{-1}\)</span>），可以很大程度地优化常数</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb35-1"><a aria-hidden="true" href="#cb35-1"></a>Poly polySin(<span class="at">const</span> Poly &amp;A) {</span>
<span id="cb35-2"><a aria-hidden="true" href="#cb35-2"></a>    Poly tmp = polyExp(imgunit * A);</span>
<span id="cb35-3"><a aria-hidden="true" href="#cb35-3"></a>    <span class="cf">return</span> qPow(<span class="dv">1</span><span class="bu">ll</span> * <span class="dv">2</span> * imgunit % mod) * (tmp - polyInv(tmp));</span>
<span id="cb35-4"><a aria-hidden="true" href="#cb35-4"></a>}</span>
<span id="cb35-5"><a aria-hidden="true" href="#cb35-5"></a></span>
<span id="cb35-6"><a aria-hidden="true" href="#cb35-6"></a>Poly polyCos(<span class="at">const</span> Poly &amp;A) {</span>
<span id="cb35-7"><a aria-hidden="true" href="#cb35-7"></a>    Poly tmp = polyExp(imgunit * A);</span>
<span id="cb35-8"><a aria-hidden="true" href="#cb35-8"></a>    <span class="cf">return</span> qPow(<span class="dv">2</span>) * (tmp + polyInv(tmp));</span>
<span id="cb35-9"><a aria-hidden="true" href="#cb35-9"></a>}</span></code></pre></div>
<p>超级短。。。</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb36-1"><a aria-hidden="true" href="#cb36-1"></a><span class="dt">int</span> n, type;</span>
<span id="cb36-2"><a aria-hidden="true" href="#cb36-2"></a>Poly f;</span>
<span id="cb36-3"><a aria-hidden="true" href="#cb36-3"></a></span>
<span id="cb36-4"><a aria-hidden="true" href="#cb36-4"></a><span class="dt">int</span> main() {</span>
<span id="cb36-5"><a aria-hidden="true" href="#cb36-5"></a>    read(n), read(type);</span>
<span id="cb36-6"><a aria-hidden="true" href="#cb36-6"></a>    f.resize(lim = n), initInv();</span>
<span id="cb36-7"><a aria-hidden="true" href="#cb36-7"></a>    FOR(i, <span class="dv">0</span>, n - <span class="dv">1</span>) read(f[i]);</span>
<span id="cb36-8"><a aria-hidden="true" href="#cb36-8"></a>    print(type ? polyCos(f) : polySin(f));</span>
<span id="cb36-9"><a aria-hidden="true" href="#cb36-9"></a>    <span class="cf">return</span> output(), <span class="dv">0</span>;</span>
<span id="cb36-10"><a aria-hidden="true" href="#cb36-10"></a>}</span></code></pre></div>
<h3 id="多项式反三角函数">多项式反三角函数</h3>
<h4 id="问题描述-6">问题描述</h4>
<p>给定 <span class="math inline">\(f(x)\)</span>，求模 <span class="math inline">\(998244353\)</span> 意义下的 <span class="math inline">\(\arcsin f(x)\)</span>，<span class="math inline">\(\arccos f(x)\)</span> 和 <span class="math inline">\(\arctan f(x)\)</span>。</p>
<h4 id="式子推导-1">式子推导</h4>
<p>首先需要知道 <span class="math display">\[
\begin{aligned}
\arcsin'x &amp;= \frac{1}{\sqrt{1 - x^2}}\\
\arccos'x &amp;= -\frac{1}{\sqrt{1 - x^2}}\\
\arctan'x &amp;= \frac{1}{1 + x^2}
\end{aligned}
\]</span> 然后类似 <span class="math inline">\(\ln\)</span>，先求求导后积分我们就可以得到： <span class="math display">\[
\begin{aligned}
\arcsin f(x) &amp;= \int\frac{f'(x)}{\sqrt{1 - f^2(x)}}\\
\arccos f(x) &amp;= -\int\frac{f'(x)}{\sqrt{1 - f^2(x)}}\\
\arctan f(x) &amp;= \int\frac{f'(x)}{1 + f^2(x)}
\end{aligned}
\]</span></p>
<h4 id="实现-6">实现</h4>
<div class="sourceCode" id="cb37"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb37-1"><a aria-hidden="true" href="#cb37-1"></a>Poly polyAsin(<span class="at">const</span> Poly &amp;A) {</span>
<span id="cb37-2"><a aria-hidden="true" href="#cb37-2"></a>    Poly one; one.push_back(<span class="dv">1</span>);</span>
<span id="cb37-3"><a aria-hidden="true" href="#cb37-3"></a>    <span class="cf">return</span> ints(deri(A) * polyInv(polySqrt(one - A * A)));</span>
<span id="cb37-4"><a aria-hidden="true" href="#cb37-4"></a>}</span>
<span id="cb37-5"><a aria-hidden="true" href="#cb37-5"></a></span>
<span id="cb37-6"><a aria-hidden="true" href="#cb37-6"></a>Poly polyAtan(<span class="at">const</span> Poly &amp;A) {</span>
<span id="cb37-7"><a aria-hidden="true" href="#cb37-7"></a>    Poly one; one.push_back(<span class="dv">1</span>);</span>
<span id="cb37-8"><a aria-hidden="true" href="#cb37-8"></a>    <span class="cf">return</span> ints(deri(A) * polyInv(one + A * A));</span>
<span id="cb37-9"><a aria-hidden="true" href="#cb37-9"></a>}</span></code></pre></div>
<p><code>vector</code> 封装的优势得到体现。</p>
<h2 id="拉格朗日插值">拉格朗日插值</h2>
<h3 id="问题背景">问题背景</h3>
<p>给出 <span class="math inline">\(n\)</span> 个点 <span class="math inline">\((x_i,y_i)\)</span>，令这 <span class="math inline">\(n\)</span> 个点确定的多项式为 <span class="math inline">\(L(x)\)</span>，求 <span class="math inline">\(L(x)\)</span> 的系数表示。</p>
<h3 id="结论">结论</h3>
<p><span class="math display">\[
L(x) = \sum_{i=1}^n y_il_i(x)
\]</span></p>
<p>其中每个 <span class="math inline">\(l_i(x)\)</span> 为拉格朗日基本多项式，表达式为</p>
<p><span class="math display">\[
l_i(x) = \prod_{j=1,j\ne i}^n\frac{x-x_j}{x_i-x_j}
\]</span></p>
<p>其特点是 <span class="math inline">\(l_i(x_i)=1\)</span>，<span class="math inline">\(\forall j\ne i\)</span> 有 <span class="math inline">\(l_i(x_j)=0\)</span>。</p>
<h3 id="推导">推导</h3>
<p>抛开拉插，这道题明显可以列方程组然后使用高斯消元求解，但是复杂度为 <span class="math inline">\(O(n^3)\)</span> 且精度问题明显，所以拉格朗日是这样考虑的：</p>
<p>对于每个点 <span class="math inline">\(P_i(x_i,y_i)\)</span>，构造一个 <span class="math inline">\(n-1\)</span> 次多项式 <span class="math inline">\(l_i(x)\)</span> 使其在 <span class="math inline">\(x_i\)</span> 上取值为 <span class="math inline">\(1\)</span>，在其余 <span class="math inline">\(x_j\)</span> 上为 <span class="math inline">\(0\)</span>。构造的结果就是上面的结论：</p>
<p><span class="math display">\[
l_i(x) = \prod_{j=1,j\ne i}^n\frac{x-x_j}{x_i-x_j}
\]</span></p>
<p>不加证明地，上面这个多项式是正确且唯一的。</p>
<p>然后考虑构造答案：很显然对于点 <span class="math inline">\(P_i(x_i,y_i)\)</span>，只有 <span class="math inline">\(l_i(x_i)\)</span> 的取值为 <span class="math inline">\(1\)</span>，其他的都为 <span class="math inline">\(0\)</span>。所以答案的正确性也是比较显然的：对于 <span class="math inline">\(x_i\)</span>，只有 <span class="math inline">\(y_il_i(x_i)\)</span> 产生了贡献，其余的都是 <span class="math inline">\(0\)</span>。故这个多项式是正确的。</p>
<p>所以回到一开始，若我们需要求 <span class="math inline">\(f(k)\)</span> 的值，则我们需要的就是</p>
<p><span class="math display">\[
f(k) = \sum_{i=1}^n y_i\prod_{j=1,j\ne i}^n\frac{k-x_j}{x_i-x_j}
\]</span></p>
<p>由于模数是质数，所以使用费马小定理求逆元，跑得飞快。</p>
<p>复杂度 <span class="math inline">\(O(n^2)\)</span>，求逆元就是个很小的常数</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb38-1"><a aria-hidden="true" href="#cb38-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb38-2"><a aria-hidden="true" href="#cb38-2"></a><span class="pp">#include </span><span class="im">&lt;cctype&gt;</span></span>
<span id="cb38-3"><a aria-hidden="true" href="#cb38-3"></a><span class="pp">#define il </span><span class="kw">inline</span></span>
<span id="cb38-4"><a aria-hidden="true" href="#cb38-4"></a></span>
<span id="cb38-5"><a aria-hidden="true" href="#cb38-5"></a><span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> ll;</span>
<span id="cb38-6"><a aria-hidden="true" href="#cb38-6"></a></span>
<span id="cb38-7"><a aria-hidden="true" href="#cb38-7"></a><span class="kw">inline</span> ll read()</span>
<span id="cb38-8"><a aria-hidden="true" href="#cb38-8"></a>{</span>
<span id="cb38-9"><a aria-hidden="true" href="#cb38-9"></a>    <span class="dt">char</span> c = getchar();</span>
<span id="cb38-10"><a aria-hidden="true" href="#cb38-10"></a>    ll s = <span class="dv">0</span>;</span>
<span id="cb38-11"><a aria-hidden="true" href="#cb38-11"></a>    <span class="dt">bool</span> x = <span class="dv">0</span>;</span>
<span id="cb38-12"><a aria-hidden="true" href="#cb38-12"></a>    <span class="cf">while</span> (!isdigit(c))</span>
<span id="cb38-13"><a aria-hidden="true" href="#cb38-13"></a>        x = x | (c == <span class="ch">'-'</span>), c = getchar();</span>
<span id="cb38-14"><a aria-hidden="true" href="#cb38-14"></a>    <span class="cf">while</span> (isdigit(c))</span>
<span id="cb38-15"><a aria-hidden="true" href="#cb38-15"></a>        s = <span class="dv">10</span> * s + c - <span class="ch">'0'</span>, c = getchar();</span>
<span id="cb38-16"><a aria-hidden="true" href="#cb38-16"></a>    <span class="cf">return</span> x ? -s : s;</span>
<span id="cb38-17"><a aria-hidden="true" href="#cb38-17"></a>}</span>
<span id="cb38-18"><a aria-hidden="true" href="#cb38-18"></a></span>
<span id="cb38-19"><a aria-hidden="true" href="#cb38-19"></a><span class="at">const</span> ll maxn = <span class="fl">2e3</span> + <span class="dv">5</span>, mod = <span class="dv">998244353</span>;</span>
<span id="cb38-20"><a aria-hidden="true" href="#cb38-20"></a>ll x[maxn], y[maxn];</span>
<span id="cb38-21"><a aria-hidden="true" href="#cb38-21"></a></span>
<span id="cb38-22"><a aria-hidden="true" href="#cb38-22"></a>ll pow(ll base, ll p)</span>
<span id="cb38-23"><a aria-hidden="true" href="#cb38-23"></a>{</span>
<span id="cb38-24"><a aria-hidden="true" href="#cb38-24"></a>    ll ans = <span class="dv">1</span>;</span>
<span id="cb38-25"><a aria-hidden="true" href="#cb38-25"></a>    base = (base + mod) % mod;</span>
<span id="cb38-26"><a aria-hidden="true" href="#cb38-26"></a>    <span class="cf">for</span> (; p; p &gt;&gt;= <span class="dv">1</span>)</span>
<span id="cb38-27"><a aria-hidden="true" href="#cb38-27"></a>    {</span>
<span id="cb38-28"><a aria-hidden="true" href="#cb38-28"></a>        <span class="cf">if</span> (p &amp; <span class="dv">1</span>)</span>
<span id="cb38-29"><a aria-hidden="true" href="#cb38-29"></a>            ans = ans * base % mod;</span>
<span id="cb38-30"><a aria-hidden="true" href="#cb38-30"></a>        base = base * base % mod;</span>
<span id="cb38-31"><a aria-hidden="true" href="#cb38-31"></a>    }</span>
<span id="cb38-32"><a aria-hidden="true" href="#cb38-32"></a>    <span class="cf">return</span> ans;</span>
<span id="cb38-33"><a aria-hidden="true" href="#cb38-33"></a>}</span>
<span id="cb38-34"><a aria-hidden="true" href="#cb38-34"></a></span>
<span id="cb38-35"><a aria-hidden="true" href="#cb38-35"></a>il ll inv(ll n)</span>
<span id="cb38-36"><a aria-hidden="true" href="#cb38-36"></a>{</span>
<span id="cb38-37"><a aria-hidden="true" href="#cb38-37"></a>    <span class="cf">return</span> pow(n, mod - <span class="dv">2</span>);</span>
<span id="cb38-38"><a aria-hidden="true" href="#cb38-38"></a>}</span>
<span id="cb38-39"><a aria-hidden="true" href="#cb38-39"></a></span>
<span id="cb38-40"><a aria-hidden="true" href="#cb38-40"></a><span class="dt">int</span> main()</span>
<span id="cb38-41"><a aria-hidden="true" href="#cb38-41"></a>{</span>
<span id="cb38-42"><a aria-hidden="true" href="#cb38-42"></a>    ll n = read(), k = read();</span>
<span id="cb38-43"><a aria-hidden="true" href="#cb38-43"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">1</span> ; i &lt;= n; ++i)</span>
<span id="cb38-44"><a aria-hidden="true" href="#cb38-44"></a>        x[i] = read(), y[i] = read();</span>
<span id="cb38-45"><a aria-hidden="true" href="#cb38-45"></a>    ll ans = <span class="dv">0</span>;</span>
<span id="cb38-46"><a aria-hidden="true" href="#cb38-46"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; ++i)</span>
<span id="cb38-47"><a aria-hidden="true" href="#cb38-47"></a>    {</span>
<span id="cb38-48"><a aria-hidden="true" href="#cb38-48"></a>        ll prod1 = <span class="dv">1</span>, prod2 = <span class="dv">1</span>;</span>
<span id="cb38-49"><a aria-hidden="true" href="#cb38-49"></a>        <span class="cf">for</span> (<span class="dt">int</span> j = <span class="dv">1</span>; j &lt;= n; ++j)</span>
<span id="cb38-50"><a aria-hidden="true" href="#cb38-50"></a>        {</span>
<span id="cb38-51"><a aria-hidden="true" href="#cb38-51"></a>            <span class="cf">if</span> (i == j)</span>
<span id="cb38-52"><a aria-hidden="true" href="#cb38-52"></a>                <span class="cf">continue</span>;</span>
<span id="cb38-53"><a aria-hidden="true" href="#cb38-53"></a>            prod1 = prod1 * (k - x[j]) % mod;</span>
<span id="cb38-54"><a aria-hidden="true" href="#cb38-54"></a>            prod2 = prod2 * (x[i] - x[j]) % mod;</span>
<span id="cb38-55"><a aria-hidden="true" href="#cb38-55"></a>        }</span>
<span id="cb38-56"><a aria-hidden="true" href="#cb38-56"></a>        ans = (ans + prod1 * y[i] % mod * inv(prod2) % mod + mod) % mod;</span>
<span id="cb38-57"><a aria-hidden="true" href="#cb38-57"></a>    }</span>
<span id="cb38-58"><a aria-hidden="true" href="#cb38-58"></a>    printf(<span class="st">"</span><span class="sc">%lld\n</span><span class="st">"</span>, ans);</span>
<span id="cb38-59"><a aria-hidden="true" href="#cb38-59"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb38-60"><a aria-hidden="true" href="#cb38-60"></a>}</span></code></pre></div>
<h3 id="重心型拉格朗日插值法">重心型拉格朗日插值法</h3>
<p>上面的做法在需要动态加点/删点的情况下是有弊端的，因为一次加点就需要 <span class="math inline">\(O(n^2)\)</span> 重新计算，这样肯定是不优秀的。</p>
<p>继续推导式子。 <span class="math display">\[
\begin{aligned}f(k) &amp;= \sum_{i = 1}^nf(x_i)\prod_{j\not=i}\frac{k - x_j}{x_i - x_j}\\&amp;=\sum_{i = 1}^nf(x_i)\frac{\prod_{j = 1}^n(k - x_j)}{(k - x_i)\prod_{j \not= i}(x_i - x_j)}\\&amp;=\prod_{i = 1}^n(k - x_i)\sum_{i = 1}^nf(x_i)\frac{1}{(k - x_i)\prod_{j \not= i}(x_i - x_j)}\end{aligned}
\]</span> 设 <span class="math inline">\(w_i = \dfrac{f(x_i)}{\prod_{j\not=i}(x_i - x_j)}\)</span>，<span class="math inline">\(g = \displaystyle\prod_{i = 1}^n(k - x_i)\)</span>，则 <span class="math display">\[
f(k) = g\sum_{i = 1}^n\frac{w_i}{k - x_i}
\]</span> 这个 <span class="math inline">\(w_i\)</span> 称为重心权。每次加点更新的话其复杂度为 <span class="math inline">\(O(n\log n)\)</span>（更新 <span class="math inline">\(O(n)\)</span> 个 <span class="math inline">\(w_i\)</span>，求逆 <span class="math inline">\(O(\log n)\)</span>）。这样做就可以快速加点删点。</p>
<p>模板题：<a href="https://loj.ac/p/165">LOJ#165. 拉格朗日插值</a></p>
<p>本题需要特判 <span class="math inline">\(k = x_i\)</span> 的情况。</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb39-1"><a aria-hidden="true" href="#cb39-1"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="dv">3005</span>;</span>
<span id="cb39-2"><a aria-hidden="true" href="#cb39-2"></a>modint g = <span class="dv">1</span>, w[maxn], x[maxn], y[maxn];</span>
<span id="cb39-3"><a aria-hidden="true" href="#cb39-3"></a><span class="dt">int</span> cnt;</span>
<span id="cb39-4"><a aria-hidden="true" href="#cb39-4"></a></span>
<span id="cb39-5"><a aria-hidden="true" href="#cb39-5"></a><span class="dt">void</span> ins(<span class="dt">int</span> cnt) {</span>
<span id="cb39-6"><a aria-hidden="true" href="#cb39-6"></a>    w[cnt] = y[cnt];</span>
<span id="cb39-7"><a aria-hidden="true" href="#cb39-7"></a>    FOR(i, <span class="dv">1</span>, cnt - <span class="dv">1</span>) w[i] *= qPow(x[i] - x[cnt], mod - <span class="dv">2</span>), w[cnt] *= qPow(x[cnt] - x[i], mod - <span class="dv">2</span>);</span>
<span id="cb39-8"><a aria-hidden="true" href="#cb39-8"></a>    <span class="cf">return</span>;</span>
<span id="cb39-9"><a aria-hidden="true" href="#cb39-9"></a>}</span>
<span id="cb39-10"><a aria-hidden="true" href="#cb39-10"></a></span>
<span id="cb39-11"><a aria-hidden="true" href="#cb39-11"></a>modint calc(modint k) {</span>
<span id="cb39-12"><a aria-hidden="true" href="#cb39-12"></a>    FOR(i, <span class="dv">1</span>, cnt) <span class="cf">if</span> (k == x[i]) <span class="cf">return</span> y[i];</span>
<span id="cb39-13"><a aria-hidden="true" href="#cb39-13"></a>    modint g = <span class="dv">1</span>;</span>
<span id="cb39-14"><a aria-hidden="true" href="#cb39-14"></a>    FOR(i, <span class="dv">1</span>, cnt) g *= (k - x[i]);</span>
<span id="cb39-15"><a aria-hidden="true" href="#cb39-15"></a>    modint ret = <span class="dv">0</span>;</span>
<span id="cb39-16"><a aria-hidden="true" href="#cb39-16"></a>    FOR(i, <span class="dv">1</span>, cnt) ret += w[i] * qPow(k - x[i], mod - <span class="dv">2</span>);</span>
<span id="cb39-17"><a aria-hidden="true" href="#cb39-17"></a>    <span class="cf">return</span> ret * g;</span>
<span id="cb39-18"><a aria-hidden="true" href="#cb39-18"></a>}</span>
<span id="cb39-19"><a aria-hidden="true" href="#cb39-19"></a></span>
<span id="cb39-20"><a aria-hidden="true" href="#cb39-20"></a><span class="dt">int</span> main() {</span>
<span id="cb39-21"><a aria-hidden="true" href="#cb39-21"></a>    <span class="dt">int</span> n; read(n);</span>
<span id="cb39-22"><a aria-hidden="true" href="#cb39-22"></a>    <span class="cf">while</span> (n--) {</span>
<span id="cb39-23"><a aria-hidden="true" href="#cb39-23"></a>        <span class="dt">int</span> op;</span>
<span id="cb39-24"><a aria-hidden="true" href="#cb39-24"></a>        read(op);</span>
<span id="cb39-25"><a aria-hidden="true" href="#cb39-25"></a>        <span class="cf">if</span> (op == <span class="dv">1</span>) {</span>
<span id="cb39-26"><a aria-hidden="true" href="#cb39-26"></a>            read(x[++cnt]), read(y[cnt]);</span>
<span id="cb39-27"><a aria-hidden="true" href="#cb39-27"></a>            ins(cnt);</span>
<span id="cb39-28"><a aria-hidden="true" href="#cb39-28"></a>        } <span class="cf">else</span> {</span>
<span id="cb39-29"><a aria-hidden="true" href="#cb39-29"></a>            <span class="dt">int</span> x; read(x);</span>
<span id="cb39-30"><a aria-hidden="true" href="#cb39-30"></a>            print(calc(x));</span>
<span id="cb39-31"><a aria-hidden="true" href="#cb39-31"></a>            putchar(<span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span>);</span>
<span id="cb39-32"><a aria-hidden="true" href="#cb39-32"></a>        }</span>
<span id="cb39-33"><a aria-hidden="true" href="#cb39-33"></a>    }</span>
<span id="cb39-34"><a aria-hidden="true" href="#cb39-34"></a>    <span class="cf">return</span> output(), <span class="dv">0</span>;</span>
<span id="cb39-35"><a aria-hidden="true" href="#cb39-35"></a>}</span></code></pre></div>
<h3 id="正整数的-k-次方之和">正整数的 <span class="math inline">\(k\)</span> 次方之和</h3>
<h4 id="问题描述-7">问题描述</h4>
<p><a href="https://www.luogu.com.cn/problem/CF622F">CF622F</a></p>
<p>题意：给定 <span class="math inline">\(n,k\)</span>（<span class="math inline">\(1\le n\le 10^9,0\le k\le 10^6\)</span>），求 <span class="math display">\[
\sum_{i = 1}^ni^k = 1^k + 2^k + 3^k +\cdots + n^k
\]</span> 模 <span class="math inline">\(10^9 + 7\)</span> 的值。</p>
<h4 id="题解">题解</h4>
<p>下面的证明会讲到，这个东西可以看作以 <span class="math inline">\(n\)</span> 为变量的 <span class="math inline">\(k + 1\)</span> 次多项式。</p>
<p>而我们很容易就可以在 <span class="math inline">\(O(k\log k)\)</span> 的时间内求出求出 <span class="math inline">\(f(1),f(2),\cdots,f(k+ 1)\)</span>，我们需要求的是 <span class="math inline">\(f(n)\)</span>，故考虑拉格朗日插值，得出如下公式 <span class="math display">\[
f(n) = \sum_{i = 1}^{k + 2}f(i)\prod_{j\neq i}\frac{n - j}{i - j}
\]</span> 如果朴素地做的话，复杂度显然是 <span class="math inline">\(O(k^2)\)</span> 的，但是注意到我们用于取点值的数都是连续的，所以 <span class="math inline">\(\prod\)</span> 这一堆是可以 <span class="math inline">\(O(n)\)</span> 预处理然后 <span class="math inline">\(O(1)\)</span> 求的。怎么预处理呢？我们考虑把他打开看看规律 <span class="math display">\[
\begin{aligned}
\prod_{j = 1,j\neq i}^{k + 2}\frac{n - j}{i - j} &amp;= \frac{(n - 1)(n - 2)\cdots(n - j + 1)(n - j - 1)\cdots(n - k - 1)(n - k - 2)}{(i - 1)(i - 2)\cdots(i - j + 1)(i - j - 1)\cdots(i - k - 2)}\\
&amp;=\frac{\prod_{j = 1}^{i - 1}(n - j)\times\prod_{j = i + 1}^{k + 2}(n - j)}{(-1)^{k -i}\times i!\times (k + 2 - i)!}
\end{aligned}
\]</span> 所以维护一下 <span class="math inline">\((n - j)\)</span> 的前/后缀积和 <span class="math inline">\([1, k + 1]\)</span> 的阶乘逆元，这道题就可以在 <span class="math inline">\(O(k\log k)\)</span> 的时间内做出来了。</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb40-1"><a aria-hidden="true" href="#cb40-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb40-2"><a aria-hidden="true" href="#cb40-2"></a><span class="pp">#define FOR</span>(i,<span class="pp"> </span>a,<span class="pp"> </span>b)<span class="pp"> </span><span class="cf">for</span><span class="pp"> </span>(<span class="dt">int</span><span class="pp"> </span>i<span class="pp"> </span>=<span class="pp"> </span>a;<span class="pp"> </span>i<span class="pp"> </span>&lt;=<span class="pp"> </span>b;<span class="pp"> </span>++i)</span>
<span id="cb40-3"><a aria-hidden="true" href="#cb40-3"></a><span class="pp">#define DEC</span>(i,<span class="pp"> </span>a,<span class="pp"> </span>b)<span class="pp"> </span><span class="cf">for</span><span class="pp"> </span>(<span class="dt">int</span><span class="pp"> </span>i<span class="pp"> </span>=<span class="pp"> </span>a;<span class="pp"> </span>i<span class="pp"> </span>&gt;=<span class="pp"> </span>b;<span class="pp"> </span>--i)</span>
<span id="cb40-4"><a aria-hidden="true" href="#cb40-4"></a></span>
<span id="cb40-5"><a aria-hidden="true" href="#cb40-5"></a><span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> ll;</span>
<span id="cb40-6"><a aria-hidden="true" href="#cb40-6"></a><span class="at">const</span> ll mod = <span class="fl">1e9</span> + <span class="dv">7</span>;</span>
<span id="cb40-7"><a aria-hidden="true" href="#cb40-7"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">1e6</span> + <span class="dv">5</span>;</span>
<span id="cb40-8"><a aria-hidden="true" href="#cb40-8"></a></span>
<span id="cb40-9"><a aria-hidden="true" href="#cb40-9"></a>ll n, k;</span>
<span id="cb40-10"><a aria-hidden="true" href="#cb40-10"></a></span>
<span id="cb40-11"><a aria-hidden="true" href="#cb40-11"></a>ll fac[maxn], pre[maxn], suf[maxn];</span>
<span id="cb40-12"><a aria-hidden="true" href="#cb40-12"></a></span>
<span id="cb40-13"><a aria-hidden="true" href="#cb40-13"></a>ll qpow(ll base, ll p = mod - <span class="dv">2</span>)</span>
<span id="cb40-14"><a aria-hidden="true" href="#cb40-14"></a>{</span>
<span id="cb40-15"><a aria-hidden="true" href="#cb40-15"></a>    ll ret = <span class="dv">1</span>;</span>
<span id="cb40-16"><a aria-hidden="true" href="#cb40-16"></a>    <span class="cf">for</span> (; p; p &gt;&gt;= <span class="dv">1</span>, base = base * base % mod)</span>
<span id="cb40-17"><a aria-hidden="true" href="#cb40-17"></a>        <span class="cf">if</span> (p &amp; <span class="dv">1</span>)</span>
<span id="cb40-18"><a aria-hidden="true" href="#cb40-18"></a>            ret = ret * base % mod;</span>
<span id="cb40-19"><a aria-hidden="true" href="#cb40-19"></a>    <span class="cf">return</span> ret;</span>
<span id="cb40-20"><a aria-hidden="true" href="#cb40-20"></a>}</span>
<span id="cb40-21"><a aria-hidden="true" href="#cb40-21"></a></span>
<span id="cb40-22"><a aria-hidden="true" href="#cb40-22"></a><span class="dt">int</span> main()</span>
<span id="cb40-23"><a aria-hidden="true" href="#cb40-23"></a>{</span>
<span id="cb40-24"><a aria-hidden="true" href="#cb40-24"></a>    scanf(<span class="st">"</span><span class="sc">%lld</span><span class="st"> </span><span class="sc">%lld</span><span class="st">"</span>, &amp;n, &amp;k);</span>
<span id="cb40-25"><a aria-hidden="true" href="#cb40-25"></a>    <span class="cf">if</span> (!k)</span>
<span id="cb40-26"><a aria-hidden="true" href="#cb40-26"></a>    {</span>
<span id="cb40-27"><a aria-hidden="true" href="#cb40-27"></a>        printf(<span class="st">"</span><span class="sc">%lld\n</span><span class="st">"</span>, n);</span>
<span id="cb40-28"><a aria-hidden="true" href="#cb40-28"></a>        <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb40-29"><a aria-hidden="true" href="#cb40-29"></a>    }</span>
<span id="cb40-30"><a aria-hidden="true" href="#cb40-30"></a>    ll ans = <span class="dv">0</span>, y = <span class="dv">0</span>;</span>
<span id="cb40-31"><a aria-hidden="true" href="#cb40-31"></a>    pre[<span class="dv">0</span>] = <span class="dv">1</span>, fac[<span class="dv">0</span>] = <span class="dv">1</span>;</span>
<span id="cb40-32"><a aria-hidden="true" href="#cb40-32"></a>    FOR(i, <span class="dv">1</span>, k + <span class="dv">2</span>)</span>
<span id="cb40-33"><a aria-hidden="true" href="#cb40-33"></a>        pre[i] = pre[i - <span class="dv">1</span>] * (n - i) % mod, fac[i] = fac[i - <span class="dv">1</span>] * i % mod;</span>
<span id="cb40-34"><a aria-hidden="true" href="#cb40-34"></a>    suf[k + <span class="dv">3</span>] = <span class="dv">1</span>;</span>
<span id="cb40-35"><a aria-hidden="true" href="#cb40-35"></a>    DEC(i, k + <span class="dv">2</span>, <span class="dv">0</span>)</span>
<span id="cb40-36"><a aria-hidden="true" href="#cb40-36"></a>        suf[i] = suf[i + <span class="dv">1</span>] * (n - i) % mod;</span>
<span id="cb40-37"><a aria-hidden="true" href="#cb40-37"></a>    FOR(i, <span class="dv">1</span>, k + <span class="dv">2</span>)</span>
<span id="cb40-38"><a aria-hidden="true" href="#cb40-38"></a>    {</span>
<span id="cb40-39"><a aria-hidden="true" href="#cb40-39"></a>        y = (y + qpow(i, k)) % mod;</span>
<span id="cb40-40"><a aria-hidden="true" href="#cb40-40"></a>        ll tmp = y * pre[i - <span class="dv">1</span>] % mod * suf[i + <span class="dv">1</span>] % mod * (((k - i) &amp; <span class="dv">1</span>) ? -<span class="dv">1</span> : <span class="dv">1</span>) * qpow(fac[i - <span class="dv">1</span>] * fac[k + <span class="dv">2</span> - i] % mod) % mod;</span>
<span id="cb40-41"><a aria-hidden="true" href="#cb40-41"></a>        ans = (ans + tmp + mod) % mod;</span>
<span id="cb40-42"><a aria-hidden="true" href="#cb40-42"></a>    }</span>
<span id="cb40-43"><a aria-hidden="true" href="#cb40-43"></a>    printf(<span class="st">"</span><span class="sc">%lld\n</span><span class="st">"</span>, ans);</span>
<span id="cb40-44"><a aria-hidden="true" href="#cb40-44"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb40-45"><a aria-hidden="true" href="#cb40-45"></a>}</span></code></pre></div>
<h4 id="证明">证明</h4>
<p>这里的证明使用差分（参考数竞小蓝本数列那一册）。</p>
<p>定义多项式 <span class="math inline">\(f(x)\)</span> 的一阶差分为 <span class="math inline">\(\Delta f(x) = f(x + 1) - f(x)\)</span>，把得到的多项式再作次差分得到 <span class="math inline">\(f(x)\)</span> 的二阶差分 <span class="math display">\[
\begin{aligned}
\Delta^2f(x) &amp;= \Delta (\Delta f(x))\\
&amp;= \Delta (f(x + 1) - f(x))\\
&amp;= (f(x + 2) - f(x + 1)) - (f(x + 1) - f(x))\\
&amp;= f(x + 2) - 2f(x + 1) + f(x)
\end{aligned}
\]</span> 类似的可以定义 <span class="math inline">\(p\)</span> 阶差分，即 <span class="math inline">\(\Delta^p f(x) = \Delta(\Delta^{p - 1}f(x))\)</span>。类似的我们对数列也是可以进行差分操作的。如果一个数列的 <span class="math inline">\(p\)</span> 阶差分为一个非零常数列，则称其为 <span class="math inline">\(p\)</span> 阶等差数列。</p>
<p><strong>定理：</strong></p>
<p>数列 <span class="math inline">\(\lbrace a_n\rbrace\)</span> 为 <span class="math inline">\(p\)</span> 阶等差数列的充要条件是其通项公式为 <span class="math inline">\(n\)</span> 的一个 <span class="math inline">\(p\)</span> 次多项式。</p>
<p><strong>证明：</strong></p>
<p>已知数列 <span class="math inline">\(\lbrace a_n\rbrace\)</span> 为 <span class="math inline">\(p\)</span> 阶等差数列，设数列 <span class="math inline">\(\lbrace a_n\rbrace\)</span> 的通项为一个关于 <span class="math inline">\(n\)</span> 的 <span class="math inline">\(v\)</span> 次多项式，即 <span class="math inline">\(f(n) = \sum_{i = 0}^vu_ix^i\)</span>。</p>
<p>令 <span class="math inline">\(\lbrace a_n\rbrace\)</span> 的差分为 <span class="math inline">\(\lbrace b_n\rbrace\)</span>，则 <span class="math inline">\(\lbrace b_n\rbrace\)</span> 的通项公式为 <span class="math display">\[
\begin{aligned}
\Delta f(x) &amp;= f(x + 1) - f(x)\\
&amp;= \sum_{i = 0}^v u_i(x + 1)^i - \sum_{i = 0}^vu_ix_i
\end{aligned}
\]</span> 打开后我们发现 <span class="math inline">\(x^v\)</span> 的系数变为了 <span class="math inline">\(0\)</span>，说明差分之后通项公式的次数减了 <span class="math inline">\(1\)</span>，从其 <span class="math inline">\(p\)</span> 阶差分为一个非零常数列可反推知其通项公式的次数为 <span class="math inline">\(p\)</span>。</p>
<p>回到本题，定义出数列 <span class="math display">\[
\lbrace a_n\rbrace = \sum_{i = 1}^1i^k, \sum_{i = 1}^2i^k,\cdots,\sum_{i = 1}^ni^k
\]</span> 对这个数列作差分可以得到 <span class="math inline">\(1^k,2^k,3^k,\cdots, n^k\)</span>，发现其通项公式为 <span class="math inline">\(f(n) = n^k\)</span>，所以原数列的通项就是关于 <span class="math inline">\(n\)</span> 的一个 <span class="math inline">\(k + 1\)</span> 次多项式。</p>
<h2 id="多项式多点求值">多项式多点求值</h2>
<p>前置知识：多项式带余除法、简单的分治思想。</p>
<h3 id="问题描述-8">问题描述</h3>
<p>给定一个多项式和 <span class="math inline">\(m\)</span> 个点 <span class="math inline">\(\{a_1,\cdots, a_m\}\)</span>，要求分别求出 <span class="math inline">\(f(a_1),f(a_2),\cdots, f(a_m)\)</span>。</p>
<h3 id="问题求解-1">问题求解</h3>
<p>核心思想是构造 + 分治。</p>
<p>考虑现在正在处理子问题 <span class="math display">\[
\{a_1, a_2, \cdots, a_m\}
\]</span> 将其分为两个部分 <span class="math display">\[
\{a_1, a_2,\cdots, a_{\left\lfloor\frac m2\right\rfloor}\}\quad \{a_{\left\lfloor\frac m2\right\rfloor + 1}, \cdots, a_m\}
\]</span> 然后构造两个多项式 <span class="math display">\[
g_0(x) = \prod_{i = 1}^{\lfloor\frac m2\rfloor}(x - a_i)\\g_1(x) = \prod_{i = \lfloor\frac m2\rfloor + 1}^m(x - a_i)
\]</span> 然后我们令 <span class="math inline">\(f(x) = g_0(x)Q(x) + f_0(x)\)</span>，则显然有 <span class="math inline">\(\forall i\in[1, \lfloor\frac m2\rfloor]\)</span>，一定有 <span class="math inline">\(g_0(a_i) = 0\)</span>。所以有 <span class="math inline">\(f(x)\equiv f_0(x)\pmod {g_0(x)}\)</span>。这就是一个多项式取模的事情。对于右边则同理。</p>
<p>这样子我们就成功将问题的规模减半。时间复杂度 <span class="math inline">\(O(n\log^2n)\)</span>。</p>
<h3 id="实现-7">实现</h3>
<p>一开始就需要求出所有的 <span class="math inline">\(g(x)\)</span>，这个过程类似于线段树，是 <span class="math inline">\(O(n\log^2n)\)</span> 的。然后每一层也要给他个多项式取模。</p>
<p>然后鉴于多项式取模的巨大常数，当区间比较小的时候可以考虑直接暴算，优化常数。</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb41-1"><a aria-hidden="true" href="#cb41-1"></a><span class="pp">#define L </span>(k<span class="pp"> </span>&lt;&lt;<span class="pp"> </span><span class="dv">1</span>)</span>
<span id="cb41-2"><a aria-hidden="true" href="#cb41-2"></a><span class="pp">#define R </span>(L<span class="pp"> </span>|<span class="pp"> </span><span class="dv">1</span>)</span>
<span id="cb41-3"><a aria-hidden="true" href="#cb41-3"></a><span class="pp">#define M </span>((l<span class="pp"> </span>+<span class="pp"> </span>r)<span class="pp"> </span>&gt;&gt;<span class="pp"> </span><span class="dv">1</span>)</span>
<span id="cb41-4"><a aria-hidden="true" href="#cb41-4"></a>Poly g[maxn &lt;&lt; <span class="dv">2</span>], Q;</span>
<span id="cb41-5"><a aria-hidden="true" href="#cb41-5"></a></span>
<span id="cb41-6"><a aria-hidden="true" href="#cb41-6"></a><span class="dt">void</span> initG(<span class="dt">int</span> k, <span class="dt">int</span> l, <span class="dt">int</span> r, <span class="dt">int</span> *a) {</span>
<span id="cb41-7"><a aria-hidden="true" href="#cb41-7"></a>    <span class="cf">if</span> (l == r) {</span>
<span id="cb41-8"><a aria-hidden="true" href="#cb41-8"></a>        g[k].push_back(a[l] ? mod - a[l] : <span class="dv">0</span>);</span>
<span id="cb41-9"><a aria-hidden="true" href="#cb41-9"></a>        g[k].push_back(<span class="dv">1</span>);</span>
<span id="cb41-10"><a aria-hidden="true" href="#cb41-10"></a>        <span class="cf">return</span>;</span>
<span id="cb41-11"><a aria-hidden="true" href="#cb41-11"></a>    }</span>
<span id="cb41-12"><a aria-hidden="true" href="#cb41-12"></a>    initG(L, l, M, a);</span>
<span id="cb41-13"><a aria-hidden="true" href="#cb41-13"></a>    initG(R, M + <span class="dv">1</span>, r, a);</span>
<span id="cb41-14"><a aria-hidden="true" href="#cb41-14"></a>    g[k] = g[L] * g[R];</span>
<span id="cb41-15"><a aria-hidden="true" href="#cb41-15"></a>    <span class="cf">return</span>;</span>
<span id="cb41-16"><a aria-hidden="true" href="#cb41-16"></a>}</span>
<span id="cb41-17"><a aria-hidden="true" href="#cb41-17"></a></span>
<span id="cb41-18"><a aria-hidden="true" href="#cb41-18"></a><span class="dt">void</span> work(<span class="dt">int</span> k, <span class="dt">int</span> l, <span class="dt">int</span> r, Poly A, <span class="dt">int</span> *a, <span class="dt">int</span> *ans) {</span>
<span id="cb41-19"><a aria-hidden="true" href="#cb41-19"></a>    <span class="cf">if</span> (r - l + <span class="dv">1</span> &lt; <span class="dv">100</span>) {</span>
<span id="cb41-20"><a aria-hidden="true" href="#cb41-20"></a>        FOR(i, l, r) {</span>
<span id="cb41-21"><a aria-hidden="true" href="#cb41-21"></a>            <span class="dt">int</span> s = <span class="dv">0</span>;</span>
<span id="cb41-22"><a aria-hidden="true" href="#cb41-22"></a>            DEC(j, A.size() - <span class="dv">1</span>, <span class="dv">0</span>)</span>
<span id="cb41-23"><a aria-hidden="true" href="#cb41-23"></a>                s = (<span class="dv">1</span><span class="bu">ll</span> * s * a[i] % mod + A[j]) % mod;</span>
<span id="cb41-24"><a aria-hidden="true" href="#cb41-24"></a>            ans[i] = s;</span>
<span id="cb41-25"><a aria-hidden="true" href="#cb41-25"></a>        }</span>
<span id="cb41-26"><a aria-hidden="true" href="#cb41-26"></a>        <span class="cf">return</span>;</span>
<span id="cb41-27"><a aria-hidden="true" href="#cb41-27"></a>    }</span>
<span id="cb41-28"><a aria-hidden="true" href="#cb41-28"></a>    Poly B;</span>
<span id="cb41-29"><a aria-hidden="true" href="#cb41-29"></a>    polyDiv(A, g[L], Q, B);</span>
<span id="cb41-30"><a aria-hidden="true" href="#cb41-30"></a>    work(L, l, M, B, a, ans);</span>
<span id="cb41-31"><a aria-hidden="true" href="#cb41-31"></a>    polyDiv(A, g[R], Q, B);</span>
<span id="cb41-32"><a aria-hidden="true" href="#cb41-32"></a>    work(R, M + <span class="dv">1</span>, r, B, a, ans);</span>
<span id="cb41-33"><a aria-hidden="true" href="#cb41-33"></a>    <span class="cf">return</span>;</span>
<span id="cb41-34"><a aria-hidden="true" href="#cb41-34"></a>}</span>
<span id="cb41-35"><a aria-hidden="true" href="#cb41-35"></a></span>
<span id="cb41-36"><a aria-hidden="true" href="#cb41-36"></a><span class="dt">void</span> evaluate(Poly f, <span class="dt">int</span> m, <span class="dt">int</span> *a, <span class="dt">int</span> *ans) {</span>
<span id="cb41-37"><a aria-hidden="true" href="#cb41-37"></a>    initG(<span class="dv">1</span>, <span class="dv">1</span>, m, a);</span>
<span id="cb41-38"><a aria-hidden="true" href="#cb41-38"></a>    work(<span class="dv">1</span>, <span class="dv">1</span>, m, f, a, ans);</span>
<span id="cb41-39"><a aria-hidden="true" href="#cb41-39"></a>    <span class="cf">return</span>;</span>
<span id="cb41-40"><a aria-hidden="true" href="#cb41-40"></a>}</span>
<span id="cb41-41"><a aria-hidden="true" href="#cb41-41"></a><span class="pp">#undef L</span></span>
<span id="cb41-42"><a aria-hidden="true" href="#cb41-42"></a><span class="pp">#undef R</span></span>
<span id="cb41-43"><a aria-hidden="true" href="#cb41-43"></a><span class="pp">#undef M</span></span></code></pre></div>
<h2 id="多项式快速插值">多项式快速插值</h2>
<p>前置知识：多点求值，洛必达法则</p>
<h3 id="问题描述-9">问题描述</h3>
<p>给定 <span class="math inline">\(n\)</span> 个点 <span class="math inline">\((x_i, y_i)\)</span>，求出经过这 <span class="math inline">\(n\)</span> 个点的 <span class="math inline">\(n - 1\)</span> 次多项式。</p>
<h3 id="问题求解-2">问题求解</h3>
<p>回顾一下拉格朗日插值公式： <span class="math display">\[
F(x) = \sum_{i = 1}^n y_i\prod_{j \not=i}\frac{x - x_j}{x_i - x_j}
\]</span> 先把后面的分母提到前面来： <span class="math display">\[
F(x) = \sum_{i = 1}^n\frac{y_i}{\prod_{j\not=i}(x_i - x_j)}\prod_{j \not= i}(x - x_j)
\]</span> 首先发现 <span class="math inline">\(\dfrac{y_i}{\prod_{j\not=i}(x_i - x_j)}\)</span>，考虑先计算这个常数。令 <span class="math inline">\(\delta(x) = \displaystyle\prod_{j = 1}^n(x - x_j)\)</span>，这个东西可以分治 <span class="math inline">\(O(n\log^2 n)\)</span> 求。然后看 <span class="math inline">\(y_i\)</span> 的分母： <span class="math display">\[
\prod_{j\not= i}(x_i - x_j) = \lim_{x\to x_i}\frac{\delta(x)}{x - x_i}
\]</span> 这个东西就是导数的定义式，不难发现 <span class="math display">\[
\lim_{x\to x_i}\frac{\delta(x)}{x - x_i} = \delta'(x_i)
\]</span> 求出 <span class="math inline">\(\delta(x)\)</span> 之后求个导再写个多点求值就可以搞定了。</p>
<p>然后问题就化简到了 <span class="math display">\[
F(x) = \sum_{i = 1}^n\frac{y_i}{\delta'(x_i)}\prod_{j\not=i}(x - x_j)
\]</span> 还是用分治大法。设 <span class="math inline">\(\displaystyle F_{l, r}(x) = \sum_{i = l}^r\frac{y_i}{\delta'(x_i)}\prod_{j\not=i}(x - x_j)\)</span>，<span class="math inline">\(\delta_{l,r}(x) = \displaystyle\prod_{j = l}^r(x - x_j)\)</span>，<span class="math inline">\(m = \left\lfloor\dfrac {i+ j}2\right\rfloor\)</span>，开始化简： <span class="math display">\[
\begin{aligned}F_{l, r}(x) &amp;= \sum_{i = l}^r\frac{y_i}{\delta'(x_i)}\prod_{j\not=i}(x - x_j)\\&amp;=\sum_{i = l}^m\frac{y_i}{\delta'(x_i)}\prod_{j = l, j\not=i}^m(x - x_j)\prod_{j = m + 1, j\not= i}^r(x - x_j) + \sum_{i = m + 1}^r\frac{y_i}{\delta'(x_i)}\prod_{j = l, j\not=i}^m(x - x_j)\prod_{j = m + 1, j\not= i}^r(x - x_j)\\&amp;=F_{l,m}(x)\delta_{m + 1, r}(x) + F_{m + 1, r}(x)\delta_{l, m}(x)\end{aligned}
\]</span> 边界肯定就是 <span class="math inline">\(l = r\)</span> 的时候 <span class="math inline">\(F_{l,l}(x) = \dfrac{y_l}{\delta'(x_l)}\)</span>。总复杂度 <span class="math inline">\(O(n\log^2n)\)</span>。</p>
<h3 id="实现-8">实现</h3>
<p>配合上面的封装，其实不难写。</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb42-1"><a aria-hidden="true" href="#cb42-1"></a>Poly delta[maxn &lt;&lt; <span class="dv">2</span>], ddelta;</span>
<span id="cb42-2"><a aria-hidden="true" href="#cb42-2"></a><span class="dt">int</span> dval[maxn];</span>
<span id="cb42-3"><a aria-hidden="true" href="#cb42-3"></a></span>
<span id="cb42-4"><a aria-hidden="true" href="#cb42-4"></a><span class="dt">void</span> initDelta(<span class="dt">int</span> k, <span class="dt">int</span> l, <span class="dt">int</span> r, <span class="dt">int</span> *x) {</span>
<span id="cb42-5"><a aria-hidden="true" href="#cb42-5"></a>    <span class="cf">if</span> (l == r) {</span>
<span id="cb42-6"><a aria-hidden="true" href="#cb42-6"></a>        delta[k].push_back(x[l] ? mod - x[l] : <span class="dv">0</span>);</span>
<span id="cb42-7"><a aria-hidden="true" href="#cb42-7"></a>        delta[k].push_back(<span class="dv">1</span>);</span>
<span id="cb42-8"><a aria-hidden="true" href="#cb42-8"></a>        <span class="cf">return</span>;</span>
<span id="cb42-9"><a aria-hidden="true" href="#cb42-9"></a>    }</span>
<span id="cb42-10"><a aria-hidden="true" href="#cb42-10"></a>    initDelta(L, l, M, x);</span>
<span id="cb42-11"><a aria-hidden="true" href="#cb42-11"></a>    initDelta(R, M + <span class="dv">1</span>, r, x);</span>
<span id="cb42-12"><a aria-hidden="true" href="#cb42-12"></a>    delta[k] = delta[L] * delta[R];</span>
<span id="cb42-13"><a aria-hidden="true" href="#cb42-13"></a>    <span class="cf">return</span>;</span>
<span id="cb42-14"><a aria-hidden="true" href="#cb42-14"></a>}</span>
<span id="cb42-15"><a aria-hidden="true" href="#cb42-15"></a></span>
<span id="cb42-16"><a aria-hidden="true" href="#cb42-16"></a>Poly interpolation(<span class="dt">int</span> k, <span class="dt">int</span> l, <span class="dt">int</span> r, <span class="dt">int</span> *x, <span class="dt">int</span> *y) {</span>
<span id="cb42-17"><a aria-hidden="true" href="#cb42-17"></a>    <span class="cf">if</span> (l == r)</span>
<span id="cb42-18"><a aria-hidden="true" href="#cb42-18"></a>        <span class="cf">return</span> Poly(<span class="dv">1</span>, <span class="dv">1</span><span class="bu">ll</span> * y[l] * qPow(dval[l]) % mod);</span>
<span id="cb42-19"><a aria-hidden="true" href="#cb42-19"></a>    <span class="cf">return</span> interpolation(L, l, M, x, y) * delta[R] + interpolation(R, M + <span class="dv">1</span>, r, x, y) * delta[L];</span>
<span id="cb42-20"><a aria-hidden="true" href="#cb42-20"></a>}</span>
<span id="cb42-21"><a aria-hidden="true" href="#cb42-21"></a></span>
<span id="cb42-22"><a aria-hidden="true" href="#cb42-22"></a>Poly interpolation(<span class="dt">int</span> n, <span class="dt">int</span> *x, <span class="dt">int</span> *y) {</span>
<span id="cb42-23"><a aria-hidden="true" href="#cb42-23"></a>    initDelta(<span class="dv">1</span>, <span class="dv">1</span>, n, x);</span>
<span id="cb42-24"><a aria-hidden="true" href="#cb42-24"></a>    ddelta = deri(delta[<span class="dv">1</span>]);</span>
<span id="cb42-25"><a aria-hidden="true" href="#cb42-25"></a>    evaluate(ddelta, n, x, dval);</span>
<span id="cb42-26"><a aria-hidden="true" href="#cb42-26"></a>    <span class="cf">return</span> interpolation(<span class="dv">1</span>, <span class="dv">1</span>, n, x, y);</span>
<span id="cb42-27"><a aria-hidden="true" href="#cb42-27"></a>}</span></code></pre></div>
</section>
<footer class="article-footer">
<section class="article-tags">
<a href="/tags/OI/">OI</a>
<a href="/tags/note/">笔记</a>
<a href="/tags/FFT/">FFT</a>
<a href="/tags/NTT/">NTT</a>
<a href="/tags/gf/">生成函数</a>
<a href="/tags/inclusion-exclusion-principle/">容斥原理</a>
<a href="/tags/lagrange-interpolation/">拉格朗日插值</a>
</section>
<section class="article-copyright">
<svg class="icon icon-tabler icon-tabler-copyright" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<circle cx="12" cy="12" r="9"></circle>
<path d="M14.5 9a3.5 4 0 1 0 0 6"></path>
</svg>
<span>Licensed under CC BY-NC-SA 4.0</span>
</section>
</footer>
<link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css" integrity="sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn" rel="stylesheet"/><script crossorigin="anonymous" defer="" integrity="sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8" src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js">
</script><script crossorigin="anonymous" defer="" integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js">
</script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.querySelector(`.article-content`), {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ]
        });})
</script>
</article>
<aside class="related-contents--wrapper">
<h2 class="section-title">相关文章</h2>
<div class="related-contents">
<div class="flex article-list--tile">
<article class="has-image">
<a href="/sol-bzoj3771/">
<div class="article-image">
<img data-hash="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg50.webp" data-key="" loading="lazy" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg50.webp"/>
</div>
<div class="article-details">
<h2 class="article-title">BZOJ3771. Triple</h2>
</div>
</a>
</article>
<article class="has-image">
<a href="/summary-atcoder/">
<div class="article-image">
<img data-hash="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg70.webp" data-key="" loading="lazy" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg70.webp"/>
</div>
<div class="article-details">
<h2 class="article-title">AtCoder 比赛日记</h2>
</div>
</a>
</article>
<article class="has-image">
<a href="/note-gf/">
<div class="article-image">
<img data-hash="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg28.webp" data-key="" loading="lazy" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg28.webp"/>
</div>
<div class="article-details">
<h2 class="article-title">生成函数胡扯</h2>
</div>
</a>
</article>
<article class="has-image">
<a href="/sol-luogu-p4451/">
<div class="article-image">
<img data-hash="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg5.webp" data-key="" loading="lazy" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg5.webp"/>
</div>
<div class="article-details">
<h2 class="article-title">P4451 [国家集训队]整数的lqp拆分</h2>
</div>
</a>
</article>
<article class="has-image">
<a href="/sol-cf438e/">
<div class="article-image">
<img data-hash="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg67.webp" data-key="" loading="lazy" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg67.webp"/>
</div>
<div class="article-details">
<h2 class="article-title">CF438E The Child and Binary Tree</h2>
</div>
</a>
</article>
</div>
</div>
</aside>
<footer class="site-footer">
<section class="copyright">
        © 
        
            2019 - 
        
        2024 清烛的博客
    </section>
<section class="powerby">
        Built with <a href="https://gohugo.io/" rel="noopener" target="_blank">Hugo</a> <br/>
        主题 <b><a data-version="3.11.0" href="https://github.com/CaiJimmy/hugo-theme-stack" rel="noopener" target="_blank">Stack</a></b> 由 <a href="https://jimmycai.com" rel="noopener" target="_blank">Jimmy</a> 设计
    </section>
</footer>
<div aria-hidden="true" class="pswp" role="dialog" tabindex="-1">
<div class="pswp__bg"></div>
<div class="pswp__scroll-wrap">
<div class="pswp__container">
<div class="pswp__item"></div>
<div class="pswp__item"></div>
<div class="pswp__item"></div>
</div>
<div class="pswp__ui pswp__ui--hidden">
<div class="pswp__top-bar">
<div class="pswp__counter"></div>
<button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title="Share"></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
<div class="pswp__preloader">
<div class="pswp__preloader__icn">
<div class="pswp__preloader__cut">
<div class="pswp__preloader__donut"></div>
</div>
</div>
</div>
</div>
<div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
<div class="pswp__share-tooltip"></div>
</div>
<button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
</button>
<div class="pswp__caption">
<div class="pswp__caption__center"></div>
</div>
</div>
</div>
</div><script crossorigin="anonymous" defer="" integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js">
</script><script crossorigin="anonymous" defer="" integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js">
</script><link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css" integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" rel="stylesheet"/><link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css" integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" rel="stylesheet"/>
</main>
</div>
<script crossorigin="anonymous" integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js">
</script><script defer="" src="/ts/main.js" type="text/javascript"></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>
</body>
</html>

<!DOCTYPE html>
<html dir="ltr" lang="zh-CN">
<head><meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/><meta content="Round div id sol rk perf A B C D E F G H I R670 2 1406 0 9207 🉑 🉑 🉑 🉑 🉑 R695 2 1467 1 6299 🉑 👀 👀 👀 👀 R697 3 1475 4 N/A 🉑 🉑 🉑 🉑 🉑 🉑 🉑 R698 2 1478 2 4882 🉑 🉑 R698 1 1477 N/A N/A 👀 👀 👀 😅 😅 😅 EDU103 edu 1476 2 4551 🉑 🉑 🉑 🉑 🉑 😅 😅 R699 2 1481 3 2113 🉑 🉑 🉑 🉑 🉑 👀 R700 2 1480 2 6974 🉑 🉑 R700 1 1479 N/A N/A 🉑 🉑 🉑 🉑 😅 R701 2 1485 1 vp 🉑 🉑 🉑 🉑 🉑 🉑 EDU104 edu 1487 2 4964 🉑 🉑 🉑 🉑 👀 👀 👀 R702 3 1490 5 1352 🉑 🉑 🉑 🉑 🉑 🉑 🉑 R705 2 1493 3 869 🉑 🉑 👀 🉑 👀 👀 R706 2 1496 3 1792 🉑 🉑 R706 1 1495 N/A N/A 🉑 🉑 🉑 👀 😅 😅 R707 2 1501 2 1320 🉑 🉑 R707 1 1500 N/A N/A 🉑 👀 👀 😅 😅 😅 R712 2 1504 1 8171 🉑 👀 R712 1 1503 N/A N/A 👀 👀 👀 😅 😅 😅 R718 1+2 1517 vp 🉑 🉑 🉑 🉑 👀 😅 😅 😅 HSSC21 1+2 1553 5 vp 🉑 🉑 🉑 🉑 🉑 🉑 🉑 👀 😅 R733 1+2 1530 4 vp 🉑 🉑 🉑 🉑 R736 2 1549 4 373 🉑 🉑 R736 1 1548 N/A N/A 🉑 🉑 🉑 👀 😅 R737 2 1557 3 463 🉑 🉑 🉑 👀 👀 R738 2 1559 4 1780 🉑 🉑 🉑 🉑 🉑 R740 2 1561 4 1738 🉑 🉑 R740 1 1558 N/A N/A 🉑 🉑 👀 👀 😅 😅 R741 2 1562 2 3894 🉑 👀 🉑 👀 👀 👀 DR 2021 1+2 1556 4 vp 🉑 🉑 🉑 🉑 🉑 👀 😅 😅 R742 2 1567 3 2622 🉑 🉑 🉑 🉑 🉑 🉑 R743 2 1573 4 vp 🉑 🉑 R743 1 1572 N/A N/A 🉑 🉑 🉑 🉑 🉑 😅 EDU113 edu 1569 2 8249 🉑 🉑 🉑 👀 👀 😅 GR17 gr 1566 4 4019 1330 🉑 🉑 🉑 🉑 🉑 EDU114 edu 1574 3 1807 1585 🉑 🉑 🉑 🉑 👀 😅 R745 2 1581 3 279 1886 🉑 🉑 R745 1 1580 N/A N/A N/A 🉑 👀 👀 👀 😅 😅 R746 2 1592 3 550 1928 🉑 🉑 🉑 🉑 👀 👀 R747 2 1594 5 605 1825 🉑 🉑 🉑 🉑 🉑 🉑 EDU115 edu 1598 4 581 1825 🉑 🉑 🉑 🉑 🉑 🉑 😅 R749 1+2 1586 5 349 2284 🉑 🉑 🉑 🉑 🉑 🉑 👀 😅 😅 R750 2 1582 4 1738 1514 🉑 🉑 🉑 🉑 🉑 👀 👀 R754 2 1605 3 869 1787 🉑 🉑 🉑 🉑 🉑 👀 R755 1 1588 2 451 1933 🉑 🉑 👀 🉑 😅 😅 R758 1+2 1608 3 522 2059 🉑 🉑 🉑 🉑 👀 😅 😅 GR18 gr 1615 3 816 2031 🉑 🉑 🉑 🉑 🉑 👀 😅 😅 Hello2022 1621 N/A skip N/A 🉑 🉑 🉑 🉑 🉑 😅 😅 😅 😅 R765 2 1625 4 140 2191 🉑 🉑 🉑 🉑 👀 R766 2 1627 3 1275 1678 🉑 🉑 🉑 🉑 🉑 🉑 EDU121 edu 1626 4 vp 🉑 🉑 🉑 🉑 🉑 👀 R767 2 1629 4 305 1988 🉑 🉑 R767 1 1628 N/A N/A N/A 🉑 🉑 🉑 🉑 😅 😅 R768 2 1631 3 2765 1435 🉑 🉑 R768 1 1630 N/A N/A N/A 🉑 🉑 👀 👀 😅 😅 R769 2 1632 3 1620 1661 🉑 🉑 🉑 🉑 🉑 EDU122 edu 1633 4 vp 🉑 🉑 🉑 🉑 🉑 👀 GR19 gr 1637 4 1047 1975 🉑 🉑 🉑 🉑 🉑 🉑 😅 😅 R771 2 1638 4 521 1936 🉑 🉑 🉑 🉑 🉑 😅 R772 2 1635 5 121 2204 🉑 🉑 🉑 🉑 🉑 🉑 EDU123 edu 1644 5 365 1968 🉑 🉑 🉑 🉑 🉑 😅 R773 1 1641 2 689 1884 🉑 🉑 👀 😅 😅 😅 R777 2 1647 4 549 1908 🉑 🉑 🉑 🉑 👀 👀 R781 2 1665 2 3461 1276 🉑 🉑 🉑 🉑 🉑 EDU126 edu 1661 4 311 2001 🉑 🉑 🉑 🉑 🉑 🉑 R785 2 1673 3 1368 1624 🉑 🉑 🉑 👀 👀 👀 EDU128 edu 1680 3 958 1742 🉑 🉑 🉑 👀 👀 👀 R796 1 1687 N/A N/A N/A 🉑 🉑 🉑 👀 😅 😅 R796 2 1688 5 181 2034 🉑 🉑 🉑 R801 2 1695 3." name="description"/><title>Codeforces 比赛日记</title>
<link href="https://oi.imyangty.com/summary-codeforces/" rel="canonical"/>
<link href="/scss/style.min.a5821f3d3ab84ce5a0ac21477e347a2e0ca00292e398d16c5e8e36ded6e35a23.css" rel="stylesheet"/><meta content="Codeforces 比赛日记" property="og:title"/>
<meta content="Round div id sol rk perf A B C D E F G H I R670 2 1406 0 9207 🉑 🉑 🉑 🉑 🉑 R695 2 1467 1 6299 🉑 👀 👀 👀 👀 R697 3 1475 4 N/A 🉑 🉑 🉑 🉑 🉑 🉑 🉑 R698 2 1478 2 4882 🉑 🉑 R698 1 1477 N/A N/A 👀 👀 👀 😅 😅 😅 EDU103 edu 1476 2 4551 🉑 🉑 🉑 🉑 🉑 😅 😅 R699 2 1481 3 2113 🉑 🉑 🉑 🉑 🉑 👀 R700 2 1480 2 6974 🉑 🉑 R700 1 1479 N/A N/A 🉑 🉑 🉑 🉑 😅 R701 2 1485 1 vp 🉑 🉑 🉑 🉑 🉑 🉑 EDU104 edu 1487 2 4964 🉑 🉑 🉑 🉑 👀 👀 👀 R702 3 1490 5 1352 🉑 🉑 🉑 🉑 🉑 🉑 🉑 R705 2 1493 3 869 🉑 🉑 👀 🉑 👀 👀 R706 2 1496 3 1792 🉑 🉑 R706 1 1495 N/A N/A 🉑 🉑 🉑 👀 😅 😅 R707 2 1501 2 1320 🉑 🉑 R707 1 1500 N/A N/A 🉑 👀 👀 😅 😅 😅 R712 2 1504 1 8171 🉑 👀 R712 1 1503 N/A N/A 👀 👀 👀 😅 😅 😅 R718 1+2 1517 vp 🉑 🉑 🉑 🉑 👀 😅 😅 😅 HSSC21 1+2 1553 5 vp 🉑 🉑 🉑 🉑 🉑 🉑 🉑 👀 😅 R733 1+2 1530 4 vp 🉑 🉑 🉑 🉑 R736 2 1549 4 373 🉑 🉑 R736 1 1548 N/A N/A 🉑 🉑 🉑 👀 😅 R737 2 1557 3 463 🉑 🉑 🉑 👀 👀 R738 2 1559 4 1780 🉑 🉑 🉑 🉑 🉑 R740 2 1561 4 1738 🉑 🉑 R740 1 1558 N/A N/A 🉑 🉑 👀 👀 😅 😅 R741 2 1562 2 3894 🉑 👀 🉑 👀 👀 👀 DR 2021 1+2 1556 4 vp 🉑 🉑 🉑 🉑 🉑 👀 😅 😅 R742 2 1567 3 2622 🉑 🉑 🉑 🉑 🉑 🉑 R743 2 1573 4 vp 🉑 🉑 R743 1 1572 N/A N/A 🉑 🉑 🉑 🉑 🉑 😅 EDU113 edu 1569 2 8249 🉑 🉑 🉑 👀 👀 😅 GR17 gr 1566 4 4019 1330 🉑 🉑 🉑 🉑 🉑 EDU114 edu 1574 3 1807 1585 🉑 🉑 🉑 🉑 👀 😅 R745 2 1581 3 279 1886 🉑 🉑 R745 1 1580 N/A N/A N/A 🉑 👀 👀 👀 😅 😅 R746 2 1592 3 550 1928 🉑 🉑 🉑 🉑 👀 👀 R747 2 1594 5 605 1825 🉑 🉑 🉑 🉑 🉑 🉑 EDU115 edu 1598 4 581 1825 🉑 🉑 🉑 🉑 🉑 🉑 😅 R749 1+2 1586 5 349 2284 🉑 🉑 🉑 🉑 🉑 🉑 👀 😅 😅 R750 2 1582 4 1738 1514 🉑 🉑 🉑 🉑 🉑 👀 👀 R754 2 1605 3 869 1787 🉑 🉑 🉑 🉑 🉑 👀 R755 1 1588 2 451 1933 🉑 🉑 👀 🉑 😅 😅 R758 1+2 1608 3 522 2059 🉑 🉑 🉑 🉑 👀 😅 😅 GR18 gr 1615 3 816 2031 🉑 🉑 🉑 🉑 🉑 👀 😅 😅 Hello2022 1621 N/A skip N/A 🉑 🉑 🉑 🉑 🉑 😅 😅 😅 😅 R765 2 1625 4 140 2191 🉑 🉑 🉑 🉑 👀 R766 2 1627 3 1275 1678 🉑 🉑 🉑 🉑 🉑 🉑 EDU121 edu 1626 4 vp 🉑 🉑 🉑 🉑 🉑 👀 R767 2 1629 4 305 1988 🉑 🉑 R767 1 1628 N/A N/A N/A 🉑 🉑 🉑 🉑 😅 😅 R768 2 1631 3 2765 1435 🉑 🉑 R768 1 1630 N/A N/A N/A 🉑 🉑 👀 👀 😅 😅 R769 2 1632 3 1620 1661 🉑 🉑 🉑 🉑 🉑 EDU122 edu 1633 4 vp 🉑 🉑 🉑 🉑 🉑 👀 GR19 gr 1637 4 1047 1975 🉑 🉑 🉑 🉑 🉑 🉑 😅 😅 R771 2 1638 4 521 1936 🉑 🉑 🉑 🉑 🉑 😅 R772 2 1635 5 121 2204 🉑 🉑 🉑 🉑 🉑 🉑 EDU123 edu 1644 5 365 1968 🉑 🉑 🉑 🉑 🉑 😅 R773 1 1641 2 689 1884 🉑 🉑 👀 😅 😅 😅 R777 2 1647 4 549 1908 🉑 🉑 🉑 🉑 👀 👀 R781 2 1665 2 3461 1276 🉑 🉑 🉑 🉑 🉑 EDU126 edu 1661 4 311 2001 🉑 🉑 🉑 🉑 🉑 🉑 R785 2 1673 3 1368 1624 🉑 🉑 🉑 👀 👀 👀 EDU128 edu 1680 3 958 1742 🉑 🉑 🉑 👀 👀 👀 R796 1 1687 N/A N/A N/A 🉑 🉑 🉑 👀 😅 😅 R796 2 1688 5 181 2034 🉑 🉑 🉑 R801 2 1695 3." property="og:description"/>
<meta content="https://oi.imyangty.com/summary-codeforces/" property="og:url"/>
<meta content="清烛的博客" property="og:site_name"/>
<meta content="article" property="og:type"/><meta content="Post" property="article:section"/><meta content="Codeforces" property="article:tag"/><meta content="OI" property="article:tag"/><meta content="解题报告" property="article:tag"/><meta content="模拟" property="article:tag"/><meta content="构造" property="article:tag"/><meta content="贪心" property="article:tag"/><meta content="博弈论" property="article:tag"/><meta content="动态规划" property="article:tag"/><meta content="组合数学" property="article:tag"/><meta content="生成函数" property="article:tag"/><meta content="线段树" property="article:tag"/><meta content="二分图" property="article:tag"/><meta content="二分答案" property="article:tag"/><meta content="拓扑排序" property="article:tag"/><meta content="强连通分量" property="article:tag"/><meta content="长链剖分" property="article:tag"/><meta content="数论" property="article:tag"/><meta content="根号分治" property="article:tag"/><meta content="2021-02-17T18:11:15+08:00" property="article:published_time"/><meta content="2021-02-17T18:11:15+08:00" property="article:modified_time"/><meta content="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg1.webp" property="og:image"/>
<meta content="Codeforces 比赛日记" name="twitter:title"/>
<meta content="Round div id sol rk perf A B C D E F G H I R670 2 1406 0 9207 🉑 🉑 🉑 🉑 🉑 R695 2 1467 1 6299 🉑 👀 👀 👀 👀 R697 3 1475 4 N/A 🉑 🉑 🉑 🉑 🉑 🉑 🉑 R698 2 1478 2 4882 🉑 🉑 R698 1 1477 N/A N/A 👀 👀 👀 😅 😅 😅 EDU103 edu 1476 2 4551 🉑 🉑 🉑 🉑 🉑 😅 😅 R699 2 1481 3 2113 🉑 🉑 🉑 🉑 🉑 👀 R700 2 1480 2 6974 🉑 🉑 R700 1 1479 N/A N/A 🉑 🉑 🉑 🉑 😅 R701 2 1485 1 vp 🉑 🉑 🉑 🉑 🉑 🉑 EDU104 edu 1487 2 4964 🉑 🉑 🉑 🉑 👀 👀 👀 R702 3 1490 5 1352 🉑 🉑 🉑 🉑 🉑 🉑 🉑 R705 2 1493 3 869 🉑 🉑 👀 🉑 👀 👀 R706 2 1496 3 1792 🉑 🉑 R706 1 1495 N/A N/A 🉑 🉑 🉑 👀 😅 😅 R707 2 1501 2 1320 🉑 🉑 R707 1 1500 N/A N/A 🉑 👀 👀 😅 😅 😅 R712 2 1504 1 8171 🉑 👀 R712 1 1503 N/A N/A 👀 👀 👀 😅 😅 😅 R718 1+2 1517 vp 🉑 🉑 🉑 🉑 👀 😅 😅 😅 HSSC21 1+2 1553 5 vp 🉑 🉑 🉑 🉑 🉑 🉑 🉑 👀 😅 R733 1+2 1530 4 vp 🉑 🉑 🉑 🉑 R736 2 1549 4 373 🉑 🉑 R736 1 1548 N/A N/A 🉑 🉑 🉑 👀 😅 R737 2 1557 3 463 🉑 🉑 🉑 👀 👀 R738 2 1559 4 1780 🉑 🉑 🉑 🉑 🉑 R740 2 1561 4 1738 🉑 🉑 R740 1 1558 N/A N/A 🉑 🉑 👀 👀 😅 😅 R741 2 1562 2 3894 🉑 👀 🉑 👀 👀 👀 DR 2021 1+2 1556 4 vp 🉑 🉑 🉑 🉑 🉑 👀 😅 😅 R742 2 1567 3 2622 🉑 🉑 🉑 🉑 🉑 🉑 R743 2 1573 4 vp 🉑 🉑 R743 1 1572 N/A N/A 🉑 🉑 🉑 🉑 🉑 😅 EDU113 edu 1569 2 8249 🉑 🉑 🉑 👀 👀 😅 GR17 gr 1566 4 4019 1330 🉑 🉑 🉑 🉑 🉑 EDU114 edu 1574 3 1807 1585 🉑 🉑 🉑 🉑 👀 😅 R745 2 1581 3 279 1886 🉑 🉑 R745 1 1580 N/A N/A N/A 🉑 👀 👀 👀 😅 😅 R746 2 1592 3 550 1928 🉑 🉑 🉑 🉑 👀 👀 R747 2 1594 5 605 1825 🉑 🉑 🉑 🉑 🉑 🉑 EDU115 edu 1598 4 581 1825 🉑 🉑 🉑 🉑 🉑 🉑 😅 R749 1+2 1586 5 349 2284 🉑 🉑 🉑 🉑 🉑 🉑 👀 😅 😅 R750 2 1582 4 1738 1514 🉑 🉑 🉑 🉑 🉑 👀 👀 R754 2 1605 3 869 1787 🉑 🉑 🉑 🉑 🉑 👀 R755 1 1588 2 451 1933 🉑 🉑 👀 🉑 😅 😅 R758 1+2 1608 3 522 2059 🉑 🉑 🉑 🉑 👀 😅 😅 GR18 gr 1615 3 816 2031 🉑 🉑 🉑 🉑 🉑 👀 😅 😅 Hello2022 1621 N/A skip N/A 🉑 🉑 🉑 🉑 🉑 😅 😅 😅 😅 R765 2 1625 4 140 2191 🉑 🉑 🉑 🉑 👀 R766 2 1627 3 1275 1678 🉑 🉑 🉑 🉑 🉑 🉑 EDU121 edu 1626 4 vp 🉑 🉑 🉑 🉑 🉑 👀 R767 2 1629 4 305 1988 🉑 🉑 R767 1 1628 N/A N/A N/A 🉑 🉑 🉑 🉑 😅 😅 R768 2 1631 3 2765 1435 🉑 🉑 R768 1 1630 N/A N/A N/A 🉑 🉑 👀 👀 😅 😅 R769 2 1632 3 1620 1661 🉑 🉑 🉑 🉑 🉑 EDU122 edu 1633 4 vp 🉑 🉑 🉑 🉑 🉑 👀 GR19 gr 1637 4 1047 1975 🉑 🉑 🉑 🉑 🉑 🉑 😅 😅 R771 2 1638 4 521 1936 🉑 🉑 🉑 🉑 🉑 😅 R772 2 1635 5 121 2204 🉑 🉑 🉑 🉑 🉑 🉑 EDU123 edu 1644 5 365 1968 🉑 🉑 🉑 🉑 🉑 😅 R773 1 1641 2 689 1884 🉑 🉑 👀 😅 😅 😅 R777 2 1647 4 549 1908 🉑 🉑 🉑 🉑 👀 👀 R781 2 1665 2 3461 1276 🉑 🉑 🉑 🉑 🉑 EDU126 edu 1661 4 311 2001 🉑 🉑 🉑 🉑 🉑 🉑 R785 2 1673 3 1368 1624 🉑 🉑 🉑 👀 👀 👀 EDU128 edu 1680 3 958 1742 🉑 🉑 🉑 👀 👀 👀 R796 1 1687 N/A N/A N/A 🉑 🉑 🉑 👀 😅 😅 R796 2 1688 5 181 2034 🉑 🉑 🉑 R801 2 1695 3." name="twitter:description"/><meta content="summary_large_image" name="twitter:card"/>
<meta content="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg1.webp" name="twitter:image"/>
<link href="https://q1.qlogo.cn/g?b=qq&amp;nk=375836877&amp;s=5" rel="shortcut icon"/>
<link href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/styles/github-dark-dimmed.min.css" rel="stylesheet"/>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
</head>
<body class="article-page">
<script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky">
<button aria-label="切换菜单" class="hamburger hamburger--spin" id="toggle-menu" type="button">
<span class="hamburger-box">
<span class="hamburger-inner"></span>
</span>
</button>
<header>
<figure class="site-avatar">
<a href="/">
<img alt="Avatar" class="site-logo" height="300" loading="lazy" src="/img/avatar_huea3ce2119467b51fdd2a81393644a76d_51594_300x0_resize_q75_box.jpg" width="300"/>
</a>
<span class="emoji">😅</span>
</figure>
<div class="site-meta">
<h1 class="site-name"><a href="/">清烛的博客</a></h1>
<h2 class="site-description">烟火已谢，笙歌未停</h2>
</div>
</header><ol class="social-menu">
<li>
<a href="mailto:i@imyangty.com" target="_blank" title="email">
<svg class="icon icon-tabler icon-tabler-mail" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
<rect height="14" rx="2" width="18" x="3" y="5"></rect>
<polyline points="3 7 12 13 21 7"></polyline>
</svg>
</a>
</li>
<li>
<a href="https://github.com/Cgfyufsygsm" target="_blank" title="GitHub">
<svg class="icon icon-tabler icon-tabler-brand-github" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
<path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5"></path>
</svg>
</a>
</li>
<li>
<a href="https://t.me/Cgfyufsygsm" target="_blank" title="Telegram">
<svg class="icon icon-tabler icon-tabler-brand-telegram" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
<path d="M15 10l-4 4l6 6l4 -16l-18 7l4 2l2 6l3 -4"></path>
</svg>
</a>
</li>
<li>
<a href="https://twitter.com/Cgfyufsygsm" target="_blank" title="Twitter">
<svg class="icon icon-tabler icon-tabler-brand-twitter" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
<path d="M22 4.01c-1 .49 -1.98 .689 -3 .99c-1.121 -1.265 -2.783 -1.335 -4.38 -.737s-2.643 2.06 -2.62 3.737v1c-3.245 .083 -6.135 -1.395 -8 -4c0 0 -4.182 7.433 4 11c-1.872 1.247 -3.739 2.088 -6 2c3.308 1.803 6.913 2.423 10.034 1.517c3.58 -1.04 6.522 -3.723 7.651 -7.742a13.84 13.84 0 0 0 .497 -3.753c-.002 -.249 1.51 -2.772 1.818 -4.013z"></path>
</svg>
</a>
</li>
</ol><ol class="menu" id="main-menu">
<li>
<a href="/">
<svg class="icon icon-tabler icon-tabler-home" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<polyline points="5 12 3 12 12 3 21 12 19 12"></polyline>
<path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7"></path>
<path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6"></path>
</svg>
<span>主页</span>
</a>
</li>
<li>
<a href="/about/">
<svg class="icon icon-tabler icon-tabler-user" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<circle cx="12" cy="7" r="4"></circle>
<path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2"></path>
</svg>
<span>关于</span>
</a>
</li>
<li>
<a href="/idx/">
<svg class="icon icon-tabler icon-tabler-hash" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<line x1="5" x2="19" y1="9" y2="9"></line>
<line x1="5" x2="19" y1="15" y2="15"></line>
<line x1="11" x2="7" y1="4" y2="20"></line>
<line x1="17" x2="13" y1="4" y2="20"></line>
</svg>
<span>导航</span>
</a>
</li>
<li>
<a href="/archives/">
<svg class="icon icon-tabler icon-tabler-archive" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<rect height="4" rx="2" width="18" x="3" y="4"></rect>
<path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10"></path>
<line x1="10" x2="14" y1="12" y2="12"></line>
</svg>
<span>归档</span>
</a>
</li>
<li>
<a href="/search/">
<svg class="icon icon-tabler icon-tabler-search" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<circle cx="10" cy="10" r="7"></circle>
<line x1="21" x2="15" y1="21" y2="15"></line>
</svg>
<span>搜索</span>
</a>
</li>
<li>
<a href="/friends/">
<svg class="icon icon-tabler icon-tabler-link" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5"></path>
<path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5"></path>
</svg>
<span>友链</span>
</a>
</li>
<li>
<a href="https://blog.imyangty.com" target="_blank">
<svg class="icon icon-tabler icon-tabler-home" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<polyline points="5 12 3 12 12 3 21 12 19 12"></polyline>
<path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7"></path>
<path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6"></path>
</svg>
<span>主博客</span>
</a>
</li>
<div class="menu-bottom-section">
<li id="dark-mode-toggle">
<svg class="icon icon-tabler icon-tabler-toggle-left" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<circle cx="8" cy="12" r="2"></circle>
<rect height="12" rx="6" width="20" x="2" y="6"></rect>
</svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<circle cx="16" cy="12" r="2"></circle>
<rect height="12" rx="6" width="20" x="2" y="6"></rect>
</svg>
<span>暗色模式</span>
</li>
</div>
</ol>
</aside>
<main class="main full-width">
<article class="has-image main-article">
<header class="article-header">
<div class="article-image">
<a href="/summary-codeforces/">
<img alt="Featured image of post Codeforces 比赛日记" loading="lazy" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg1.webp"/>
</a>
</div>
<div class="article-details">
<header class="article-category">
<a href="/categories/oi/">
                OI
            </a>
<a href="/categories/summary/">
                总结
            </a>
</header>
<div class="article-title-wrapper">
<h2 class="article-title">
<a href="/summary-codeforces/">Codeforces 比赛日记</a>
</h2>
</div>
<footer class="article-time">
<div>
<svg class="icon icon-tabler icon-tabler-calendar-time" fill="none" height="56" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="56" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4"></path>
<circle cx="18" cy="18" r="4"></circle>
<path d="M15 3v4"></path>
<path d="M7 3v4"></path>
<path d="M3 11h16"></path>
<path d="M18 16.496v1.504l1 1"></path>
</svg>
<time class="article-time--published">Feb 17, 2021</time>
</div>
<div>
<svg class="icon icon-tabler icon-tabler-clock" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<circle cx="12" cy="12" r="9"></circle>
<polyline points="12 7 12 12 15 15"></polyline>
</svg>
<time class="article-time--reading">
                    阅读时长: 69 分钟
                </time>
</div>
</footer>
</div>
</header>
<section class="article-content">
<div class="table-wrapper"><table>
<thead>
<tr class="header">
<th>Round</th>
<th>div</th>
<th>id</th>
<th>sol</th>
<th>rk</th>
<th>perf</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
<th>H</th>
<th>I</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>R670</td>
<td>2</td>
<td>1406</td>
<td>0</td>
<td>9207</td>
<td></td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>R695</td>
<td>2</td>
<td>1467</td>
<td>1</td>
<td>6299</td>
<td></td>
<td>🉑</td>
<td>👀</td>
<td>👀</td>
<td>👀</td>
<td>👀</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>R697</td>
<td>3</td>
<td>1475</td>
<td>4</td>
<td>N/A</td>
<td></td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>R698</td>
<td>2</td>
<td>1478</td>
<td>2</td>
<td>4882</td>
<td></td>
<td>🉑</td>
<td>🉑</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>R698</td>
<td>1</td>
<td>1477</td>
<td>N/A</td>
<td>N/A</td>
<td></td>
<td>👀</td>
<td>👀</td>
<td>👀</td>
<td>😅</td>
<td>😅</td>
<td>😅</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>EDU103</td>
<td>edu</td>
<td>1476</td>
<td>2</td>
<td>4551</td>
<td></td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>😅</td>
<td>😅</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>R699</td>
<td>2</td>
<td>1481</td>
<td>3</td>
<td>2113</td>
<td></td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>👀</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>R700</td>
<td>2</td>
<td>1480</td>
<td>2</td>
<td>6974</td>
<td></td>
<td>🉑</td>
<td>🉑</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>R700</td>
<td>1</td>
<td>1479</td>
<td>N/A</td>
<td>N/A</td>
<td></td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>😅</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>R701</td>
<td>2</td>
<td>1485</td>
<td>1</td>
<td>vp</td>
<td></td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>EDU104</td>
<td>edu</td>
<td>1487</td>
<td>2</td>
<td>4964</td>
<td></td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>👀</td>
<td>👀</td>
<td>👀</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>R702</td>
<td>3</td>
<td>1490</td>
<td>5</td>
<td>1352</td>
<td></td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>R705</td>
<td>2</td>
<td>1493</td>
<td>3</td>
<td>869</td>
<td></td>
<td>🉑</td>
<td>🉑</td>
<td>👀</td>
<td>🉑</td>
<td>👀</td>
<td>👀</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>R706</td>
<td>2</td>
<td>1496</td>
<td>3</td>
<td>1792</td>
<td></td>
<td>🉑</td>
<td>🉑</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>R706</td>
<td>1</td>
<td>1495</td>
<td>N/A</td>
<td>N/A</td>
<td></td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>👀</td>
<td>😅</td>
<td>😅</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>R707</td>
<td>2</td>
<td>1501</td>
<td>2</td>
<td>1320</td>
<td></td>
<td>🉑</td>
<td>🉑</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>R707</td>
<td>1</td>
<td>1500</td>
<td>N/A</td>
<td>N/A</td>
<td></td>
<td>🉑</td>
<td>👀</td>
<td>👀</td>
<td>😅</td>
<td>😅</td>
<td>😅</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>R712</td>
<td>2</td>
<td>1504</td>
<td>1</td>
<td>8171</td>
<td></td>
<td>🉑</td>
<td>👀</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>R712</td>
<td>1</td>
<td>1503</td>
<td>N/A</td>
<td>N/A</td>
<td></td>
<td>👀</td>
<td>👀</td>
<td>👀</td>
<td>😅</td>
<td>😅</td>
<td>😅</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>R718</td>
<td>1+2</td>
<td>1517</td>
<td></td>
<td>vp</td>
<td></td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>👀</td>
<td>😅</td>
<td>😅</td>
<td>😅</td>
<td></td>
</tr>
<tr class="odd">
<td>HSSC21</td>
<td>1+2</td>
<td>1553</td>
<td>5</td>
<td>vp</td>
<td></td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>👀</td>
<td>😅</td>
</tr>
<tr class="even">
<td>R733</td>
<td>1+2</td>
<td>1530</td>
<td>4</td>
<td>vp</td>
<td></td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>R736</td>
<td>2</td>
<td>1549</td>
<td>4</td>
<td>373</td>
<td></td>
<td>🉑</td>
<td>🉑</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>R736</td>
<td>1</td>
<td>1548</td>
<td>N/A</td>
<td>N/A</td>
<td></td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>👀</td>
<td>😅</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>R737</td>
<td>2</td>
<td>1557</td>
<td>3</td>
<td>463</td>
<td></td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>👀</td>
<td>👀</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>R738</td>
<td>2</td>
<td>1559</td>
<td>4</td>
<td>1780</td>
<td></td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>R740</td>
<td>2</td>
<td>1561</td>
<td>4</td>
<td>1738</td>
<td></td>
<td>🉑</td>
<td>🉑</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>R740</td>
<td>1</td>
<td>1558</td>
<td>N/A</td>
<td>N/A</td>
<td></td>
<td>🉑</td>
<td>🉑</td>
<td>👀</td>
<td>👀</td>
<td>😅</td>
<td>😅</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>R741</td>
<td>2</td>
<td>1562</td>
<td>2</td>
<td>3894</td>
<td></td>
<td>🉑</td>
<td>👀</td>
<td>🉑</td>
<td>👀</td>
<td>👀</td>
<td>👀</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>DR 2021</td>
<td>1+2</td>
<td>1556</td>
<td>4</td>
<td>vp</td>
<td></td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>👀</td>
<td>😅</td>
<td>😅</td>
<td></td>
</tr>
<tr class="odd">
<td>R742</td>
<td>2</td>
<td>1567</td>
<td>3</td>
<td>2622</td>
<td></td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>R743</td>
<td>2</td>
<td>1573</td>
<td>4</td>
<td>vp</td>
<td></td>
<td>🉑</td>
<td>🉑</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>R743</td>
<td>1</td>
<td>1572</td>
<td>N/A</td>
<td>N/A</td>
<td></td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>😅</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>EDU113</td>
<td>edu</td>
<td>1569</td>
<td>2</td>
<td>8249</td>
<td></td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>👀</td>
<td>👀</td>
<td>😅</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>GR17</td>
<td>gr</td>
<td>1566</td>
<td>4</td>
<td>4019</td>
<td>1330</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>EDU114</td>
<td>edu</td>
<td>1574</td>
<td>3</td>
<td>1807</td>
<td>1585</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>👀</td>
<td>😅</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>R745</td>
<td>2</td>
<td>1581</td>
<td>3</td>
<td>279</td>
<td>1886</td>
<td>🉑</td>
<td>🉑</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>R745</td>
<td>1</td>
<td>1580</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
<td>🉑</td>
<td>👀</td>
<td>👀</td>
<td>👀</td>
<td>😅</td>
<td>😅</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>R746</td>
<td>2</td>
<td>1592</td>
<td>3</td>
<td>550</td>
<td>1928</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>👀</td>
<td>👀</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>R747</td>
<td>2</td>
<td>1594</td>
<td>5</td>
<td>605</td>
<td>1825</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>EDU115</td>
<td>edu</td>
<td>1598</td>
<td>4</td>
<td>581</td>
<td>1825</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>😅</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>R749</td>
<td>1+2</td>
<td>1586</td>
<td>5</td>
<td>349</td>
<td>2284</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>👀</td>
<td>😅</td>
<td>😅</td>
</tr>
<tr class="odd">
<td>R750</td>
<td>2</td>
<td>1582</td>
<td>4</td>
<td>1738</td>
<td>1514</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>👀</td>
<td>👀</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>R754</td>
<td>2</td>
<td>1605</td>
<td>3</td>
<td>869</td>
<td>1787</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>👀</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>R755</td>
<td>1</td>
<td>1588</td>
<td>2</td>
<td>451</td>
<td>1933</td>
<td>🉑</td>
<td>🉑</td>
<td>👀</td>
<td>🉑</td>
<td>😅</td>
<td>😅</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>R758</td>
<td>1+2</td>
<td>1608</td>
<td>3</td>
<td>522</td>
<td>2059</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>👀</td>
<td>😅</td>
<td>😅</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>GR18</td>
<td>gr</td>
<td>1615</td>
<td>3</td>
<td>816</td>
<td>2031</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>👀</td>
<td>😅</td>
<td>😅</td>
<td></td>
</tr>
<tr class="even">
<td>Hello2022</td>
<td></td>
<td>1621</td>
<td>N/A</td>
<td>skip</td>
<td>N/A</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>😅</td>
<td>😅</td>
<td>😅</td>
<td>😅</td>
</tr>
<tr class="odd">
<td>R765</td>
<td>2</td>
<td>1625</td>
<td>4</td>
<td>140</td>
<td>2191</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>👀</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>R766</td>
<td>2</td>
<td>1627</td>
<td>3</td>
<td>1275</td>
<td>1678</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>EDU121</td>
<td>edu</td>
<td>1626</td>
<td>4</td>
<td>vp</td>
<td></td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>👀</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>R767</td>
<td>2</td>
<td>1629</td>
<td>4</td>
<td>305</td>
<td>1988</td>
<td>🉑</td>
<td>🉑</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>R767</td>
<td>1</td>
<td>1628</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>😅</td>
<td>😅</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>R768</td>
<td>2</td>
<td>1631</td>
<td>3</td>
<td>2765</td>
<td>1435</td>
<td>🉑</td>
<td>🉑</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>R768</td>
<td>1</td>
<td>1630</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
<td>🉑</td>
<td>🉑</td>
<td>👀</td>
<td>👀</td>
<td>😅</td>
<td>😅</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>R769</td>
<td>2</td>
<td>1632</td>
<td>3</td>
<td>1620</td>
<td>1661</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>EDU122</td>
<td>edu</td>
<td>1633</td>
<td>4</td>
<td>vp</td>
<td></td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>👀</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>GR19</td>
<td>gr</td>
<td>1637</td>
<td>4</td>
<td>1047</td>
<td>1975</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>😅</td>
<td>😅</td>
<td></td>
</tr>
<tr class="odd">
<td>R771</td>
<td>2</td>
<td>1638</td>
<td>4</td>
<td>521</td>
<td>1936</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>😅</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>R772</td>
<td>2</td>
<td>1635</td>
<td>5</td>
<td>121</td>
<td>2204</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>EDU123</td>
<td>edu</td>
<td>1644</td>
<td>5</td>
<td>365</td>
<td>1968</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>😅</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>R773</td>
<td>1</td>
<td>1641</td>
<td>2</td>
<td>689</td>
<td>1884</td>
<td>🉑</td>
<td>🉑</td>
<td>👀</td>
<td>😅</td>
<td>😅</td>
<td>😅</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>R777</td>
<td>2</td>
<td>1647</td>
<td>4</td>
<td>549</td>
<td>1908</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>👀</td>
<td>👀</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>R781</td>
<td>2</td>
<td>1665</td>
<td>2</td>
<td>3461</td>
<td>1276</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>EDU126</td>
<td>edu</td>
<td>1661</td>
<td>4</td>
<td>311</td>
<td>2001</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>R785</td>
<td>2</td>
<td>1673</td>
<td>3</td>
<td>1368</td>
<td>1624</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>👀</td>
<td>👀</td>
<td>👀</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>EDU128</td>
<td>edu</td>
<td>1680</td>
<td>3</td>
<td>958</td>
<td>1742</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>👀</td>
<td>👀</td>
<td>👀</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>R796</td>
<td>1</td>
<td>1687</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>👀</td>
<td>😅</td>
<td>😅</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>R796</td>
<td>2</td>
<td>1688</td>
<td>5</td>
<td>181</td>
<td>2034</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>R801</td>
<td>2</td>
<td>1695</td>
<td>3.5</td>
<td>332</td>
<td>2038</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>R802</td>
<td>2</td>
<td>1700</td>
<td>4</td>
<td>240</td>
<td>2044</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>👀</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>R807</td>
<td>2</td>
<td>1705</td>
<td>5</td>
<td>140</td>
<td>2206</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>👀</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>TON R2</td>
<td>1+2</td>
<td>1704</td>
<td>5</td>
<td>424</td>
<td>2303</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>👀</td>
<td>😅</td>
<td>😅</td>
<td></td>
</tr>
<tr class="even">
<td>R812</td>
<td>2</td>
<td>1713</td>
<td>4</td>
<td>226</td>
<td>2138</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>👀</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>R813</td>
<td>2</td>
<td>1712</td>
<td>5</td>
<td>88</td>
<td>2318</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>👀</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>R815</td>
<td>2</td>
<td>1720</td>
<td>5</td>
<td>287</td>
<td>2042</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>👀</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table></div>
<h2 id="codeforces-round-670-div.-2">Codeforces Round #670 (Div. 2)</h2>
<p>打的第一场 CF 然而一题都没做出来。</p>
<h3 id="d---three-sequences">1406D - Three Sequences</h3>
<p>题意：给定 <span class="math inline">\(a_i\)</span>，要求构造一个不减序列 <span class="math inline">\(b_i\)</span> 和一个不增序列 <span class="math inline">\(c_i\)</span> 使得 <span class="math inline">\(a_i = b_i + c_i\)</span>。请最小化 <span class="math inline">\(\max\{b_i, c_i\}\)</span>。<span class="math inline">\(q\)</span> 次操作，每次可以对 <span class="math inline">\(a_l, a_{l + 1},\cdots , a_r\)</span> 加上 <span class="math inline">\(x\)</span>。问每次修改后的最小的 <span class="math inline">\(\max\{b_i, c_i\}\)</span>。</p>
<p>一个比较奇妙的贪心。我们注意到答案为 <span class="math inline">\(\max(b_n, c_1)\)</span>。而我们发现，对于 <span class="math inline">\(a_{i + 1} &gt; a_i\)</span>，我们若是调整在 <span class="math inline">\(c\)</span> 上，则不优；但如若调整 <span class="math inline">\(b\)</span>，则因为 <span class="math inline">\(b\)</span> 递增，所以令 <span class="math inline">\(b_{i + 1} = b_i + a_{i + 1} - a_i\)</span> 是最优的。而 <span class="math inline">\(a_{i + 1} &lt; a_i\)</span> 时，我们若是调整 <span class="math inline">\(c\)</span>，则 <span class="math inline">\(c_{i + 1} = c_i + a_{i +1} - a_i\)</span> 是最优的。</p>
<p>好，那么我们可以知道，<span class="math inline">\(a_1 = b_1 + c_1 = b_n - \sum_{i = 2}^n(b_i - b_{i - 1}) + c_1\)</span>。故令 <span class="math inline">\(b_n\)</span> 和 <span class="math inline">\(c_1\)</span> 尽量接近最优。答案为 <span class="math inline">\(\displaystyle\lceil\frac{a_1 + \sum_{i = 2}^n(b_i - b_{i - 1})}{2}\rceil\)</span>。</p>
<p>而 <span class="math inline">\(\sum_{i = 2}^n(b_i - b_{i - 1}) = \sum_{i = 2}^n(a_i - a_{i - 1})\cdot[a_i &gt; a_{i - 1}]\)</span>。这个东西应该是可以 <span class="math inline">\(O(1)\)</span> 维护的。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a aria-hidden="true" href="#cb1-1"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">1e5</span> + <span class="dv">5</span>;</span>
<span id="cb1-2"><a aria-hidden="true" href="#cb1-2"></a><span class="kw">using</span> ll = <span class="dt">long</span> <span class="dt">long</span>;</span>
<span id="cb1-3"><a aria-hidden="true" href="#cb1-3"></a><span class="dt">int</span> n, q;</span>
<span id="cb1-4"><a aria-hidden="true" href="#cb1-4"></a>ll a[maxn], d[maxn];</span>
<span id="cb1-5"><a aria-hidden="true" href="#cb1-5"></a></span>
<span id="cb1-6"><a aria-hidden="true" href="#cb1-6"></a><span class="dt">int</span> main() {</span>
<span id="cb1-7"><a aria-hidden="true" href="#cb1-7"></a>    read(n);</span>
<span id="cb1-8"><a aria-hidden="true" href="#cb1-8"></a>    FOR(i, <span class="dv">1</span>, n) read(a[i]), d[i] = a[i] - a[i - <span class="dv">1</span>];</span>
<span id="cb1-9"><a aria-hidden="true" href="#cb1-9"></a>    ll sum = <span class="dv">0</span>;</span>
<span id="cb1-10"><a aria-hidden="true" href="#cb1-10"></a>    FOR(i, <span class="dv">2</span>, n) <span class="cf">if</span> (d[i] &gt; <span class="dv">0</span>) sum += d[i];</span>
<span id="cb1-11"><a aria-hidden="true" href="#cb1-11"></a>    print((ll)ceil((sum + d[<span class="dv">1</span>]) * <span class="fl">0.5</span>));</span>
<span id="cb1-12"><a aria-hidden="true" href="#cb1-12"></a>    <span class="dt">int</span> q; read(q);</span>
<span id="cb1-13"><a aria-hidden="true" href="#cb1-13"></a>    <span class="cf">while</span> (q--) {</span>
<span id="cb1-14"><a aria-hidden="true" href="#cb1-14"></a>        <span class="dt">int</span> l, r; ll x;</span>
<span id="cb1-15"><a aria-hidden="true" href="#cb1-15"></a>        read(l, r, x), ++r;</span>
<span id="cb1-16"><a aria-hidden="true" href="#cb1-16"></a>        ll dl = d[l], dr = d[r];</span>
<span id="cb1-17"><a aria-hidden="true" href="#cb1-17"></a>        d[l] += x, d[r] -= x;</span>
<span id="cb1-18"><a aria-hidden="true" href="#cb1-18"></a>        <span class="cf">if</span> (l != <span class="dv">1</span>) sum += max(d[l], <span class="dv">0</span><span class="bu">ll</span>) - max(dl, <span class="dv">0</span><span class="bu">ll</span>);</span>
<span id="cb1-19"><a aria-hidden="true" href="#cb1-19"></a>        <span class="cf">if</span> (r != n + <span class="dv">1</span>) sum += max(d[r], <span class="dv">0</span><span class="bu">ll</span>) - max(dr, <span class="dv">0</span><span class="bu">ll</span>);</span>
<span id="cb1-20"><a aria-hidden="true" href="#cb1-20"></a>        print((ll)ceil((sum + d[<span class="dv">1</span>]) * <span class="fl">0.5</span>));</span>
<span id="cb1-21"><a aria-hidden="true" href="#cb1-21"></a>    }</span>
<span id="cb1-22"><a aria-hidden="true" href="#cb1-22"></a>    <span class="cf">return</span> output(), <span class="dv">0</span>;</span>
<span id="cb1-23"><a aria-hidden="true" href="#cb1-23"></a>}</span></code></pre></div>
<h3 id="e---deleting-numbers">1406E - Deleting Numbers</h3>
<p>交互题。交互库给定一个数字 <span class="math inline">\(n\)</span>，要你猜一个数字 <span class="math inline">\(x\)</span>（<span class="math inline">\(1\le x\le n\)</span>）。一开始你有一个集合 <span class="math inline">\(\{1, 2,\cdots, n\}\)</span>，你可以进行至多 <span class="math inline">\(10000\)</span> 次操作：</p>
<ul>
<li><code>A a</code>：询问当前集合中有多少数为 <span class="math inline">\(a\)</span> 的倍数。</li>
<li><code>B a</code>：询问当前集合中有多少数为 <span class="math inline">\(a\)</span> 的倍数，并将他们全部删掉。<strong><span class="math inline">\(x\)</span> 不会被删掉。</strong></li>
<li><code>C a</code>：告诉交互库答案为 <span class="math inline">\(a\)</span>。</li>
</ul>
<p><span class="math inline">\(1\le x\le n\le 10^5\)</span>。</p>
<p>首先，有一种很朴素的想法是枚举每个质数，删除其倍数然后判断 <span class="math inline">\(x\)</span> 是否有这一个质因子 <span class="math inline">\(p\)</span>，然后就依次枚举 <span class="math inline">\(p^k\)</span> 并询问 <code>A p^k</code> 直到收到的答案为 <span class="math inline">\(0\)</span>，那么 <span class="math inline">\(x\)</span> 就有一部分 <span class="math inline">\(p^{k - 1}\)</span>，根据唯一分解定理，我们这样子就能确定 <span class="math inline">\(x\)</span>。</p>
<p>令 <span class="math inline">\(\tau(n)\)</span> 为 <span class="math inline">\([1, n]\)</span> 中质数的幂的数量，<span class="math inline">\(\pi(n)\)</span> 为 <span class="math inline">\([1, n]\)</span> 中质数个数。发现 <span class="math inline">\(\pi(10^5) = 9592\)</span>，<span class="math inline">\(\tau(10^5) = 9700\)</span>。上面这个做法的询问次数为 <span class="math inline">\(\pi(n) + \tau(n) + 1\)</span>，显然要寄。</p>
<p>考虑优化。一个很常见的结论是，考虑根号分治，将质因子分为 <span class="math inline">\(\le \sqrt n\)</span> 和 <span class="math inline">\(&gt;\sqrt n\)</span> 两部分，则 <span class="math inline">\(&gt; \sqrt n\)</span> 的一定只有一个。</p>
<p>对于 <span class="math inline">\(\le \sqrt n\)</span> 的部分，我们直接用上面的方法暴力，操作次数为 <span class="math inline">\(\pi(\sqrt n) + \tau(\sqrt n)\le 238\)</span>。对于 <span class="math inline">\(&gt; \sqrt n\)</span> 的部分，我们考虑分块，每次删 <span class="math inline">\(100\)</span> 个质数，删了之后询问被删掉的数是否为 <span class="math inline">\(100\)</span> 个，如果不是，那么直接暴力找这个 <span class="math inline">\(&gt;\sqrt n\)</span> 的质因子就能得到答案了。</p>
<p>细节有点烦人，一定要小心。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a aria-hidden="true" href="#cb2-1"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">1e5</span> + <span class="dv">5</span>;</span>
<span id="cb2-2"><a aria-hidden="true" href="#cb2-2"></a><span class="dt">int</span> vis[maxn], p[maxn], tot, n;</span>
<span id="cb2-3"><a aria-hidden="true" href="#cb2-3"></a></span>
<span id="cb2-4"><a aria-hidden="true" href="#cb2-4"></a><span class="dt">int</span> ask(<span class="dt">int</span> a, <span class="dt">char</span> c) {</span>
<span id="cb2-5"><a aria-hidden="true" href="#cb2-5"></a>    cout &lt;&lt; c &lt;&lt; <span class="ch">' '</span> &lt;&lt; a &lt;&lt; endl &lt;&lt; flush;</span>
<span id="cb2-6"><a aria-hidden="true" href="#cb2-6"></a>    <span class="dt">int</span> x; cin &gt;&gt; x;</span>
<span id="cb2-7"><a aria-hidden="true" href="#cb2-7"></a>    <span class="cf">return</span> x;</span>
<span id="cb2-8"><a aria-hidden="true" href="#cb2-8"></a>}</span>
<span id="cb2-9"><a aria-hidden="true" href="#cb2-9"></a></span>
<span id="cb2-10"><a aria-hidden="true" href="#cb2-10"></a><span class="dt">int</span> main() {</span>
<span id="cb2-11"><a aria-hidden="true" href="#cb2-11"></a>    cin &gt;&gt; n;</span>
<span id="cb2-12"><a aria-hidden="true" href="#cb2-12"></a>    FOR(i, <span class="dv">2</span>, n) {</span>
<span id="cb2-13"><a aria-hidden="true" href="#cb2-13"></a>        <span class="cf">if</span> (!vis[i]) p[++tot] = i;</span>
<span id="cb2-14"><a aria-hidden="true" href="#cb2-14"></a>        <span class="cf">for</span> (<span class="dt">int</span> j = <span class="dv">1</span>; i * p[j] &lt;= n; ++j) {</span>
<span id="cb2-15"><a aria-hidden="true" href="#cb2-15"></a>            vis[i * p[j]] = <span class="dv">1</span>;</span>
<span id="cb2-16"><a aria-hidden="true" href="#cb2-16"></a>            <span class="cf">if</span> (i % p[j] == <span class="dv">0</span>) <span class="cf">break</span>;</span>
<span id="cb2-17"><a aria-hidden="true" href="#cb2-17"></a>        }</span>
<span id="cb2-18"><a aria-hidden="true" href="#cb2-18"></a>    }</span>
<span id="cb2-19"><a aria-hidden="true" href="#cb2-19"></a>    <span class="dt">int</span> B = (<span class="dt">int</span>)ceil(sqrt(<span class="fl">1e5</span>)), ans = <span class="dv">1</span>, i;</span>
<span id="cb2-20"><a aria-hidden="true" href="#cb2-20"></a>    <span class="cf">for</span> (i = <span class="dv">1</span>; i &lt;= tot &amp;&amp; p[i] &lt;= B; ++i) {</span>
<span id="cb2-21"><a aria-hidden="true" href="#cb2-21"></a>        ask(p[i], <span class="ch">'B'</span>);</span>
<span id="cb2-22"><a aria-hidden="true" href="#cb2-22"></a>        <span class="dt">int</span> tmp = p[i], flag = ask(p[i], <span class="ch">'A'</span>);</span>
<span id="cb2-23"><a aria-hidden="true" href="#cb2-23"></a>        <span class="cf">while</span> (flag &amp;&amp; (tmp *= p[i]) &lt;= n) flag = ask(tmp, <span class="ch">'A'</span>);</span>
<span id="cb2-24"><a aria-hidden="true" href="#cb2-24"></a>        ans *= tmp / p[i];</span>
<span id="cb2-25"><a aria-hidden="true" href="#cb2-25"></a>    }</span>
<span id="cb2-26"><a aria-hidden="true" href="#cb2-26"></a>    <span class="cf">for</span> (i; i &lt;= tot; i += <span class="dv">98</span>) {</span>
<span id="cb2-27"><a aria-hidden="true" href="#cb2-27"></a>        <span class="dt">int</span> cnt0 = ask(<span class="dv">1</span>, <span class="ch">'A'</span>), r = min(i + <span class="dv">97</span>, tot);</span>
<span id="cb2-28"><a aria-hidden="true" href="#cb2-28"></a>        FOR(j, i, r) cnt0 -= ask(p[j], <span class="ch">'B'</span>);</span>
<span id="cb2-29"><a aria-hidden="true" href="#cb2-29"></a>        <span class="dt">int</span> cnt1 = ask(<span class="dv">1</span>, <span class="ch">'A'</span>);</span>
<span id="cb2-30"><a aria-hidden="true" href="#cb2-30"></a>        <span class="cf">if</span> (cnt0 != cnt1) {</span>
<span id="cb2-31"><a aria-hidden="true" href="#cb2-31"></a>            FOR(j, i, r) {</span>
<span id="cb2-32"><a aria-hidden="true" href="#cb2-32"></a>                <span class="cf">if</span> (ask(p[j], <span class="ch">'A'</span>)) {</span>
<span id="cb2-33"><a aria-hidden="true" href="#cb2-33"></a>                    ans *= p[j];</span>
<span id="cb2-34"><a aria-hidden="true" href="#cb2-34"></a>                    <span class="cf">break</span>;</span>
<span id="cb2-35"><a aria-hidden="true" href="#cb2-35"></a>                }</span>
<span id="cb2-36"><a aria-hidden="true" href="#cb2-36"></a>            }</span>
<span id="cb2-37"><a aria-hidden="true" href="#cb2-37"></a>            <span class="cf">break</span>;</span>
<span id="cb2-38"><a aria-hidden="true" href="#cb2-38"></a>        }</span>
<span id="cb2-39"><a aria-hidden="true" href="#cb2-39"></a>    }</span>
<span id="cb2-40"><a aria-hidden="true" href="#cb2-40"></a>    cout &lt;&lt; <span class="st">"C "</span> &lt;&lt; ans &lt;&lt; endl &lt;&lt; flush;</span>
<span id="cb2-41"><a aria-hidden="true" href="#cb2-41"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb2-42"><a aria-hidden="true" href="#cb2-42"></a>}</span></code></pre></div>
<h2 id="codeforces-round-698">Codeforces Round 698</h2>
<h3 id="a---nezzar-and-board">1477A - Nezzar and Board</h3>
<p>一开始黑板上写着 <span class="math inline">\(n\le 2\times 10^5\)</span> 个不同整数，给定 <span class="math inline">\(k\)</span>，一次操作可以任意选两个（不一定互异的数）<span class="math inline">\(x,y\)</span> 然后在黑板上加上 <span class="math inline">\(2x-y\)</span>，问有限次操作后能否得到 <span class="math inline">\(k\)</span>。值域 <span class="math inline">\([-10^{18}, 10^{18}]\)</span>。</p>
<p>发现最后形式很像是一个判断满足某种条件的线性组合能不能得到 <span class="math inline">\(k\)</span> 的问题，即裴蜀定理。</p>
<p>发现当 <span class="math inline">\(x_1 = 0\)</span> 的时候，我们可以任意构造 <span class="math inline">\(x_i\)</span> 的倍数，所以当 <span class="math inline">\(\gcd(x_2,\cdots, x_n)\mid k\)</span> 的时候有解。</p>
<p>对于 <span class="math inline">\(x_1\ne 0\)</span> 的情况，就将 <span class="math inline">\(x_2,\cdots, x_n, k\)</span> 全部减去 <span class="math inline">\(x_1\)</span>，根据 <span class="math inline">\(2x-y\)</span> 的过程会发现 <span class="math inline">\(-x_1\)</span> 的偏移量是一直带着走的，没有影响。</p>
<p>当然 Asd_Okuu 教育了另一种思路：考虑 <span class="math inline">\(z = 2x - y\)</span> 的过程是在数轴上做轴对称（钦定 <span class="math inline">\(y&gt;x\)</span>），那么一定有 <span class="math inline">\(z\equiv x\pmod{(y-x)}\)</span>，即我们可以用长度为 <span class="math inline">\(y-x\)</span> 的段来覆盖。所以若存在两个段的长度分别为 <span class="math inline">\(a,b\)</span>，且 <span class="math inline">\(\gcd(a,b) = 1\)</span>，那么这些段线性组合起来是可以把数轴上所有点干碎的，其实也就是裴蜀定理了。</p>
<p>所以将所有数排个序，将差分做 <span class="math inline">\(\gcd\)</span>，发现这样是充分的，搞定了。</p>
<h3 id="b---nezzar-and-binary-string">1477B - Nezzar and Binary String</h3>
<p>一个 0-1 串 <span class="math inline">\(S\)</span>，需要满足第 <span class="math inline">\(i\)</span> 天时 <span class="math inline">\([l_i,r_i]\)</span> 内不同时含 0 和 1，第 <span class="math inline">\(i\)</span> 天结束时可以改变里面<strong>少于</strong> <span class="math inline">\((r_i - l_1 + 1) / 2\)</span> 个字符，同时需要 <span class="math inline">\(q\)</span> 天结束后变成 <span class="math inline">\(T\)</span>，问能否达成。数据范围 <span class="math inline">\(2\times 10^5\)</span>。</p>
<p>正着做太难了，倒着来吧。倒着来就相当于是填平区间，若里面 <span class="math inline">\(0\)</span> 个数等于 <span class="math inline">\(1\)</span> 个数就不可以，否则往改动少的那个去改，就完事了。。。。。拿个分块或者线段树维护就行了。</p>
<h3 id="c---nezzar-and-nice-beatmap">1477C - Nezzar and Nice Beatmap</h3>
<p>给定平面直角坐标系上的 <span class="math inline">\(n\)</span> 个点 <span class="math inline">\(A_1,A_2,\dots,A_n\)</span> ，求一个排列 <span class="math inline">\(p_1,p_2,\dots,p_n\)</span> 使得对于任意一个 $i(1,n),i$ 都有 <span class="math inline">\(\angle A_{p_i-1} A_{p_i} A_{p_i+1} &lt; \dfrac{\pi}{2}\)</span> 。若无解，输出 <span class="math inline">\(-1\)</span> ，若有多个答案，输出任意一个即可。<span class="math inline">\(3 \leq n \leq 5000,\ -10^9\leq x_i,y_i \leq 10^9\)</span>。</p>
<p>手玩一下发现解一定存在，而且似乎每次选最远的点就可以了，结果真的就是这样，选出钝角的时候我们总可以通过选更长的边来解决钝角的问题。</p>
<h2 id="codeforces-round-700">Codeforces Round 700</h2>
<h3 id="b---painting-the-array">1479B - Painting the Array</h3>
<p>给定数组 <span class="math inline">\(a\)</span>，你将将 <span class="math inline">\(a_i\)</span> 染成 <span class="math inline">\(b_i\)</span> 色，其中 <span class="math inline">\(b\)</span> 为你指定的 <span class="math inline">\(0/1\)</span> 数组，将 <span class="math inline">\(a\)</span> 中被染成 <span class="math inline">\(0\)</span> 色的数字取出来按原顺序排成 <span class="math inline">\(a^{(0)}\)</span>，染成 <span class="math inline">\(1\)</span> 色的排成 <span class="math inline">\(a^{(1)}\)</span>，定义 <span class="math inline">\(seg(a)\)</span> 为 <span class="math inline">\(a\)</span> 中连续段的个数，求 <span class="math inline">\(seg(a^{(0)}) + seg(a^{(1)})\)</span> 的最大值/最小值（分别对应 B1/B2），数据范围 <span class="math inline">\(10^5\)</span>。</p>
<p>高妙贪心真的不是很玩得起，考虑 dp。令 <span class="math inline">\(f_{i,a,b}\)</span> 表示填了 <span class="math inline">\([1,i]\)</span>，第一个序列末尾为 <span class="math inline">\(a\)</span>，第二个序列末尾为 <span class="math inline">\(b\)</span> 的最大/最小答案。发现可以干掉一维因为必然有一维是 <span class="math inline">\(a_i\)</span>。于是变成了 <span class="math inline">\(f_{i,x}\)</span> 表示填完 <span class="math inline">\([1,i]\)</span>，分别的末尾为 <span class="math inline">\(a_i\)</span> 和 <span class="math inline">\(x\)</span>，能达到的最大/最小答案。</p>
<p>那么有转移 <span class="math display">\[
\begin{aligned}
f_{i, a_{i-1}} &amp;\leftarrow f_{i-1,x} + 1&amp;a_i \ne x\\
f_{i,a_{i-1}}&amp;\leftarrow f_{i-1,x}&amp;a_i=x\\
f_{i,x}&amp;\leftarrow f_{i-1,x} + 1&amp;a_i\ne a_{i-1}\\
f_{i,x}&amp;\leftarrow f_{i-1,x}&amp;a_i=a_{i-1}
\end{aligned}
\]</span> 这个东西可以使用线段树维护，大部分的转移都是平凡的 <span class="math inline">\(+1\)</span>，写一个区间加区间最值的线段树即可，<span class="math inline">\(O(n\log n)\)</span> 带走。</p>
<p>当然高妙贪心也是有意思的——看根据两边队尾的 <span class="math inline">\(nxt\)</span> 来选择，感觉非常的牛逼。</p>
<h3 id="c---continuous-city">1479C - Continuous City</h3>
<p>给定 <span class="math inline">\(1\le L\le R\le 10^6\)</span>，构造一个有向带权图。要求 <span class="math inline">\(n\le 32\)</span>，且所有边都从编号小的点指向编号大的点，此外还要求 <span class="math inline">\(1\to n\)</span> 的所有路径权值都在 <span class="math inline">\([L, R]\)</span> 内且不存在 <span class="math inline">\(x\in[L,R]\)</span> 使得不存在或多于一条 <span class="math inline">\(1\to n\)</span> 的路径的权值为 <span class="math inline">\(x\)</span>。或说明无解。</p>
<p>说人话就是 <span class="math inline">\(1\to n\)</span> 的路径需要恰好有 <span class="math inline">\(R - L + 1\)</span> 条并且权值刚好覆盖了 <span class="math inline">\([L,R]\)</span> 的区间。</p>
<p><span class="math inline">\(n\le 32\)</span> 有点二进制的意思？考虑构造 <span class="math inline">\([1, 2^{k}]\)</span> 的答案，令经过 <span class="math inline">\(i\)</span> 号点表示选上 <span class="math inline">\(2^{i-2}\)</span>，将 <span class="math inline">\(i\)</span> 号点向后面所有边连上权为 <span class="math inline">\(2^{i-2}\)</span> 的边，再从 <span class="math inline">\(1\)</span> 向后面所有点连权为 <span class="math inline">\(1\)</span> 的边，那么从 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(k+2\)</span> 的所有路径就都对应了 <span class="math inline">\([1,2^k]\)</span> 里面的每一个数。</p>
<p>对于 <span class="math inline">\(R\ne 2^k\)</span> 的情况，令其为 <span class="math inline">\(2^k + t\)</span>，其中 <span class="math inline">\(2^{k+1}&gt;R\)</span>。刚才的图中有一个性质，就是对于 <span class="math inline">\(i\)</span> 号点（<span class="math inline">\(i&gt;1\)</span>），<span class="math inline">\(1\to i\)</span> 的所有路径里面是恰好覆盖了 <span class="math inline">\([1, 2^{i-2}]\)</span> 的。并且若我们令 <span class="math inline">\(R\)</span> 的二进制表示为 <span class="math inline">\((R_kR_{k-1}\cdots R_1R_0)_2\)</span>，则对于 <span class="math inline">\(R_j=1\)</span>，将该位设为 <span class="math inline">\(0\)</span> 的话低位就可以任意覆盖的。</p>
<p>就例如 <span class="math inline">\(R = (111010)_2\)</span>，关注 <span class="math inline">\(R_3 = 1\)</span>，发现 <span class="math inline">\([(110000)_2, (110111)_2]\)</span> 都是可以取到的（第 <span class="math inline">\(0\)</span> 到 <span class="math inline">\(2\)</span> 位任意取），这启发我们从 <span class="math inline">\(j+2\)</span> 号点连边向一个新点 <span class="math inline">\(k+3\)</span>，边权为更高位上的值之类的想法。但是这样会出现一些细节上的遗漏，因为形如 <span class="math inline">\((110000)_2\)</span> 就是没能覆盖到的，因为 <span class="math inline">\(j+2\)</span> 号点覆盖的是 <span class="math inline">\([1, 2^{j}]\)</span>，有一个 <span class="math inline">\(0\)</span> 的下界没被覆盖，而 <span class="math inline">\(2^{j}\)</span> 的上界又恰好多覆盖了一位。</p>
<p>这启发我们 <span class="math inline">\(R\leftarrow R - 1\)</span>，这样子就刚好把上述问题全部修复了，<span class="math inline">\(1\to k+3\)</span> 的所有路径就能覆盖整个区间了。而对于 <span class="math inline">\(L\ne 1\)</span>，直接平移 <span class="math inline">\(L - 1\)</span>，新开一个节点再接上去即可。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a aria-hidden="true" href="#cb3-1"></a><span class="pp">#include </span><span class="im">&lt;bits/stdc++.h&gt;</span></span>
<span id="cb3-2"><a aria-hidden="true" href="#cb3-2"></a><span class="pp">#define FOR</span>(i,<span class="pp"> </span>a,<span class="pp"> </span>b)<span class="pp"> </span><span class="cf">for</span><span class="pp"> </span>(<span class="dt">int</span><span class="pp"> </span>i<span class="pp"> </span>=<span class="pp"> </span>(a);<span class="pp"> </span>i<span class="pp"> </span>&lt;=<span class="pp"> </span>(b);<span class="pp"> </span>++i)</span>
<span id="cb3-3"><a aria-hidden="true" href="#cb3-3"></a></span>
<span id="cb3-4"><a aria-hidden="true" href="#cb3-4"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb3-5"><a aria-hidden="true" href="#cb3-5"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">1e6</span> + <span class="dv">5</span>;</span>
<span id="cb3-6"><a aria-hidden="true" href="#cb3-6"></a>vector&lt;tuple&lt;<span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>&gt;&gt; ans;</span>
<span id="cb3-7"><a aria-hidden="true" href="#cb3-7"></a><span class="dt">int</span> l, r, n;</span>
<span id="cb3-8"><a aria-hidden="true" href="#cb3-8"></a></span>
<span id="cb3-9"><a aria-hidden="true" href="#cb3-9"></a><span class="dt">int</span> main() {</span>
<span id="cb3-10"><a aria-hidden="true" href="#cb3-10"></a>    cin &gt;&gt; l &gt;&gt; r;</span>
<span id="cb3-11"><a aria-hidden="true" href="#cb3-11"></a>    r = r - l + <span class="dv">1</span>;</span>
<span id="cb3-12"><a aria-hidden="true" href="#cb3-12"></a>    <span class="dt">int</span> k = <span class="dv">31</span> - <span class="fu">__builtin_clz</span>(r); <span class="co">// 最高位</span></span>
<span id="cb3-13"><a aria-hidden="true" href="#cb3-13"></a>    n = k + <span class="dv">2</span>;</span>
<span id="cb3-14"><a aria-hidden="true" href="#cb3-14"></a>    FOR(i, <span class="dv">0</span>, k) FOR(j, i + <span class="dv">1</span>, k) ans.emplace_back(i + <span class="dv">2</span>, j + <span class="dv">2</span>, <span class="dv">1</span> &lt;&lt; i);</span>
<span id="cb3-15"><a aria-hidden="true" href="#cb3-15"></a>    FOR(i, <span class="dv">0</span>, k) ans.emplace_back(<span class="dv">1</span>, i + <span class="dv">2</span>, <span class="dv">1</span>);</span>
<span id="cb3-16"><a aria-hidden="true" href="#cb3-16"></a>    <span class="cf">if</span> (<span class="fu">__builtin_popcount</span>(r) &gt; <span class="dv">1</span>) {</span>
<span id="cb3-17"><a aria-hidden="true" href="#cb3-17"></a>        --r, ans.emplace_back(<span class="dv">1</span>, ++n, <span class="dv">1</span>);</span>
<span id="cb3-18"><a aria-hidden="true" href="#cb3-18"></a>        FOR(i, <span class="dv">0</span>, k) <span class="cf">if</span> ((<span class="dv">1</span> &lt;&lt; i) &amp; r) {</span>
<span id="cb3-19"><a aria-hidden="true" href="#cb3-19"></a>            <span class="dt">int</span> tmp = <span class="dv">0</span>;</span>
<span id="cb3-20"><a aria-hidden="true" href="#cb3-20"></a>            FOR(j, i + <span class="dv">1</span>, k) tmp |= ((<span class="dv">1</span> &lt;&lt; j) &amp; r);</span>
<span id="cb3-21"><a aria-hidden="true" href="#cb3-21"></a>            ans.emplace_back(i + <span class="dv">2</span>, n, <span class="dv">1</span> + tmp);</span>
<span id="cb3-22"><a aria-hidden="true" href="#cb3-22"></a>        }</span>
<span id="cb3-23"><a aria-hidden="true" href="#cb3-23"></a>    }</span>
<span id="cb3-24"><a aria-hidden="true" href="#cb3-24"></a>    <span class="cf">if</span> (l != <span class="dv">1</span>) ans.emplace_back(n, n + <span class="dv">1</span>, l - <span class="dv">1</span>), ++n;</span>
<span id="cb3-25"><a aria-hidden="true" href="#cb3-25"></a>    cout &lt;&lt; <span class="st">"YES</span><span class="sc">\n</span><span class="st">"</span> &lt;&lt; n &lt;&lt; <span class="ch">' '</span> &lt;&lt; ans.size() &lt;&lt; endl;</span>
<span id="cb3-26"><a aria-hidden="true" href="#cb3-26"></a>    <span class="cf">for</span> (<span class="kw">auto</span> &amp;x : ans) {</span>
<span id="cb3-27"><a aria-hidden="true" href="#cb3-27"></a>        <span class="dt">int</span> i, j, k; tie(i, j, k) = x;</span>
<span id="cb3-28"><a aria-hidden="true" href="#cb3-28"></a>        cout &lt;&lt; i &lt;&lt; <span class="ch">' '</span> &lt;&lt; j &lt;&lt; <span class="ch">' '</span> &lt;&lt; k &lt;&lt; endl;</span>
<span id="cb3-29"><a aria-hidden="true" href="#cb3-29"></a>    }</span>
<span id="cb3-30"><a aria-hidden="true" href="#cb3-30"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb3-31"><a aria-hidden="true" href="#cb3-31"></a>}</span></code></pre></div>
<h3 id="d---odd-mineral-resource">1479D - Odd Mineral Resource</h3>
<p>给定一棵树，每个点有颜色 <span class="math inline">\(c_i\)</span>。多次查询，给定 <span class="math inline">\(u,v,l,r\)</span>，求一个颜色 <span class="math inline">\(x\)</span> 使得 <span class="math inline">\(x\in[l,r]\)</span> 且 <span class="math inline">\(x\)</span> 在路径 <span class="math inline">\((u,v)\)</span> 上出现了奇数次。数据范围 <span class="math inline">\(3\times 10^5\)</span>，5s。</p>
<p>根号做法见<a href="/summary-ds4/">这里</a>，这里说一下随机化的单 <span class="math inline">\(\log\)</span> 算法。</p>
<p>考虑到出现偶数次不考虑的限制很像异或，那么如果设路径 <span class="math inline">\((u,v)\)</span> 上 <span class="math inline">\([l,r]\)</span> 颜色的异或和为 <span class="math inline">\(f(u,v,l,r)\)</span> 的话，若其异或起来为 <span class="math inline">\(0\)</span> 能描述路径上没有出现奇数次的话，那我们就可以使用主席树 + 二分来单 <span class="math inline">\(\log\)</span> 查询。</p>
<p>所以考虑将每种颜色在 <span class="math inline">\([0,2^{64})\)</span> 内随机重新赋值，这样子出错的概率极低（为 <span class="math inline">\(2^{-64}q\)</span>，接近为 <span class="math inline">\(0\)</span>）。</p>
<p>套路地，将 <span class="math inline">\(f(u,v,l,r)\)</span> 拆分为 <span class="math inline">\(f(1,u,l,r)\oplus f(1,v,l,r)\oplus f(1,\mathrm{LCA}, l,r)\oplus f(1,\mathrm{fa}_{\mathrm{LCA}}, l, r)\)</span>，使用主席树维护 <span class="math inline">\(f(1, u, l, r)\)</span> 然后四路同时二分即可。</p>
<h2 id="codeforces-round-701-div.-2">Codeforces Round #701 (Div. 2)</h2>
<p>VP on 22/07/14。A + C + D。</p>
<h3 id="e---move-and-swap">1485E - Move and Swap</h3>
<p>有一棵树，以 <span class="math inline">\(1\)</span> 为根，叶子结点深度相同,结点 <span class="math inline">\(i\)</span> 有权值 <span class="math inline">\(a_i\)</span>。现在有红蓝两颗棋子，每一步可以进行如下操作：</p>
<ul>
<li>把红色棋子移动到它的子节点；</li>
<li>把蓝色棋子移动到它下一层的任何一个结点；</li>
<li>选择交换或不交换红子与蓝子的位置；</li>
<li>计算得分为 <span class="math inline">\(|a_{red}-a_{blue}|\)</span>。</li>
</ul>
<p>问最大的得分和。</p>
<p>将点分层考虑，主要考虑到红点比较固定而蓝点四处乱飞，所以设 <span class="math inline">\(f_u\)</span> 为操作完后红点在 <span class="math inline">\(u\)</span> 时的答案（发现蓝点的位置是无关紧要的）。考虑转移：</p>
<ul>
<li><p>不交换的时候，设 <span class="math inline">\(\mathrm{fa}_u\)</span> 为 <span class="math inline">\(u\)</span> 的父亲，则 <span class="math display">\[
f_u = f_{\mathrm{fa}_u} + \max_v\{|a_u - a_v|\}
\]</span> 其中 <span class="math inline">\(v\)</span> 就是蓝点下落的位置，不难发现只能是最大的或最小的。</p></li>
<li><p>交换的话，那么红点就是任意飘了，设交换前红点位于 <span class="math inline">\(k\)</span>，则 <span class="math display">\[
f_u = \max_k\{|a_u - a_k| + f_{\mathrm{fa}_k}\}
\]</span> 套路地拆绝对值得到 <span class="math inline">\(f_{\mathrm{fa}_k} - a_k + a_u\)</span> 和 <span class="math inline">\(f_{\mathrm{fa}_k} + a_k - a_u\)</span>。考虑维护 <span class="math inline">\(\max\{f_{\mathrm{fa}_k} + a_k\}\)</span> 和 <span class="math inline">\(\max\{f_{\mathrm{fa}_k} - a_k\}\)</span> 即可。</p></li>
</ul>
<h3 id="f---copy-or-prefix-sum">1485F - Copy or Prefix Sum</h3>
<p>给定一个 <span class="math inline">\(b\)</span> 数组，一个 <span class="math inline">\(a\)</span> 是合法的指对于每一个 <span class="math inline">\(i\)</span> 都有 <span class="math inline">\(b_i=a_i\)</span> 或 <span class="math inline">\(b_i=\sum\limits_{j=1}^{i}a_j\)</span> 。问合法的 <span class="math inline">\(a\)</span> 有多少个。答案对 <span class="math inline">\(10^9+7\)</span> 取模。<span class="math inline">\(1\le t\le 10^4,1\le \sum n\le 2\times 10^5,-10^9\le b_i\le 10^9\)</span>。</p>
<p>考虑使用 dp 求解，设 <span class="math inline">\(f_{i,S}\)</span> 为填了前 <span class="math inline">\(i\)</span> 位，<span class="math inline">\(a_i = S\)</span> 的方案数。根据是满足 <span class="math inline">\(b_i = a_i\)</span> 还是 <span class="math inline">\(b_i = \sum a_j\)</span> 分为两种转移：</p>
<ul>
<li><span class="math inline">\(f_{i, j + b_i} = f_{i - 1, j}\)</span>，此时是 <span class="math inline">\(b_i = a_i\)</span>。</li>
<li><span class="math inline">\(f_{i, b_i} = \sum f_{i - 1, j}\)</span>，此时是 <span class="math inline">\(b_i = a_i\)</span> 的情况，但是需要与上面 <span class="math inline">\(j = 0\)</span> 的情况去一下重。</li>
</ul>
<p>发现第一种转移实际上就是数组平移，第二种转移是在做全局和。开一个小标记记录第一种操作的全局平移量，再开一个 <span class="math inline">\(ans\)</span>，发现 <span class="math inline">\(f_{i, b_i}= ans + ans - f_{i - 1, b_i}\)</span>（因为新的 <span class="math inline">\(f_{i, b_i}\)</span> 就是 <span class="math inline">\(ans\)</span>）。</p>
<p>拿 <code>map</code> 随缘维护一下就行了。</p>
<h2 id="codeforces-round-706">Codeforces Round 706</h2>
<h3 id="a---diamond-miner">1495A - Diamond Miner</h3>
<p>在 <span class="math inline">\(x\)</span> 轴上有 <span class="math inline">\(n\)</span> 个钻石矿，<span class="math inline">\(y\)</span> 轴上有 <span class="math inline">\(n\)</span> 个矿工，保证所有的矿工和钻石都不在原点。需要建立每个矿工与每个钻石矿的一一对应关系使得每对矿工和矿的距离之和最小。</p>
<p>要么是贪心要么是 <span class="math inline">\(O(n)\)</span> 的 dp，先考虑两对矿工和钻石的情况：（由于正负其实不影响，所以我们把所有的钻石和矿的坐标都取绝对值，在正半轴上考虑问题。两对点的情况无非就是交叉着连（蓝线）和平行着连（红线）。所以考虑哪个要大一些，即比较 <span class="math inline">\(\sqrt{a^2 + d^2} + \sqrt{b^2 + c^2}\)</span> 和 <span class="math inline">\(\sqrt{a^2 + c^2} + \sqrt{b^2 + d^2}\)</span> 的大小。</p>
<p>两边同时平方：</p>
<p><span class="math display">\[
a^2 + b^2 + c^2 + d^2 + \sqrt{(a^2 + d^2)(b^2 + c^2)}
\]</span></p>
<p>和</p>
<p><span class="math display">\[
a^2 + b^2 + c^2 + d^ 2+ \sqrt{(a^2 + c^2)(b^2 + d^2)}
\]</span></p>
<p>所以只需要考虑 <span class="math inline">\((a + d)(b+ c)\)</span> 与 <span class="math inline">\((a + c)(b + d)\)</span> 的大小即可，化简之后不难发现</p>
<p><span class="math display">\[
(a + d)(b + c)\ge(a + c)(b + d)
\]</span></p>
<p>所以<strong>平行的连法一定是最优的</strong>。将所有的点取绝对值后排序然后依次累加答案就搞定了。</p>
<h3 id="b---lets-go-hiking">1495B - Let’s Go Hiking</h3>
<p>题意：给定一个 <span class="math inline">\(1-n\)</span> 的排列 <span class="math inline">\(p\)</span>，Qingshan 和 Daniel 在草稿纸上按照如下规则进行远足游戏。 首先 Qingshan 选定一个数 <span class="math inline">\(x\)</span> <strong>并告诉 Daniel</strong>，接下来 Daniel 选定另一个数 <span class="math inline">\(y\)</span>，<span class="math inline">\(1\le x, y\le n\)</span> 且 <span class="math inline">\(x\not=y\)</span>。然后他们轮流进行游戏，Qingshan 为先手：</p>
<ul>
<li>如果轮到 Qingshan，则 Qingshan 只能把 <span class="math inline">\(x\)</span> 移动到 <span class="math inline">\(x'\)</span>，其中 <span class="math inline">\(x' - x = 1\)</span>，且 <span class="math inline">\(x' \neq y\)</span>，<span class="math inline">\(p_x\gt p_{x'}\)</span>。</li>
<li>如果轮到 Daniel，则 Daniel 只能把 <span class="math inline">\(y\)</span> 移动到 <span class="math inline">\(y'\)</span>，其中 <span class="math inline">\(y' - y = 1\)</span>，且 <span class="math inline">\(y'\neq x\)</span>，<span class="math inline">\(p_y\lt p_{y'}\)</span>。</li>
</ul>
<p>如果轮到某一方时无路可走了，则另一方胜利。 假设双方都足够聪明，那么判断有多少个初始的 <span class="math inline">\(x\)</span> 可以让 Qingshan 一定取胜。</p>
<p>题解：首先发掘这个游戏的性质：每个人只能往一个方向走，不能回头。注意到这个性质之后不难发现如果 Qingshan 要赢，那么 Daniel 必须被 Qingshan 卡死或者自己被卡死。</p>
<p>因为两方都足够聪明，所以我们把问题范围缩小到最长单调序列上面来，因为这样可以最大化双方的移动步数。</p>
<p>可以证明的是，<strong>Qingshan 一开始选的点在最长单调序列的顶端是他能赢的必要条件</strong>。至于为什么呢？如果 Qingshan 选的不是最长单调序列的顶端，那么 Daniel 就可以选最长单调序列的底端进行游戏，那么 Qingshan 肯定先被卡死。</p>
<p>并且如果有多条不相交的最长单调序列，<strong>Qingshan 必输</strong>。因为这样 Daniel 可以选择另外一条序列的底端，而 Qingshan 是先手，所以 Qingshan <strong>肯定先被卡死</strong>。</p>
<p>如果只有一条最长单调序列，还是 <strong>Qingshan 必输</strong>，因为 Qingshan 是先手，Daniel 选择的位置但凡与 Qingshan 的初始位置成的链长为<strong>偶数</strong>，<strong>那么 Daniel 肯定可以卡死 Qingshan</strong>。</p>
<p>剩下的两种情况就是同时有两条最长单调序列，要么成“V”形要么成山峰形。对于“V”形的情况<strong>还是 Qingshan 必输</strong>，因为 Daniel 可以往与 Qingshan 相反的方向跑走，那么当 Qingshan 最后到达谷底的时候就 GG 了。对于山峰形的情况，Qingshan 肯定是选峰顶，接下来分最长单调序列长度的奇偶性讨论：</p>
<p>奇数：如果 Daniel 选了坡底，<strong>那么 Qingshan 只要往 Daniel 的方向走那么就必然可以卡死 Daniel</strong>；如果不选坡底，<strong>那么 Qingshan 只要往另一个方向走就可以让 Daniel 先无路可走</strong>，所以此时答案为 <span class="math inline">\(1\)</span>，Qingshan 唯一的必胜策略就是选择山顶。</p>
<p>偶数：类似上面的分析方法，不难发现<strong>要么 Daniel 卡死 Qingshan，要么 Qingshan 先无路可走</strong>，所以 Qingshan <strong>必败</strong>。</p>
<p>分析到这里我们就发现了<strong>答案为 <span class="math inline">\(1\)</span> 当且仅当有两条最长单调序列并且他们共享一个最高点，否则答案为 <span class="math inline">\(0\)</span></strong>。<span class="math inline">\(O(n)\)</span> 直接扫就可以过了。</p>
<h3 id="c---garden-of-the-sun">1495C - Garden of the Sun</h3>
<p>题意：给定一个 <span class="math inline">\(n\times m\)</span> 矩阵，里面含有字符 <code>.</code> 和 <code>X</code>。保证所有 <code>X</code> 之间无公共点（即不联通），请将一部分 <code>.</code> 替换成 <code>X</code> 使得这些 <code>X</code> 形成一棵树（要求四联通，即两个 <code>X</code> 之间有一公共边，不能有环）。</p>
<p>首先<strong>所有 <code>X</code> 之间无公共点</strong>是一个特别好的性质，这保证了下面填充列的方法的正确性。</p>
<p>具体地，考虑 <span class="math inline">\(3\mid m\)</span> 的情况，不妨直接将 <span class="math inline">\(2,5,8,\cdots\)</span> 列全部填成 <code>X</code>，不难发现这样<strong>隔两列填一列的方式是不会出现环的</strong>，然后再将 <span class="math inline">\(3, 6, 9, \cdots\)</span> 和 <span class="math inline">\(4,7,10,\cdots\)</span> 等列构造成联通的就可以了，最简单的方法就是只考虑第一行和第二行，如果合法就直接连。</p>
<p>如果 <span class="math inline">\(3\not\mid m\)</span>，那么只需要变一下，把 <span class="math inline">\(1, 4, 7,\cdots\)</span> 填成 <code>X</code>，剩余操作类似。至于为什么填的列改变了则可以考虑画一下图自己模拟一下，会发现如果选 <span class="math inline">\(2, 5, 8,\cdots\)</span> 的话在 <span class="math inline">\(m = 3k + 1\)</span> 的时候会多出一个需要单独考虑的列，所以不如简化问题。</p>
<h2 id="codeforces-round-707-div.2-based-on-moscow-open-olympiad-in-informatics">Codeforces Round 707 Div.2 based on moscow open olympiad in informatics</h2>
<h3 id="a---going-home">1500A - Going Home</h3>
<p>给定 <span class="math inline">\(\lbrace a_n\rbrace\)</span>，满足 <span class="math inline">\(4\le n\le 2\times10^5\)</span> 并且 <span class="math inline">\(\forall i\in[1,n],1\le a_i\le 2.5\times10^6\)</span>，求四个不同的下标 <span class="math inline">\(x,y,z,w\)</span> 使得 <span class="math inline">\(a_x + a_y = a_z + a_w\)</span>。 有解则打印解，无解输出 <span class="math inline">\(\texttt{NO}\)</span>。</p>
<p>注意到我们的和 <span class="math inline">\(a_i + a_j\le 5\times 10^6\)</span>，这个是解决问题的关键。 所以我们直接大力枚举 <span class="math inline">\(S = a_i + a_j\)</span>，记录一下加出来的这个 <span class="math inline">\(S\)</span>，如果同样的 <span class="math inline">\(S\)</span> 出现了第二次则直接输出答案就好。根据<strong>鸽巢原理</strong>，我们如果枚举的次数超过了值域，那么就肯定不存在解。</p>
<h2 id="contest-2050-and-codeforces-round-718-div.1-div.2">Contest 2050 and Codeforces Round #718 (Div.1 + Div.2)</h2>
<p>VP on 22/07/14</p>
<h3 id="e---group-photo">1517E - Group Photo</h3>
<p>将正整数序列 <span class="math inline">\(a\)</span> 划分成两部分，下标分别为 <span class="math inline">\(c_i\)</span> 和 <span class="math inline">\(p_i\)</span>，要求</p>
<ul>
<li><span class="math inline">\(c_i - c_{i-1} \le c_{i+1} - c_i\)</span>；</li>
<li><span class="math inline">\(p_i - p_{i-1}\ge p_{i+1}-p_i\)</span>；</li>
<li><span class="math inline">\(\sum\limits_{x\in C}a_x &lt; \sum\limits_{y\in P}a_y\)</span>。</li>
</ul>
<p>问方案数模 <span class="math inline">\(998244353\)</span>，<span class="math inline">\(n\)</span> 二十万，<span class="math inline">\(a_i\le 10^9\)</span>。</p>
<p>发现 <span class="math inline">\(c\)</span> 和 <span class="math inline">\(p\)</span> 的限制是前松后紧和前紧后松，而一个紧对应着另一个必须松，有点诈骗的感觉，所以能出现的划分也就只有如下两种：</p>
<ul>
<li><code>P...PC...C</code>，正则表达式 <code>P+C+</code>；</li>
<li><code>PC...CPC...PCP...PC</code>，正则表达式 <code>P?C+(PC)*P+C?</code>。</li>
</ul>
<p>注意到第二种里面 <code>C..</code> 的部分和 <code>P..</code> 的部分必须至少一个 <code>C</code> 和一个 <code>P</code>，否则会退化成第一种。</p>
<p>第一种很容易使用前缀和统计。第二种枚举 <span class="math inline">\(4\)</span> 种头尾选/不选的 case，然后枚举 <code>C</code> 的个数，由于其显然关于 <code>PC</code> 的个数有单调性，所以二分即可，时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<h3 id="f---reunion">1517F - Reunion</h3>
<p>大会有 <span class="math inline">\(n\)</span> 个志愿者 , 他们之间的关系可以用一棵 <span class="math inline">\(n\)</span> 的点的树描述 . 第 <span class="math inline">\(i\)</span> 个结点代表第 <span class="math inline">\(i\)</span> 个志愿者 . 定义树上两点间距离 <span class="math inline">\(\mathrm{dis}(u,v)\)</span> 为为他们之间的最短路径所经过的边数。</p>
<p>现在他们想进行一场聚会 , 一些志愿者有空参加 , 而其它的正忙 . 在这种情况下 , 对于某个志愿者 <span class="math inline">\(x\)</span> 和非负整数 <span class="math inline">\(r\)</span> , 如果所有与 <span class="math inline">\(x\)</span> 的距离不超过 <span class="math inline">\(r\)</span> 的志愿者<strong>全部</strong>有空参加 , 那么可以召开一场以 <span class="math inline">\(x\)</span> 为中心 , 半径为 <span class="math inline">\(r\)</span> 的聚会 . 这场聚会的等级定义为所有可能的半径 <span class="math inline">\(r\)</span> 中的<strong>最大值</strong> .</p>
<p>每一个志愿者都有 <span class="math inline">\(\frac12\)</span> 的概率有空参加或者正忙 . 现在请你求出所有情况下聚会等级的<strong>期望</strong>对 <span class="math inline">\(998\ 244\ 353\)</span> 取模的结果 . 特别的 , 当所有志愿者都正忙时 , 该聚会的等级为 <span class="math inline">\(-1\)</span> ; 当所有志愿者都有空参加时 , 该聚会的等级为 <span class="math inline">\(n\)</span>。<span class="math inline">\(2\le n\le300\)</span></p>
<p>期望题基本没做过几道，不埋怨自己了。</p>
<p>对每个 <span class="math inline">\(x\)</span> 去寻找答案是困难的，考虑通过每个 <span class="math inline">\(r\)</span> 求方案数来算期望。</p>
<p>而正面地考虑<strong>存在</strong>一个节点 <span class="math inline">\(x\)</span> 使得与其距离 <span class="math inline">\(\le r\)</span> 的人都有空是困难的，逆向地来看，不妨令不能参加的染成黑色，定义 <span class="math inline">\(B_{u,r} = \{v:dis(u,v)\le r\}\)</span>，那么对于所有染色了的 <span class="math inline">\(u\)</span>，<span class="math inline">\(B_{u,r}\)</span> 都是被干掉了的。</p>
<p>那么，若所有 <span class="math inline">\(B_{u,r}\)</span> 的并包含了所有点，则说明该情况下合法的半径一定 <span class="math inline">\(&lt;r\)</span>，如果我们能对于所有 <span class="math inline">\(r\)</span> 算出 <span class="math inline">\(&lt; r\)</span> 的情况，简单差分一下也就可以得到 <span class="math inline">\(=r\)</span> 的情况了。</p>
<p>所以问题转化为对于一个 <span class="math inline">\(r\)</span>，求染色方案数，使得 <span class="math inline">\(B_{u,r}\)</span> 的并能将所有点包含。考虑 dp。</p>
<h2 id="harbour.space-scholarship-contest-2021-2022-open-for-everyone-rated-div.-1-div.-2">Harbour.Space Scholarship Contest 2021-2022 (open for everyone, rated, Div. 1 + Div. 2)</h2>
<p>VP on 21/10/18. A + B + C + D + F。</p>
<h3 id="e---permutation-shift">1553E - Permutation Shift</h3>
<p>初始有排列 <span class="math inline">\((1, 2, \cdots, n)\)</span>，现给定排列 <span class="math inline">\(P\)</span> 和正整数 <span class="math inline">\(m\)</span>，求出所有满足下列条件的整数 <span class="math inline">\(k\in[0, n- 1]\)</span>：</p>
<ul>
<li>将初始排列向右循环移位 <span class="math inline">\(k\)</span> 个单位后，能经过不超过 <span class="math inline">\(m\)</span> 次交换元素的操作后得到 <span class="math inline">\(P\)</span>。</li>
</ul>
<p><span class="math inline">\(1\le n\le 3\times 10^5\)</span>，<span class="math inline">\(0\le m\le \dfrac n3\)</span>。</p>
<p>可以考虑枚举 <span class="math inline">\(k\)</span> 然后判断这个 <span class="math inline">\(k\)</span> 是否可行。但是 <span class="math inline">\(O(n^2)\)</span> 显然会爆炸。考虑由于我们一次交换最多改变两个数的位置，所以位置不用改变的数字至少有 <span class="math inline">\(n - 2m\)</span> 个，令 <span class="math inline">\(x_k\)</span> 表示循环移位 <span class="math inline">\(k\)</span> 次后不用动的数字个数，一定有 <span class="math inline">\(\displaystyle\sum_{i = 0}^{n - 1}x_i = n\)</span>，而且由 <span class="math inline">\(m\le \dfrac n 3\)</span> 得知 <span class="math inline">\(x_k\ge \dfrac n 3\)</span> 恒成立。这样满足条件的 <span class="math inline">\(x_k\)</span> 至多有 <span class="math inline">\(3\)</span> 个。所以我们预处理一下所有的 <span class="math inline">\(x_k\)</span> 然后每次找 <span class="math inline">\(\ge n - 2m\)</span> 的 <span class="math inline">\(x_k\)</span> 然后 <span class="math inline">\(O(n)\)</span> 找环即可，复杂度 <span class="math inline">\(O(n)\)</span>。</p>
<h3 id="f---pairwise-modulo">1553F - Pairwise Modulo</h3>
<p>给定 <span class="math inline">\(n\)</span> 和 <span class="math inline">\(\{a_n\}\)</span>（<span class="math inline">\(1\le a_i\le 2\times 10^5\)</span>），对每个 <span class="math inline">\(k\)</span> 求出 <span class="math inline">\(f_k = \displaystyle\sum_{1\le i,j\le k}a_i\bmod a_j\)</span>。</p>
<p>考虑新加进来一个 <span class="math inline">\(a_i\)</span> 时产生的贡献，将这部分贡献与 <span class="math inline">\(f_{i - 1}\)</span> 相加即得到 <span class="math inline">\(f_i\)</span>。其分为</p>
<ul>
<li><span class="math inline">\(\sum_j a_j\bmod a_i\)</span>。这部分比较好办，树状数组直接扫便是，俩 <span class="math inline">\(\log\)</span>。</li>
<li><span class="math inline">\(\sum_j a_i\bmod a_j\)</span>。这部分不太好直接去算。考虑 <span class="math inline">\(a_i\bmod a_j = a_i - a_j\lfloor a_i/a_j\rfloor\)</span>，故可以在计算之前的 <span class="math inline">\(a_j\)</span> 的时候顺便更新一下它能更新到的区间。区间加，单点查，依然可以树状数组。还是俩 <span class="math inline">\(\log\)</span>。</li>
</ul>
<p>于是 <span class="math inline">\(O(n\log^2n)\)</span> 解决掉了。比 E 不知道简单到哪里去了。</p>
<h3 id="g---common-divisor-graph">1553G - Common Divisor Graph</h3>
<p>给定一个包含 <span class="math inline">\(n\)</span> 个节点的图。第 <span class="math inline">\(i\)</span> 个节点都有权值 <span class="math inline">\(a_i\)</span>，没有两个节点权值相同。节点 <span class="math inline">\(i,j\)</span> 之间有一条无向边仅当 <span class="math inline">\(\gcd(a_i,a_j)&gt;1\)</span>。</p>
<p>给定 <span class="math inline">\(q\)</span> 次询问，每次包含整数 <span class="math inline">\(s,t\)</span> 表示你希望从节点 <span class="math inline">\(s\)</span> 到达节点 <span class="math inline">\(t\)</span>。为了到达那个节点，你可以进行下列操作任意次：</p>
<ul>
<li>选定一个节点 <span class="math inline">\(i\)</span>。创造一个新的节点，该节点的权值为 <span class="math inline">\(a_i\times(a_i+1)\)</span>，并按照上述规则连边。</li>
</ul>
<p>对于每次询问，你都需要求出，至少需要多少次操作才能使节点 <span class="math inline">\(s\)</span> 能到达节点 <span class="math inline">\(t\)</span>。询问互相独立。</p>
<p>由于 <span class="math inline">\(a_s(a_s + 1)\)</span> 和 <span class="math inline">\(a_t(a_t + 1)\)</span> 必然有公约数 <span class="math inline">\(2\)</span> 所以连通。所以答案至多为 <span class="math inline">\(2\)</span>。</p>
<p>考虑一开始先用并查集连好已经有了的边，查询的时候若已经连通，则答案为 <span class="math inline">\(0\)</span>。然后考虑什么时候答案为 <span class="math inline">\(1\)</span>，显然，当 <span class="math inline">\(a_s + 1\)</span> 和 <span class="math inline">\(a_t\)</span> 所在集合连通或者 <span class="math inline">\(a_s\)</span> 所在集合和 <span class="math inline">\(a_t + 1\)</span> 连通时答案就为 <span class="math inline">\(1\)</span>。这个可以预处理一下。</p>
<p>时间复杂度大抵是 <span class="math inline">\(\log\)</span> 级别的，能过。</p>
<h2 id="codeforces-round-737-div.-2">Codeforces Round #737 (Div. 2)</h2>
<h3 id="c.-moamen-and-xor">1557C. Moamen and XOR</h3>
<p>拆开位来考虑。处理一下组合数。</p>
<h2 id="codeforces-round-738-div.-2">Codeforces Round #738 (Div. 2)</h2>
<h3 id="d1.-mocha-and-diana-easy-version">1559D1. Mocha and Diana (Easy Version)</h3>
<p>暴力给两个森林加边，<span class="math inline">\(O(n^2\log n)\)</span> 可过。</p>
<h3 id="d2.-mocha-and-diana-hard-version">1559D2. Mocha and Diana (Hard Version)</h3>
<p>考虑延续上题的性质。</p>
<p>贪心的把 <span class="math inline">\(1\)</span> 能连的边连了，然后会出现两类点：只在 <span class="math inline">\(A\)</span> 图中与 <span class="math inline">\(1\)</span> 相连以及只在 <span class="math inline">\(B\)</span> 图中与 <span class="math inline">\(1\)</span> 相连。然后显然可以在两个集合中挑点出来连边。直接连就行了，复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<h3 id="e.-mocha-and-stars">1559E. Mocha and Stars</h3>
<p>求满足如下条件的序列 <span class="math inline">\((a_1, a_2, \cdots , a_n)\)</span> 的数量：</p>
<ul>
<li><span class="math inline">\(\forall i\in[1, n], a_i\in[l_i, r_i]\)</span>；</li>
<li><span class="math inline">\(\sum a_i\le m\)</span>；</li>
<li><span class="math inline">\(\gcd(a_1, a_2, \cdots, a_n) = 1\)</span></li>
</ul>
<p><span class="math inline">\(2\le n\le 50\)</span>，<span class="math inline">\(1\le m\le 10^5\)</span>，答案对 <span class="math inline">\(998244353\)</span> 取模。</p>
<p>不考虑 <span class="math inline">\(\gcd\)</span> 的限制，发现其为一个背包。令 <span class="math inline">\(f_{i, j}\)</span> 为前 <span class="math inline">\(i\)</span> 个物品，背包容量为 <span class="math inline">\(j\)</span> 的方案数，则有转移方程： <span class="math display">\[
f_{i, j} = \sum_{k = l_i}^{r_i}f_{i - 1, j - k}
\]</span> 这样直接去做是 <span class="math inline">\(O(nm^2)\)</span> 的，发现转移可以使用前缀和优化，具体设 <span class="math inline">\(s_{i, j}\)</span> 表示 <span class="math display">\[
s_{i, j} = \sum_{k = 0}^jf_{i, k}
\]</span> 然后就有了转移方程 <span class="math display">\[
f_{i, j} = s_{i - 1, j - l_i} - s_{i - 1, j - r_i - 1}
\]</span> 背包部分的复杂度为 <span class="math inline">\(O(nm)\)</span>。</p>
<p>然后考虑 <span class="math inline">\(\gcd\)</span> 的限制，这类套路问题使用莫比乌斯反演即可。 <span class="math display">\[
\begin{aligned}
&amp;\sum_{a_1=l_1}^{r_1}\sum_{a_2=l_2}^{r_2}\cdots\sum_{a_n=l_n}^{r_n}[\gcd(a_1,\cdots,a_n)=1]\left[\sum_{i = 1}^na_i\le m\right]\\
=&amp;\sum_{a_1=l_1}^{r_1}\sum_{a_2=l_2}^{r_2}\cdots\sum_{a_n=l_n}^{r_n}\left[\sum_{i = 1}^na_i\le m\right]\sum_{d \mid \gcd(a_1,\cdots,a_n)}\mu(d)\\ =&amp;\sum_{a_1=l_1}^{r_1}\sum_{a_2=l_2}^{r_2}\cdots\sum_{a_n=l_n}^{r_n}\left[\sum_{i = 1}^na_i\le m\right]\sum_{d\mid a_1,\cdots,d \mid a_n}\mu(d)\\
=&amp;\sum_{d=1}^M\mu(d)\sum_{a_1=\lceil\frac{l_1}{d}\rceil}^{\lfloor\frac{r_1}{d}\rfloor}\sum_{a_2=\lceil\frac{l_2}{d}\rceil}^{\lfloor\frac{r_2}{d}\rfloor}\cdots\sum_{a_n=\lceil\frac{l_n}{d}\rceil}^{\lfloor\frac{r_n}{d}\rfloor}\left[\sum_{i = 1}^na_i\le \left\lfloor\frac m d\right\rfloor\right]
\end{aligned}
\]</span> 总时间复杂度 <span class="math inline">\(O(nm\log m)\)</span>。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a aria-hidden="true" href="#cb4-1"></a><span class="dt">int</span> main() {</span>
<span id="cb4-2"><a aria-hidden="true" href="#cb4-2"></a>    init();</span>
<span id="cb4-3"><a aria-hidden="true" href="#cb4-3"></a>    read(n), read(m);</span>
<span id="cb4-4"><a aria-hidden="true" href="#cb4-4"></a>    FOR(i, <span class="dv">1</span>, n) read(L[i]), read(R[i]);</span>
<span id="cb4-5"><a aria-hidden="true" href="#cb4-5"></a>    modint ans = <span class="dv">0</span>;</span>
<span id="cb4-6"><a aria-hidden="true" href="#cb4-6"></a>    FOR(d, <span class="dv">1</span>, m) {</span>
<span id="cb4-7"><a aria-hidden="true" href="#cb4-7"></a>        <span class="cf">if</span> (mu[d] == <span class="dv">0</span>) <span class="cf">continue</span>;</span>
<span id="cb4-8"><a aria-hidden="true" href="#cb4-8"></a>        FOR(j, <span class="dv">0</span>, m / d) sum[j] = <span class="dv">1</span>;</span>
<span id="cb4-9"><a aria-hidden="true" href="#cb4-9"></a>        FOR(i, <span class="dv">1</span>, n) {</span>
<span id="cb4-10"><a aria-hidden="true" href="#cb4-10"></a>            l[i] = (L[i] + d - <span class="dv">1</span>) / d, r[i] = R[i] / d;</span>
<span id="cb4-11"><a aria-hidden="true" href="#cb4-11"></a>            FOR(j, <span class="dv">1</span>, m / d) f[j] = <span class="dv">0</span>;</span>
<span id="cb4-12"><a aria-hidden="true" href="#cb4-12"></a>            FOR(j, l[i], m / d) {</span>
<span id="cb4-13"><a aria-hidden="true" href="#cb4-13"></a>                f[j] = sum[j - l[i]];</span>
<span id="cb4-14"><a aria-hidden="true" href="#cb4-14"></a>                <span class="cf">if</span> (j - r[i] - <span class="dv">1</span> &gt;= <span class="dv">0</span>) f[j] -= sum[j - r[i] - <span class="dv">1</span>];</span>
<span id="cb4-15"><a aria-hidden="true" href="#cb4-15"></a>            }</span>
<span id="cb4-16"><a aria-hidden="true" href="#cb4-16"></a>            sum[<span class="dv">0</span>] = <span class="dv">0</span>;</span>
<span id="cb4-17"><a aria-hidden="true" href="#cb4-17"></a>            FOR(j, <span class="dv">1</span>, m / d) sum[j] = f[j] + sum[j - <span class="dv">1</span>];</span>
<span id="cb4-18"><a aria-hidden="true" href="#cb4-18"></a>        }</span>
<span id="cb4-19"><a aria-hidden="true" href="#cb4-19"></a>        ans += sum[m / d] * mu[d];</span>
<span id="cb4-20"><a aria-hidden="true" href="#cb4-20"></a>    }</span>
<span id="cb4-21"><a aria-hidden="true" href="#cb4-21"></a>    print(ans);</span>
<span id="cb4-22"><a aria-hidden="true" href="#cb4-22"></a>    <span class="cf">return</span> output(), <span class="dv">0</span>;</span>
<span id="cb4-23"><a aria-hidden="true" href="#cb4-23"></a>}</span></code></pre></div>
<h2 id="vk-cup-2021-final-engine-and-codeforces-round-740">VK Cup 2021 — Final (Engine) and Codeforces Round #740</h2>
<h3 id="a.-simply-strange-sort">1561A. Simply Strange Sort</h3>
<p>模拟</p>
<h3 id="a.-charmed-by-the-game">1558A. Charmed by the Game</h3>
<p>直接枚举 A 先手 B 赢比赛的次数，分 <span class="math inline">\(a + b\)</span> 的奇偶性讨论即可。</p>
<h3 id="c.-deep-down-below">1561C. Deep Down Below</h3>
<p>二分答案，水。</p>
<h3 id="b.-up-the-strip">1558B. Up the Strip</h3>
<p>一个点 <span class="math inline">\(x\)</span> 可以通过以下两种方式到别的格子：</p>
<ul>
<li>减法操作：到 <span class="math inline">\(y\)</span>，<span class="math inline">\(1\le y &lt; x\)</span>。</li>
<li>除法操作：到 <span class="math inline">\(y\)</span>，<span class="math inline">\(y = \lfloor x / d\rfloor\)</span>，<span class="math inline">\(d\ge 2\)</span>。</li>
</ul>
<p>dp，首先最朴素的做法可以通过前缀和和整除分块实现，总复杂度 <span class="math inline">\(O(n\sqrt n)\)</span>。</p>
<p>考虑 <span class="math inline">\(f_i\)</span> 对后面产生的贡献。</p>
<p>设 <span class="math inline">\(j = qi + r\)</span>，<span class="math inline">\(0\le r &lt; q\)</span>，则不难发现 <span class="math inline">\(\lfloor j / q\rfloor = i\)</span>，所以一个 <span class="math inline">\(i\)</span> 对于每个 <span class="math inline">\(q\ge 2\)</span>，会对 <span class="math inline">\([qi, q(i + 1))\)</span> 产生贡献。</p>
<p>差分维护一下即可，复杂度调和 <span class="math inline">\(O(n\log n)\)</span>。</p>
<h2 id="codeforces-round-741-div.-2">Codeforces Round 741 (Div. 2)</h2>
<p>A + C</p>
<h3 id="c---rings">1562C - Rings</h3>
<p>题意：给定 <span class="math inline">\(10^5\)</span> 的 <span class="math inline">\(01\)</span> 串，要求选出两不同的长度大于 <span class="math inline">\(\lfloor \frac n2\rfloor\)</span> 的子段，要求一个为另一个的倍数，保证有解。</p>
<p>注意到一个二进制数后面添一个 <span class="math inline">\(0\)</span> 相当于就是乘上 <span class="math inline">\(2\)</span>。而本题中前导零也不影响，所以直接找串中的 <span class="math inline">\(0\)</span> 即可。特判全 <span class="math inline">\(1\)</span> 串。</p>
<h2 id="deltix-round-summer-2021-open-for-everyone-rated-div.-1-div.-2">Deltix Round, Summer 2021 (open for everyone, rated, Div. 1 + Div. 2)</h2>
<h3 id="c---compressed-bracket-sequence">1556C - Compressed Bracket Sequence</h3>
<p>考虑如果我们遇到了一串连续的右括号，统计他们的贡献。</p>
<ul>
<li>如果左边的左括号比他多，则贡献为右括号的个数。</li>
<li>如果左边的左括号和他一样多，则贡献为右括号的数量加上左边相邻合法括号串的数量。</li>
<li>如果左边的左括号比他少，则贡献为右括号的数量加上左边相邻合法括号串的数量，但是还剩若干右括号没有匹配，往左枚举左括号重复上述三种情况即可。</li>
</ul>
<p>需要维护一个点结尾处合法括号串的数量。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a aria-hidden="true" href="#cb5-1"></a><span class="kw">using</span> ll = <span class="dt">long</span> <span class="dt">long</span>;</span>
<span id="cb5-2"><a aria-hidden="true" href="#cb5-2"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="dv">1005</span>;</span>
<span id="cb5-3"><a aria-hidden="true" href="#cb5-3"></a><span class="dt">int</span> n, a[maxn];</span>
<span id="cb5-4"><a aria-hidden="true" href="#cb5-4"></a>ll sum[maxn];</span>
<span id="cb5-5"><a aria-hidden="true" href="#cb5-5"></a></span>
<span id="cb5-6"><a aria-hidden="true" href="#cb5-6"></a><span class="dt">int</span> main() {</span>
<span id="cb5-7"><a aria-hidden="true" href="#cb5-7"></a>    read(n);</span>
<span id="cb5-8"><a aria-hidden="true" href="#cb5-8"></a>    FOR(i, <span class="dv">1</span>, n) read(a[i]);</span>
<span id="cb5-9"><a aria-hidden="true" href="#cb5-9"></a>    ll ans = <span class="dv">0</span>;</span>
<span id="cb5-10"><a aria-hidden="true" href="#cb5-10"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">2</span>; i &lt;= n; i += <span class="dv">2</span>) {</span>
<span id="cb5-11"><a aria-hidden="true" href="#cb5-11"></a>        <span class="dt">int</span> tot = a[i];</span>
<span id="cb5-12"><a aria-hidden="true" href="#cb5-12"></a>        <span class="cf">for</span> (<span class="dt">int</span> j = i - <span class="dv">1</span>; j &gt;= <span class="dv">1</span>; j -= <span class="dv">2</span>) {</span>
<span id="cb5-13"><a aria-hidden="true" href="#cb5-13"></a>            <span class="cf">if</span> (!tot) <span class="cf">break</span>;</span>
<span id="cb5-14"><a aria-hidden="true" href="#cb5-14"></a>            <span class="cf">if</span> (!a[j]) <span class="cf">continue</span>;</span>
<span id="cb5-15"><a aria-hidden="true" href="#cb5-15"></a>            <span class="cf">if</span> (tot &lt; a[j]) {</span>
<span id="cb5-16"><a aria-hidden="true" href="#cb5-16"></a>                ans += tot;</span>
<span id="cb5-17"><a aria-hidden="true" href="#cb5-17"></a>                a[j] -= tot;</span>
<span id="cb5-18"><a aria-hidden="true" href="#cb5-18"></a>                ++sum[i];</span>
<span id="cb5-19"><a aria-hidden="true" href="#cb5-19"></a>                <span class="cf">break</span>;</span>
<span id="cb5-20"><a aria-hidden="true" href="#cb5-20"></a>            } <span class="cf">else</span> <span class="cf">if</span> (tot == a[j]) {</span>
<span id="cb5-21"><a aria-hidden="true" href="#cb5-21"></a>                ans += tot + sum[j - <span class="dv">1</span>];</span>
<span id="cb5-22"><a aria-hidden="true" href="#cb5-22"></a>                sum[i] += <span class="dv">1</span> + sum[j - <span class="dv">1</span>];</span>
<span id="cb5-23"><a aria-hidden="true" href="#cb5-23"></a>                a[j] = <span class="dv">0</span>;</span>
<span id="cb5-24"><a aria-hidden="true" href="#cb5-24"></a>                <span class="cf">break</span>;</span>
<span id="cb5-25"><a aria-hidden="true" href="#cb5-25"></a>            } <span class="cf">else</span> {</span>
<span id="cb5-26"><a aria-hidden="true" href="#cb5-26"></a>                tot -= a[j];</span>
<span id="cb5-27"><a aria-hidden="true" href="#cb5-27"></a>                ans += a[j] + sum[j - <span class="dv">1</span>];</span>
<span id="cb5-28"><a aria-hidden="true" href="#cb5-28"></a>                a[j] = <span class="dv">0</span>;</span>
<span id="cb5-29"><a aria-hidden="true" href="#cb5-29"></a>            }</span>
<span id="cb5-30"><a aria-hidden="true" href="#cb5-30"></a>        }</span>
<span id="cb5-31"><a aria-hidden="true" href="#cb5-31"></a>    }</span>
<span id="cb5-32"><a aria-hidden="true" href="#cb5-32"></a>    print(ans, <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span>);</span>
<span id="cb5-33"><a aria-hidden="true" href="#cb5-33"></a>    <span class="cf">return</span> output(), <span class="dv">0</span>;</span>
<span id="cb5-34"><a aria-hidden="true" href="#cb5-34"></a>}</span></code></pre></div>
<h3 id="d---take-a-guess">1556D - Take a Guess</h3>
<p>有一个很关键的结论是 <span class="math inline">\(a + b = (a\land b) + (a\lor b)\)</span>。</p>
<p>所以直接询问 <span class="math inline">\(a_1 + a_i\)</span>（<span class="math inline">\(i\le [2, n]\)</span>），然后再询问 <span class="math inline">\(a_2 + a_3\)</span>，就可以刚好在 <span class="math inline">\(2n\)</span> 次询问里面得到答案。</p>
<h3 id="e---equilibrium">1556E - Equilibrium</h3>
<p>首先，令 <span class="math inline">\(c_i = b_i - a_i\)</span>，则一次操作变为在 <span class="math inline">\(c\)</span> 的某些位置上加一，某些位置上减一，目标变为使某一段 <span class="math inline">\(c\)</span> 全部变为 <span class="math inline">\(0\)</span>。</p>
<p>可行性：会发现这个操作有点类似括号匹配，故 <span class="math inline">\(c\)</span> 在 <span class="math inline">\([l, r]\)</span> 上的任意位置的前缀和不可小于零而且总和要为 <span class="math inline">\(0\)</span>。即 <span class="math inline">\(\min\{s_j\}\ge s_{l - 1}\)</span>。需要一个 RMQ。</p>
<p>构造答案：将加减法两两配对之后多组的一起完成。即为嵌套最深的括号，相当于爬山爬的最高峰，查一下爬山的最高峰即可。也需要一个 RMQ。直接上就行了。</p>
<h3 id="f---sports-betting">1556F - Sports Betting</h3>
<h3 id="g---gates-to-another-world">1556G - Gates to Another World</h3>
<h2 id="codeforces-round-742-div.-2">Codeforces Round #742 (Div. 2)</h2>
<p>A + B + C</p>
<h3 id="c---carrying-conundrum">1567C - Carrying Conundrum</h3>
<p>题意：定义 Alice 的加法为 <span class="math inline">\(a + b\)</span> 竖式下进位进到前面两位去。问有多少种有序正整数对 <span class="math inline">\((a, b)\)</span> 使得 <span class="math inline">\(a + b = n\)</span>。</p>
<p>可以考虑 DP，注意到只有当前位和后面一位有后效性，所以可以令 <span class="math inline">\(f_{i, k_0, k_1}\)</span> 表示从低到高第 <span class="math inline">\(i\)</span> 位，当前位及上一位有没有产生进位，转移易得，答案为 <span class="math inline">\(f_{len, 0, 0}\)</span>。</p>
<p>注意需要去除 <span class="math inline">\((n, 0)\)</span> 和 <span class="math inline">\((0, n)\)</span>。<a href="https://codeforces.com/contest/1567/submission/127974617">评测记录#127974617</a>。</p>
<h3 id="d---expression-evaluation-error">1567D - Expression Evaluation Error</h3>
<p>题意：给定一个数 <span class="math inline">\(s\)</span>，要求划分成 <span class="math inline">\(n\)</span> 个数 <span class="math inline">\(n_1,\cdots n_s\)</span>，要求把这些数看成 <span class="math inline">\(11\)</span> 进制的然后按照 <span class="math inline">\(11\)</span> 进制加起来使得结果最大。构造方案。</p>
<p>首先考虑按位贪心：让最高位最大是显然的，让其等于 <span class="math inline">\(s\)</span> 的最高位一定是最优的。然后我们会发现这个构造出的最大结果一定不会大于 <span class="math inline">\(s\)</span> 看成 <span class="math inline">\(11\)</span> 进制表示的结果。</p>
<p>最优的做法是尽量让 Alice 不要进位：将 <span class="math inline">\(s\)</span> 表示成 <span class="math inline">\(10^k\)</span> 之和，例如 <span class="math inline">\(25\)</span> 就可以被表示为 <span class="math inline">\(10 + 10 + 1 + 1 + 1 + 1 + 1\)</span>。但是难免有划分数量多的时候，那么就从高位往低位贪，让高位尽量不要进位即可。</p>
<p>所以从最高位往最低位依次划分即可。</p>
<h3 id="e---non-decreasing-dilemma">1567E - Non-Decreasing Dilemma</h3>
<p>单点修改序列，区间查询不降子段个数。</p>
<p>线段树维护每个区间的答案，左端的不降子段长度，右端的不降子段长度。</p>
<p>注意 <code>pushup</code> 即可。<a href="https://codeforces.com/contest/1567/submission/127985171">评测记录</a></p>
<h3 id="f---one-four-overload">1567F - One-Four Overload</h3>
<p>题意：给定 <span class="math inline">\(n\times m\)</span> 的方格，有 <code>.</code> 和 <code>X</code> 两种点，要求在 <code>.</code> 中填入 <span class="math inline">\(1\)</span> 或 <span class="math inline">\(4\)</span>，<code>X</code> 点中填入 <span class="math inline">\(5\)</span> 的倍数满足其为与其四联通的 <code>.</code> 中数字之和。输出无解或构造方案。</p>
<p>注意到 <span class="math display">\[
\begin{aligned}
1&amp;\equiv 1&amp;\pmod 5\\
4&amp;\equiv -1&amp;\pmod 5
\end{aligned}
\]</span> 所以，不难发现一个 <code>X</code> 点旁边必须具有数量相等的 <span class="math inline">\(1\)</span> 和 <span class="math inline">\(4\)</span>。对于形如 <code>.X.</code> 的情况，只需要建边然后二分图染色一下就好了。关键是对于“十”字形的我们怎么处理。</p>
<p>在纸上手玩几个发现对面的填相同颜色的是最优的，这样子能方便其他的构造方案：如</p>
<pre class="plain"><code>.1..
4X41
.1XX
.1X4</code></pre>
<p>如果我们这样</p>
<pre class="plain"><code>.1..
1X4.
.4XX
..X.</code></pre>
<p>发现构造不出来。按照上述方法构造二分图（为什么是二分图应该挺显然的）然后就可以通过了。<a href="https://codeforces.com/contest/1567/submission/128134089">评测记录</a>。</p>
<h2 id="codeforces-global-round-16">Codeforces Global Round 16</h2>
<p>A + B + C + D1。D2 已补，水。</p>
<h3 id="e---buds-re-hanging">1566E - Buds Re-hanging</h3>
<p>定义一棵有根树的一个节点为 bud 当且仅当其有至少一个儿子且其所有儿子都为叶节点。</p>
<p>每次操作可以提出一个 bud 及其儿子然后接在任意一个节点下面。</p>
<p>问若干次操作之后叶子节点最少为多少个。</p>
<p>一个 bud 接在一个叶子下之后会使得叶子节点至多减 <span class="math inline">\(1\)</span>（如果 bud 上面是根则会减 <span class="math inline">\(1\)</span>）。而且移动 bud 的过程可逆，不妨将所有的 bud 找出来接在根上，设树节点为 <span class="math inline">\(n\)</span>，bud 有 <span class="math inline">\(k\)</span> 个，则叶子节点数肯定为 <span class="math inline">\(n - k - 1\)</span>（总结点减去根和每个 bud）。</p>
<p>然后考虑如果根上至少连有一个叶子节点，则把所有的 bud 依次接上去，一共会接 <span class="math inline">\(k\)</span> 次，答案为 <span class="math inline">\(n - 2k - 1\)</span>。</p>
<p>如果根上没有直接连的叶子节点，则把每个 bud 依次合并，接 <span class="math inline">\(k - 1\)</span> 次，答案为 <span class="math inline">\(n - k - 1 - (k -1) = n - 2k\)</span>。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a aria-hidden="true" href="#cb8-1"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">2e5</span> + <span class="dv">5</span>;</span>
<span id="cb8-2"><a aria-hidden="true" href="#cb8-2"></a></span>
<span id="cb8-3"><a aria-hidden="true" href="#cb8-3"></a><span class="dt">int</span> n, head[maxn], to[maxn &lt;&lt; <span class="dv">1</span>], nxt[maxn &lt;&lt; <span class="dv">1</span>], cnte, d[maxn], k;</span>
<span id="cb8-4"><a aria-hidden="true" href="#cb8-4"></a></span>
<span id="cb8-5"><a aria-hidden="true" href="#cb8-5"></a>il <span class="dt">void</span> add(<span class="dt">int</span> u, <span class="dt">int</span> v) {</span>
<span id="cb8-6"><a aria-hidden="true" href="#cb8-6"></a>    to[++cnte] = v;</span>
<span id="cb8-7"><a aria-hidden="true" href="#cb8-7"></a>    nxt[cnte] = head[u];</span>
<span id="cb8-8"><a aria-hidden="true" href="#cb8-8"></a>    head[u] = cnte;</span>
<span id="cb8-9"><a aria-hidden="true" href="#cb8-9"></a>    <span class="cf">return</span>;</span>
<span id="cb8-10"><a aria-hidden="true" href="#cb8-10"></a>}</span>
<span id="cb8-11"><a aria-hidden="true" href="#cb8-11"></a></span>
<span id="cb8-12"><a aria-hidden="true" href="#cb8-12"></a><span class="dt">void</span> dfs(<span class="dt">int</span> u, <span class="dt">int</span> fa) {</span>
<span id="cb8-13"><a aria-hidden="true" href="#cb8-13"></a>    <span class="dt">bool</span> flag = <span class="dv">0</span>;</span>
<span id="cb8-14"><a aria-hidden="true" href="#cb8-14"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = head[u]; i; i = nxt[i]) {</span>
<span id="cb8-15"><a aria-hidden="true" href="#cb8-15"></a>        <span class="dt">int</span> v = to[i];</span>
<span id="cb8-16"><a aria-hidden="true" href="#cb8-16"></a>        <span class="cf">if</span> (v == fa) <span class="cf">continue</span>;</span>
<span id="cb8-17"><a aria-hidden="true" href="#cb8-17"></a>        dfs(v, u);</span>
<span id="cb8-18"><a aria-hidden="true" href="#cb8-18"></a>        <span class="cf">if</span> (d[v] == <span class="dv">2</span>) flag = <span class="dv">1</span>;</span>
<span id="cb8-19"><a aria-hidden="true" href="#cb8-19"></a>    }</span>
<span id="cb8-20"><a aria-hidden="true" href="#cb8-20"></a>    <span class="cf">if</span> (fa) {</span>
<span id="cb8-21"><a aria-hidden="true" href="#cb8-21"></a>        <span class="cf">if</span> (flag) ++k, d[u] = <span class="dv">3</span>;</span>
<span id="cb8-22"><a aria-hidden="true" href="#cb8-22"></a>        <span class="cf">else</span> d[u] = <span class="dv">2</span>;</span>
<span id="cb8-23"><a aria-hidden="true" href="#cb8-23"></a>    }</span>
<span id="cb8-24"><a aria-hidden="true" href="#cb8-24"></a>    <span class="cf">return</span>;</span>
<span id="cb8-25"><a aria-hidden="true" href="#cb8-25"></a>}</span>
<span id="cb8-26"><a aria-hidden="true" href="#cb8-26"></a></span>
<span id="cb8-27"><a aria-hidden="true" href="#cb8-27"></a><span class="dt">int</span> main() {</span>
<span id="cb8-28"><a aria-hidden="true" href="#cb8-28"></a>    <span class="dt">int</span> T; read(T);</span>
<span id="cb8-29"><a aria-hidden="true" href="#cb8-29"></a>    <span class="cf">while</span> (T--) {</span>
<span id="cb8-30"><a aria-hidden="true" href="#cb8-30"></a>        read(n);</span>
<span id="cb8-31"><a aria-hidden="true" href="#cb8-31"></a>        FOR(i, <span class="dv">1</span>, n) head[i] = d[i] = <span class="dv">0</span>;</span>
<span id="cb8-32"><a aria-hidden="true" href="#cb8-32"></a>        k = <span class="dv">0</span>;</span>
<span id="cb8-33"><a aria-hidden="true" href="#cb8-33"></a>        FOR(i, <span class="dv">1</span>, n - <span class="dv">1</span>) {</span>
<span id="cb8-34"><a aria-hidden="true" href="#cb8-34"></a>            <span class="dt">int</span> u, v; read(u), read(v);</span>
<span id="cb8-35"><a aria-hidden="true" href="#cb8-35"></a>            add(u, v), add(v, u);</span>
<span id="cb8-36"><a aria-hidden="true" href="#cb8-36"></a>        }</span>
<span id="cb8-37"><a aria-hidden="true" href="#cb8-37"></a>        dfs(<span class="dv">1</span>, <span class="dv">0</span>);</span>
<span id="cb8-38"><a aria-hidden="true" href="#cb8-38"></a>        <span class="dt">int</span> s = <span class="dv">0</span>;</span>
<span id="cb8-39"><a aria-hidden="true" href="#cb8-39"></a>        <span class="cf">for</span> (<span class="dt">int</span> i = head[<span class="dv">1</span>]; i; i = nxt[i])</span>
<span id="cb8-40"><a aria-hidden="true" href="#cb8-40"></a>            <span class="cf">if</span> (d[to[i]] == <span class="dv">2</span>) {s = <span class="dv">1</span>; <span class="cf">break</span>;}</span>
<span id="cb8-41"><a aria-hidden="true" href="#cb8-41"></a>        print(n - <span class="dv">2</span> * k - s), putchar(<span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span>);</span>
<span id="cb8-42"><a aria-hidden="true" href="#cb8-42"></a>    }</span>
<span id="cb8-43"><a aria-hidden="true" href="#cb8-43"></a>    <span class="cf">return</span> output(), <span class="dv">0</span>;</span>
<span id="cb8-44"><a aria-hidden="true" href="#cb8-44"></a>}</span></code></pre></div>
<h2 id="codeforces-round-743-div.-12">Codeforces Round #743 (Div. 1/2)</h2>
<p>VP on 21/10/09。D2A + D2B + D1A + D1B。</p>
<h3 id="b---xor-of-3">1572B - Xor of 3</h3>
<p>首先有解的必要条件是 <span class="math inline">\(1\)</span> 的个数为偶数个，因为每次操作是不会改变 <span class="math inline">\(1\)</span> 的个数的奇偶性的。</p>
<p>然后考虑构造，若 <span class="math inline">\(n\)</span> 为奇数，那么执行 <span class="math inline">\(n - 2, \cdots, 3, 1\)</span>，这样子之后 <span class="math inline">\(a_1 = 0\)</span>，然后再执行一遍 <span class="math inline">\(1, 3, \cdots, n - 2\)</span> 就可以了。</p>
<p>对于 <span class="math inline">\(n\)</span> 为偶数的情况将其拆成两段长度为奇数的含偶数个 <span class="math inline">\(1\)</span> 的然后分开做就行了。</p>
<h3 id="c---paint">1572C - Paint</h3>
<p>题意：给定一个最多含 <span class="math inline">\(20\)</span> 种颜色的序列，每次操作可以把一段颜色相同的区间染成一种颜色，问将所有颜色染成同一种的最小操作次数。<span class="math inline">\(n\le 3000\)</span>。</p>
<p>考虑区间 dp。</p>
<p>首先肯定将相邻的同色缩起来。</p>
<p>然后设 <span class="math inline">\(f_{i, j}\)</span> 为<strong>将 <span class="math inline">\([i, j]\)</span> 染成 <span class="math inline">\(c_j\)</span> 的最小代价</strong>。为什么这样定义状态是因为一定存在一种方案使得最后的颜色为 <span class="math inline">\(c_j\)</span>，容易发现将 <span class="math inline">\([1, j - 1]\)</span> 同色之后再和 <span class="math inline">\(c_j\)</span> 统一是不会更劣的。</p>
<p>首先有 <span class="math inline">\(f_{i, j} = \min\{f_{i + 1, j}, f_{i, j - 1} \} + 1\)</span>。</p>
<p>其次，如果存在 <span class="math inline">\(k\)</span> 使得 <span class="math inline">\(i\le k &lt; j\)</span> 且 <span class="math inline">\(c_k = c_j\)</span>，那么我们也可以从 <span class="math inline">\(f_{i, k} + f_{k + 1, j}\)</span> 转移过来。记录一下上一个与 <span class="math inline">\(k\)</span> 颜色相同的点就可以了。答案为 <span class="math inline">\(f_{1, n}\)</span>。</p>
<h3 id="d---bridge-club">1572D - Bridge Club</h3>
<p>显然，图为二分图，按照二进制表示下 <span class="math inline">\(1\)</span> 的个数即可分为左部和右部，中间连权为 <span class="math inline">\(a_i + a_j\)</span> 的边。</p>
<p>但是直接费用流或者 KM 都会死掉，因为点数为 <span class="math inline">\(O(2^n)\)</span> 级别，边数为 <span class="math inline">\(O(n2^n)\)</span> 级别，必死无疑。但是注意到这个 <span class="math inline">\(k\)</span> 是很小的，我们需要从 <span class="math inline">\(k\)</span> 上下手。</p>
<p>不难发现，每个点会连出去 <span class="math inline">\(n\)</span> 条边，如果我们选择了一个匹配，那么剩下能匹配的方案数就会减少 <span class="math inline">\(2(n - 1)\)</span>，所以我们选了 <span class="math inline">\(k\)</span> 个匹配后最多只会减少 <span class="math inline">\(k(2n - 1)\)</span> 个匹配方式，即我们选了 <span class="math inline">\(k(2n - 1)\)</span> 个匹配就会至少存在 <span class="math inline">\(k\)</span> 个匹配。</p>
<p>所以我们只需要选出最大的 <span class="math inline">\(k(2n - 1)\)</span> 条边，然后跑费用流就行了，不难发现一定有最优的方案存在在这最大的 <span class="math inline">\(k(2n - 1)\)</span> 条边里面，证明可用反证法。</p>
<p>具体实现中，选出最大的 <span class="math inline">\(k(2n - 1)\)</span> 条边我们使用 STL 的 <code>nth_element()</code> 函数，其复杂度为 <span class="math inline">\(O(\text{length of the seq})\)</span>，本题中为 <span class="math inline">\(n2^n\)</span>，然后注意加边的时候不要给每个 <span class="math inline">\([0, 2^n - 1]\)</span> 的球员都加边，否则会 TLE。</p>
<h3 id="e---polygon">1572E - Polygon</h3>
<p>给定一个严格凸多边形，最大化划 <span class="math inline">\(k\)</span> 刀后的最小面积，<span class="math inline">\(3\le n\le 200, 0\le k\le n - 3\)</span>。</p>
<p>二分这个最小面积。现在我们就需要划出来的 <span class="math inline">\(k + 1\)</span> 个区域的面积都大于等于 <span class="math inline">\(S\)</span>。</p>
<p>只考虑划分 <span class="math inline">\([l, r]\)</span> 这个区间的点，有个贪心就是我们尽可能多划分，而 <span class="math inline">\(l\)</span> 和 <span class="math inline">\(r\)</span> 相邻的这部分有可能面积不大于 <span class="math inline">\(S\)</span>，我们要让其尽可能大。</p>
<p>设 <span class="math inline">\(f_{l, r} = (K, M)\)</span> 表示最多划分出了 <span class="math inline">\(K\)</span> 块合法的区域，<span class="math inline">\(l\)</span> 和 <span class="math inline">\(r\)</span> 相邻部分这块三角形的最大面积为 <span class="math inline">\(M\)</span>。转移易得，枚举 <span class="math inline">\(k\in(l, r)\)</span> 然后考虑合并 <span class="math inline">\(M\)</span> 和 <span class="math inline">\(K\)</span> 即可。</p>
<p>只要 <span class="math inline">\(f_{1, n}\ge k + 1\)</span>，就说明二分出来这个面积是合法的。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a aria-hidden="true" href="#cb9-1"></a><span class="kw">using</span> ll = <span class="dt">long</span> <span class="dt">long</span>;</span>
<span id="cb9-2"><a aria-hidden="true" href="#cb9-2"></a><span class="kw">using</span> pii = <span class="bu">std::</span>pair&lt;ll, ll&gt;;</span>
<span id="cb9-3"><a aria-hidden="true" href="#cb9-3"></a></span>
<span id="cb9-4"><a aria-hidden="true" href="#cb9-4"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="dv">205</span>;</span>
<span id="cb9-5"><a aria-hidden="true" href="#cb9-5"></a>ll x[maxn], y[maxn];</span>
<span id="cb9-6"><a aria-hidden="true" href="#cb9-6"></a><span class="dt">int</span> n, k;</span>
<span id="cb9-7"><a aria-hidden="true" href="#cb9-7"></a>pii f[maxn][maxn];</span>
<span id="cb9-8"><a aria-hidden="true" href="#cb9-8"></a></span>
<span id="cb9-9"><a aria-hidden="true" href="#cb9-9"></a>ll S(<span class="dt">int</span> i, <span class="dt">int</span> j, <span class="dt">int</span> k) {<span class="cf">return</span> (x[j] - x[i]) * (y[k] - y[i]) - (y[j] - y[i]) * (x[k] - x[i]);}</span>
<span id="cb9-10"><a aria-hidden="true" href="#cb9-10"></a></span>
<span id="cb9-11"><a aria-hidden="true" href="#cb9-11"></a><span class="dt">bool</span> check(ll mid) {</span>
<span id="cb9-12"><a aria-hidden="true" href="#cb9-12"></a>    FOR(len, <span class="dv">3</span>, n) {</span>
<span id="cb9-13"><a aria-hidden="true" href="#cb9-13"></a>        <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>, j = i + len - <span class="dv">1</span>; j &lt;= n; ++i, ++j) {</span>
<span id="cb9-14"><a aria-hidden="true" href="#cb9-14"></a>            f[i][j] = pii(<span class="dv">0</span>, <span class="dv">0</span>);</span>
<span id="cb9-15"><a aria-hidden="true" href="#cb9-15"></a>            FOR(k, i + <span class="dv">1</span>, j - <span class="dv">1</span>) {</span>
<span id="cb9-16"><a aria-hidden="true" href="#cb9-16"></a>                ll K = f[i][k].first + f[k][j].first;</span>
<span id="cb9-17"><a aria-hidden="true" href="#cb9-17"></a>                ll M = f[i][k].second + f[k][j].second + S(i, k, j);</span>
<span id="cb9-18"><a aria-hidden="true" href="#cb9-18"></a>                <span class="cf">if</span> (M &gt;= mid) f[i][j] = max(f[i][j], pii(K + <span class="dv">1</span>, <span class="dv">0</span>));</span>
<span id="cb9-19"><a aria-hidden="true" href="#cb9-19"></a>                <span class="cf">else</span> f[i][j] = max(f[i][j], pii(K, M));</span>
<span id="cb9-20"><a aria-hidden="true" href="#cb9-20"></a>            }</span>
<span id="cb9-21"><a aria-hidden="true" href="#cb9-21"></a>        }</span>
<span id="cb9-22"><a aria-hidden="true" href="#cb9-22"></a>    }</span>
<span id="cb9-23"><a aria-hidden="true" href="#cb9-23"></a>    <span class="cf">return</span> f[<span class="dv">1</span>][n].first &gt; k;</span>
<span id="cb9-24"><a aria-hidden="true" href="#cb9-24"></a>}</span>
<span id="cb9-25"><a aria-hidden="true" href="#cb9-25"></a></span>
<span id="cb9-26"><a aria-hidden="true" href="#cb9-26"></a><span class="dt">int</span> main() {</span>
<span id="cb9-27"><a aria-hidden="true" href="#cb9-27"></a>    read(n), read(k);</span>
<span id="cb9-28"><a aria-hidden="true" href="#cb9-28"></a>    FOR(i, <span class="dv">1</span>, n) read(x[i]), read(y[i]);</span>
<span id="cb9-29"><a aria-hidden="true" href="#cb9-29"></a>    ll l = <span class="dv">0</span>, r = <span class="fl">4e18</span>, ans;</span>
<span id="cb9-30"><a aria-hidden="true" href="#cb9-30"></a>    <span class="cf">while</span> (l &lt;= r) {</span>
<span id="cb9-31"><a aria-hidden="true" href="#cb9-31"></a>        ll mid = (l + r) &gt;&gt; <span class="dv">1</span>;</span>
<span id="cb9-32"><a aria-hidden="true" href="#cb9-32"></a>        <span class="cf">if</span> (check(mid)) ans = mid, l = mid + <span class="dv">1</span>;</span>
<span id="cb9-33"><a aria-hidden="true" href="#cb9-33"></a>        <span class="cf">else</span> r = mid - <span class="dv">1</span>;</span>
<span id="cb9-34"><a aria-hidden="true" href="#cb9-34"></a>    }</span>
<span id="cb9-35"><a aria-hidden="true" href="#cb9-35"></a>    print(ans, <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span>);</span>
<span id="cb9-36"><a aria-hidden="true" href="#cb9-36"></a>    <span class="cf">return</span> output(), <span class="dv">0</span>;</span>
<span id="cb9-37"><a aria-hidden="true" href="#cb9-37"></a>}</span></code></pre></div>
<h2 id="codeforces-round-745-div.-12">Codeforces Round #745 (Div. 1/2)</h2>
<p>真的很毒瘤的场。Terrible Round。</p>
<h3 id="d---subsequence">1580D - Subsequence</h3>
<p>给定长度为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(a\)</span>，所有元素两两不同。需要选择一个长度为 <span class="math inline">\(m\)</span> 的子序列 <span class="math inline">\(a_{b_1}, a_{b_2},\cdots, a_{b_m}\)</span>，要使得其代价最大。</p>
<p>子序列的价值被定义为 <span class="math display">\[
\sum_{i=1}^m(m\cdot a_{b_i}) - \sum_{i=1}^m\sum_{j=1}^mf(\min(b_i, b_j), \max(b_i, b_j))
\]</span> 其中 <span class="math inline">\(f(x, y)\)</span> 表示 <span class="math inline">\(\min_{x\le i\le y}\{a_i \}\)</span>。<span class="math inline">\(1\le m\le n\le 4000\)</span>。</p>
<p>化出式子： <span class="math display">\[
\sum_{i = 1}^m(m - 1)a_{b_i} - 2\sum_{i=1}^{m-1}\sum_{j=i+1}^mf(b_i, b_j)
\]</span> 然后像 <span class="math inline">\(f\)</span> 这种一脸 RMQ 样的东西考虑放到笛卡尔树上，然后再化好看一点： <span class="math display">\[
\sum_{i=1}^{m-1}\sum_{j=i+1}^m a_{b_i} + a_{b_j} - 2f(b_i, b_j)
\]</span> 那就是 <span class="math inline">\(a_{b_i} + a_{b_j}\)</span> 再减去两倍他们的 LCA 的值，很像两点间的树上距离。考虑树形 dp <span class="math inline">\(f_{i,j}\)</span> 表示 <span class="math inline">\(i\)</span> 子树里面选了 <span class="math inline">\(j\)</span> 个元素的最大代价，容易知道时间复杂度为 <span class="math inline">\(O(n^2)\)</span>。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a aria-hidden="true" href="#cb10-1"></a><span class="kw">using</span> ll = <span class="dt">long</span> <span class="dt">long</span>;</span>
<span id="cb10-2"><a aria-hidden="true" href="#cb10-2"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="dv">4005</span>;</span>
<span id="cb10-3"><a aria-hidden="true" href="#cb10-3"></a><span class="dt">int</span> n, m, ls[maxn], rs[maxn], stk[maxn], top;</span>
<span id="cb10-4"><a aria-hidden="true" href="#cb10-4"></a>ll a[maxn], size[maxn], f[maxn][maxn], w[maxn];</span>
<span id="cb10-5"><a aria-hidden="true" href="#cb10-5"></a></span>
<span id="cb10-6"><a aria-hidden="true" href="#cb10-6"></a><span class="dt">void</span> dfs(<span class="dt">int</span> u) {</span>
<span id="cb10-7"><a aria-hidden="true" href="#cb10-7"></a>    size[u] = <span class="dv">1</span>;</span>
<span id="cb10-8"><a aria-hidden="true" href="#cb10-8"></a>    <span class="cf">if</span> (ls[u]) {</span>
<span id="cb10-9"><a aria-hidden="true" href="#cb10-9"></a>        dfs(ls[u]), w[ls[u]] = a[ls[u]] - a[u];</span>
<span id="cb10-10"><a aria-hidden="true" href="#cb10-10"></a>        DEC(i, size[u], <span class="dv">0</span>)</span>
<span id="cb10-11"><a aria-hidden="true" href="#cb10-11"></a>            DEC(j, size[ls[u]], <span class="dv">0</span>)</span>
<span id="cb10-12"><a aria-hidden="true" href="#cb10-12"></a>                chkmax(f[u][i + j], f[u][i] + f[ls[u]][j] + j * (m - j) * w[ls[u]]);</span>
<span id="cb10-13"><a aria-hidden="true" href="#cb10-13"></a>        size[u] += size[ls[u]];</span>
<span id="cb10-14"><a aria-hidden="true" href="#cb10-14"></a>    }</span>
<span id="cb10-15"><a aria-hidden="true" href="#cb10-15"></a>    <span class="cf">if</span> (rs[u]) {</span>
<span id="cb10-16"><a aria-hidden="true" href="#cb10-16"></a>        dfs(rs[u]), w[rs[u]] = a[rs[u]] - a[u];</span>
<span id="cb10-17"><a aria-hidden="true" href="#cb10-17"></a>        DEC(i, size[u], <span class="dv">0</span>)</span>
<span id="cb10-18"><a aria-hidden="true" href="#cb10-18"></a>            DEC(j, size[rs[u]], <span class="dv">0</span>)</span>
<span id="cb10-19"><a aria-hidden="true" href="#cb10-19"></a>                chkmax(f[u][i + j], f[u][i] + f[rs[u]][j] + j * (m - j) * w[rs[u]]);</span>
<span id="cb10-20"><a aria-hidden="true" href="#cb10-20"></a>        size[u] += size[rs[u]];</span>
<span id="cb10-21"><a aria-hidden="true" href="#cb10-21"></a>    }</span>
<span id="cb10-22"><a aria-hidden="true" href="#cb10-22"></a>    <span class="cf">return</span>;</span>
<span id="cb10-23"><a aria-hidden="true" href="#cb10-23"></a>}</span>
<span id="cb10-24"><a aria-hidden="true" href="#cb10-24"></a></span>
<span id="cb10-25"><a aria-hidden="true" href="#cb10-25"></a><span class="dt">int</span> main() {</span>
<span id="cb10-26"><a aria-hidden="true" href="#cb10-26"></a>    read(n, m);</span>
<span id="cb10-27"><a aria-hidden="true" href="#cb10-27"></a>    FOR(i, <span class="dv">1</span>, n) read(a[i]);</span>
<span id="cb10-28"><a aria-hidden="true" href="#cb10-28"></a>    stk[top = <span class="dv">1</span>] = <span class="dv">1</span>;</span>
<span id="cb10-29"><a aria-hidden="true" href="#cb10-29"></a>    FOR(i, <span class="dv">2</span>, n) {</span>
<span id="cb10-30"><a aria-hidden="true" href="#cb10-30"></a>        <span class="cf">while</span> (top &amp;&amp; a[stk[top]] &gt; a[i]) --top;</span>
<span id="cb10-31"><a aria-hidden="true" href="#cb10-31"></a>        <span class="cf">if</span> (!top) ls[i] = stk[top + <span class="dv">1</span>];</span>
<span id="cb10-32"><a aria-hidden="true" href="#cb10-32"></a>        <span class="cf">else</span> ls[i] = rs[stk[top]], rs[stk[top]] = i;</span>
<span id="cb10-33"><a aria-hidden="true" href="#cb10-33"></a>        stk[++top] = i;</span>
<span id="cb10-34"><a aria-hidden="true" href="#cb10-34"></a>    }</span>
<span id="cb10-35"><a aria-hidden="true" href="#cb10-35"></a>    dfs(stk[<span class="dv">1</span>]);</span>
<span id="cb10-36"><a aria-hidden="true" href="#cb10-36"></a>    print(f[stk[<span class="dv">1</span>]][m]);</span>
<span id="cb10-37"><a aria-hidden="true" href="#cb10-37"></a>    <span class="cf">return</span> output(), <span class="dv">0</span>;</span>
<span id="cb10-38"><a aria-hidden="true" href="#cb10-38"></a>}</span></code></pre></div>
<h2 id="codeforces-round-746-div.-2">Codeforces Round #746 (Div. 2)</h2>
<p>题目出得不错。</p>
<h3 id="c---bakry-and-partitioning">1592C - Bakry and Partitioning</h3>
<p>问将一棵树划分为最多 <span class="math inline">\(k\)</span> 个连通块，要求这些连通块内点权的异或和相等，问是否有解。</p>
<p>首先发现，如果所有的点权异或和为 <span class="math inline">\(0\)</span>，则必然有解，而且断掉任意一条边都是可以的。</p>
<p>然而异或和可能不为 <span class="math inline">\(0\)</span>，我们不妨设其为 <span class="math inline">\(m\)</span>。而根据异或的性质，我们知道划分出来的各个连通块的异或和只能为 <span class="math inline">\(m\)</span>，而且连通块的个数为奇数。</p>
<p>这是为什么？考虑划分为三个连通块的情况：既要异或起来为 <span class="math inline">\(m\)</span> 又要两两相等，不难发现只能为三个 <span class="math inline">\(m\)</span>。然后我们又会发现，但凡有解，一定能划分为这样的三个连通块。</p>
<p>现在问题就转化为了找到三个连通块使得他们的异或和都为 <span class="math inline">\(m\)</span>。dfs 扫描一遍即可。如果遇到一个节点 <span class="math inline">\(u\)</span> 有两个子树 <span class="math inline">\(v_1,v_2\)</span> 内含异或和为 <span class="math inline">\(m\)</span> 的子树，则一定有解。而且，如果当前子树 <span class="math inline">\(u\)</span> 的异或和为 <span class="math inline">\(0\)</span>，且存在一个包含在 <span class="math inline">\(u\)</span> 内的异或和为 <span class="math inline">\(m\)</span> 的子树，则也一定有解。</p>
<p>稍加分析可知上面两种涵盖了所有的情况。</p>
<h3 id="d---hemose-in-icpc">1592D - Hemose in ICPC ?</h3>
<p>点数为 <span class="math inline">\(n\)</span>（<span class="math inline">\(n \le 1000\)</span>）的树，最多 <span class="math inline">\(12\)</span> 次查询，每次查询给定一个点集，返回最大的 <span class="math inline">\(Dist(u, v)\)</span>，代表 <span class="math inline">\(u\)</span> 到 <span class="math inline">\(v\)</span> 的简单路径上的边权的 <span class="math inline">\(\gcd\)</span>。要求找到 <span class="math inline">\(\gcd\)</span> 最大的 <span class="math inline">\(u\)</span> 和 <span class="math inline">\(v\)</span>。</p>
<p>注意到 <span class="math inline">\(\gcd\)</span> 只会减小，不会增大，因此 <span class="math inline">\(\gcd(u, v)\)</span> 最大时一定是 <span class="math inline">\(u\)</span> 和 <span class="math inline">\(v\)</span> 相连，相当于我们要找这棵树的最大边权。</p>
<p>如何去找？这个查询次数和数据范围很明显的暗示了我们要二分一个点集，可是我们如何保证二分出来的两个点集是联通的呢？</p>
<p>不妨考虑这棵树的欧拉序，将欧拉序建出来后会发现两两之间一定是有边的，所以在欧拉序上二分找最大值就可以了，可以保证查询次数最多为 <span class="math inline">\(1 + \log(2n - 1)\)</span>。</p>
<p>实现起来很简单。</p>
<h2 id="codeforces-round-747-div.-2">Codeforces Round #747 (Div. 2)</h2>
<p>A + B + C + D + E1。rk 606。补完了，好耶。</p>
<h3 id="e2---rubiks-cube-coloring-hard-version">1594E2 - Rubik’s Cube Coloring (hard version)</h3>
<p>题意：<span class="math inline">\(k\)</span> 层的满二叉树，<span class="math inline">\(n\)</span> 个节点已经被染色，颜色来自魔方的六种颜色。要求树上相邻的节点染的颜色不能为魔方上不 相邻的颜色，问将整棵树涂满的方案数。</p>
<p>继承一下 E1 的做法，没有预先钦定的颜色那么答案为 <span class="math inline">\(6\times 4^{2^k - 2}\)</span>。我们发现，已经钦定好的 <span class="math inline">\(n\)</span> 个点会影响其到根的一条路径，把这条路径抽出来 dp 即可。然后令没有被影响的点有 <span class="math inline">\(m\)</span> 个，答案乘上 <span class="math inline">\(4^m\)</span> 即可。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a aria-hidden="true" href="#cb11-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb11-2"><a aria-hidden="true" href="#cb11-2"></a><span class="kw">using</span> ll = <span class="dt">long</span> <span class="dt">long</span>;</span>
<span id="cb11-3"><a aria-hidden="true" href="#cb11-3"></a></span>
<span id="cb11-4"><a aria-hidden="true" href="#cb11-4"></a>map&lt;string, <span class="dt">int</span>&gt; st;</span>
<span id="cb11-5"><a aria-hidden="true" href="#cb11-5"></a>map&lt;ll, modint&gt; f[<span class="dv">3</span>];</span>
<span id="cb11-6"><a aria-hidden="true" href="#cb11-6"></a>map&lt;ll, <span class="dt">int</span>&gt; mp;</span>
<span id="cb11-7"><a aria-hidden="true" href="#cb11-7"></a>map&lt;ll, set&lt;ll&gt; &gt; G;</span>
<span id="cb11-8"><a aria-hidden="true" href="#cb11-8"></a>ll k, n;</span>
<span id="cb11-9"><a aria-hidden="true" href="#cb11-9"></a></span>
<span id="cb11-10"><a aria-hidden="true" href="#cb11-10"></a><span class="dt">void</span> dfs(ll u) {</span>
<span id="cb11-11"><a aria-hidden="true" href="#cb11-11"></a>    <span class="cf">for</span> (<span class="kw">auto</span> v : G[u]) dfs(v);</span>
<span id="cb11-12"><a aria-hidden="true" href="#cb11-12"></a>    FOR(c, <span class="dv">0</span>, <span class="dv">2</span>) {</span>
<span id="cb11-13"><a aria-hidden="true" href="#cb11-13"></a>        <span class="cf">if</span> (~mp[u] &amp;&amp; c ^ mp[u]) <span class="cf">continue</span>;</span>
<span id="cb11-14"><a aria-hidden="true" href="#cb11-14"></a>        f[c][u] = ~mp[u] ? <span class="dv">1</span> : <span class="dv">2</span>;</span>
<span id="cb11-15"><a aria-hidden="true" href="#cb11-15"></a>        <span class="cf">for</span> (<span class="kw">auto</span> v : G[u])</span>
<span id="cb11-16"><a aria-hidden="true" href="#cb11-16"></a>            f[c][u] *= (f[(c + <span class="dv">1</span>) % <span class="dv">3</span>][v] + f[(c + <span class="dv">2</span>) % <span class="dv">3</span>][v]);</span>
<span id="cb11-17"><a aria-hidden="true" href="#cb11-17"></a>    }</span>
<span id="cb11-18"><a aria-hidden="true" href="#cb11-18"></a>    <span class="cf">return</span>;</span>
<span id="cb11-19"><a aria-hidden="true" href="#cb11-19"></a>}</span>
<span id="cb11-20"><a aria-hidden="true" href="#cb11-20"></a></span>
<span id="cb11-21"><a aria-hidden="true" href="#cb11-21"></a><span class="dt">int</span> main() {</span>
<span id="cb11-22"><a aria-hidden="true" href="#cb11-22"></a>    ios::sync_with_stdio(<span class="kw">false</span>);</span>
<span id="cb11-23"><a aria-hidden="true" href="#cb11-23"></a>    cin.tie(<span class="dv">0</span>);</span>
<span id="cb11-24"><a aria-hidden="true" href="#cb11-24"></a>    cin &gt;&gt; k &gt;&gt; n;</span>
<span id="cb11-25"><a aria-hidden="true" href="#cb11-25"></a>    st[<span class="st">"white"</span>] = st[<span class="st">"yellow"</span>] = <span class="dv">0</span>;</span>
<span id="cb11-26"><a aria-hidden="true" href="#cb11-26"></a>    st[<span class="st">"green"</span>] = st[<span class="st">"blue"</span>] = <span class="dv">1</span>;</span>
<span id="cb11-27"><a aria-hidden="true" href="#cb11-27"></a>    st[<span class="st">"red"</span>] = st[<span class="st">"orange"</span>] = <span class="dv">2</span>;</span>
<span id="cb11-28"><a aria-hidden="true" href="#cb11-28"></a>    FOR(i, <span class="dv">1</span>, n) {</span>
<span id="cb11-29"><a aria-hidden="true" href="#cb11-29"></a>        ll u;</span>
<span id="cb11-30"><a aria-hidden="true" href="#cb11-30"></a>        string s;</span>
<span id="cb11-31"><a aria-hidden="true" href="#cb11-31"></a>        cin &gt;&gt; u &gt;&gt; s;</span>
<span id="cb11-32"><a aria-hidden="true" href="#cb11-32"></a>        mp[u] = st[s];</span>
<span id="cb11-33"><a aria-hidden="true" href="#cb11-33"></a>    }</span>
<span id="cb11-34"><a aria-hidden="true" href="#cb11-34"></a>    <span class="cf">if</span> (!mp.count(<span class="dv">1</span>)) mp[<span class="dv">1</span>] = -<span class="dv">1</span>;</span>
<span id="cb11-35"><a aria-hidden="true" href="#cb11-35"></a>    <span class="kw">auto</span> mp0 = mp;</span>
<span id="cb11-36"><a aria-hidden="true" href="#cb11-36"></a>    <span class="cf">for</span> (<span class="kw">auto</span> p : mp0) {</span>
<span id="cb11-37"><a aria-hidden="true" href="#cb11-37"></a>        ll u = p.first;</span>
<span id="cb11-38"><a aria-hidden="true" href="#cb11-38"></a>        <span class="cf">while</span> (u ^ <span class="dv">1</span>) {</span>
<span id="cb11-39"><a aria-hidden="true" href="#cb11-39"></a>            G[u &gt;&gt; <span class="dv">1</span><span class="bu">ll</span>].insert(u);</span>
<span id="cb11-40"><a aria-hidden="true" href="#cb11-40"></a>            <span class="cf">if</span> (!mp.count(u)) mp[u] = -<span class="dv">1</span>;</span>
<span id="cb11-41"><a aria-hidden="true" href="#cb11-41"></a>            u &gt;&gt;= <span class="dv">1</span>;</span>
<span id="cb11-42"><a aria-hidden="true" href="#cb11-42"></a>        }</span>
<span id="cb11-43"><a aria-hidden="true" href="#cb11-43"></a>    }</span>
<span id="cb11-44"><a aria-hidden="true" href="#cb11-44"></a>    dfs(<span class="dv">1</span>);</span>
<span id="cb11-45"><a aria-hidden="true" href="#cb11-45"></a>    modint ans = (f[<span class="dv">0</span>][<span class="dv">1</span>] + f[<span class="dv">1</span>][<span class="dv">1</span>] + f[<span class="dv">2</span>][<span class="dv">1</span>]) * qPow(<span class="dv">4</span>, ((<span class="dv">1</span><span class="bu">ll</span> &lt;&lt; k) - <span class="dv">1</span> - mp.size()) % (mod - <span class="dv">1</span>));</span>
<span id="cb11-46"><a aria-hidden="true" href="#cb11-46"></a>    cout &lt;&lt; ans.val &lt;&lt; endl;</span>
<span id="cb11-47"><a aria-hidden="true" href="#cb11-47"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb11-48"><a aria-hidden="true" href="#cb11-48"></a>}</span></code></pre></div>
<p>还是挺好的一道题，提出有用的点来进行树形 dp。</p>
<h3 id="f---ideal-farm">1594F - Ideal Farm</h3>
<p>给出 <span class="math inline">\(n, s, k\)</span>，问是否所有的长度为 <span class="math inline">\(n\)</span> 的和为 <span class="math inline">\(s\)</span> 的正整数序列都有一段长度为 <span class="math inline">\(k\)</span> 的区间。</p>
<p>考虑构造一个无解的情况。即要求没有两个前缀和的差为 <span class="math inline">\(k\)</span>，构造的时候即 <span class="math inline">\(1, 1,1,\cdots, k + 1, 1, 1, \cdots\)</span> 如是构造。</p>
<p><span class="math inline">\(n &lt; k\)</span> 的时候特判一下。蠢得要死。。。</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a aria-hidden="true" href="#cb12-1"></a><span class="kw">using</span> ll = <span class="dt">long</span> <span class="dt">long</span>;</span>
<span id="cb12-2"><a aria-hidden="true" href="#cb12-2"></a></span>
<span id="cb12-3"><a aria-hidden="true" href="#cb12-3"></a><span class="dt">int</span> main() {</span>
<span id="cb12-4"><a aria-hidden="true" href="#cb12-4"></a>    <span class="dt">int</span> T; read(T);</span>
<span id="cb12-5"><a aria-hidden="true" href="#cb12-5"></a>    <span class="cf">while</span> (T--) {</span>
<span id="cb12-6"><a aria-hidden="true" href="#cb12-6"></a>        ll s, n, k;</span>
<span id="cb12-7"><a aria-hidden="true" href="#cb12-7"></a>        read(s), read(n), read(k);</span>
<span id="cb12-8"><a aria-hidden="true" href="#cb12-8"></a>        <span class="cf">if</span> (n &lt; k) {</span>
<span id="cb12-9"><a aria-hidden="true" href="#cb12-9"></a>            <span class="cf">if</span> (s == k) puts(<span class="st">"YES"</span>);</span>
<span id="cb12-10"><a aria-hidden="true" href="#cb12-10"></a>            <span class="cf">else</span> puts(<span class="st">"NO"</span>);</span>
<span id="cb12-11"><a aria-hidden="true" href="#cb12-11"></a>        } <span class="cf">else</span> {</span>
<span id="cb12-12"><a aria-hidden="true" href="#cb12-12"></a>            ll w = n / k * <span class="dv">2</span><span class="bu">ll</span> * k + n % k;</span>
<span id="cb12-13"><a aria-hidden="true" href="#cb12-13"></a>            s &lt; w ? puts(<span class="st">"YES"</span>) : puts(<span class="st">"NO"</span>);</span>
<span id="cb12-14"><a aria-hidden="true" href="#cb12-14"></a>        }</span>
<span id="cb12-15"><a aria-hidden="true" href="#cb12-15"></a>    }</span>
<span id="cb12-16"><a aria-hidden="true" href="#cb12-16"></a>    <span class="cf">return</span> output(), <span class="dv">0</span>;</span>
<span id="cb12-17"><a aria-hidden="true" href="#cb12-17"></a>}</span></code></pre></div>
<h2 id="educational-codeforces-round-115">Educational Codeforces Round 115</h2>
<p>A + B + C + D。</p>
<h3 id="e---staircases">1598E - Staircases</h3>
<p>注意到其实就这两种楼梯，要么结束位置是两个横着的，要么是两个竖着的。所以可以 dp，设 <span class="math inline">\(f_{i, j, 0/1}\)</span> 表示 <span class="math inline">\((i, j)\)</span> 结束，最后位置为横/竖的方案数，则有转移 <span class="math display">\[
\begin{cases}
f_{i, j, 0} :=f_{i, j, 0} + f_{i - 1, j, 1}\\
f_{i, j, 1} := f_{i ,j , 1} + f_{i, j - 1. 0}
\end{cases}
\]</span> 初始条件为 <span class="math inline">\(f_{i, j, 0/1} = 1\)</span>，因为一个格子也算楼梯。但是会算重，所以需要特判一下。</p>
<p>然后是修改操作。我们需要知道，一次修改操作能影响的 dp 值是有限的。手玩一下发现最多影响 <span class="math inline">\(3n\)</span> 个格子。故总时间复杂度 <span class="math inline">\(O(n^2 + nq)\)</span>。</p>
<p>代码就不放了。</p>
<h3 id="f---rbs">1598F - RBS</h3>
<p>括号匹配 + 状压 dp 好题。</p>
<p>定义合法的括号串，给出 <span class="math inline">\(n\le 20\)</span> 个总长不超过 <span class="math inline">\(4\times 10^5\)</span> 的括号串 <span class="math inline">\(s_i\)</span>，问将所有 <span class="math inline">\(s_i\)</span> 按照一定顺序拼接起来后最多有多少个前缀为合法括号串。</p>
<p><span class="math inline">\(n\le 20\)</span> 这个限制就很灵性，考虑状压 dp。设 <span class="math inline">\(f_{S}\)</span> 为集合 <span class="math inline">\(S\)</span> 内字符串拼起来的答案。</p>
<p>思考转移。假设 <span class="math inline">\(S\)</span> 在加上一个 <span class="math inline">\(x\)</span> 后变成 <span class="math inline">\(T\)</span>，并假定 <span class="math inline">\(x\)</span> 被接在末尾。</p>
<p>考虑括号串的性质，我们令 <span class="math inline">\(\texttt{'('} = 1\)</span>，<span class="math inline">\(\texttt{')'} = -1\)</span>，然后一个括号串将为合法当且仅当其每个前缀和都为非负且整个的前缀和为 <span class="math inline">\(0\)</span>。那么不妨处理出每个串的前缀和以及每个状态的串的前缀和之和。</p>
<p>而遍历一个字符串 <span class="math inline">\(x\)</span> 将会形成一个“爬山”的过程，若这个过程中前缀和接触到了 <span class="math inline">\(0\)</span>，那么合法的答案将会增加 <span class="math inline">\(1\)</span>，若这个过程中前缀和变为了负数，那么这个状态就废掉了——答案不可能再增加。</p>
<p>所以对于每个串，我们需要记录一下其向下“穿过”了每个平面几次。然后在 dp 转移的时候就可以判定了。如果从 <span class="math inline">\(S\)</span> 的高度走向 <span class="math inline">\(T\)</span> 会走到若干次 <span class="math inline">\(0\)</span>，那么答案对应累计，若会穿到 <span class="math inline">\(0\)</span> 下面去，说明这个状态就废掉了，判掉即可。</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a aria-hidden="true" href="#cb13-1"></a><span class="pp">#include </span><span class="im">&lt;bits/stdc++.h&gt;</span></span>
<span id="cb13-2"><a aria-hidden="true" href="#cb13-2"></a><span class="pp">#define il </span><span class="kw">inline</span></span>
<span id="cb13-3"><a aria-hidden="true" href="#cb13-3"></a><span class="pp">#define FOR</span>(i,<span class="pp"> </span>a,<span class="pp"> </span>b)<span class="pp"> </span><span class="cf">for</span><span class="pp"> </span>(<span class="dt">int</span><span class="pp"> </span>i<span class="pp"> </span>=<span class="pp"> </span>(a);<span class="pp"> </span>i<span class="pp"> </span>&lt;=<span class="pp"> </span>(b);<span class="pp"> </span>++i)</span>
<span id="cb13-4"><a aria-hidden="true" href="#cb13-4"></a></span>
<span id="cb13-5"><a aria-hidden="true" href="#cb13-5"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb13-6"><a aria-hidden="true" href="#cb13-6"></a></span>
<span id="cb13-7"><a aria-hidden="true" href="#cb13-7"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="dv">22</span>, maxs = <span class="dv">1</span> &lt;&lt; <span class="dv">21</span> | <span class="dv">50</span>;</span>
<span id="cb13-8"><a aria-hidden="true" href="#cb13-8"></a></span>
<span id="cb13-9"><a aria-hidden="true" href="#cb13-9"></a><span class="kw">struct</span> String {</span>
<span id="cb13-10"><a aria-hidden="true" href="#cb13-10"></a>    <span class="dt">int</span> minp, sum;</span>
<span id="cb13-11"><a aria-hidden="true" href="#cb13-11"></a>    map&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt; H;</span>
<span id="cb13-12"><a aria-hidden="true" href="#cb13-12"></a>    vector&lt;<span class="dt">int</span>&gt; L;</span>
<span id="cb13-13"><a aria-hidden="true" href="#cb13-13"></a>    <span class="dt">int</span> delta;</span>
<span id="cb13-14"><a aria-hidden="true" href="#cb13-14"></a>    <span class="dt">void</span> init(string s) {</span>
<span id="cb13-15"><a aria-hidden="true" href="#cb13-15"></a>        <span class="dt">int</span> p = <span class="dv">0</span>;</span>
<span id="cb13-16"><a aria-hidden="true" href="#cb13-16"></a>        minp = <span class="fl">1e9</span>;</span>
<span id="cb13-17"><a aria-hidden="true" href="#cb13-17"></a>        map&lt;<span class="dt">int</span>, <span class="dt">bool</span>&gt; no;</span>
<span id="cb13-18"><a aria-hidden="true" href="#cb13-18"></a>        FOR(i, <span class="dv">0</span>, (<span class="dt">int</span>)s.size() - <span class="dv">1</span>) {</span>
<span id="cb13-19"><a aria-hidden="true" href="#cb13-19"></a>            <span class="cf">if</span> (s[i] == <span class="ch">'('</span>) ++p;</span>
<span id="cb13-20"><a aria-hidden="true" href="#cb13-20"></a>            <span class="cf">else</span> --p;</span>
<span id="cb13-21"><a aria-hidden="true" href="#cb13-21"></a>            <span class="cf">if</span> (s[i] == <span class="ch">')'</span>) {</span>
<span id="cb13-22"><a aria-hidden="true" href="#cb13-22"></a>                <span class="cf">if</span> (!no[p]) ++H[p];</span>
<span id="cb13-23"><a aria-hidden="true" href="#cb13-23"></a>            } <span class="cf">else</span> no[p] = <span class="dv">1</span>;</span>
<span id="cb13-24"><a aria-hidden="true" href="#cb13-24"></a>            minp = min(minp, p);</span>
<span id="cb13-25"><a aria-hidden="true" href="#cb13-25"></a>        }</span>
<span id="cb13-26"><a aria-hidden="true" href="#cb13-26"></a>        sum = p;</span>
<span id="cb13-27"><a aria-hidden="true" href="#cb13-27"></a>        <span class="cf">if</span> (H.empty()) <span class="cf">return</span>;</span>
<span id="cb13-28"><a aria-hidden="true" href="#cb13-28"></a>        delta = H.begin()-&gt;first;</span>
<span id="cb13-29"><a aria-hidden="true" href="#cb13-29"></a>        <span class="dt">int</span> R = H.rbegin()-&gt;first;</span>
<span id="cb13-30"><a aria-hidden="true" href="#cb13-30"></a>        L.resize(R - delta + <span class="dv">1</span>);</span>
<span id="cb13-31"><a aria-hidden="true" href="#cb13-31"></a>        <span class="cf">for</span> (<span class="kw">auto</span> p : H) L[p.first - delta] = p.second;</span>
<span id="cb13-32"><a aria-hidden="true" href="#cb13-32"></a>        <span class="cf">return</span>;</span>
<span id="cb13-33"><a aria-hidden="true" href="#cb13-33"></a>    }</span>
<span id="cb13-34"><a aria-hidden="true" href="#cb13-34"></a>    il <span class="dt">int</span> query(<span class="dt">int</span> x) {</span>
<span id="cb13-35"><a aria-hidden="true" href="#cb13-35"></a>        x -= delta;</span>
<span id="cb13-36"><a aria-hidden="true" href="#cb13-36"></a>        <span class="cf">if</span> (x &lt; <span class="dv">0</span> || x &gt;= (<span class="dt">int</span>)L.size()) <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb13-37"><a aria-hidden="true" href="#cb13-37"></a>        <span class="cf">return</span> L[x];</span>
<span id="cb13-38"><a aria-hidden="true" href="#cb13-38"></a>    }</span>
<span id="cb13-39"><a aria-hidden="true" href="#cb13-39"></a>} s[<span class="dv">22</span>];</span>
<span id="cb13-40"><a aria-hidden="true" href="#cb13-40"></a></span>
<span id="cb13-41"><a aria-hidden="true" href="#cb13-41"></a><span class="dt">int</span> dp[maxs], sum[maxs], n;</span>
<span id="cb13-42"><a aria-hidden="true" href="#cb13-42"></a></span>
<span id="cb13-43"><a aria-hidden="true" href="#cb13-43"></a><span class="dt">int</span> main() {</span>
<span id="cb13-44"><a aria-hidden="true" href="#cb13-44"></a>    ios::sync_with_stdio(<span class="kw">false</span>);</span>
<span id="cb13-45"><a aria-hidden="true" href="#cb13-45"></a>    cin.tie(<span class="dv">0</span>);</span>
<span id="cb13-46"><a aria-hidden="true" href="#cb13-46"></a>    cin &gt;&gt; n;</span>
<span id="cb13-47"><a aria-hidden="true" href="#cb13-47"></a>    FOR(i, <span class="dv">1</span>, n) {</span>
<span id="cb13-48"><a aria-hidden="true" href="#cb13-48"></a>        string str; cin &gt;&gt; str;</span>
<span id="cb13-49"><a aria-hidden="true" href="#cb13-49"></a>        s[i].init(str);</span>
<span id="cb13-50"><a aria-hidden="true" href="#cb13-50"></a>    }</span>
<span id="cb13-51"><a aria-hidden="true" href="#cb13-51"></a>    FOR(S, <span class="dv">0</span>, (<span class="dv">1</span> &lt;&lt; n) - <span class="dv">1</span>) FOR(i, <span class="dv">1</span>, n) <span class="cf">if</span> ((<span class="dv">1</span> &lt;&lt; (i - <span class="dv">1</span>)) &amp; S) sum[S] += s[i].sum;</span>
<span id="cb13-52"><a aria-hidden="true" href="#cb13-52"></a>    memset(dp, -<span class="dv">1</span>, <span class="kw">sizeof</span> dp);</span>
<span id="cb13-53"><a aria-hidden="true" href="#cb13-53"></a>    dp[<span class="dv">0</span>] = <span class="dv">0</span>;</span>
<span id="cb13-54"><a aria-hidden="true" href="#cb13-54"></a>    <span class="dt">int</span> ans = <span class="dv">0</span>;</span>
<span id="cb13-55"><a aria-hidden="true" href="#cb13-55"></a>    FOR(S, <span class="dv">1</span>, (<span class="dv">1</span> &lt;&lt; n) - <span class="dv">1</span>) {</span>
<span id="cb13-56"><a aria-hidden="true" href="#cb13-56"></a>        FOR(i, <span class="dv">1</span>, n) <span class="cf">if</span> (S &amp; (<span class="dv">1</span> &lt;&lt; (i - <span class="dv">1</span>))) {</span>
<span id="cb13-57"><a aria-hidden="true" href="#cb13-57"></a>            <span class="dt">int</span> F = S ^ (<span class="dv">1</span> &lt;&lt; (i - <span class="dv">1</span>));</span>
<span id="cb13-58"><a aria-hidden="true" href="#cb13-58"></a>            <span class="cf">if</span> (dp[F] == -<span class="dv">1</span>) <span class="cf">continue</span>;</span>
<span id="cb13-59"><a aria-hidden="true" href="#cb13-59"></a>            <span class="dt">int</span> nows = sum[F], cur = dp[F] + s[i].query(-nows);</span>
<span id="cb13-60"><a aria-hidden="true" href="#cb13-60"></a>            ans = max(ans, cur);</span>
<span id="cb13-61"><a aria-hidden="true" href="#cb13-61"></a>            <span class="cf">if</span> (nows + s[i].minp &lt; <span class="dv">0</span>) <span class="cf">continue</span>;</span>
<span id="cb13-62"><a aria-hidden="true" href="#cb13-62"></a>            dp[S] = max(dp[S], cur);</span>
<span id="cb13-63"><a aria-hidden="true" href="#cb13-63"></a>        }</span>
<span id="cb13-64"><a aria-hidden="true" href="#cb13-64"></a>    }</span>
<span id="cb13-65"><a aria-hidden="true" href="#cb13-65"></a>    cout &lt;&lt; ans &lt;&lt; <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span>;</span>
<span id="cb13-66"><a aria-hidden="true" href="#cb13-66"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb13-67"><a aria-hidden="true" href="#cb13-67"></a>}</span></code></pre></div>
<h2 id="technocup-2022-elimination-round-1-and-codeforces-round-749-div.-1div.-2">Technocup 2022 — Elimination Round 1 and Codeforces Round #749 (Div. 1+Div. 2)</h2>
<p>A + B + C + D + F，rk 352，上 CM 了。</p>
<h3 id="d---omkar-and-the-meaning-of-life">1583D - Omkar and the Meaning of Life</h3>
<p>考虑寻找每个元素在排列中的下一个数。</p>
<ul>
<li>对于每个 <span class="math inline">\(i\)</span>，询问 <span class="math inline">\(a_i = 2\)</span>，<span class="math inline">\(a_j=1\)</span>，其中 <span class="math inline">\(j\neq i\)</span>，如果找到了一个 <span class="math inline">\(k\)</span>，则不难发现 <span class="math inline">\(\operatorname{nxt}(k) = i\)</span>。</li>
<li>询问 <span class="math inline">\(a_i = 1\)</span>，<span class="math inline">\(a_j = 2\)</span> 的情况同理。</li>
</ul>
<p>最后一个拓扑排序就可以求出整个排列。询问次数正好为 <span class="math inline">\(2n\)</span>。</p>
<h3 id="e---момент-цветения">1583E - Момент цветения</h3>
<p>在一张无向图上构造 <span class="math inline">\(q\)</span> 条始末点给定的路径，使得每条边都被覆盖偶数次，输出构造方案或者输出还需要多少条路径才有解。</p>
<p>考虑一张新图：将所有的点保留，为 <span class="math inline">\(q\)</span> 次询问的 <span class="math inline">\(a\)</span>，<span class="math inline">\(b\)</span> 点连边，若这张图中的各个连通分量都能形成欧拉回路，则一定有解。为什么？考虑原图的 dfs 生成树，每次在新图上走一条边相当于在原图上通过某种方式从 <span class="math inline">\(a\)</span> 走到 <span class="math inline">\(b\)</span>，而欧拉回路代表着我最终又走回了一开始的起点，其每条边的经过次数必然是偶数。</p>
<p>构造就直接在 dfs 生成树上找路径就行了，倍增即可。</p>
<h3 id="f---defender-of-childhood-dreams">1586F - Defender of Childhood Dreams</h3>
<p>给定一张竞赛图，其中边永远从编号小的点连向编号大的，用最少的颜色染这些边使得任何长度 <span class="math inline">\(\ge k\)</span> 的路径至少有两种颜色的边。</p>
<p>据说是 ZR CSP 七连的原题，亏。</p>
<p>考虑分块。将所有点每 <span class="math inline">\(k\)</span> 个分为一小块，每 <span class="math inline">\(k^2\)</span> 个分为一大块……依此类推，大小为 <span class="math inline">\(k\)</span> 的块内部连一种颜色的边，大小为 <span class="math inline">\(k^2\)</span> 的块内部连一种颜色的边……依此类推。所以一共有 <span class="math inline">\(\lceil\log_k n \rceil\)</span> 种颜色，代码很短。</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a aria-hidden="true" href="#cb14-1"></a><span class="dt">int</span> n, k;</span>
<span id="cb14-2"><a aria-hidden="true" href="#cb14-2"></a></span>
<span id="cb14-3"><a aria-hidden="true" href="#cb14-3"></a><span class="dt">int</span> getans(<span class="dt">int</span> x, <span class="dt">int</span> y) {</span>
<span id="cb14-4"><a aria-hidden="true" href="#cb14-4"></a>    <span class="dt">int</span> now = k, ret = <span class="dv">1</span>;</span>
<span id="cb14-5"><a aria-hidden="true" href="#cb14-5"></a>    <span class="cf">while</span> ((x - <span class="dv">1</span>) / now != (y - <span class="dv">1</span>) / now) now *= k, ++ret;</span>
<span id="cb14-6"><a aria-hidden="true" href="#cb14-6"></a>    <span class="cf">return</span> ret;</span>
<span id="cb14-7"><a aria-hidden="true" href="#cb14-7"></a>}</span>
<span id="cb14-8"><a aria-hidden="true" href="#cb14-8"></a></span>
<span id="cb14-9"><a aria-hidden="true" href="#cb14-9"></a><span class="dt">int</span> main() {</span>
<span id="cb14-10"><a aria-hidden="true" href="#cb14-10"></a>    read(n), read(k);</span>
<span id="cb14-11"><a aria-hidden="true" href="#cb14-11"></a>    print((<span class="dt">int</span>)ceil(log(n) / log(k)), <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span>);</span>
<span id="cb14-12"><a aria-hidden="true" href="#cb14-12"></a>    FOR(i, <span class="dv">1</span>, n) FOR(j, i + <span class="dv">1</span>, n) print(getans(i, j), <span class="ch">' '</span>);</span>
<span id="cb14-13"><a aria-hidden="true" href="#cb14-13"></a>    <span class="cf">return</span> output(), <span class="dv">0</span>;</span>
<span id="cb14-14"><a aria-hidden="true" href="#cb14-14"></a>}</span></code></pre></div>
<p>绝绝子了属于是。</p>
<h2 id="codeforces-round-750-div.2">Codeforces Round #750 (Div.2)</h2>
<h3 id="d---vupsen-pupsen-and-0">1582D - Vupsen, Pupsen and 0</h3>
<p>给定向量 <span class="math inline">\(a\)</span>，求一个向量 <span class="math inline">\(b\)</span> 使得 <span class="math inline">\(a\cdot b = 0\)</span>，其中向量维数 <span class="math inline">\(n\le 10^5\)</span>，<span class="math inline">\(|a_i|\le 10^4\)</span>，要求 <span class="math inline">\(\sum|b_i|\le 10^9\)</span>。</p>
<p>考虑两两配对，最后三个特判一下。</p>
<h3 id="e---pchelyonok-and-segments">1582E - Pchelyonok and Segments</h3>
<p>重点：找到 <span class="math inline">\(k\)</span> 的范围然后直接 <span class="math inline">\(O(n\sqrt n)\)</span> 暴力。</p>
<p>由于 <span class="math inline">\(\dfrac{k(k + 1)}{2}\le n\)</span>，所以 <span class="math inline">\(k\le \sqrt{2n}\le 447\)</span>。然后就可以设计一个 dp：令 <span class="math inline">\(f_{i, j}\)</span> 为当前考虑了 <span class="math inline">\([i, n]\)</span>，最前面的选的一段长度为 <span class="math inline">\(j\)</span>，最大的和。（类似 LIS 的贪心设计）然后转移就随便转移一下。</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a aria-hidden="true" href="#cb15-1"></a><span class="kw">using</span> ll = <span class="dt">long</span> <span class="dt">long</span>;</span>
<span id="cb15-2"><a aria-hidden="true" href="#cb15-2"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">1e5</span> + <span class="dv">5</span>, sqrtn = <span class="dv">500</span>, INF = <span class="fl">2e9</span>;</span>
<span id="cb15-3"><a aria-hidden="true" href="#cb15-3"></a><span class="dt">int</span> n, a[maxn];</span>
<span id="cb15-4"><a aria-hidden="true" href="#cb15-4"></a>ll sum[maxn], f[maxn][sqrtn];</span>
<span id="cb15-5"><a aria-hidden="true" href="#cb15-5"></a></span>
<span id="cb15-6"><a aria-hidden="true" href="#cb15-6"></a><span class="dt">int</span> main() {</span>
<span id="cb15-7"><a aria-hidden="true" href="#cb15-7"></a>    <span class="dt">int</span> T; read(T);</span>
<span id="cb15-8"><a aria-hidden="true" href="#cb15-8"></a>    <span class="cf">while</span> (T--) {</span>
<span id="cb15-9"><a aria-hidden="true" href="#cb15-9"></a>        read(n);</span>
<span id="cb15-10"><a aria-hidden="true" href="#cb15-10"></a>        FOR(i, <span class="dv">1</span>, n) read(a[i]), sum[i] = sum[i - <span class="dv">1</span>] + a[i];</span>
<span id="cb15-11"><a aria-hidden="true" href="#cb15-11"></a>        <span class="dt">int</span> k = <span class="dv">0</span>;</span>
<span id="cb15-12"><a aria-hidden="true" href="#cb15-12"></a>        <span class="cf">while</span> (k * (k + <span class="dv">1</span>) / <span class="dv">2</span> &lt;= n) ++k;</span>
<span id="cb15-13"><a aria-hidden="true" href="#cb15-13"></a>        --k;</span>
<span id="cb15-14"><a aria-hidden="true" href="#cb15-14"></a>        FOR(j, <span class="dv">0</span>, k) f[n + <span class="dv">1</span>][j] = -INF;</span>
<span id="cb15-15"><a aria-hidden="true" href="#cb15-15"></a>        f[n + <span class="dv">1</span>][<span class="dv">0</span>] = INF;</span>
<span id="cb15-16"><a aria-hidden="true" href="#cb15-16"></a>        DEC(i, n, <span class="dv">1</span>) {</span>
<span id="cb15-17"><a aria-hidden="true" href="#cb15-17"></a>            FOR(j, <span class="dv">0</span>, k) {</span>
<span id="cb15-18"><a aria-hidden="true" href="#cb15-18"></a>                f[i][j] = f[i + <span class="dv">1</span>][j];</span>
<span id="cb15-19"><a aria-hidden="true" href="#cb15-19"></a>                <span class="cf">if</span> (j &amp;&amp; i + j - <span class="dv">1</span> &lt;= n &amp;&amp; sum[i + j - <span class="dv">1</span>] - sum[i - <span class="dv">1</span>] &lt; f[i + j][j - <span class="dv">1</span>])</span>
<span id="cb15-20"><a aria-hidden="true" href="#cb15-20"></a>                    chkmax(f[i][j], sum[i + j - <span class="dv">1</span>] - sum[i - <span class="dv">1</span>]);</span>
<span id="cb15-21"><a aria-hidden="true" href="#cb15-21"></a>            }</span>
<span id="cb15-22"><a aria-hidden="true" href="#cb15-22"></a>        }</span>
<span id="cb15-23"><a aria-hidden="true" href="#cb15-23"></a>        <span class="dt">int</span> ans = <span class="dv">0</span>;</span>
<span id="cb15-24"><a aria-hidden="true" href="#cb15-24"></a>        FOR(j, <span class="dv">0</span>, k) <span class="cf">if</span> (f[<span class="dv">1</span>][j] &gt; <span class="dv">0</span>) ans = j;</span>
<span id="cb15-25"><a aria-hidden="true" href="#cb15-25"></a>        print(ans, <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span>);</span>
<span id="cb15-26"><a aria-hidden="true" href="#cb15-26"></a>    }</span>
<span id="cb15-27"><a aria-hidden="true" href="#cb15-27"></a>    <span class="cf">return</span> output(), <span class="dv">0</span>;</span>
<span id="cb15-28"><a aria-hidden="true" href="#cb15-28"></a>}</span></code></pre></div>
<h2 id="codeforces-round-754-div.-2">Codeforces Round #754 (Div. 2)</h2>
<p>打的有点差劲，A + B + C。</p>
<h3 id="d---treelabeling">1605D - Treelabeling</h3>
<p>给定一棵未标号的树，求一个标号方式使得相邻的 <span class="math inline">\((u,v)\)</span> 满足 <span class="math inline">\(u\)</span> 的最高位与 <span class="math inline">\(v\)</span> 的最高位不同。</p>
<p>原题意易被翻译成如上，现在考虑如何构造。令 <span class="math inline">\(f(x)\)</span> 为 <span class="math inline">\(x\)</span> 在二进制表示下的最高位（从 <span class="math inline">\(0\)</span> 开始编号）。</p>
<p>先给树二分图染色，然后令黑点个数为 <span class="math inline">\(b\)</span>，白点个数为 <span class="math inline">\(w\)</span>，不妨假设 <span class="math inline">\(w \le b\)</span>，则显然 <span class="math inline">\(w\le \lfloor n / 2\rfloor\)</span>。所以可以得到 <span class="math inline">\(f(w) \le f(n) - 1\)</span>。</p>
<p>然后还有一个很好的性质，就是满足 <span class="math inline">\(f(x) = i\)</span> 的 <span class="math inline">\(x\)</span> 一共有 <span class="math inline">\(2^i\)</span> 个，因此直接考虑 <span class="math inline">\(w\)</span> 的每一位，若第 <span class="math inline">\(i\)</span> 位为 <span class="math inline">\(1\)</span>，则直接将满足 <span class="math inline">\(f(x) = i\)</span> 的 <span class="math inline">\(x\)</span> 分配给白点，剩余的分配给黑点。</p>
<p>于是这样就构造完了，正确性应该是十分显然的。</p>
<h3 id="e---array-equalizer">1605E - Array Equalizer</h3>
<p>给定两个序列 <span class="math inline">\(\{a_i\}\)</span> 和 <span class="math inline">\(\{b_i\}\)</span>，其中 <span class="math inline">\(a_i\)</span> 是给定的，<span class="math inline">\(b_i\)</span> 除了 <span class="math inline">\(b_1\)</span> 其余都给出。一次操作可以选定一个 <span class="math inline">\(i\)</span> 然后对于所有的 <span class="math inline">\(i\mid j\)</span> 的 <span class="math inline">\(j\)</span>，<span class="math inline">\(b_j\)</span> 加上或减去 <span class="math inline">\(1\)</span>。对于 <span class="math inline">\(q\)</span> 个 <span class="math inline">\(b_1\)</span>，问将 <span class="math inline">\(\{a_i\}\)</span> 变为 <span class="math inline">\(\{b_i\}\)</span> 的最小操作次数。</p>
<p>首先令 <span class="math inline">\(b_i = b_i - a_i\)</span>，然后问题就变为将 <span class="math inline">\(\{0\}\)</span> 变成 <span class="math inline">\(\{b_i\}\)</span> 的最小操作次数。然后首先考虑只有一个 <span class="math inline">\(b_1\)</span> 的时候，如何解决这个问题。</p>
<p>然后不难发现，只需要从小到大考虑即可。模拟一下操作：</p>
<div class="table-wrapper"><table>
<thead>
<tr class="header">
<th><span class="math inline">\(A\)</span></th>
<th><span class="math inline">\(B_1\)</span></th>
<th><span class="math inline">\(B_2\)</span></th>
<th><span class="math inline">\(B_3\)</span></th>
<th><span class="math inline">\(B_4\)</span></th>
<th><span class="math inline">\(B_5\)</span></th>
<th><span class="math inline">\(\cdots\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(B\)</span></td>
<td><span class="math inline">\(B_1\)</span></td>
<td><span class="math inline">\(B_2\)</span></td>
<td><span class="math inline">\(B_3\)</span></td>
<td><span class="math inline">\(B_4\)</span></td>
<td><span class="math inline">\(B_5\)</span></td>
<td><span class="math inline">\(\cdots\)</span></td>
</tr>
<tr class="even">
<td>Add</td>
<td><span class="math inline">\(B_1\)</span></td>
<td><span class="math inline">\(B_2 - B_1\)</span></td>
<td><span class="math inline">\(B_3 - B_1\)</span></td>
<td><span class="math inline">\(B_4 - B_2\)</span></td>
<td><span class="math inline">\(B_5 - B_1\)</span></td>
<td><span class="math inline">\(\cdots\)</span></td>
</tr>
</tbody>
</table></div>
<p>令 <span class="math inline">\(B_1 = x\)</span> 的话，每次操作加上的数都形如 <span class="math inline">\(cx + d\)</span>，对操作次数的贡献即为 <span class="math inline">\(|cx + d|\)</span>。这个 <span class="math inline">\(c\)</span> 和 <span class="math inline">\(d\)</span> 是可以提前预处理出来的。然后的话，现在的目标就是求出一坨 <span class="math inline">\(|cx + d|\)</span> 的和，发现这个可能不太好做，我们拆开绝对值，分类讨论一下：</p>
<ul>
<li>当 <span class="math inline">\(cx + d &gt; 0\)</span>，即 <span class="math inline">\(x &gt; -\dfrac dc\)</span>，贡献就为 <span class="math inline">\(cx + d\)</span>。</li>
<li>当 <span class="math inline">\(cx + d&lt; 0\)</span>，即 <span class="math inline">\(x&lt;-\dfrac dc\)</span>，贡献为 <span class="math inline">\(-cx - d\)</span>。</li>
</ul>
<p>当然，上述条件当且仅当 <span class="math inline">\(c &gt; 0\)</span> 时成立，对于 <span class="math inline">\(c &lt; 0\)</span> 的情况，直接乘个 <span class="math inline">\(-1\)</span> 转换成 <span class="math inline">\(c &gt; 0\)</span> 即可。而 <span class="math inline">\(c = 0\)</span> 的时候，直接统计 <span class="math inline">\(d\)</span> 的贡献即可。所以我们按照 <span class="math inline">\(-\dfrac dc\)</span> 排序，存储这些一次函数，然后就可以预处理一下前缀和和后缀和，每次二分一下就可以的解了。</p>
<p>事实上，<span class="math inline">\(c\)</span> 就是 <span class="math inline">\(\mu\)</span>。所以问题可以得到简化很多。</p>
<h2 id="technocup-2022-elimination-round-2-and-codeforces-round-755-div.-1-div.-2">Technocup 2022 — Elimination Round 2 and Codeforces Round #755 (Div. 1, Div. 2)</h2>
<p>div 1. A + B。</p>
<h3 id="b---guess-the-permutation">1588B - Guess the Permutation</h3>
<p>给定一个 <span class="math inline">\([1, n]\)</span> 的有序排列（<span class="math inline">\(n\)</span> 为 <span class="math inline">\(10^9\)</span> 级别），翻转了 <span class="math inline">\([i, j - 1]\)</span> 和 <span class="math inline">\([j, k]\)</span>。最多 <span class="math inline">\(40\)</span> 次询问，一次询问一个区间的逆序对数，要求最后给出 <span class="math inline">\(i\)</span>，<span class="math inline">\(j\)</span> 和 <span class="math inline">\(k\)</span>。</p>
<p>不难发现 <span class="math inline">\(i\)</span> 可以通过二分得到，而 <span class="math inline">\(k\)</span> 似乎也可以二分，但是 <span class="math inline">\(2\log n\)</span> 就会爆炸。所以只考虑二分出 <span class="math inline">\(i\)</span>，然后考虑 <span class="math inline">\([i, k]\)</span> 中逆序对的贡献，令两端的长度为 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span>，则有 <span class="math inline">\(f(i, k) = (a - 1)a / 2 + (b - 1)b/2\)</span>，所以我们询问一下 <span class="math inline">\([i + 1, n]\)</span>，就可以得到 <span class="math inline">\(a\)</span> 的值，具体地，<span class="math inline">\(a = f(i, k) - f(i - 1, k) + 1\)</span>，证明考虑逆序对的性质。</p>
<p>然后不难二分出 <span class="math inline">\(b\)</span> 的值，这题就做完了。</p>
<h3 id="c---game-with-stones">1588C - Game with Stones</h3>
<h2 id="codeforces-round-758-div.1-div.-2">Codeforces Round #758 (Div.1 + Div. 2)</h2>
<p>terrible round。A + B + C，rk522。</p>
<h3 id="d---dominoes">1608D - Dominoes</h3>
<p>首先我们知道，一个染色方案合法当且仅当 W 和 B 的数量相同，以及 WW 和 BB 的数量相同。计算 W 和 B 的数量，若其大于 <span class="math inline">\(n\)</span>，则显然无解。</p>
<p>否则，无解的情况就是 WB 和 BW 同时存在却没有 WW 或 BB。其他都为合法情况，方案大家可以在草稿纸上尝试进行构造。设问号有 <span class="math inline">\(c_0\)</span> 个，W 有 <span class="math inline">\(c_B\)</span> 个，则显然总染色方案数为 <span class="math inline">\(\dbinom{c_0}{n - c_B}\)</span>。然后处理一下无解的情况。</p>
<p>同时存在 WB 和 BW 却没有 WW 或 BB 的方案数其实就是用 <strong>不存在 WW 和 BB 的方案数</strong> 减去 <strong>全是 WB</strong> 和 <strong>全是 BW</strong> 的情况。设 ?? 有 <span class="math inline">\(c_P\)</span> 个，则对于第一个“不存在 WW 和 BB 的”的方案数就是 <span class="math inline">\(2^{c_P}\)</span>，且不存在 BB 或 WW；对于全是 WB 的至多一种，且不能存在 Bx 或 Wx，全是 BW 同理。</p>
<h2 id="codeforces-global-round-18">Codeforces Global Round 18</h2>
<p>tiring and difficult round. A + B + C。</p>
<h3 id="c---menorah">1615C - Menorah</h3>
<p>比较巧妙的题。注意到一次对 <span class="math inline">\(i\)</span> 的操作可以视为改变 <span class="math inline">\(i\)</span>，然后打上全局标记。</p>
<p>之后我们注意到，第一次操作要操作一开始为 <span class="math inline">\(1\)</span> 的，第二次操作就必须操作一开始为 <span class="math inline">\(0\)</span> 的。之后肯定是 <span class="math inline">\(1010\cdots\)</span> 交替操作。</p>
<p>预处理一下 <span class="math inline">\(same_{i, j}\)</span> 数组表示 <span class="math inline">\(a_k = i\)</span>，<span class="math inline">\([a_k = b_k] = j\)</span> 的 <span class="math inline">\(k\)</span> 的数量（即 <span class="math inline">\(a = 1/0\)</span>，与 <span class="math inline">\(b\)</span> 相同/不同的数量），则我们可以发现，一次对 <span class="math inline">\(1\)</span> 同的操作会使得 <span class="math inline">\(1\)</span> 同减一，同时 <span class="math inline">\(0\)</span> 不同加一。</p>
<p>若果我们进行奇数次操作，那么全局翻转标记是有的，要求的就是 <span class="math inline">\(same_{1/0, 1} = 0\)</span>。所以一共要进行 <span class="math inline">\(same_{1, 1} + same_{0, 1}\)</span> 次操作将所有的相同变为不同，然后因为有翻转，所以我们就能得到答案。这样做的前提条件是 <span class="math inline">\(same_{1,1} - same_{0, 1} = 1\)</span>。</p>
<p>那么若进行偶数次操作，同理，没有全局翻转标记，要求的就是 <span class="math inline">\(same_{1/0, 0} = 0\)</span>。所以一共要进行 <span class="math inline">\(same_{1, 0} + same_{0,0}\)</span> 次操作将所有的不同变为相同，答案就能得到了。这样做的前提条件是 <span class="math inline">\(same_{1, 0} = same_{0, 0}\)</span>。</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a aria-hidden="true" href="#cb16-1"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">1e5</span> + <span class="dv">5</span>;</span>
<span id="cb16-2"><a aria-hidden="true" href="#cb16-2"></a><span class="dt">char</span> s1[maxn], s2[maxn];</span>
<span id="cb16-3"><a aria-hidden="true" href="#cb16-3"></a><span class="dt">int</span> n;</span>
<span id="cb16-4"><a aria-hidden="true" href="#cb16-4"></a></span>
<span id="cb16-5"><a aria-hidden="true" href="#cb16-5"></a><span class="dt">int</span> main() {</span>
<span id="cb16-6"><a aria-hidden="true" href="#cb16-6"></a>    <span class="dt">int</span> T; read(T);</span>
<span id="cb16-7"><a aria-hidden="true" href="#cb16-7"></a>    <span class="cf">while</span> (T--) {</span>
<span id="cb16-8"><a aria-hidden="true" href="#cb16-8"></a>        read(n), read(s1 + <span class="dv">1</span>), read(s2 + <span class="dv">1</span>);</span>
<span id="cb16-9"><a aria-hidden="true" href="#cb16-9"></a>        <span class="dt">int</span> same[<span class="dv">2</span>][<span class="dv">2</span>] = {<span class="dv">0</span>};</span>
<span id="cb16-10"><a aria-hidden="true" href="#cb16-10"></a>        FOR(i, <span class="dv">1</span>, n)</span>
<span id="cb16-11"><a aria-hidden="true" href="#cb16-11"></a>            ++same[s1[i] - <span class="ch">'0'</span>][s1[i] == s2[i]];</span>
<span id="cb16-12"><a aria-hidden="true" href="#cb16-12"></a>        <span class="dt">int</span> ans = <span class="fl">1e9</span>;</span>
<span id="cb16-13"><a aria-hidden="true" href="#cb16-13"></a>        <span class="cf">if</span> (same[<span class="dv">1</span>][<span class="dv">1</span>] - same[<span class="dv">0</span>][<span class="dv">1</span>] == <span class="dv">1</span>) ans = same[<span class="dv">1</span>][<span class="dv">1</span>] + same[<span class="dv">0</span>][<span class="dv">1</span>];</span>
<span id="cb16-14"><a aria-hidden="true" href="#cb16-14"></a>        <span class="cf">if</span> (same[<span class="dv">1</span>][<span class="dv">0</span>] == same[<span class="dv">0</span>][<span class="dv">0</span>]) chkmin(ans, same[<span class="dv">1</span>][<span class="dv">0</span>] + same[<span class="dv">0</span>][<span class="dv">0</span>]);</span>
<span id="cb16-15"><a aria-hidden="true" href="#cb16-15"></a>        print(ans &gt; n ? -<span class="dv">1</span> : ans);</span>
<span id="cb16-16"><a aria-hidden="true" href="#cb16-16"></a>    }</span>
<span id="cb16-17"><a aria-hidden="true" href="#cb16-17"></a>    <span class="cf">return</span> output(), <span class="dv">0</span>;</span>
<span id="cb16-18"><a aria-hidden="true" href="#cb16-18"></a>}</span></code></pre></div>
<h3 id="d---xor-mas-tree">1615D - X(or)-mas Tree</h3>
<p>题意：给定一棵边带权树，有些边权未确定。给定形如 <span class="math inline">\((a, b, c)\)</span> 的限制表示 <span class="math inline">\(a\)</span> 到 <span class="math inline">\(b\)</span> 路径上的边权异或和的 popcount 的奇偶性为 <span class="math inline">\(c\)</span>。构造一个给未定权边定权的方案。</p>
<p>定义 <span class="math inline">\(\operatorname{parity}(x)\)</span> 表示 <span class="math inline">\(\operatorname{popcount}(x)\bmod 2\)</span>，则我们可以知道 <span class="math inline">\(\operatorname{parity}(x\oplus y) = \operatorname{parity}(x)\oplus \operatorname{parity}(y)\)</span>。所以干脆直接先将树上的所有边权 <span class="math inline">\(d\)</span> 先变成 <span class="math inline">\(\operatorname{parity}(d)\)</span>。</p>
<p>令树上前缀异或和为 <span class="math inline">\(r_u\)</span>，则我们注意到，<span class="math inline">\((a,b)\)</span> 路径的异或和为 <span class="math inline">\(r_a\oplus r_b\)</span>。所以我们现在就有了若干条形如 <span class="math inline">\(r_a\oplus r_b = c\)</span> 的限制（对于树上已有的边 <span class="math inline">\((u,v, x)\)</span> 可以看作是 <span class="math inline">\(r_u\oplus r_v = x\)</span>）。</p>
<p>对于每个限制 <span class="math inline">\(r_a\oplus r_b = c\)</span>，在新图上建一条边 <span class="math inline">\((a, b, c)\)</span>，然后考虑二分图染色（一开始钦定一个 <span class="math inline">\(r_1\)</span>），这样子就可以求出所有的 <span class="math inline">\(r_u\)</span> 并且判断矛盾。</p>
<h3 id="e---purple-crayon">1615E - Purple Crayon</h3>
<p>题意：红蓝双方在一棵 <span class="math inline">\(1\)</span> 为根的树上涂色。红先涂，每次可以选择一个子树内的点涂成红色，但涂的个数不能超过 <span class="math inline">\(k\)</span>。然后蓝涂，每次可以选择一个子树内的点涂成蓝色，但该子树内不能有红色节点。设最后白、红、蓝三种颜色的点各有 <span class="math inline">\(w\)</span>、<span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 个，则分数定义为 <span class="math inline">\(w(r - b)\)</span>。红方想最大化分数，蓝方想最小化分数。双方都绝顶聪明，问最后的分数。</p>
<p>拆开式子：<span class="math inline">\(w(r- b) = (n - r - b)(r - b) = r(n - r) - b(n - b)\)</span>。所以对于红方，他想要做的就是最大化 <span class="math inline">\(r(n - r)\)</span> 和最小化 <span class="math inline">\(b(n - b)\)</span>。到了蓝方这里，他一定是想最大化 <span class="math inline">\(b(n - b)\)</span>，其在 <span class="math inline">\(b = \lfloor n / 2\rfloor\)</span> 处有最大值。</p>
<p>另外我们可以发现，红方选择了 <span class="math inline">\(u\)</span> 子树意味着 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(u\)</span> 上的点都不能被蓝方涂色，相当于控制了一条链。为了使得蓝方能达到的最大的 <span class="math inline">\(b(n - b)\)</span> 最小，红方的最优策略一定是尽可能最小化 <span class="math inline">\(b\)</span> 的最大值。所以说，<strong>红方尽可能多控制点，一定是最优的</strong>。</p>
<p>而且，为了尽可能多控制点，<strong>红方选的一定是叶子节点</strong>，若选的不是叶子，则选一个儿子节点能控制的节点肯定更多。</p>
<p>所以，我们从大到小取 <span class="math inline">\(k\)</span> 根长链，取的时候算一下蓝方还能涂多少个 <span class="math inline">\(b\)</span>，若 <span class="math inline">\(b &gt; \lfloor n / 2\rfloor\)</span> 则取 <span class="math inline">\(b = \lfloor n / 2\rfloor\)</span>。依此计算答案。</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a aria-hidden="true" href="#cb17-1"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">2e5</span> + <span class="dv">5</span>;</span>
<span id="cb17-2"><a aria-hidden="true" href="#cb17-2"></a>vector&lt;<span class="dt">int</span>&gt; G[maxn];</span>
<span id="cb17-3"><a aria-hidden="true" href="#cb17-3"></a><span class="dt">int</span> n, k, son[maxn], h[maxn], fa[maxn], len[maxn], cnt;</span>
<span id="cb17-4"><a aria-hidden="true" href="#cb17-4"></a></span>
<span id="cb17-5"><a aria-hidden="true" href="#cb17-5"></a><span class="dt">void</span> dfs1(<span class="dt">int</span> u, <span class="dt">int</span> pre) {</span>
<span id="cb17-6"><a aria-hidden="true" href="#cb17-6"></a>    fa[u] = pre;</span>
<span id="cb17-7"><a aria-hidden="true" href="#cb17-7"></a>    <span class="cf">for</span> (<span class="kw">auto</span> v : G[u]) {</span>
<span id="cb17-8"><a aria-hidden="true" href="#cb17-8"></a>        <span class="cf">if</span> (v == pre) <span class="cf">continue</span>;</span>
<span id="cb17-9"><a aria-hidden="true" href="#cb17-9"></a>        dfs1(v, u);</span>
<span id="cb17-10"><a aria-hidden="true" href="#cb17-10"></a>        <span class="cf">if</span> (h[v] &gt; h[son[u]])</span>
<span id="cb17-11"><a aria-hidden="true" href="#cb17-11"></a>            son[u] = v;</span>
<span id="cb17-12"><a aria-hidden="true" href="#cb17-12"></a>    }</span>
<span id="cb17-13"><a aria-hidden="true" href="#cb17-13"></a>    h[u] = h[son[u]] + <span class="dv">1</span>;</span>
<span id="cb17-14"><a aria-hidden="true" href="#cb17-14"></a>    <span class="cf">return</span>;</span>
<span id="cb17-15"><a aria-hidden="true" href="#cb17-15"></a>}</span>
<span id="cb17-16"><a aria-hidden="true" href="#cb17-16"></a></span>
<span id="cb17-17"><a aria-hidden="true" href="#cb17-17"></a><span class="dt">void</span> dfs2(<span class="dt">int</span> u, <span class="dt">int</span> topf) {</span>
<span id="cb17-18"><a aria-hidden="true" href="#cb17-18"></a>    <span class="cf">if</span> (!son[u]) {</span>
<span id="cb17-19"><a aria-hidden="true" href="#cb17-19"></a>        len[++cnt] = h[topf];</span>
<span id="cb17-20"><a aria-hidden="true" href="#cb17-20"></a>        <span class="cf">return</span>;</span>
<span id="cb17-21"><a aria-hidden="true" href="#cb17-21"></a>    }</span>
<span id="cb17-22"><a aria-hidden="true" href="#cb17-22"></a>    dfs2(son[u], topf);</span>
<span id="cb17-23"><a aria-hidden="true" href="#cb17-23"></a>    <span class="cf">for</span> (<span class="kw">auto</span> v : G[u]) {</span>
<span id="cb17-24"><a aria-hidden="true" href="#cb17-24"></a>        <span class="cf">if</span> (v == son[u] || v == fa[u]) <span class="cf">continue</span>;</span>
<span id="cb17-25"><a aria-hidden="true" href="#cb17-25"></a>        dfs2(v, v);</span>
<span id="cb17-26"><a aria-hidden="true" href="#cb17-26"></a>    }</span>
<span id="cb17-27"><a aria-hidden="true" href="#cb17-27"></a>    <span class="cf">return</span>;</span>
<span id="cb17-28"><a aria-hidden="true" href="#cb17-28"></a>}</span>
<span id="cb17-29"><a aria-hidden="true" href="#cb17-29"></a></span>
<span id="cb17-30"><a aria-hidden="true" href="#cb17-30"></a><span class="dt">int</span> main() {</span>
<span id="cb17-31"><a aria-hidden="true" href="#cb17-31"></a>    read(n, k);</span>
<span id="cb17-32"><a aria-hidden="true" href="#cb17-32"></a>    FOR(i, <span class="dv">1</span>, n - <span class="dv">1</span>) {</span>
<span id="cb17-33"><a aria-hidden="true" href="#cb17-33"></a>        <span class="dt">int</span> u, v; read(u, v);</span>
<span id="cb17-34"><a aria-hidden="true" href="#cb17-34"></a>        G[u].push_back(v), G[v].push_back(u);</span>
<span id="cb17-35"><a aria-hidden="true" href="#cb17-35"></a>    }</span>
<span id="cb17-36"><a aria-hidden="true" href="#cb17-36"></a>    dfs1(<span class="dv">1</span>, <span class="dv">0</span>), dfs2(<span class="dv">1</span>, <span class="dv">1</span>);</span>
<span id="cb17-37"><a aria-hidden="true" href="#cb17-37"></a>    sort(len + <span class="dv">1</span>, len + cnt + <span class="dv">1</span>, greater&lt;<span class="dt">int</span>&gt;());</span>
<span id="cb17-38"><a aria-hidden="true" href="#cb17-38"></a>    <span class="dt">long</span> <span class="dt">long</span> ans = -<span class="fl">1e18</span>;</span>
<span id="cb17-39"><a aria-hidden="true" href="#cb17-39"></a>    <span class="dt">int</span> b = n;</span>
<span id="cb17-40"><a aria-hidden="true" href="#cb17-40"></a>    FOR(a, <span class="dv">1</span>, k) {</span>
<span id="cb17-41"><a aria-hidden="true" href="#cb17-41"></a>        <span class="dt">int</span> x = min(n / <span class="dv">2</span>, b -= len[a]);</span>
<span id="cb17-42"><a aria-hidden="true" href="#cb17-42"></a>        chkmax(ans, <span class="dv">1</span><span class="bu">ll</span> * (n - a - x) * (a - x));</span>
<span id="cb17-43"><a aria-hidden="true" href="#cb17-43"></a>    }</span>
<span id="cb17-44"><a aria-hidden="true" href="#cb17-44"></a>    print(ans);</span>
<span id="cb17-45"><a aria-hidden="true" href="#cb17-45"></a>    <span class="cf">return</span> output(), <span class="dv">0</span>;</span>
<span id="cb17-46"><a aria-hidden="true" href="#cb17-46"></a>}</span></code></pre></div>
<h2 id="hello-2022">Hello 2022</h2>
<h3 id="c---hidden-permutations">1621C - Hidden Permutations</h3>
<p>交互题，猜一个排列 <span class="math inline">\(p\)</span>（<span class="math inline">\(n\le 10000\)</span>）。初始有一个排列 <span class="math inline">\(q_i = i\)</span>，每次可以询问一个 <span class="math inline">\(q_i\)</span> 的值，交互库回答你的询问之后会将 <span class="math inline">\(q\)</span> 替换成 <span class="math inline">\(q_i' = q_{p_i}\)</span>。最多 <span class="math inline">\(2n\)</span> 次询问，求出 <span class="math inline">\(p\)</span>。</p>
<p>我们注意到，对 <span class="math inline">\(q\)</span> 施加 <span class="math inline">\(q_i = q_{p_i}\)</span> 的变换这一过程的本质是一个置换。不妨盯着一个 <span class="math inline">\(q_i\)</span> 不放，我们发现其变换下去之后会为 <span class="math inline">\(p_i, p_{p_i}, p_{p_{p_i}},\cdots\)</span> 会形成一个环，环上 <span class="math inline">\(u\to v\)</span> 表示 <span class="math inline">\(p_u = v\)</span>。那么我们就可以每次盯着一个没有求出答案的下标询问，把这部分环找到，这题就解决了。</p>
<p>询问次数的上界刚好为 <span class="math inline">\(2n\)</span>，卡的很准。</p>
<h3 id="d---the-winter-hike">1621D - The Winter Hike</h3>
<p>给定 <span class="math inline">\(2n\times 2n\)</span> 的棋盘，初始有 <span class="math inline">\(n^2\)</span> 个人在左上角的 <span class="math inline">\(n\times n\)</span> 正方形内（每个格子里面 <span class="math inline">\(1\)</span> 人）。现要将这 <span class="math inline">\(n^2\)</span> 个人通过如下方式移动到右下角的 <span class="math inline">\(n\times n\)</span> 正方形内（每个格子 <span class="math inline">\(1\)</span> 人）：</p>
<ul>
<li>选定一行，将其里面所有的人循环往左/右移一格。即对于有人的 <span class="math inline">\((x_0, y)\)</span>，我们施变换 <span class="math inline">\((x_0, y)\to (x_0, y + 1)\)</span> 或 <span class="math inline">\((x_0, y)\to(x_0, y - 1)\)</span>。在 <span class="math inline">\((x_0, 2n)\)</span> 和 <span class="math inline">\((x_0, 1)\)</span> 的特判。</li>
<li>选定一列，将其里面所有的人循环往上/下移一格。即对于有人的 <span class="math inline">\((x, y_0)\)</span>，我们施变换 <span class="math inline">\((x, y_0)\to (x + 1, y_0)\)</span> 或 <span class="math inline">\((x, y_0)\to(x - 1, y_0)\)</span>。在 <span class="math inline">\((2n, y_0)\)</span> 和 <span class="math inline">\((1, y_0)\)</span> 的特判。</li>
</ul>
<p>操作可以进行任意次。同时有些格子里面有障碍，人不能经过，除掉 <span class="math inline">\((x, y)\)</span> 的障碍需要花费 <span class="math inline">\(c_{x, y}\)</span>，可除掉的障碍数不限。问最小花费。</p>
<p>是一道非常巧妙的构造。</p>
<p>首先我们观察一下，发现右下角的 <span class="math inline">\(n\times n\)</span> 区域是必须除掉的。然后观察一下样例 <span class="math inline">\(3\)</span>，发现右下角的权值和为 <span class="math inline">\(12\)</span>，说明我们只扣掉了一个多余的 <span class="math inline">\(2\)</span>。然后注意到挖掉 <span class="math inline">\((2, 3)\)</span>，<span class="math inline">\((3, 2)\)</span> 或者 <span class="math inline">\((1, 4)\)</span> 和 <span class="math inline">\((4, 1)\)</span> 都是可以的。方案可以自行尝试构造。</p>
<p>然后我们就发现，我们除了右下角的 <span class="math inline">\(n\times n\)</span> 要抠掉，只需要在两块 <span class="math inline">\(n\times n\)</span> 区域四角的交界格点处抠掉一个点就可以了。至于方案构造，就考虑一行行/一列列的移入右下角的区域，可以自行想象一下。这些点一共有 <span class="math inline">\(8\)</span> 个，分别是：</p>
<p><span class="math inline">\((1, 2n)\)</span>，<span class="math inline">\((2n, 1)\)</span>，<span class="math inline">\((1, n + 1)\)</span>，<span class="math inline">\((n + 1, 1)\)</span>，<span class="math inline">\((n, n + 1)\)</span>，<span class="math inline">\((n + 1, n)\)</span>，<span class="math inline">\((n, 2n)\)</span>，<span class="math inline">\((2n, n)\)</span>。于是这题就做完了。非常妙。</p>
<h3 id="e---new-school">1621E - New School</h3>
<p>要开办学校。<span class="math inline">\(n\)</span> 个老师，<span class="math inline">\(m\)</span> 组学生。第 <span class="math inline">\(i\)</span> 组学生有 <span class="math inline">\(k_i\)</span> 人。老师的年龄分别为 <span class="math inline">\(a_1, \cdots, a_n\)</span>，学生的年龄分别为 <span class="math inline">\(b_{i, 1},\cdots, b_{i, k_i}\)</span>。要求安排老师到每组学生，满足</p>
<ul>
<li>每组学生都恰好有一个老师。</li>
<li>一个老师最多带一个组。</li>
<li>一组内，学生的平均年龄不超过老师的年龄。</li>
</ul>
<p>对于每个学生，求出若其不来上课，课程能否被安排。<span class="math inline">\(1\le m\le n\le 10^5\)</span>，<span class="math inline">\(1\le a_i,b_{i,j}\le 10^5\)</span>，<span class="math inline">\(2\le k_i\le 10^5\)</span>，<span class="math inline">\(\sum k_i\le 2\times 10^5\)</span>。</p>
<p>考虑将所有学生组和所有老师降序排序。则有解当且仅当 <span class="math inline">\(\forall 1\le i\le m\)</span> 有 <span class="math inline">\(avr_i\le a_i\)</span>，该情况下我们将其一一对应即可。</p>
<p>而当一个学生不来时，其只会影响一个组 <span class="math inline">\(i\)</span> 的平均年龄 <span class="math inline">\(avr_i\)</span>。对于每一个学生 <span class="math inline">\(b_{i, x}\)</span>，都可以二分找出没有他之后，整组人的新的位置 <span class="math inline">\(j\)</span>。这样一来，<span class="math inline">\([j, i)\)</span> 内的组都会往 <span class="math inline">\(i\)</span> 的方向平移一格。我们需要知道的，就是改变后的局面是否合法。</p>
<p>至于改变之后是否合法，可以记三个前缀和数组（分别维护当前位置，当前位置往左/右平移一格后是否合法）来实现，详见代码。实现较为复杂恶心。同时，需要避开浮点误差。</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a aria-hidden="true" href="#cb18-1"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">2e5</span> + <span class="dv">5</span>;</span>
<span id="cb18-2"><a aria-hidden="true" href="#cb18-2"></a><span class="kw">using</span> ll = <span class="dt">long</span> <span class="dt">long</span>;</span>
<span id="cb18-3"><a aria-hidden="true" href="#cb18-3"></a><span class="kw">using</span> pli = pair&lt;ll, <span class="dt">int</span>&gt;;</span>
<span id="cb18-4"><a aria-hidden="true" href="#cb18-4"></a><span class="dt">int</span> ok[maxn], ok_suf[maxn], ok_pre[maxn], pos0[maxn];</span>
<span id="cb18-5"><a aria-hidden="true" href="#cb18-5"></a>pair&lt;pli, <span class="dt">int</span>&gt; B[maxn];</span>
<span id="cb18-6"><a aria-hidden="true" href="#cb18-6"></a>pli a[maxn];</span>
<span id="cb18-7"><a aria-hidden="true" href="#cb18-7"></a>vector&lt;<span class="dt">int</span>&gt; c[maxn];</span>
<span id="cb18-8"><a aria-hidden="true" href="#cb18-8"></a></span>
<span id="cb18-9"><a aria-hidden="true" href="#cb18-9"></a><span class="dt">bool</span> <span class="kw">operator</span>&gt;(<span class="at">const</span> pli &amp;a, <span class="at">const</span> pli &amp;b) {<span class="cf">return</span> a.first * b.second &gt; b.first * a.second;}</span>
<span id="cb18-10"><a aria-hidden="true" href="#cb18-10"></a></span>
<span id="cb18-11"><a aria-hidden="true" href="#cb18-11"></a><span class="dt">void</span> solve() {</span>
<span id="cb18-12"><a aria-hidden="true" href="#cb18-12"></a>    <span class="dt">int</span> n, m; read(n, m);</span>
<span id="cb18-13"><a aria-hidden="true" href="#cb18-13"></a>    FOR(i, <span class="dv">1</span>, n) read(a[i].first), a[i].second = <span class="dv">1</span>;</span>
<span id="cb18-14"><a aria-hidden="true" href="#cb18-14"></a>    FOR(i, <span class="dv">1</span>, m) {</span>
<span id="cb18-15"><a aria-hidden="true" href="#cb18-15"></a>        <span class="dt">int</span> k; read(k); ll sum = <span class="dv">0</span>;</span>
<span id="cb18-16"><a aria-hidden="true" href="#cb18-16"></a>        c[i].resize(k);</span>
<span id="cb18-17"><a aria-hidden="true" href="#cb18-17"></a>        FOR(j, <span class="dv">0</span>, k - <span class="dv">1</span>) read(c[i][j]), sum += c[i][j];</span>
<span id="cb18-18"><a aria-hidden="true" href="#cb18-18"></a>        B[i] = make_pair(pli(sum, k), i);</span>
<span id="cb18-19"><a aria-hidden="true" href="#cb18-19"></a>    }</span>
<span id="cb18-20"><a aria-hidden="true" href="#cb18-20"></a>    sort(a + <span class="dv">1</span>, a + n + <span class="dv">1</span>, <span class="kw">operator</span>&gt;);</span>
<span id="cb18-21"><a aria-hidden="true" href="#cb18-21"></a>    <span class="kw">auto</span> cmp = [](<span class="at">const</span> <span class="kw">auto</span> &amp;a, <span class="at">const</span> <span class="kw">auto</span> &amp;b) {<span class="cf">return</span> a.first &gt; b.first;};</span>
<span id="cb18-22"><a aria-hidden="true" href="#cb18-22"></a>    sort(B + <span class="dv">1</span>, B + m + <span class="dv">1</span>, cmp);</span>
<span id="cb18-23"><a aria-hidden="true" href="#cb18-23"></a>    FOR(i, <span class="dv">1</span>, m) {</span>
<span id="cb18-24"><a aria-hidden="true" href="#cb18-24"></a>        ok[i] = ok[i - <span class="dv">1</span>] + (B[i].first &gt; a[i]);<span class="co">//记录不合法的情况</span></span>
<span id="cb18-25"><a aria-hidden="true" href="#cb18-25"></a>        ok_pre[i] = ok_pre[i - <span class="dv">1</span>] + (B[i].first &gt; a[i - <span class="dv">1</span>]);<span class="co">//记录不合法的情况</span></span>
<span id="cb18-26"><a aria-hidden="true" href="#cb18-26"></a>        ok_suf[i] = ok_suf[i - <span class="dv">1</span>] + (B[i].first &gt; a[i + <span class="dv">1</span>]);<span class="co">//记录不合法的情况</span></span>
<span id="cb18-27"><a aria-hidden="true" href="#cb18-27"></a>        pos0[B[i].second] = i;</span>
<span id="cb18-28"><a aria-hidden="true" href="#cb18-28"></a>    }</span>
<span id="cb18-29"><a aria-hidden="true" href="#cb18-29"></a>    FOR(i, <span class="dv">1</span>, m) {</span>
<span id="cb18-30"><a aria-hidden="true" href="#cb18-30"></a>        <span class="cf">for</span> (<span class="kw">auto</span> x : c[i]) {</span>
<span id="cb18-31"><a aria-hidden="true" href="#cb18-31"></a>            pli now(B[pos0[i]].first.first - x, B[pos0[i]].first.second - <span class="dv">1</span>);</span>
<span id="cb18-32"><a aria-hidden="true" href="#cb18-32"></a>            <span class="dt">int</span> to = lower_bound(B + <span class="dv">1</span>, B + m + <span class="dv">1</span>, make_pair(now, i), cmp) - B;</span>
<span id="cb18-33"><a aria-hidden="true" href="#cb18-33"></a>            <span class="cf">if</span> (to &gt; pos0[i])</span>
<span id="cb18-34"><a aria-hidden="true" href="#cb18-34"></a>                putchar((now &gt; a[to - <span class="dv">1</span>] || ok[pos0[i] - <span class="dv">1</span>] + ok_pre[to - <span class="dv">1</span>] - ok_pre[pos0[i]] + ok[m] - ok[to - <span class="dv">1</span>]) ? <span class="ch">'0'</span> : <span class="ch">'1'</span>);</span>
<span id="cb18-35"><a aria-hidden="true" href="#cb18-35"></a>            <span class="cf">else</span> putchar((now &gt; a[to] || ok[to - <span class="dv">1</span>] + ok_suf[pos0[i] - <span class="dv">1</span>] - ok_suf[to - <span class="dv">1</span>] + ok[m] - ok[pos0[i]]) ? <span class="ch">'0'</span> : <span class="ch">'1'</span>);</span>
<span id="cb18-36"><a aria-hidden="true" href="#cb18-36"></a>        }</span>
<span id="cb18-37"><a aria-hidden="true" href="#cb18-37"></a>    }</span>
<span id="cb18-38"><a aria-hidden="true" href="#cb18-38"></a>    putchar(<span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span>);</span>
<span id="cb18-39"><a aria-hidden="true" href="#cb18-39"></a>    <span class="cf">return</span>;</span>
<span id="cb18-40"><a aria-hidden="true" href="#cb18-40"></a>}</span>
<span id="cb18-41"><a aria-hidden="true" href="#cb18-41"></a></span>
<span id="cb18-42"><a aria-hidden="true" href="#cb18-42"></a><span class="dt">int</span> main() {</span>
<span id="cb18-43"><a aria-hidden="true" href="#cb18-43"></a>    <span class="dt">int</span> T; read(T);</span>
<span id="cb18-44"><a aria-hidden="true" href="#cb18-44"></a>    <span class="cf">while</span> (T--) solve();</span>
<span id="cb18-45"><a aria-hidden="true" href="#cb18-45"></a>    <span class="cf">return</span> output(), <span class="dv">0</span>;</span>
<span id="cb18-46"><a aria-hidden="true" href="#cb18-46"></a>}</span></code></pre></div>
<h2 id="codeforces-round-764-div.-3">Codeforces Round #764 (Div. 3)</h2>
<p>随缘来做做。</p>
<h3 id="f---interacdive-problem">1624F - Interacdive Problem</h3>
<p>交互题，猜数字。给定一个正整数 <span class="math inline">\(n\)</span>（<span class="math inline">\(2 &lt; n\le 1000\)</span>），要猜一个整数 <span class="math inline">\(x\)</span> 满足 <span class="math inline">\(1\le x &lt; n\)</span>。可以进行如下操作：</p>
<ul>
<li>`+ c`，使得 <span class="math inline">\(x:=x + c\)</span>，然后交互器返回 <span class="math inline">\(\displaystyle\left\lfloor\frac{x}{n}\right\rfloor\)</span> 的值。</li>
<li><code>! x</code>，输出答案，<strong>当前的</strong> <span class="math inline">\(x\)</span> 的值。</li>
</ul>
<p>最多 <span class="math inline">\(10\)</span> 次询问。</p>
<p>直觉告诉我们，<span class="math inline">\(2^{10} = 1024\)</span>，所以我们考虑二分出这个 <span class="math inline">\(x\)</span>，我们只需要每次对二分左右端点同时加上我们给交互库加上的 <span class="math inline">\(c\)</span> 就可以了。我们的思路是尽可能把当前的 <span class="math inline">\(x\)</span> 往其上面的第一个 <span class="math inline">\(n\)</span> 的倍数去凑，所以每次二分的时候加上的都是 <span class="math inline">\(n - mid\bmod n\)</span>。然后就可以根据交互库返回的值来一步步框死范围。</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a aria-hidden="true" href="#cb19-1"></a><span class="dt">int</span> add(<span class="dt">int</span> x) {</span>
<span id="cb19-2"><a aria-hidden="true" href="#cb19-2"></a>    cout &lt;&lt; <span class="st">"+ "</span> &lt;&lt; x &lt;&lt; endl;</span>
<span id="cb19-3"><a aria-hidden="true" href="#cb19-3"></a>    <span class="dt">int</span> res; cin &gt;&gt; res;</span>
<span id="cb19-4"><a aria-hidden="true" href="#cb19-4"></a>    <span class="cf">return</span> res;</span>
<span id="cb19-5"><a aria-hidden="true" href="#cb19-5"></a>}</span>
<span id="cb19-6"><a aria-hidden="true" href="#cb19-6"></a></span>
<span id="cb19-7"><a aria-hidden="true" href="#cb19-7"></a><span class="dt">int</span> main() {</span>
<span id="cb19-8"><a aria-hidden="true" href="#cb19-8"></a>    <span class="dt">int</span> n; cin &gt;&gt; n;</span>
<span id="cb19-9"><a aria-hidden="true" href="#cb19-9"></a>    <span class="dt">int</span> l = <span class="dv">1</span>, r = n;</span>
<span id="cb19-10"><a aria-hidden="true" href="#cb19-10"></a>    <span class="cf">while</span> (l &lt; r - <span class="dv">1</span>) {</span>
<span id="cb19-11"><a aria-hidden="true" href="#cb19-11"></a>        <span class="dt">int</span> mid = (l + r) &gt;&gt; <span class="dv">1</span>;</span>
<span id="cb19-12"><a aria-hidden="true" href="#cb19-12"></a>        <span class="dt">int</span> a = n - mid % n;</span>
<span id="cb19-13"><a aria-hidden="true" href="#cb19-13"></a>        <span class="dt">int</span> res = add(a);</span>
<span id="cb19-14"><a aria-hidden="true" href="#cb19-14"></a>        l += a, r += a, mid += a;</span>
<span id="cb19-15"><a aria-hidden="true" href="#cb19-15"></a>        <span class="cf">if</span> (res == l / n) r = mid;</span>
<span id="cb19-16"><a aria-hidden="true" href="#cb19-16"></a>        <span class="cf">else</span> l = mid; </span>
<span id="cb19-17"><a aria-hidden="true" href="#cb19-17"></a>    }</span>
<span id="cb19-18"><a aria-hidden="true" href="#cb19-18"></a>    cout &lt;&lt; <span class="st">"! "</span> &lt;&lt; l &lt;&lt; endl;</span>
<span id="cb19-19"><a aria-hidden="true" href="#cb19-19"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb19-20"><a aria-hidden="true" href="#cb19-20"></a>}</span></code></pre></div>
<h3 id="g---minor-tree">1624G - MinOr Tree</h3>
<p>给定一张无向图，定义其生成树的边权为 OR 和，问最小生成树的边权 OR 和。</p>
<p>考虑从高到低按位贪心，用并查集判断该位是不是必须取，不是的话就不取。具体地，令 <span class="math inline">\(ans = 2^{30} - 1\)</span>，然后每次先将 <span class="math inline">\(ans\)</span> 的第 <span class="math inline">\(j\)</span> 位去掉，看能否满足存在生成树，若能存在则第 <span class="math inline">\(j\)</span> 位不取。</p>
<p>时间复杂度 <span class="math inline">\(O(m\log a\log n)\)</span>。</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a aria-hidden="true" href="#cb20-1"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">2e5</span> + <span class="dv">5</span>;</span>
<span id="cb20-2"><a aria-hidden="true" href="#cb20-2"></a><span class="kw">struct</span> edge {</span>
<span id="cb20-3"><a aria-hidden="true" href="#cb20-3"></a>    <span class="dt">int</span> u, v, w;</span>
<span id="cb20-4"><a aria-hidden="true" href="#cb20-4"></a>} e[maxn];</span>
<span id="cb20-5"><a aria-hidden="true" href="#cb20-5"></a><span class="dt">int</span> n, m, fa[maxn];</span>
<span id="cb20-6"><a aria-hidden="true" href="#cb20-6"></a></span>
<span id="cb20-7"><a aria-hidden="true" href="#cb20-7"></a><span class="dt">int</span> find(<span class="dt">int</span> u) {<span class="cf">return</span> fa[u] == u ? u : fa[u] = find(fa[u]);}</span>
<span id="cb20-8"><a aria-hidden="true" href="#cb20-8"></a></span>
<span id="cb20-9"><a aria-hidden="true" href="#cb20-9"></a><span class="dt">int</span> merge(<span class="dt">int</span> u, <span class="dt">int</span> v) {</span>
<span id="cb20-10"><a aria-hidden="true" href="#cb20-10"></a>    u = find(u), v = find(v);</span>
<span id="cb20-11"><a aria-hidden="true" href="#cb20-11"></a>    <span class="cf">if</span> (u == v) <span class="cf">return</span> <span class="kw">false</span>;</span>
<span id="cb20-12"><a aria-hidden="true" href="#cb20-12"></a>    <span class="cf">return</span> fa[u] = v, <span class="kw">true</span>;</span>
<span id="cb20-13"><a aria-hidden="true" href="#cb20-13"></a>}</span>
<span id="cb20-14"><a aria-hidden="true" href="#cb20-14"></a></span>
<span id="cb20-15"><a aria-hidden="true" href="#cb20-15"></a><span class="dt">int</span> check(<span class="dt">int</span> mask) {</span>
<span id="cb20-16"><a aria-hidden="true" href="#cb20-16"></a>    FOR(i, <span class="dv">1</span>, n) fa[i] = i;</span>
<span id="cb20-17"><a aria-hidden="true" href="#cb20-17"></a>    <span class="dt">int</span> size = n;</span>
<span id="cb20-18"><a aria-hidden="true" href="#cb20-18"></a>    FOR(i, <span class="dv">1</span>, m) {</span>
<span id="cb20-19"><a aria-hidden="true" href="#cb20-19"></a>        <span class="cf">if</span> ((e[i].w | mask) != mask) <span class="cf">continue</span>;</span>
<span id="cb20-20"><a aria-hidden="true" href="#cb20-20"></a>        <span class="cf">if</span> (merge(e[i].u, e[i].v)) --size;</span>
<span id="cb20-21"><a aria-hidden="true" href="#cb20-21"></a>    }</span>
<span id="cb20-22"><a aria-hidden="true" href="#cb20-22"></a>    <span class="cf">return</span> size == <span class="dv">1</span>;</span>
<span id="cb20-23"><a aria-hidden="true" href="#cb20-23"></a>}</span>
<span id="cb20-24"><a aria-hidden="true" href="#cb20-24"></a></span>
<span id="cb20-25"><a aria-hidden="true" href="#cb20-25"></a><span class="dt">int</span> main() {</span>
<span id="cb20-26"><a aria-hidden="true" href="#cb20-26"></a>    <span class="dt">int</span> T; read(T);</span>
<span id="cb20-27"><a aria-hidden="true" href="#cb20-27"></a>    <span class="cf">while</span> (T--) {</span>
<span id="cb20-28"><a aria-hidden="true" href="#cb20-28"></a>        read(n, m);</span>
<span id="cb20-29"><a aria-hidden="true" href="#cb20-29"></a>        FOR(i, <span class="dv">1</span>, m) read(e[i].u, e[i].v, e[i].w);</span>
<span id="cb20-30"><a aria-hidden="true" href="#cb20-30"></a>        <span class="dt">int</span> ans = (<span class="dv">1</span> &lt;&lt; <span class="dv">30</span>) - <span class="dv">1</span>;</span>
<span id="cb20-31"><a aria-hidden="true" href="#cb20-31"></a>        DEC(i, <span class="dv">29</span>, <span class="dv">0</span>) {</span>
<span id="cb20-32"><a aria-hidden="true" href="#cb20-32"></a>            ans ^= (<span class="dv">1</span> &lt;&lt; i);</span>
<span id="cb20-33"><a aria-hidden="true" href="#cb20-33"></a>            <span class="cf">if</span> (!check(ans)) ans ^= (<span class="dv">1</span> &lt;&lt; i);</span>
<span id="cb20-34"><a aria-hidden="true" href="#cb20-34"></a>        }</span>
<span id="cb20-35"><a aria-hidden="true" href="#cb20-35"></a>        print(ans);</span>
<span id="cb20-36"><a aria-hidden="true" href="#cb20-36"></a>    }</span>
<span id="cb20-37"><a aria-hidden="true" href="#cb20-37"></a>    <span class="cf">return</span> output(), <span class="dv">0</span>;</span>
<span id="cb20-38"><a aria-hidden="true" href="#cb20-38"></a>}</span></code></pre></div>
<h2 id="codeforces-round-765-div.-2">Codeforces Round #765 (Div. 2)</h2>
<p>补完了！</p>
<h3 id="d---binary-spiders">1625D - Binary Spiders</h3>
<p>题意：给定一个数集 <span class="math inline">\(A\)</span>，大小 <span class="math inline">\(n\le 3\times 10^5\)</span>，要求选出一个大小最大的子集 <span class="math inline">\(S\)</span>，使得其中元素两两异或的值都大于等于 <span class="math inline">\(K\)</span>。构造方案。</p>
<p>我们发现两个数字异或起来大于等于 <span class="math inline">\(K\)</span> 的一个必要条件是其二进制表示下，最高的不相同的位大于等于 <span class="math inline">\(K\)</span> 的最高位。即他们在 Trie 上的 LCA 大于等于 <span class="math inline">\(K\)</span> 的最高位。下面令这个第 <span class="math inline">\(K\)</span> 位为 <span class="math inline">\(up\)</span>。</p>
<p>在 Trie 上递归求解问题。点对分为在左右子树内部和跨越该节点两种情况。</p>
<ul>
<li>当前 Trie 表示的位数大于 <span class="math inline">\(up\)</span>，此时左右子树内部的点对都有希望异或大于等于 <span class="math inline">\(K\)</span>，而跨越该节点的铁定大于 <span class="math inline">\(K\)</span>，所以递归下去做然后把两边答案合并。</li>
<li>当前 Trie 表示的位数等于 <span class="math inline">\(up\)</span>，此时我们要么在该子树中选出一个大于等于 <span class="math inline">\(K\)</span> 的元素，要么找一对跨越左右子树的异或大于等于 <span class="math inline">\(K\)</span> 的数对，然后就不用递归下去了。</li>
</ul>
<p>这个过程应该是自证明的。找大于等于 <span class="math inline">\(K\)</span> 的元素很简单，一直往右子树找最大的即可。找异或大于等于 <span class="math inline">\(K\)</span> 的也很简单，将一个子树内的所有数字提出来，挨个在右边查最大异或对，就可以找到了。</p>
<p><span class="math inline">\(K = 0\)</span> 的情况需要特判。</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a aria-hidden="true" href="#cb21-1"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">3e5</span> + <span class="dv">5</span>;</span>
<span id="cb21-2"><a aria-hidden="true" href="#cb21-2"></a><span class="dt">int</span> n, K, a[maxn], up;</span>
<span id="cb21-3"><a aria-hidden="true" href="#cb21-3"></a><span class="dt">int</span> ch[maxn * <span class="dv">30</span>][<span class="dv">2</span>], val[maxn * <span class="dv">30</span>], tot, root;</span>
<span id="cb21-4"><a aria-hidden="true" href="#cb21-4"></a></span>
<span id="cb21-5"><a aria-hidden="true" href="#cb21-5"></a><span class="dt">void</span> insert(<span class="dt">int</span> &amp;u, <span class="dt">int</span> id, <span class="dt">int</span> x, <span class="dt">int</span> k) {</span>
<span id="cb21-6"><a aria-hidden="true" href="#cb21-6"></a>    <span class="cf">if</span> (!u) u = ++tot;</span>
<span id="cb21-7"><a aria-hidden="true" href="#cb21-7"></a>    <span class="cf">if</span> (k &lt; <span class="dv">0</span>) <span class="cf">return</span> val[u] = id, <span class="dt">void</span>();</span>
<span id="cb21-8"><a aria-hidden="true" href="#cb21-8"></a>    <span class="dt">int</span> c = (x &gt;&gt; k) &amp; <span class="dv">1</span>;</span>
<span id="cb21-9"><a aria-hidden="true" href="#cb21-9"></a>    insert(ch[u][c], id, x, k - <span class="dv">1</span>);</span>
<span id="cb21-10"><a aria-hidden="true" href="#cb21-10"></a>    <span class="cf">return</span>;</span>
<span id="cb21-11"><a aria-hidden="true" href="#cb21-11"></a>}</span>
<span id="cb21-12"><a aria-hidden="true" href="#cb21-12"></a></span>
<span id="cb21-13"><a aria-hidden="true" href="#cb21-13"></a>vector&lt;<span class="dt">int</span>&gt; getval(<span class="dt">int</span> u, <span class="dt">int</span> k) {</span>
<span id="cb21-14"><a aria-hidden="true" href="#cb21-14"></a>    <span class="cf">if</span> (!u) <span class="cf">return</span> vector&lt;<span class="dt">int</span>&gt;();</span>
<span id="cb21-15"><a aria-hidden="true" href="#cb21-15"></a>    <span class="cf">if</span> (k &lt; <span class="dv">0</span>) <span class="cf">return</span> vector&lt;<span class="dt">int</span>&gt;{val[u]};</span>
<span id="cb21-16"><a aria-hidden="true" href="#cb21-16"></a>    <span class="kw">auto</span> r1 = getval(ch[u][<span class="dv">0</span>], k - <span class="dv">1</span>), r2 = getval(ch[u][<span class="dv">1</span>], k - <span class="dv">1</span>);</span>
<span id="cb21-17"><a aria-hidden="true" href="#cb21-17"></a>    <span class="cf">for</span> (<span class="kw">auto</span> xx : r2) r1.push_back(xx);</span>
<span id="cb21-18"><a aria-hidden="true" href="#cb21-18"></a>    <span class="cf">return</span> r1;</span>
<span id="cb21-19"><a aria-hidden="true" href="#cb21-19"></a>}</span>
<span id="cb21-20"><a aria-hidden="true" href="#cb21-20"></a></span>
<span id="cb21-21"><a aria-hidden="true" href="#cb21-21"></a><span class="dt">int</span> query(<span class="dt">int</span> u, <span class="dt">int</span> k, <span class="dt">int</span> x) {</span>
<span id="cb21-22"><a aria-hidden="true" href="#cb21-22"></a>    <span class="cf">if</span> (k &lt; <span class="dv">0</span>) <span class="cf">return</span> val[u];</span>
<span id="cb21-23"><a aria-hidden="true" href="#cb21-23"></a>    <span class="dt">int</span> c = ((x &gt;&gt; k) &amp; <span class="dv">1</span>) ^ <span class="dv">1</span>;</span>
<span id="cb21-24"><a aria-hidden="true" href="#cb21-24"></a>    <span class="cf">if</span> (!ch[u][c]) <span class="cf">return</span> query(ch[u][c ^ <span class="dv">1</span>], k - <span class="dv">1</span>, x);</span>
<span id="cb21-25"><a aria-hidden="true" href="#cb21-25"></a>    <span class="cf">else</span> <span class="cf">return</span> query(ch[u][c], k - <span class="dv">1</span>, x);</span>
<span id="cb21-26"><a aria-hidden="true" href="#cb21-26"></a>}</span>
<span id="cb21-27"><a aria-hidden="true" href="#cb21-27"></a></span>
<span id="cb21-28"><a aria-hidden="true" href="#cb21-28"></a>vector&lt;<span class="dt">int</span>&gt; solve(<span class="dt">int</span> u, <span class="dt">int</span> k) {</span>
<span id="cb21-29"><a aria-hidden="true" href="#cb21-29"></a>    <span class="cf">if</span> (k &lt; up || !u) <span class="cf">return</span> vector&lt;<span class="dt">int</span>&gt;();</span>
<span id="cb21-30"><a aria-hidden="true" href="#cb21-30"></a>    <span class="cf">if</span> (k &gt; up) {</span>
<span id="cb21-31"><a aria-hidden="true" href="#cb21-31"></a>        <span class="kw">auto</span> r1 = solve(ch[u][<span class="dv">0</span>], k - <span class="dv">1</span>), r2 = solve(ch[u][<span class="dv">1</span>], k - <span class="dv">1</span>);</span>
<span id="cb21-32"><a aria-hidden="true" href="#cb21-32"></a>        <span class="cf">for</span> (<span class="kw">auto</span> xx : r2) r1.push_back(xx);</span>
<span id="cb21-33"><a aria-hidden="true" href="#cb21-33"></a>        <span class="cf">return</span> r1;</span>
<span id="cb21-34"><a aria-hidden="true" href="#cb21-34"></a>    } <span class="cf">else</span> <span class="cf">if</span> (k == up) {</span>
<span id="cb21-35"><a aria-hidden="true" href="#cb21-35"></a>        vector&lt;<span class="dt">int</span>&gt; vec1 = getval(ch[u][<span class="dv">1</span>], k - <span class="dv">1</span>), vec2 = getval(ch[u][<span class="dv">0</span>], k - <span class="dv">1</span>), ans;</span>
<span id="cb21-36"><a aria-hidden="true" href="#cb21-36"></a>        <span class="cf">if</span> (!vec1.size()) {</span>
<span id="cb21-37"><a aria-hidden="true" href="#cb21-37"></a>            <span class="cf">if</span> (a[vec2.back()] &gt;= K) ans.push_back(vec2.back());</span>
<span id="cb21-38"><a aria-hidden="true" href="#cb21-38"></a>            <span class="cf">return</span> ans;</span>
<span id="cb21-39"><a aria-hidden="true" href="#cb21-39"></a>        }</span>
<span id="cb21-40"><a aria-hidden="true" href="#cb21-40"></a>        <span class="cf">if</span> (!vec2.size()) {</span>
<span id="cb21-41"><a aria-hidden="true" href="#cb21-41"></a>            <span class="cf">if</span> (a[vec1.back()] &gt;= K) ans.push_back(vec1.back());</span>
<span id="cb21-42"><a aria-hidden="true" href="#cb21-42"></a>            <span class="cf">return</span> ans;</span>
<span id="cb21-43"><a aria-hidden="true" href="#cb21-43"></a>        }</span>
<span id="cb21-44"><a aria-hidden="true" href="#cb21-44"></a>        <span class="dt">bool</span> flag = <span class="dv">0</span>;</span>
<span id="cb21-45"><a aria-hidden="true" href="#cb21-45"></a>        <span class="cf">for</span> (<span class="kw">auto</span> x1 : vec1) {</span>
<span id="cb21-46"><a aria-hidden="true" href="#cb21-46"></a>            <span class="dt">int</span> x2 = query(ch[u][<span class="dv">0</span>], k - <span class="dv">1</span>, a[x1]);</span>
<span id="cb21-47"><a aria-hidden="true" href="#cb21-47"></a>            <span class="cf">if</span> ((a[x1] ^ a[x2]) &gt;= K) {</span>
<span id="cb21-48"><a aria-hidden="true" href="#cb21-48"></a>                flag = <span class="dv">1</span>;</span>
<span id="cb21-49"><a aria-hidden="true" href="#cb21-49"></a>                ans.push_back(x1), ans.push_back(x2);</span>
<span id="cb21-50"><a aria-hidden="true" href="#cb21-50"></a>                <span class="cf">break</span>;</span>
<span id="cb21-51"><a aria-hidden="true" href="#cb21-51"></a>            }</span>
<span id="cb21-52"><a aria-hidden="true" href="#cb21-52"></a>        }</span>
<span id="cb21-53"><a aria-hidden="true" href="#cb21-53"></a>        <span class="cf">if</span> (!flag) {</span>
<span id="cb21-54"><a aria-hidden="true" href="#cb21-54"></a>            <span class="cf">if</span> (a[vec1.back()] &gt;= K) ans.push_back(vec1.back());</span>
<span id="cb21-55"><a aria-hidden="true" href="#cb21-55"></a>        }</span>
<span id="cb21-56"><a aria-hidden="true" href="#cb21-56"></a>        <span class="cf">return</span> ans;</span>
<span id="cb21-57"><a aria-hidden="true" href="#cb21-57"></a>    }</span>
<span id="cb21-58"><a aria-hidden="true" href="#cb21-58"></a>}</span>
<span id="cb21-59"><a aria-hidden="true" href="#cb21-59"></a></span>
<span id="cb21-60"><a aria-hidden="true" href="#cb21-60"></a><span class="dt">int</span> main() {</span>
<span id="cb21-61"><a aria-hidden="true" href="#cb21-61"></a>    read(n, K);</span>
<span id="cb21-62"><a aria-hidden="true" href="#cb21-62"></a>    DEC(i, <span class="dv">30</span>, <span class="dv">0</span>) <span class="cf">if</span> ((K &gt;&gt; i) &amp; <span class="dv">1</span>) {</span>
<span id="cb21-63"><a aria-hidden="true" href="#cb21-63"></a>        up = i;</span>
<span id="cb21-64"><a aria-hidden="true" href="#cb21-64"></a>        <span class="cf">break</span>;</span>
<span id="cb21-65"><a aria-hidden="true" href="#cb21-65"></a>    }</span>
<span id="cb21-66"><a aria-hidden="true" href="#cb21-66"></a>    <span class="cf">if</span> (K == <span class="dv">0</span>) {</span>
<span id="cb21-67"><a aria-hidden="true" href="#cb21-67"></a>        print(n);</span>
<span id="cb21-68"><a aria-hidden="true" href="#cb21-68"></a>        FOR(i, <span class="dv">1</span>, n) print(i, <span class="ch">' '</span>);</span>
<span id="cb21-69"><a aria-hidden="true" href="#cb21-69"></a>        <span class="cf">return</span> output(), <span class="dv">0</span>;</span>
<span id="cb21-70"><a aria-hidden="true" href="#cb21-70"></a>    }</span>
<span id="cb21-71"><a aria-hidden="true" href="#cb21-71"></a>    FOR(i, <span class="dv">1</span>, n) read(a[i]), insert(root, i, a[i], <span class="dv">30</span>);</span>
<span id="cb21-72"><a aria-hidden="true" href="#cb21-72"></a>    <span class="kw">auto</span> ans = solve(root, <span class="dv">30</span>);</span>
<span id="cb21-73"><a aria-hidden="true" href="#cb21-73"></a>    <span class="cf">if</span> (!ans.size()) print(-<span class="dv">1</span>);</span>
<span id="cb21-74"><a aria-hidden="true" href="#cb21-74"></a>    <span class="cf">else</span> {</span>
<span id="cb21-75"><a aria-hidden="true" href="#cb21-75"></a>        print(ans.size());</span>
<span id="cb21-76"><a aria-hidden="true" href="#cb21-76"></a>        <span class="cf">for</span> (<span class="kw">auto</span> x : ans) print(x, <span class="ch">' '</span>);</span>
<span id="cb21-77"><a aria-hidden="true" href="#cb21-77"></a>    }</span>
<span id="cb21-78"><a aria-hidden="true" href="#cb21-78"></a>    <span class="cf">return</span> output(), <span class="dv">0</span>;</span>
<span id="cb21-79"><a aria-hidden="true" href="#cb21-79"></a>}</span></code></pre></div>
<h3 id="e1---cats-on-the-upgrade-easy-version">1625E1 - Cats on the Upgrade (easy version)</h3>
<p>给出如下定义：</p>
<ul>
<li>定义一个字符串是合法的括号序列（RBS）当且仅当其能通过每次去掉一个 <code>.</code> 或者一个连续的 <code>()</code> 变成空串。</li>
<li>一个 RBS 被称为“简单的”当且仅当其开头和结尾均不为<code>.</code>。</li>
</ul>
<p>然后给定一个长为 <span class="math inline">\(n\)</span> 的只包含字符 <code>(</code> 和 <code>)</code> 的字符串 <span class="math inline">\(S\)</span>。要求完成如下操作：</p>
<ul>
<li>给定 <span class="math inline">\(l, r\)</span>，保证 <span class="math inline">\(S_l\)</span> 为 <code>(</code>，<span class="math inline">\(S_r\)</span> 为 <code>)</code>，其中间的字符均为 <code>.</code>，然后将 <span class="math inline">\(S_l\)</span> 和 <span class="math inline">\(S_r\)</span> 设为 <code>.</code>。</li>
<li>给定 <span class="math inline">\(l, r\)</span>，询问 <span class="math inline">\(S_{[l\cdots r]}\)</span> 有多少连续子段为简单的 RBS，保证 <span class="math inline">\(S_{[l\cdots r]}\)</span> 为简单 RBS。</li>
</ul>
<p><span class="math inline">\(2\le n\le 3\times 10^5\)</span>，<span class="math inline">\(1\le q\le 3\times10^5\)</span>。</p>
<p>easy version 无修改操作。</p>
<p>静态问题的话我们不妨记 <span class="math inline">\(p_i\)</span> 为以 <span class="math inline">\(i\)</span> 结尾的 RBS 的数量，这个东西很好 DP 出来，然后做个前缀和 <span class="math inline">\(S_i\)</span>，然后会发现 <span class="math inline">\(S_r - S_{l}\)</span> 算重了某些信息。</p>
<p>具体地，多算 RBS 的左端点应该在 <span class="math inline">\([1, l - 1]\)</span>，右端点应该在 <span class="math inline">\([l, r]\)</span>，这些东西需要减掉。而，我们知道，设这样的 RBS 为 <span class="math inline">\([i,j]\)</span>，则 <span class="math inline">\([i, l - 1]\)</span>，<span class="math inline">\([l, j]\)</span> 和 <span class="math inline">\([j + 1, r]\)</span> 都应该是 RBS。所以这些形如 <span class="math inline">\([i,j]\)</span> 的 RBS 的数量应该是形如 <span class="math inline">\([i, l -1]\)</span> 的 RBS 的数量乘上形如 <span class="math inline">\([l, j]\)</span> 的 RBS 的数量，即为 <span class="math inline">\(p_{l - 1}\times (p_r - p_{l - 1})\)</span>。</p>
<h3 id="e2---cats-on-the-upgrade-hard-version">1625E2 - Cats on the Upgrade (hard version)</h3>
<p>hard version 带上修改操作。</p>
<p>上面这种做法的扩展性应该是不太好的。考虑建出括号树（或者说，森林，那些不合法的字符就直接扔掉），一对左右括号是一个节点，类似下面这张图：</p>
<p><img src="https://s4.ax1x.com/2022/01/28/7zM1Ej.png"/></p>
<p>然后我们注意到，每次询问肯定都是询问树上一个节点或者若干个同层相邻节点的信息，并且每次操作都是删除叶子节点。我们考虑如何对于一个节点计算<strong>只选其儿子能构成 RBS 的数量</strong> <span class="math inline">\(g_u\)</span>，发现其就是选择 <span class="math inline">\(1\)</span> 个儿子、两个相邻儿子、三个相邻儿子……，设 <span class="math inline">\(x\)</span> 个儿子的话，<span class="math inline">\(g_u = x(x+1)/2\)</span>。</p>
<p>而我们考虑一个节点 <span class="math inline">\(u\)</span> 代表的 <span class="math inline">\([l, r]\)</span> 内的 RBS 数量的话，其明显为 <span class="math inline">\(\sum_{u是v祖先} g_v + g_u\)</span>。所以，对于一次询问的 <span class="math inline">\([l, r]\)</span>，其肯定包含了一个同层的点集 <span class="math inline">\(A\)</span>，其答案就再加上 <span class="math inline">\(|A|\times (|A| + 1) / 2\)</span> 即可。</p>
<p>那么对于一次修改操作，我们思考其改变了什么：无非就是父亲节点的儿子数量减小，我们需要维护每个节点的 <span class="math inline">\(g_u\)</span>，支持单修区查；然后维护每个点的儿子，同样是单修区查，用树状数组就可以了。</p>
<p>这应该是最简洁的做法了。具体看代码，目前为 CF 最优解。</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a aria-hidden="true" href="#cb22-1"></a><span class="kw">using</span> ll = <span class="dt">long</span> <span class="dt">long</span>;</span>
<span id="cb22-2"><a aria-hidden="true" href="#cb22-2"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">3e5</span> + <span class="dv">5</span>;</span>
<span id="cb22-3"><a aria-hidden="true" href="#cb22-3"></a><span class="dt">char</span> s[maxn];</span>
<span id="cb22-4"><a aria-hidden="true" href="#cb22-4"></a><span class="dt">int</span> n, q;</span>
<span id="cb22-5"><a aria-hidden="true" href="#cb22-5"></a></span>
<span id="cb22-6"><a aria-hidden="true" href="#cb22-6"></a><span class="kw">struct</span> bit {</span>
<span id="cb22-7"><a aria-hidden="true" href="#cb22-7"></a>    vector&lt;ll&gt; s; <span class="dt">int</span> sz;</span>
<span id="cb22-8"><a aria-hidden="true" href="#cb22-8"></a>    <span class="dt">void</span> build(<span class="dt">int</span> SZ) {sz = SZ + <span class="dv">5</span>, s.resize(sz); <span class="cf">return</span>;}</span>
<span id="cb22-9"><a aria-hidden="true" href="#cb22-9"></a>    <span class="dt">void</span> add(<span class="dt">int</span> x, ll v) {<span class="cf">for</span> (; x &lt; sz; x += (x &amp; -x)) s[x] += v; <span class="cf">return</span>;}</span>
<span id="cb22-10"><a aria-hidden="true" href="#cb22-10"></a>    ll query(<span class="dt">int</span> x) {ll ret = <span class="dv">0</span>; <span class="cf">for</span> (; x; x -= (x &amp; -x)) ret += s[x]; <span class="cf">return</span> ret;}</span>
<span id="cb22-11"><a aria-hidden="true" href="#cb22-11"></a>} T, t[maxn];</span>
<span id="cb22-12"><a aria-hidden="true" href="#cb22-12"></a></span>
<span id="cb22-13"><a aria-hidden="true" href="#cb22-13"></a><span class="dt">int</span> son[maxn], fa[maxn], bel[maxn], ord[maxn], size[maxn];</span>
<span id="cb22-14"><a aria-hidden="true" href="#cb22-14"></a></span>
<span id="cb22-15"><a aria-hidden="true" href="#cb22-15"></a><span class="dt">int</span> main() {</span>
<span id="cb22-16"><a aria-hidden="true" href="#cb22-16"></a>    read(n, q);</span>
<span id="cb22-17"><a aria-hidden="true" href="#cb22-17"></a>    read(s + <span class="dv">1</span>);</span>
<span id="cb22-18"><a aria-hidden="true" href="#cb22-18"></a>    <span class="dt">int</span> cnt = <span class="dv">1</span>, now = <span class="dv">1</span>;</span>
<span id="cb22-19"><a aria-hidden="true" href="#cb22-19"></a>    FOR(i, <span class="dv">1</span>, n) {</span>
<span id="cb22-20"><a aria-hidden="true" href="#cb22-20"></a>        <span class="cf">if</span> (s[i] == <span class="ch">'('</span>) {</span>
<span id="cb22-21"><a aria-hidden="true" href="#cb22-21"></a>            ord[++cnt] = ++son[now];</span>
<span id="cb22-22"><a aria-hidden="true" href="#cb22-22"></a>            fa[cnt] = now, bel[i] = cnt, now = cnt;</span>
<span id="cb22-23"><a aria-hidden="true" href="#cb22-23"></a>        } <span class="cf">else</span> <span class="cf">if</span> (now != <span class="dv">1</span>) {</span>
<span id="cb22-24"><a aria-hidden="true" href="#cb22-24"></a>            bel[i] = now;</span>
<span id="cb22-25"><a aria-hidden="true" href="#cb22-25"></a>            now = fa[now];</span>
<span id="cb22-26"><a aria-hidden="true" href="#cb22-26"></a>        }</span>
<span id="cb22-27"><a aria-hidden="true" href="#cb22-27"></a>    }</span>
<span id="cb22-28"><a aria-hidden="true" href="#cb22-28"></a>    T.build(cnt);</span>
<span id="cb22-29"><a aria-hidden="true" href="#cb22-29"></a>    FOR(i, <span class="dv">1</span>, cnt) {</span>
<span id="cb22-30"><a aria-hidden="true" href="#cb22-30"></a>        T.add(i, <span class="dv">1</span><span class="bu">ll</span> * son[i] * (son[i] + <span class="dv">1</span>) / <span class="dv">2</span>);</span>
<span id="cb22-31"><a aria-hidden="true" href="#cb22-31"></a>        t[i].build(son[i]);</span>
<span id="cb22-32"><a aria-hidden="true" href="#cb22-32"></a>    }</span>
<span id="cb22-33"><a aria-hidden="true" href="#cb22-33"></a>    DEC(i, cnt, <span class="dv">1</span>) size[fa[i]] += (++size[i]);</span>
<span id="cb22-34"><a aria-hidden="true" href="#cb22-34"></a>    <span class="cf">while</span> (q--) {</span>
<span id="cb22-35"><a aria-hidden="true" href="#cb22-35"></a>        <span class="dt">int</span> op, l, r; read(op, l, r);</span>
<span id="cb22-36"><a aria-hidden="true" href="#cb22-36"></a>        <span class="cf">if</span> (op == <span class="dv">1</span>) {</span>
<span id="cb22-37"><a aria-hidden="true" href="#cb22-37"></a>            <span class="dt">int</span> now = bel[l];</span>
<span id="cb22-38"><a aria-hidden="true" href="#cb22-38"></a>            t[fa[now]].add(ord[now], <span class="dv">1</span>);</span>
<span id="cb22-39"><a aria-hidden="true" href="#cb22-39"></a>            T.add(fa[now], -son[fa[now]]--);</span>
<span id="cb22-40"><a aria-hidden="true" href="#cb22-40"></a>        } <span class="cf">else</span> {</span>
<span id="cb22-41"><a aria-hidden="true" href="#cb22-41"></a>            l = bel[l], r = bel[r];</span>
<span id="cb22-42"><a aria-hidden="true" href="#cb22-42"></a>            ll ans = T.query(r + size[r] - <span class="dv">1</span>) - T.query(l - <span class="dv">1</span>);</span>
<span id="cb22-43"><a aria-hidden="true" href="#cb22-43"></a>            ll cnt = ord[r] - ord[l] + <span class="dv">1</span> - t[fa[l]].query(ord[r]) + t[fa[l]].query(ord[l] - <span class="dv">1</span>);</span>
<span id="cb22-44"><a aria-hidden="true" href="#cb22-44"></a>            ans += cnt * (cnt + <span class="dv">1</span>) / <span class="dv">2</span>;</span>
<span id="cb22-45"><a aria-hidden="true" href="#cb22-45"></a>            print(ans);</span>
<span id="cb22-46"><a aria-hidden="true" href="#cb22-46"></a>        }</span>
<span id="cb22-47"><a aria-hidden="true" href="#cb22-47"></a>    }</span>
<span id="cb22-48"><a aria-hidden="true" href="#cb22-48"></a>    <span class="cf">return</span> output(), <span class="dv">0</span>;</span>
<span id="cb22-49"><a aria-hidden="true" href="#cb22-49"></a>}</span></code></pre></div>
<h2 id="codeforces-round-766-div.-2">Codeforces Round #766 (Div. 2)</h2>
<p>补完了，好！</p>
<h3 id="d---not-adding">1627D - Not Adding</h3>
<p>注意到所谓的加入数字的顺序其实无关紧要，为了尽可能多的加数，我们从大到小枚举加的这个数字。</p>
<p>假设其为 <span class="math inline">\(i\)</span>，然后枚举倍数 <span class="math inline">\(j\)</span>。我们只需要保证数组内有满足 <span class="math inline">\(\gcd\)</span> 为 <span class="math inline">\(i\)</span> 的 <span class="math inline">\(j\)</span> 即可。</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a aria-hidden="true" href="#cb23-1"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">1e6</span> + <span class="dv">5</span>, N = <span class="fl">1e6</span>;</span>
<span id="cb23-2"><a aria-hidden="true" href="#cb23-2"></a><span class="dt">int</span> vis[maxn], n, maxx, ans;</span>
<span id="cb23-3"><a aria-hidden="true" href="#cb23-3"></a></span>
<span id="cb23-4"><a aria-hidden="true" href="#cb23-4"></a><span class="dt">int</span> gcd(<span class="dt">int</span> a, <span class="dt">int</span> b) {<span class="cf">return</span> b ? gcd(b, a % b) : a;}</span>
<span id="cb23-5"><a aria-hidden="true" href="#cb23-5"></a></span>
<span id="cb23-6"><a aria-hidden="true" href="#cb23-6"></a><span class="dt">int</span> main() {</span>
<span id="cb23-7"><a aria-hidden="true" href="#cb23-7"></a>    read(n);</span>
<span id="cb23-8"><a aria-hidden="true" href="#cb23-8"></a>    FOR(i, <span class="dv">1</span>, n) {</span>
<span id="cb23-9"><a aria-hidden="true" href="#cb23-9"></a>        <span class="dt">int</span> x; read(x);</span>
<span id="cb23-10"><a aria-hidden="true" href="#cb23-10"></a>        vis[x] = <span class="dv">1</span>;</span>
<span id="cb23-11"><a aria-hidden="true" href="#cb23-11"></a>        chkmax(maxx, x);</span>
<span id="cb23-12"><a aria-hidden="true" href="#cb23-12"></a>    }</span>
<span id="cb23-13"><a aria-hidden="true" href="#cb23-13"></a>    DEC(i, maxx, <span class="dv">1</span>) {</span>
<span id="cb23-14"><a aria-hidden="true" href="#cb23-14"></a>        <span class="cf">if</span> (vis[i]) <span class="cf">continue</span>;</span>
<span id="cb23-15"><a aria-hidden="true" href="#cb23-15"></a>        <span class="dt">int</span> cnt = <span class="dv">0</span>, f = <span class="dv">0</span>;</span>
<span id="cb23-16"><a aria-hidden="true" href="#cb23-16"></a>        <span class="cf">for</span> (<span class="dt">int</span> j = <span class="dv">2</span> * i; j &lt;= N; j += i) {</span>
<span id="cb23-17"><a aria-hidden="true" href="#cb23-17"></a>            <span class="cf">if</span> (vis[j]) {</span>
<span id="cb23-18"><a aria-hidden="true" href="#cb23-18"></a>                ++cnt;</span>
<span id="cb23-19"><a aria-hidden="true" href="#cb23-19"></a>                <span class="cf">if</span> (cnt == <span class="dv">1</span>) f = j / i;</span>
<span id="cb23-20"><a aria-hidden="true" href="#cb23-20"></a>                <span class="cf">else</span> f = gcd(f, j / i);</span>
<span id="cb23-21"><a aria-hidden="true" href="#cb23-21"></a>            }</span>
<span id="cb23-22"><a aria-hidden="true" href="#cb23-22"></a>        }</span>
<span id="cb23-23"><a aria-hidden="true" href="#cb23-23"></a>        <span class="cf">if</span> (cnt &gt; <span class="dv">1</span> &amp;&amp; f == <span class="dv">1</span>) vis[i] = <span class="dv">1</span>, ++ans;</span>
<span id="cb23-24"><a aria-hidden="true" href="#cb23-24"></a>    }</span>
<span id="cb23-25"><a aria-hidden="true" href="#cb23-25"></a>    print(ans);</span>
<span id="cb23-26"><a aria-hidden="true" href="#cb23-26"></a>    <span class="cf">return</span> output(), <span class="dv">0</span>;</span>
<span id="cb23-27"><a aria-hidden="true" href="#cb23-27"></a>}</span></code></pre></div>
<h3 id="e---not-escaping">1627E - Not Escaping</h3>
<p><span class="math inline">\(n\)</span> 层楼，每层楼有 <span class="math inline">\(m\)</span> 个房间，要求从 <span class="math inline">\((1,1)\to(n,m)\)</span>。走法有两种：</p>
<ul>
<li>在同一楼层平移，如 <span class="math inline">\((i, j_1)\to(i, j_2)\)</span>，代价为 <span class="math inline">\(x_i\cdot|j_2 - j_1|\)</span>。</li>
<li>通过梯子从 <span class="math inline">\((a_i,b_i)\to(c_i,d_i)\)</span>，代价为 <span class="math inline">\(-h_i\)</span>。保证有 <span class="math inline">\(a_i&lt;c_i\)</span>。</li>
</ul>
<p>问最小代价或者输出无解。<span class="math inline">\(2\le n,m\le 10^5\)</span>，梯子总数 <span class="math inline">\(1\le k\le 10^5\)</span>，<span class="math inline">\(1\le x_i,h_i\le 10^6\)</span>。</p>
<p>实际上会发现，有用的点不超过 <span class="math inline">\(2k + 2\)</span> 个（起点，终点和梯子的端点），并且梯子都是自下而上的。</p>
<p>因此我们从下往上一层一层的 dp，用当前层的 dp 值更新当前层，然后有梯子的就往上更新。</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb24-1"><a aria-hidden="true" href="#cb24-1"></a><span class="kw">using</span> ll = <span class="dt">long</span> <span class="dt">long</span>;</span>
<span id="cb24-2"><a aria-hidden="true" href="#cb24-2"></a><span class="kw">using</span> pil = pair&lt;<span class="dt">int</span>, ll&gt;;</span>
<span id="cb24-3"><a aria-hidden="true" href="#cb24-3"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">1e5</span> + <span class="dv">5</span>;</span>
<span id="cb24-4"><a aria-hidden="true" href="#cb24-4"></a><span class="at">const</span> ll INF = <span class="bn">0x3f3f3f3f3f3f3f3f</span>;</span>
<span id="cb24-5"><a aria-hidden="true" href="#cb24-5"></a>ll x[maxn], dp[maxn];</span>
<span id="cb24-6"><a aria-hidden="true" href="#cb24-6"></a><span class="kw">struct</span> ladder {</span>
<span id="cb24-7"><a aria-hidden="true" href="#cb24-7"></a>    <span class="dt">int</span> a, b, c, d, h;</span>
<span id="cb24-8"><a aria-hidden="true" href="#cb24-8"></a>    ladder() {}</span>
<span id="cb24-9"><a aria-hidden="true" href="#cb24-9"></a>    ladder(<span class="dt">int</span> _a, <span class="dt">int</span> _b, <span class="dt">int</span> _c, <span class="dt">int</span> _d, <span class="dt">int</span> _h) : a(_a), b(_b), c(_c), d(_d), h(_h) {}</span>
<span id="cb24-10"><a aria-hidden="true" href="#cb24-10"></a>};</span>
<span id="cb24-11"><a aria-hidden="true" href="#cb24-11"></a>vector&lt;ladder&gt; lad[maxn];</span>
<span id="cb24-12"><a aria-hidden="true" href="#cb24-12"></a>map&lt;<span class="dt">int</span>, ll&gt; row[maxn];</span>
<span id="cb24-13"><a aria-hidden="true" href="#cb24-13"></a></span>
<span id="cb24-14"><a aria-hidden="true" href="#cb24-14"></a><span class="dt">void</span> solve() {</span>
<span id="cb24-15"><a aria-hidden="true" href="#cb24-15"></a>    <span class="dt">int</span> n, m, k; read(n, m, k);</span>
<span id="cb24-16"><a aria-hidden="true" href="#cb24-16"></a>    FOR(i, <span class="dv">1</span>, n) read(x[i]), vector&lt;ladder&gt;().swap(lad[i]), map&lt;<span class="dt">int</span>, ll&gt;().swap(row[i]);</span>
<span id="cb24-17"><a aria-hidden="true" href="#cb24-17"></a>    FOR(i, <span class="dv">1</span>, k) {</span>
<span id="cb24-18"><a aria-hidden="true" href="#cb24-18"></a>        <span class="dt">int</span> a, b, c, d, h; read(a, b, c, d, h);</span>
<span id="cb24-19"><a aria-hidden="true" href="#cb24-19"></a>        lad[a].push_back(ladder(a, b, c, d, h));</span>
<span id="cb24-20"><a aria-hidden="true" href="#cb24-20"></a>        row[a][b] = INF, row[c][d] = INF;</span>
<span id="cb24-21"><a aria-hidden="true" href="#cb24-21"></a>    }</span>
<span id="cb24-22"><a aria-hidden="true" href="#cb24-22"></a>    row[<span class="dv">1</span>][<span class="dv">1</span>] = <span class="dv">0</span>, row[n][m] = INF;</span>
<span id="cb24-23"><a aria-hidden="true" href="#cb24-23"></a>    FOR(i, <span class="dv">1</span>, n) {</span>
<span id="cb24-24"><a aria-hidden="true" href="#cb24-24"></a>        <span class="cf">if</span> (row[i].size() &gt;= <span class="dv">2</span>) {</span>
<span id="cb24-25"><a aria-hidden="true" href="#cb24-25"></a>            pil last = *row[i].begin();</span>
<span id="cb24-26"><a aria-hidden="true" href="#cb24-26"></a>            <span class="cf">for</span> (<span class="kw">auto</span> it = ++(row[i].begin()); it != row[i].end(); last = *it++)</span>
<span id="cb24-27"><a aria-hidden="true" href="#cb24-27"></a>                chkmin(it-&gt;second, last.second + x[i] * myabs(last.first - it-&gt;first));</span>
<span id="cb24-28"><a aria-hidden="true" href="#cb24-28"></a>            last = *row[i].rbegin();</span>
<span id="cb24-29"><a aria-hidden="true" href="#cb24-29"></a>            <span class="cf">for</span> (<span class="kw">auto</span> it = ++(row[i].rbegin()); it != row[i].rend(); last = *it++)</span>
<span id="cb24-30"><a aria-hidden="true" href="#cb24-30"></a>                chkmin(it-&gt;second, last.second + x[i] * myabs(last.first - it-&gt;first));</span>
<span id="cb24-31"><a aria-hidden="true" href="#cb24-31"></a>        }</span>
<span id="cb24-32"><a aria-hidden="true" href="#cb24-32"></a>        <span class="cf">for</span> (<span class="kw">auto</span> ld : lad[i])</span>
<span id="cb24-33"><a aria-hidden="true" href="#cb24-33"></a>            <span class="cf">if</span> (row[ld.a][ld.b] &lt; INF) chkmin(row[ld.c][ld.d], row[ld.a][ld.b] - ld.h);</span>
<span id="cb24-34"><a aria-hidden="true" href="#cb24-34"></a>    }</span>
<span id="cb24-35"><a aria-hidden="true" href="#cb24-35"></a>    <span class="cf">if</span> (row[n][m] &lt; INF) print(row[n][m]);</span>
<span id="cb24-36"><a aria-hidden="true" href="#cb24-36"></a>    <span class="cf">else</span> print(<span class="st">"NO ESCAPE"</span>);</span>
<span id="cb24-37"><a aria-hidden="true" href="#cb24-37"></a>}</span>
<span id="cb24-38"><a aria-hidden="true" href="#cb24-38"></a></span>
<span id="cb24-39"><a aria-hidden="true" href="#cb24-39"></a><span class="dt">int</span> main() {</span>
<span id="cb24-40"><a aria-hidden="true" href="#cb24-40"></a>    <span class="dt">int</span> T; read(T);</span>
<span id="cb24-41"><a aria-hidden="true" href="#cb24-41"></a>    <span class="cf">while</span> (T--) solve();</span>
<span id="cb24-42"><a aria-hidden="true" href="#cb24-42"></a>    <span class="cf">return</span> output(), <span class="dv">0</span>;</span>
<span id="cb24-43"><a aria-hidden="true" href="#cb24-43"></a>}</span></code></pre></div>
<h3 id="f---not-splitting">1627F - Not Splitting</h3>
<p>给定一个 <span class="math inline">\(k\times k\)</span> 的方格（<span class="math inline">\(k\)</span> 为不超过 <span class="math inline">\(500\)</span> 的偶数），并给定 <span class="math inline">\(n\)</span>（<span class="math inline">\(1\le n\le 10^5\)</span>）对相邻点对 <span class="math inline">\((r_{i,1}, c_{i,1})\leftrightarrow (r_{i,2}, c_{i,2})\)</span>。然后将这个 <span class="math inline">\(k\times k\)</span> 方格切分为全等的两块，使得最多的约束条件能被满足（即点对中的两个点在一块上）。</p>
<p><img src="https://espresso.codeforces.com/0012ed54311c86b8968d6963561d937ba08d1737.png"/></p>
<p>然后我们会发现，这个切分的痕迹应该是关于方格中心对称的。</p>
<p>不妨将其看成一个最短路模型。将其视作一个网格图，若其有限制条件，则边权为 <span class="math inline">\(1\)</span>，否则为 <span class="math inline">\(0\)</span>。</p>
<p>之后就从 <span class="math inline">\((k/2, k/2)\)</span> 出发，以四周为终点，跑最短路即可。需要注意的的是我们认为经过了 <span class="math inline">\((x,y)\)</span> 就等同于经过了 <span class="math inline">\((k - x, k - y)\)</span>，因为要关于方格中心对称。</p>
<p>是一道非常有意思的题！</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a aria-hidden="true" href="#cb25-1"></a><span class="pp">#define mktp </span>make_tuple</span>
<span id="cb25-2"><a aria-hidden="true" href="#cb25-2"></a></span>
<span id="cb25-3"><a aria-hidden="true" href="#cb25-3"></a><span class="kw">struct</span> node {</span>
<span id="cb25-4"><a aria-hidden="true" href="#cb25-4"></a>    <span class="dt">int</span> x, y, w;</span>
<span id="cb25-5"><a aria-hidden="true" href="#cb25-5"></a>    node() {}</span>
<span id="cb25-6"><a aria-hidden="true" href="#cb25-6"></a>    node(<span class="dt">int</span> xx, <span class="dt">int</span> yy, <span class="dt">int</span> ww) : x(xx), y(yy), w(ww) {}</span>
<span id="cb25-7"><a aria-hidden="true" href="#cb25-7"></a>    il <span class="dt">bool</span> <span class="kw">operator</span>&lt;(node rhs) <span class="at">const</span> {</span>
<span id="cb25-8"><a aria-hidden="true" href="#cb25-8"></a>        <span class="cf">return</span> w &gt; rhs.w;</span>
<span id="cb25-9"><a aria-hidden="true" href="#cb25-9"></a>    }</span>
<span id="cb25-10"><a aria-hidden="true" href="#cb25-10"></a>};</span>
<span id="cb25-11"><a aria-hidden="true" href="#cb25-11"></a></span>
<span id="cb25-12"><a aria-hidden="true" href="#cb25-12"></a>map&lt;tuple&lt;<span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>&gt;, <span class="dt">int</span>&gt; mp;</span>
<span id="cb25-13"><a aria-hidden="true" href="#cb25-13"></a></span>
<span id="cb25-14"><a aria-hidden="true" href="#cb25-14"></a><span class="at">const</span> <span class="dt">int</span> fx[] = {<span class="dv">1</span>, -<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>};</span>
<span id="cb25-15"><a aria-hidden="true" href="#cb25-15"></a><span class="at">const</span> <span class="dt">int</span> fy[] = {<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, -<span class="dv">1</span>};</span>
<span id="cb25-16"><a aria-hidden="true" href="#cb25-16"></a><span class="dt">bool</span> vis[<span class="dv">510</span>][<span class="dv">510</span>];</span>
<span id="cb25-17"><a aria-hidden="true" href="#cb25-17"></a></span>
<span id="cb25-18"><a aria-hidden="true" href="#cb25-18"></a><span class="dt">int</span> main() {</span>
<span id="cb25-19"><a aria-hidden="true" href="#cb25-19"></a>    <span class="dt">int</span> T; read(T);</span>
<span id="cb25-20"><a aria-hidden="true" href="#cb25-20"></a>    <span class="cf">while</span> (T--) {</span>
<span id="cb25-21"><a aria-hidden="true" href="#cb25-21"></a>        <span class="dt">int</span> n, k; read(n, k);</span>
<span id="cb25-22"><a aria-hidden="true" href="#cb25-22"></a>        map&lt;tuple&lt;<span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>&gt;, <span class="dt">int</span>&gt;().swap(mp);</span>
<span id="cb25-23"><a aria-hidden="true" href="#cb25-23"></a>        FOR(i, <span class="dv">0</span>, k) FOR(j, <span class="dv">0</span>, k) vis[i][j] = <span class="dv">0</span>;</span>
<span id="cb25-24"><a aria-hidden="true" href="#cb25-24"></a>        FOR(i, <span class="dv">1</span>, n) {</span>
<span id="cb25-25"><a aria-hidden="true" href="#cb25-25"></a>            <span class="dt">int</span> r1, c1, r2, c2; read(r1, c1, r2, c2);</span>
<span id="cb25-26"><a aria-hidden="true" href="#cb25-26"></a>            <span class="cf">if</span> (r1 &gt; r2) myswap(r1, r2);</span>
<span id="cb25-27"><a aria-hidden="true" href="#cb25-27"></a>            <span class="cf">if</span> (c1 &gt; c2) myswap(c1, c2);</span>
<span id="cb25-28"><a aria-hidden="true" href="#cb25-28"></a>            <span class="cf">if</span> (r1 == r2) mp[mktp(r1 - <span class="dv">1</span>, c1, r1, c1)]++, mp[mktp(r1, c1, r1 - <span class="dv">1</span>, c1)]++;</span>
<span id="cb25-29"><a aria-hidden="true" href="#cb25-29"></a>            <span class="cf">if</span> (c1 == c2) mp[mktp(r1, c1 - <span class="dv">1</span>, r1, c1)]++, mp[mktp(r1, c1, r1, c1 - <span class="dv">1</span>)]++;</span>
<span id="cb25-30"><a aria-hidden="true" href="#cb25-30"></a>        }</span>
<span id="cb25-31"><a aria-hidden="true" href="#cb25-31"></a>        priority_queue&lt;node&gt; q;</span>
<span id="cb25-32"><a aria-hidden="true" href="#cb25-32"></a>        q.push(node(k &gt;&gt; <span class="dv">1</span>, k &gt;&gt; <span class="dv">1</span>, <span class="dv">0</span>));</span>
<span id="cb25-33"><a aria-hidden="true" href="#cb25-33"></a>        <span class="cf">while</span> (!q.empty()) {</span>
<span id="cb25-34"><a aria-hidden="true" href="#cb25-34"></a>            <span class="kw">auto</span> now = q.top(); q.pop();</span>
<span id="cb25-35"><a aria-hidden="true" href="#cb25-35"></a>            <span class="cf">if</span> (vis[now.x][now.y]) <span class="cf">continue</span>;</span>
<span id="cb25-36"><a aria-hidden="true" href="#cb25-36"></a>            vis[now.x][now.y] = vis[k - now.x][k - now.y] = <span class="dv">1</span>;</span>
<span id="cb25-37"><a aria-hidden="true" href="#cb25-37"></a>            <span class="cf">if</span> (!now.x || now.x == k || !now.y || now.y == k) {</span>
<span id="cb25-38"><a aria-hidden="true" href="#cb25-38"></a>                print(n - now.w);</span>
<span id="cb25-39"><a aria-hidden="true" href="#cb25-39"></a>                <span class="cf">break</span>;</span>
<span id="cb25-40"><a aria-hidden="true" href="#cb25-40"></a>            }</span>
<span id="cb25-41"><a aria-hidden="true" href="#cb25-41"></a>            FOR(d, <span class="dv">0</span>, <span class="dv">3</span>) {</span>
<span id="cb25-42"><a aria-hidden="true" href="#cb25-42"></a>                <span class="dt">int</span> tx = now.x + fx[d], ty = now.y + fy[d];</span>
<span id="cb25-43"><a aria-hidden="true" href="#cb25-43"></a>                <span class="cf">if</span> (tx &lt; <span class="dv">0</span> || tx &gt; k || ty &lt; <span class="dv">0</span> || ty &gt; k) <span class="cf">continue</span>;</span>
<span id="cb25-44"><a aria-hidden="true" href="#cb25-44"></a>                <span class="cf">if</span> (vis[tx][ty]) <span class="cf">continue</span>;</span>
<span id="cb25-45"><a aria-hidden="true" href="#cb25-45"></a>                q.push(node(tx, ty, now.w + mp[mktp(now.x, now.y, tx, ty)] + mp[mktp(k - now.x, k - now.y, k - tx, k - ty)]));</span>
<span id="cb25-46"><a aria-hidden="true" href="#cb25-46"></a>            }</span>
<span id="cb25-47"><a aria-hidden="true" href="#cb25-47"></a>        }</span>
<span id="cb25-48"><a aria-hidden="true" href="#cb25-48"></a>    }</span>
<span id="cb25-49"><a aria-hidden="true" href="#cb25-49"></a>    <span class="cf">return</span> output(), <span class="dv">0</span>;</span>
<span id="cb25-50"><a aria-hidden="true" href="#cb25-50"></a>}</span></code></pre></div>
<h2 id="educational-codeforces-round-121-rated-for-div.-2">Educational Codeforces Round 121 (Rated for Div. 2)</h2>
<p>VP on 22/07/15，A + B + C + D。</p>
<h3 id="f---a-random-code-problem">1626F - A Random Code Problem</h3>
<p>给定整数 <span class="math inline">\(k\)</span> 和数组 <span class="math inline">\(a\)</span>，执行下面的代码：</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb26-1"><a aria-hidden="true" href="#cb26-1"></a><span class="dt">long</span> <span class="dt">long</span> ans = <span class="dv">0</span>;</span>
<span id="cb26-2"><a aria-hidden="true" href="#cb26-2"></a><span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= k; ++i) {</span>
<span id="cb26-3"><a aria-hidden="true" href="#cb26-3"></a>    <span class="dt">int</span> idx = rnd.next(<span class="dv">0</span>, n - <span class="dv">1</span>);</span>
<span id="cb26-4"><a aria-hidden="true" href="#cb26-4"></a>    ans += a[idx];</span>
<span id="cb26-5"><a aria-hidden="true" href="#cb26-5"></a>    a[idx] -= (a[idx] % i);</span>
<span id="cb26-6"><a aria-hidden="true" href="#cb26-6"></a>}</span></code></pre></div>
<p>求 <code>ans</code> 的期望。<span class="math inline">\(a\)</span> 满足递推关系 <span class="math inline">\(a_i = (xa_{i-1} + y)\bmod M\)</span>，输出期望乘上 <span class="math inline">\(n^k\)</span> 后对 <span class="math inline">\(998244353\)</span> 取模的结果。<span class="math inline">\(1\le n\le 10^7; 1\le k\le 17\)</span>。</p>
<p>乘上 <span class="math inline">\(n^k\)</span> 本质上要我们求的就是每个下标序列 <span class="math inline">\(b_i\)</span> 产生的贡献之和。</p>
<p>不妨先不考虑难以处理的 <code>a[idx] -= (a[idx] % i);</code> 这句，只考虑随机下标产生的贡献，发现即为 <span class="math inline">\(\sum\limits_{i=1}^k\sum\limits_{j=0}^{n-1}a_jn^{i-1}n^{k-i} = n^{k-1}k\sum a_i\)</span>，而每个位置似乎又是可以独立考虑的。</p>
<p>并且，设 <span class="math inline">\(L = \operatorname{lcm}(1,2,\cdots, k)\)</span>，会发现 <span class="math inline">\(a_i\)</span> 最多就减到 <span class="math inline">\(\lfloor a_i/L\rfloor L\)</span>，不妨设 <span class="math inline">\(a_i = x\times L + y\)</span>，则 <span class="math inline">\(xL\)</span> 是一定会被统计入答案的，所以根据上面的想法，答案总要加上 <span class="math inline">\(n^{k-1}kL\sum\lfloor a_i/L\rfloor\)</span>。接下来就处理 <span class="math inline">\(y = a_i\bmod L\)</span> 的贡献。</p>
<p>考虑 dp：设 <span class="math inline">\(f_{i,j}\)</span> 为选了 <span class="math inline">\(i\)</span> 次，<span class="math inline">\(j\)</span> 的出现次数，此时两维的大小分别是 <span class="math inline">\(k\)</span> 和 <span class="math inline">\(L\)</span>，是足够的：</p>
<ul>
<li><span class="math inline">\(f_{i+1,j}\leftarrow f_{i+1, j} + (n-1)f_{i,j}\)</span>，对应的是这次不选 <span class="math inline">\(j\)</span>。</li>
<li><span class="math inline">\(f_{i+1, j - j\bmod i}\leftarrow f_{i+1, j - j \bmod i} + f_{i,j}\)</span>，对应的是选了 <span class="math inline">\(j\)</span>。</li>
</ul>
<p>同时，考虑 <span class="math inline">\(f_{i,j}\)</span> 产生的贡献，不难发现是 <span class="math inline">\(n^{k-i}\times f_{i,j}\times j\)</span>，所以对应累加一下即可。初始条件是 <span class="math inline">\(f_{1, j}\)</span> 为 <span class="math inline">\(j\)</span> 的出现次数。</p>
<h2 id="codeforces-round-767-div.-1-and-div.-2">Codeforces Round #767 (Div. 1 and Div. 2)</h2>
<p>能补的补完了。</p>
<h3 id="c---xor-сетка">1628C - XOR-сетка</h3>
<p>一个很明显的转化就是每个格子内的数都要贡献奇数次，然后考虑构造。</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb27-1"><a aria-hidden="true" href="#cb27-1"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="dv">1005</span>;</span>
<span id="cb27-2"><a aria-hidden="true" href="#cb27-2"></a><span class="dt">int</span> n, vis[maxn][maxn], a[maxn][maxn];</span>
<span id="cb27-3"><a aria-hidden="true" href="#cb27-3"></a></span>
<span id="cb27-4"><a aria-hidden="true" href="#cb27-4"></a><span class="at">const</span> <span class="dt">int</span> fx[] = {<span class="dv">1</span>, -<span class="dv">1</span>, <span class="dv">0</span> ,<span class="dv">0</span>};</span>
<span id="cb27-5"><a aria-hidden="true" href="#cb27-5"></a><span class="at">const</span> <span class="dt">int</span> fy[] = {<span class="dv">0</span> ,<span class="dv">0</span>, -<span class="dv">1</span>, <span class="dv">1</span>};</span>
<span id="cb27-6"><a aria-hidden="true" href="#cb27-6"></a></span>
<span id="cb27-7"><a aria-hidden="true" href="#cb27-7"></a><span class="dt">int</span> main() {</span>
<span id="cb27-8"><a aria-hidden="true" href="#cb27-8"></a>    <span class="dt">int</span> T; read(T);</span>
<span id="cb27-9"><a aria-hidden="true" href="#cb27-9"></a>    <span class="cf">while</span> (T--) {</span>
<span id="cb27-10"><a aria-hidden="true" href="#cb27-10"></a>        read(n);</span>
<span id="cb27-11"><a aria-hidden="true" href="#cb27-11"></a>        <span class="dt">int</span> ans = <span class="dv">0</span>;</span>
<span id="cb27-12"><a aria-hidden="true" href="#cb27-12"></a>        FOR(i, <span class="dv">1</span>, n) FOR(j, <span class="dv">1</span>, n) read(a[i][j]), vis[i][j] = <span class="dv">0</span>;</span>
<span id="cb27-13"><a aria-hidden="true" href="#cb27-13"></a>        FOR(i, <span class="dv">2</span>, n) FOR(j, <span class="dv">1</span>, n) {</span>
<span id="cb27-14"><a aria-hidden="true" href="#cb27-14"></a>            <span class="cf">if</span> (!vis[i - <span class="dv">1</span>][j]) {</span>
<span id="cb27-15"><a aria-hidden="true" href="#cb27-15"></a>                ans ^= a[i][j];</span>
<span id="cb27-16"><a aria-hidden="true" href="#cb27-16"></a>                <span class="cf">for</span> (<span class="dt">int</span> k = <span class="dv">0</span>; k &lt; <span class="dv">4</span>; ++k) {</span>
<span id="cb27-17"><a aria-hidden="true" href="#cb27-17"></a>                    <span class="dt">int</span> tx = i + fx[k], ty = j + fy[k];</span>
<span id="cb27-18"><a aria-hidden="true" href="#cb27-18"></a>                    <span class="cf">if</span> (tx &lt; <span class="dv">1</span> || ty &lt; <span class="dv">1</span> || tx &gt; n || ty &gt; n) <span class="cf">continue</span>;</span>
<span id="cb27-19"><a aria-hidden="true" href="#cb27-19"></a>                    vis[tx][ty] ^= <span class="dv">1</span>;</span>
<span id="cb27-20"><a aria-hidden="true" href="#cb27-20"></a>                }</span>
<span id="cb27-21"><a aria-hidden="true" href="#cb27-21"></a>            }</span>
<span id="cb27-22"><a aria-hidden="true" href="#cb27-22"></a>        }</span>
<span id="cb27-23"><a aria-hidden="true" href="#cb27-23"></a>        print(ans);</span>
<span id="cb27-24"><a aria-hidden="true" href="#cb27-24"></a>    }</span>
<span id="cb27-25"><a aria-hidden="true" href="#cb27-25"></a>    <span class="cf">return</span> output(), <span class="dv">0</span>;</span>
<span id="cb27-26"><a aria-hidden="true" href="#cb27-26"></a>}</span></code></pre></div>
<p>上面这个构造的方法就是从第二行开始遍历每个点 <span class="math inline">\((i, j)\)</span>，如果遇到 <span class="math inline">\((i - 1, j)\)</span> 只被覆盖了偶数次，则我们贪心的直接选上 <span class="math inline">\((i, j)\)</span> 让其被覆盖奇数次。可以发现后面的过程中 <span class="math inline">\((i - 1, j)\)</span> 不会再被访问。于是这个构造方法的正确性被成功说明。</p>
<h3 id="d1---game-on-sum-easy-version">1628D1 - Game on Sum (Easy Version)</h3>
<p>Alice 和 Bob 在玩一个游戏，<span class="math inline">\(n\)</span> 轮，他们轮流对 <span class="math inline">\(x\)</span> 操作，已知 <span class="math inline">\(x\)</span> 初始为 <span class="math inline">\(0\)</span>。每个回合：</p>
<ul>
<li>Alice 先选择一个实数 <span class="math inline">\(t\in[0, k]\)</span>。</li>
<li>Bob 选择让 <span class="math inline">\(x\)</span> 变为 <span class="math inline">\(x+t\)</span> 或 <span class="math inline">\(x-t\)</span>，但是至少要有 <span class="math inline">\(m\)</span> 个回合选择 <span class="math inline">\(x + t\)</span>。</li>
</ul>
<p>Alice 想最大化 <span class="math inline">\(x\)</span>，Bob 想最小化 <span class="math inline">\(x\)</span>。双方绝顶聪明，问最终的 <span class="math inline">\(x\)</span> 对 <span class="math inline">\(10^9 + 7\)</span> 取模的结果。<span class="math inline">\(1\le m\le n\le 2000\)</span>，<span class="math inline">\(1\le k\le 10^9 + 7\)</span>。</p>
<p>显然 Bob 会选恰好 <span class="math inline">\(m\)</span> 次增加操作。设 <span class="math inline">\(f_{n, m}\)</span> 表示 <span class="math inline">\(n\)</span> 轮游戏中 Bob 选了 <span class="math inline">\(m\)</span> 次增加操作后最终的 <span class="math inline">\(x\)</span>。</p>
<p>假设 Alice 当前选了 <span class="math inline">\(t\)</span>，则 Bob 要选使得分数最小的一种方案，即 <span class="math inline">\(f_{n, m}= \min\{f_{n - 1, m} - t, f_{n - 1, m - 1} + t\}\)</span>。而 Alice 为了使得 <span class="math inline">\(f_{n, m}\)</span> 最大化，故其会选择一个最优的 <span class="math inline">\(t\)</span>。这里发现 <span class="math inline">\(f_{n - 1, m} - t = f_{n - 1, m - 1} + t\)</span> 时会最优，故 <span class="math inline">\(t = \dfrac{f_{n - 1, m} - f_{n - 1, m - 1}}{2}\)</span>。所以转移方程如下： <span class="math display">\[
f_{n, m} = \frac{f_{n - 1, m} + f_{n - 1, m - 1}}{2}
\]</span> 边界条件是 <span class="math inline">\(f_{n, n} = nk\)</span>，<span class="math inline">\(f_{n, 0} = 0\)</span>。直接 DP 即可，复杂度 <span class="math inline">\(O(nm)\)</span>。</p>
<h3 id="d2---game-on-sum-hard-version">1628D2 - Game on Sum (Hard Version)</h3>
<p>将上面的条件改为 <span class="math inline">\(1\le m\le n\le 10^6\)</span>，剩余不变。</p>
<p>上面那个东西给了我们什么启示呢？可以单独考虑每个 <span class="math inline">\(f_{i, i}\)</span> 产生的贡献！这个 <span class="math inline">\(ik\)</span> 一看就是一层层往下面像杨辉三角一样扩散。随便推一下式子就可以得到 <span class="math display">\[
f_{n,m} = \sum_{i = 1}^m\frac{ki}{2^{n - i}}\binom{n - i - 1}{m - i}
\]</span> <span class="math inline">\(O(n)\)</span> 解决了。需要特判一下 <span class="math inline">\(n = m\)</span> 的情况，需要直接输出 <span class="math inline">\(nk\)</span>，代码就不放了。</p>
<h2 id="codeforces-round-768-div.-1-and-div.-2">Codeforces Round #768 (Div. 1 and Div. 2)</h2>
<p>打得好像有点差的离谱。</p>
<h3 id="b---range-and-partition">1630B - Range and Partition</h3>
<p>给定长度为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(\{a_i\}\)</span> 和正整数 <span class="math inline">\(k\)</span>，要求找到一个长度最短的区间 <span class="math inline">\([x, y]\)</span> 使得能将 <span class="math inline">\(\{a_i\}\)</span> 恰好分为 <span class="math inline">\(k\)</span> 段，使得每一段中 <span class="math inline">\(\in[x,y]\)</span> 的元素数量严格大于 <span class="math inline">\(\notin [x,y]\)</span> 的元素数量。<span class="math inline">\(1&lt;k\le n\le 2\times 10^5\)</span>，<span class="math inline">\(1\le a_i\le n\)</span>。</p>
<p>我们先考虑如何判断一个区间 <span class="math inline">\([x, y]\)</span> 是否合法。不妨设 <span class="math inline">\(b_i = \begin{cases}1&amp;a_i\in[x,y]\\-1&amp;a_i\notin[x,y\end{cases}\)</span>，然后求出 <span class="math inline">\(S = \sum_{i = 1}^n b_i\)</span>，当 <span class="math inline">\(S \ge k\)</span> 时合法。为什么呢？因为划分出的每一段内，<span class="math inline">\(b_i\)</span> 的和都至少为 <span class="math inline">\(1\)</span>，所以总体的 <span class="math inline">\(S\ge k\)</span> 时就是合法的。</p>
<p>这个区间我们就可以通过二分或者双指针求出来，然后随便构造一下分段方式就有了。</p>
<h3 id="c---paint-the-middle">1630C - Paint the Middle</h3>
<p>给定长度为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(a_i\)</span>，一开始 <span class="math inline">\(c_i = 0\)</span>。可以进行如下操作：</p>
<ul>
<li>选择 <span class="math inline">\(1\le i &lt; j &lt; k\le n\)</span>，满足 <span class="math inline">\(c_i = c_j = c_k = 0\land a_i = a_k\)</span>，然后 <span class="math inline">\(c_j:=1\)</span>。</li>
</ul>
<p>问若干次操作之后最大的 <span class="math inline">\(\sum_{i = 1}^nc_i\)</span>。<span class="math inline">\(3\le n\le 2\times 10^5\)</span>。</p>
<p>该做法来自<a href="https://codeforces.com/blog/entry/99384?#comment-881614">评论区</a>。DP，设 <span class="math inline">\(f_i\)</span> 为区间 <span class="math inline">\([1, i]\)</span> 的答案，显然 <span class="math inline">\(f_1 = 0\)</span>。有如下 <span class="math inline">\(3\)</span> 种转移到 <span class="math inline">\(f_i\)</span> 的办法：</p>
<ul>
<li><span class="math inline">\(a_i\)</span> 在 <span class="math inline">\(a_j\)</span> 出现过（<span class="math inline">\(j &lt; i\)</span>），考虑将 <span class="math inline">\((j, i)\)</span> 全部涂色，则 <span class="math inline">\(f_i = f_j + (i - j - 1)\)</span>。</li>
<li><span class="math inline">\(a_i\)</span> 在 <span class="math inline">\(a_k\)</span> 出现过（<span class="math inline">\(k &lt; j &lt; i\)</span>），考虑取 <span class="math inline">\(f_j\)</span> 的最优解但是留下 <span class="math inline">\(c_k\)</span> 不涂，然后再涂上 <span class="math inline">\([j, i)\)</span>，同样有 <span class="math inline">\(f_i = f_j + i - j - 1\)</span>。</li>
<li>直接继承 <span class="math inline">\(f_{i - 1}\)</span>，写规范一点就是 <span class="math inline">\(f_i = f_{i - 1} + (i - (i - 1) - 1)\)</span>。</li>
</ul>
<p>于是若我们令 <span class="math inline">\(\mathrm {first}(a_i)\)</span> 表示 <span class="math inline">\(a_i\)</span> 第一次出现时的下标，则转移方程就有了： <span class="math display">\[
f_i = \max_{\mathrm{first}(a_i)\le j &lt; i}\{f_{j} - j \} + i - 1
\]</span> 此时这个做法是 <span class="math inline">\(O(n^2)\)</span> 的，需要优化。改写转移方程： <span class="math display">\[
f_i - i = \max_{\mathrm{first}(a_i)\le j &lt; i\lor j = i - 1}\{f_{j} - j \} - 1
\]</span> 不难发现这可以拿一个维护 <span class="math inline">\(f_i - i\)</span> 的最大值的线段树来优化，于是 <span class="math inline">\(O(n\log n)\)</span>。代码太弱智不放了。</p>
<h2 id="codeforces-round-769-div.-2">Codeforces Round #769 (Div. 2)</h2>
<p>打的很差。</p>
<h3 id="d---new-year-concert">1632D - New Year Concert</h3>
<p>给定一个长度为 <span class="math inline">\(n\)</span> 的正整数组 <span class="math inline">\(a\)</span>。对于一个长度为 <span class="math inline">\(k\)</span> 的正整数组 <span class="math inline">\(b\)</span>，定义 <span class="math inline">\(f(b_1,b_2,\cdots,b_k)\)</span> 为使得对于所有的 <span class="math inline">\(1\leq l\le r\le k\)</span>，都有 <span class="math inline">\(\gcd\{b_l,b_{l+1},\dots,b_r\}\neq r-l+1\)</span> 的最少操作次数，其中一次操作可以将数组中的一个数改为任意正整数。现在，请求出 <span class="math inline">\(f(a_1),f(a_1,a_2),\cdots,f(a_1,a_2,\cdots,a_n)\)</span> 的值。<span class="math inline">\(1\le n\le 2\times 10^5\)</span>，<span class="math inline">\(1\le a_i\le 10^9\)</span>。</p>
<p>我们一个个来处理。设 <span class="math inline">\(f_i\)</span> 为 <span class="math inline">\([1, i]\)</span> 的答案，若不存在 <span class="math inline">\(l\)</span> 使得 <span class="math inline">\(\gcd\{a_l, \cdots, a_i\} = i - l + 1\)</span>，则 <span class="math inline">\(f_i = f_{i - 1}\)</span>，否则 <span class="math inline">\(f_i = f_{i - 1} + 1\)</span>，并且需要修改 <span class="math inline">\(a_l\)</span> 为一大质数。</p>
<p>考虑查找 <span class="math inline">\(l\)</span>，根据后缀 <span class="math inline">\(\gcd\)</span> 的单调不增性，且不同后缀 <span class="math inline">\(\gcd\)</span> 只有 <span class="math inline">\(O(\log)\)</span> 种，所以可以二分。这里使用 ST 表来查询区间 <span class="math inline">\(\gcd\)</span>。</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb28-1"><a aria-hidden="true" href="#cb28-1"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">2e5</span> + <span class="dv">5</span>;</span>
<span id="cb28-2"><a aria-hidden="true" href="#cb28-2"></a><span class="dt">int</span> n, a[maxn], f[maxn], st[<span class="dv">21</span>][maxn], lg[maxn];</span>
<span id="cb28-3"><a aria-hidden="true" href="#cb28-3"></a></span>
<span id="cb28-4"><a aria-hidden="true" href="#cb28-4"></a><span class="dt">int</span> gcd(<span class="dt">int</span> a, <span class="dt">int</span> b) {<span class="cf">return</span> b ? gcd(b, a % b) : a;}</span>
<span id="cb28-5"><a aria-hidden="true" href="#cb28-5"></a></span>
<span id="cb28-6"><a aria-hidden="true" href="#cb28-6"></a>il <span class="dt">int</span> query(<span class="dt">int</span> l, <span class="dt">int</span> r) {</span>
<span id="cb28-7"><a aria-hidden="true" href="#cb28-7"></a>    <span class="dt">int</span> len = lg[r - l + <span class="dv">1</span>];</span>
<span id="cb28-8"><a aria-hidden="true" href="#cb28-8"></a>    <span class="cf">return</span> gcd(st[len][l], st[len][r - (<span class="dv">1</span> &lt;&lt; len) + <span class="dv">1</span>]);</span>
<span id="cb28-9"><a aria-hidden="true" href="#cb28-9"></a>}</span>
<span id="cb28-10"><a aria-hidden="true" href="#cb28-10"></a></span>
<span id="cb28-11"><a aria-hidden="true" href="#cb28-11"></a><span class="dt">int</span> main() {</span>
<span id="cb28-12"><a aria-hidden="true" href="#cb28-12"></a>    read(n);</span>
<span id="cb28-13"><a aria-hidden="true" href="#cb28-13"></a>    FOR(i, <span class="dv">1</span>, n) read(a[i]), lg[i] = i &gt; <span class="dv">1</span> ? lg[i &gt;&gt; <span class="dv">1</span>] + <span class="dv">1</span> : <span class="dv">0</span>, st[<span class="dv">0</span>][i] = a[i];</span>
<span id="cb28-14"><a aria-hidden="true" href="#cb28-14"></a>    FOR(j, <span class="dv">1</span>, lg[n]) FOR(i, <span class="dv">1</span>, n + <span class="dv">1</span> - (<span class="dv">1</span> &lt;&lt; j)) st[j][i] = gcd(st[j - <span class="dv">1</span>][i], st[j - <span class="dv">1</span>][i + (<span class="dv">1</span> &lt;&lt; (j - <span class="dv">1</span>))]);</span>
<span id="cb28-15"><a aria-hidden="true" href="#cb28-15"></a>    FOR(i, <span class="dv">1</span>, n) {</span>
<span id="cb28-16"><a aria-hidden="true" href="#cb28-16"></a>        f[i] = f[i - <span class="dv">1</span>];</span>
<span id="cb28-17"><a aria-hidden="true" href="#cb28-17"></a>        <span class="cf">for</span> (<span class="dt">int</span> j = i; j &gt; <span class="dv">0</span>; ) {</span>
<span id="cb28-18"><a aria-hidden="true" href="#cb28-18"></a>            <span class="dt">int</span> g = query(j, i), now = j;</span>
<span id="cb28-19"><a aria-hidden="true" href="#cb28-19"></a>            DEC(k, lg[n], <span class="dv">0</span>) <span class="cf">if</span> (j &gt; (<span class="dv">1</span> &lt;&lt; k) &amp;&amp; query(j - (<span class="dv">1</span> &lt;&lt; k), i) == g)</span>
<span id="cb28-20"><a aria-hidden="true" href="#cb28-20"></a>                j -= (<span class="dv">1</span> &lt;&lt; k);</span>
<span id="cb28-21"><a aria-hidden="true" href="#cb28-21"></a>            <span class="cf">if</span> (g &lt;= i - j + <span class="dv">1</span> &amp;&amp; g &gt;= i - now + <span class="dv">1</span>) {</span>
<span id="cb28-22"><a aria-hidden="true" href="#cb28-22"></a>                f[i] = f[i - g] + <span class="dv">1</span>;</span>
<span id="cb28-23"><a aria-hidden="true" href="#cb28-23"></a>                <span class="cf">break</span>;</span>
<span id="cb28-24"><a aria-hidden="true" href="#cb28-24"></a>            }</span>
<span id="cb28-25"><a aria-hidden="true" href="#cb28-25"></a>            --j;</span>
<span id="cb28-26"><a aria-hidden="true" href="#cb28-26"></a>        }</span>
<span id="cb28-27"><a aria-hidden="true" href="#cb28-27"></a>        print(f[i], <span class="ch">' '</span>);</span>
<span id="cb28-28"><a aria-hidden="true" href="#cb28-28"></a>    }</span>
<span id="cb28-29"><a aria-hidden="true" href="#cb28-29"></a>    <span class="cf">return</span> output(), <span class="dv">0</span>;</span>
<span id="cb28-30"><a aria-hidden="true" href="#cb28-30"></a>}</span></code></pre></div>
<h3 id="e---distance-tree">1632E - Distance Tree</h3>
<p><span class="math inline">\(n\)</span> 个节点的树，每条边权为 <span class="math inline">\(1\)</span>，定义：</p>
<ul>
<li><span class="math inline">\(d(v)\)</span> 为节点 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(v\)</span> 的距离。</li>
<li><span class="math inline">\(f(x)\)</span> 为在任意两点 <span class="math inline">\(a, b\)</span> 间添加一条权为 <span class="math inline">\(x\)</span> 的边后，<span class="math inline">\(\max_{1\le v\le n}\{d(v)\}\)</span> 的最小值。</li>
</ul>
<p>对于 <span class="math inline">\(\forall x\in[1, n]\)</span>，求出 <span class="math inline">\(f(x)\)</span>。<del>Easy ver. <span class="math inline">\(2\le n,\sum n\le 3000\)</span>​</del>。Hard ver. <span class="math inline">\(2\le n,\sum n\le 3\times 10^5\)</span>。</p>
<p>通过简单观察可以发现加的这条边的一个端点一定是 <span class="math inline">\(1\)</span> 号点，可以反证。接下来钦定 <span class="math inline">\(1\)</span> 为根。</p>
<p>之后会发现正着做似乎有点难搞。不妨思考一下如果给定了一个距离 <span class="math inline">\(y\)</span> 然后反推边权 <span class="math inline">\(x\)</span> 的范围，首先发现连边一定连深度大于 <span class="math inline">\(y\)</span> 的边。</p>
<p>然后，设这些点构成的点集为 <span class="math inline">\(K(y)\)</span>，则考虑从 <span class="math inline">\(1\)</span> 连哪个 <span class="math inline">\(v\)</span> 能够使得最大的距离尽量小。发现连 <span class="math inline">\(K(y)\)</span> 的直径中点是最优的，因为需要满足 <span class="math inline">\(x + \operatorname{dis}(v, u)\le y\)</span>。而 <span class="math inline">\(\operatorname{dis}(v, u)\)</span> 的最大值在当 <span class="math inline">\(v\)</span> 为直径中点时取到最小，为 <span class="math inline">\(\lceil \mathrm{diameter} / 2 \rceil\)</span>，不妨设其为 <span class="math inline">\(f(y)\)</span>，然后我们可以通过一个 <span class="math inline">\(O(n)\)</span> 的树形 dp 来求出所有的 <span class="math inline">\(f(y)\)</span>，然后由于 <span class="math inline">\(f(y)\)</span> 随 <span class="math inline">\(y\)</span> 的增大而单调不增，所以可以双指针 <span class="math inline">\(O(n)\)</span> 求出答案。</p>
<p>DP 的流程如下：对于每个节点，找到两个深度最大的儿子（即长链），设两个链底的深度分别为 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span>，其中 <span class="math inline">\(a\ge b\)</span>，则 <span class="math inline">\(f(b - 1)\)</span> 就可以用 <span class="math inline">\(a + b - 2d_u\)</span> 来更新了，代码中写的不太一样。然后再对所有的 <span class="math inline">\(f\)</span> 来一个后缀最大值就可以了。</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb29-1"><a aria-hidden="true" href="#cb29-1"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">3e5</span> + <span class="dv">5</span>;</span>
<span id="cb29-2"><a aria-hidden="true" href="#cb29-2"></a>vector&lt;<span class="dt">int</span>&gt; G[maxn];</span>
<span id="cb29-3"><a aria-hidden="true" href="#cb29-3"></a><span class="dt">int</span> n, f[maxn];</span>
<span id="cb29-4"><a aria-hidden="true" href="#cb29-4"></a></span>
<span id="cb29-5"><a aria-hidden="true" href="#cb29-5"></a><span class="dt">int</span> dfs(<span class="dt">int</span> u, <span class="dt">int</span> fa, <span class="dt">int</span> d) {</span>
<span id="cb29-6"><a aria-hidden="true" href="#cb29-6"></a>    <span class="dt">int</span> a = <span class="dv">0</span>, b = <span class="dv">0</span>;</span>
<span id="cb29-7"><a aria-hidden="true" href="#cb29-7"></a>    <span class="cf">for</span> (<span class="kw">auto</span> v : G[u]) {</span>
<span id="cb29-8"><a aria-hidden="true" href="#cb29-8"></a>        <span class="cf">if</span> (v == fa) <span class="cf">continue</span>;</span>
<span id="cb29-9"><a aria-hidden="true" href="#cb29-9"></a>        <span class="dt">int</span> c = dfs(v, u, d + <span class="dv">1</span>) + <span class="dv">1</span>;</span>
<span id="cb29-10"><a aria-hidden="true" href="#cb29-10"></a>        <span class="cf">if</span> (c &gt; a) b = a, a = c;</span>
<span id="cb29-11"><a aria-hidden="true" href="#cb29-11"></a>        <span class="cf">else</span> chkmax(b, c);</span>
<span id="cb29-12"><a aria-hidden="true" href="#cb29-12"></a>    }</span>
<span id="cb29-13"><a aria-hidden="true" href="#cb29-13"></a>    <span class="cf">if</span> (b + d) chkmax(f[b + d - <span class="dv">1</span>], (a + b + <span class="dv">1</span>) &gt;&gt; <span class="dv">1</span>);</span>
<span id="cb29-14"><a aria-hidden="true" href="#cb29-14"></a>    <span class="cf">return</span> a;</span>
<span id="cb29-15"><a aria-hidden="true" href="#cb29-15"></a>}</span>
<span id="cb29-16"><a aria-hidden="true" href="#cb29-16"></a></span>
<span id="cb29-17"><a aria-hidden="true" href="#cb29-17"></a><span class="dt">int</span> main() {</span>
<span id="cb29-18"><a aria-hidden="true" href="#cb29-18"></a>    <span class="dt">int</span> T; read(T);</span>
<span id="cb29-19"><a aria-hidden="true" href="#cb29-19"></a>    <span class="cf">while</span> (T--) {</span>
<span id="cb29-20"><a aria-hidden="true" href="#cb29-20"></a>        read(n);</span>
<span id="cb29-21"><a aria-hidden="true" href="#cb29-21"></a>        FOR(i, <span class="dv">1</span>, n) vector&lt;<span class="dt">int</span>&gt;().swap(G[i]), f[i] = <span class="dv">0</span>;</span>
<span id="cb29-22"><a aria-hidden="true" href="#cb29-22"></a>        FOR(i, <span class="dv">1</span>, n - <span class="dv">1</span>) {</span>
<span id="cb29-23"><a aria-hidden="true" href="#cb29-23"></a>            <span class="dt">int</span> u, v; read(u, v);</span>
<span id="cb29-24"><a aria-hidden="true" href="#cb29-24"></a>            G[u].push_back(v), G[v].push_back(u);</span>
<span id="cb29-25"><a aria-hidden="true" href="#cb29-25"></a>        }</span>
<span id="cb29-26"><a aria-hidden="true" href="#cb29-26"></a>        <span class="dt">int</span> lim = dfs(<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>);</span>
<span id="cb29-27"><a aria-hidden="true" href="#cb29-27"></a>        DEC(i, n - <span class="dv">2</span>, <span class="dv">0</span>) chkmax(f[i], f[i + <span class="dv">1</span>]);</span>
<span id="cb29-28"><a aria-hidden="true" href="#cb29-28"></a>        <span class="dt">int</span> ans = <span class="dv">1</span>;</span>
<span id="cb29-29"><a aria-hidden="true" href="#cb29-29"></a>        FOR(i, <span class="dv">1</span>, n) {</span>
<span id="cb29-30"><a aria-hidden="true" href="#cb29-30"></a>            <span class="cf">while</span> (i + f[ans] &gt; ans) ++ans;</span>
<span id="cb29-31"><a aria-hidden="true" href="#cb29-31"></a>            print(min(ans, lim), <span class="st">" </span><span class="sc">\n</span><span class="st">"</span>[i == n]);</span>
<span id="cb29-32"><a aria-hidden="true" href="#cb29-32"></a>        }</span>
<span id="cb29-33"><a aria-hidden="true" href="#cb29-33"></a>    }</span>
<span id="cb29-34"><a aria-hidden="true" href="#cb29-34"></a>    <span class="cf">return</span> output(), <span class="dv">0</span>;</span>
<span id="cb29-35"><a aria-hidden="true" href="#cb29-35"></a>}</span></code></pre></div>
<h2 id="educational-codeforces-round-122-rated-for-div.-2">Educational Codeforces Round 122 (Rated for Div. 2)</h2>
<p>VP on 22/07/15。</p>
<h3 id="e---spanning-tree-queries">1633E - Spanning Tree Queries</h3>
<p>VP 时想到正解了，但是没写出来。说几个细节：</p>
<ul>
<li>分界点为 <span class="math inline">\(\dfrac{w_i+w_j}{2}\)</span>，避免小数点出问题，考虑直接 <span class="math inline">\(w_i\leftarrow 2w_i\)</span>。</li>
<li>为了保证选的尽可能多减函数防止出锅，Kruskal 给边排序的时候第二关键字是原边权降序。</li>
<li>最后使用 <code>upper_bound</code> 查找对应的分界点。</li>
<li>同时 <span class="math inline">\(w_i\)</span> 作为转折点本身也要加进去，所有分界点要去重。</li>
</ul>
<h3 id="f---perfect-matching">1633F - Perfect Matching</h3>
<p>题意：交互题，初始根为 <span class="math inline">\(1\)</span>，动态添加叶子，问有无完美匹配，不超过 <span class="math inline">\(10\)</span> 次要求构造。</p>
<p>首先树不变的话，匹配一定是从叶子开始匹配的，然后隔一条选一条。那么维护 <span class="math inline">\(f_u\)</span> 表示 <span class="math inline">\(u\)</span> 连接其父亲的边有没有被选，使用树剖 + 线段树维护，搞一个取反 + 区间和即可，最后看下边的数量是不是点数 <span class="math inline">\(/2\)</span>。</p>
<p>而这个题动态添加叶子，所以直接做就行了。</p>
<h2 id="codeforces-global-round-19">Codeforces Global Round 19</h2>
<h3 id="d---yet-another-minimization-problem">1637D - Yet Another Minimization Problem</h3>
<p>值域很小，拆分贡献之后发现可以定义 <span class="math inline">\(f_{i, s_1}\)</span>，然后就可以 <span class="math inline">\(O(n^3)\)</span> dp 了。</p>
<h3 id="e---best-pair">1637E - Best Pair</h3>
<p>首先这题有一个非常关键的性质就是，<strong>不同的 <span class="math inline">\(cnt_i\)</span> 只有 <span class="math inline">\(O(\sqrt n)\)</span> 种</strong>。</p>
<p>因此我们枚举 <span class="math inline">\(cnt_x\)</span> 和 <span class="math inline">\(cnt_y\le cnt_x\)</span>，这样子复杂度就是 <span class="math inline">\(O(n)\)</span> 的，从大到小找到第一个不和 <span class="math inline">\(a_i\)</span> 形成 bad pair 的 <span class="math inline">\(j\)</span>（可以用 <code>set</code> 维护，<span class="math inline">\(O(\log n)\)</span>），这样的复杂度是 <span class="math inline">\(O(n\log n)\)</span> 的。</p>
<h3 id="f---towers">1637F - Towers</h3>
<p>给定 <span class="math inline">\(n\)</span> 个节点的树，第 <span class="math inline">\(i\)</span> 个点的高度为 <span class="math inline">\(h_i\)</span>。可以在 <span class="math inline">\(n\)</span> 个点上建任意多个塔，对于每个塔可以指定其能量 <span class="math inline">\(e\)</span> 和其所在点的编号。建立能量为 <span class="math inline">\(e\)</span> 的塔消耗 <span class="math inline">\(e\)</span> 枚金币。</p>
<p>一个点 <span class="math inline">\(x\)</span> 接收到信号当且仅当存在信号塔在点 <span class="math inline">\(u\)</span> 和点 <span class="math inline">\(v\)</span>（允许 <span class="math inline">\(x = u\)</span> 或 <span class="math inline">\(x = v\)</span>，但是 <span class="math inline">\(u\ne v\)</span>），满足 <span class="math inline">\(\min(e_u, e_v)\ge h_x\)</span> 且 <span class="math inline">\(x\)</span> 在链 <span class="math inline">\((u, v)\)</span> 上。</p>
<p>求一个让所有点接收到信号的最小代价。<span class="math inline">\(2\le n\le 10^5\)</span>，<span class="math inline">\(1\le h_i\le 10^9\)</span>。</p>
<p>比较牛逼的贪心。经过观察可知只有叶子节点放信号塔是最优的，否则一定可以调整到只放叶子节点。</p>
<p>然后，不妨令 <span class="math inline">\(h\)</span> 值最大的为根，那么我们就可以选择两个叶子 <span class="math inline">\(x, y\)</span> 放上 <span class="math inline">\(h_{\max}\)</span> 的塔，然后 <span class="math inline">\(x, y\)</span> 链上所有的点都会被覆盖掉。于是，剩下的所有点都只需要有某个子树的信号塔大于等于 <span class="math inline">\(h_u\)</span> 即可。</p>
<p>考虑贪心，令 <span class="math inline">\(f_u\)</span> 为 <span class="math inline">\(u\)</span> 子树内 <span class="math inline">\(h\)</span> 的最大值，然后对于叶子节点，答案加上 <span class="math inline">\(h_u\)</span>，对于非叶子节点，若其不是根，答案加上 <span class="math inline">\(\max(0, h_u - \max_{v\in son(u)} f_v)\)</span>，若其是根，答案加上 <span class="math inline">\(2h_u\)</span> 减去子树内最大的两个 <span class="math inline">\(h\)</span> 值。<span class="math inline">\(O(n)\)</span>，很优秀。</p>
<h2 id="codeforces-round-771-div.-2">Codeforces Round #771 (Div. 2)</h2>
<h3 id="d---big-brush">1638D - Big Brush</h3>
<p>给定一个染了色的网格，要求构造方案从空白染成这样。</p>
<p>一次可以涂一个 <span class="math inline">\(2\times 2\)</span>，可以覆盖，<span class="math inline">\(n,m\le 1000\)</span>。</p>
<p>考虑时光倒流，别人涂色我们刮刮乐。我们可以从若干个 <span class="math inline">\(2\times 2\)</span> 为起点来进行操作，没有 <span class="math inline">\(2\times 2\)</span> 就说明无解。然后就 bfs 即可。</p>
<h3 id="e---colorful-operations">1638E - Colorful Operations</h3>
<p>给定一个长度为 <span class="math inline">\(n\)</span> 的序列，初始时所有元素的值为 <span class="math inline">\(0\)</span> ，颜色为 <span class="math inline">\(1\)</span>。你需要实现以下三种操作：</p>
<ul>
<li><code>Color l r c</code> ：把 <span class="math inline">\([l,r]\)</span> 这段的元素颜色改为 <span class="math inline">\(c\)</span>；</li>
<li><code>Add c x</code>：把所有颜色为 <span class="math inline">\(c\)</span> 的元素值都加上 <span class="math inline">\(x\)</span>；</li>
<li><code>Query i</code>：输出元素 <span class="math inline">\(i\)</span> 的值。</li>
</ul>
<p><span class="math inline">\(n,q\le 10^6\)</span>。</p>
<p>颜色段均摊傻逼题，技不如人甘拜下风。</p>
<p>考虑对于修改同种颜色的操作，对其维护一个全局加标记。并用一个线段树维护一下所有的元素的值，输出的时候就输出单点修改 + tag 值。</p>
<p>然后，修改颜色的操作就硬递归，找到一段相同颜色的段之后加上原来的 tag 再减去新的 tag。由于一次染色操作最多添加一次连续段，所以一次操作均摊复杂度为 <span class="math inline">\(O(\log n)\)</span>。</p>
<p>总 <span class="math inline">\(O((n + q)\log n)\)</span>，随便维护一下就行了。</p>
<h2 id="codeforces-round-772-div.-2">Codeforces Round #772 (Div. 2)</h2>
<p>打出了有史以来最高的 perf，A + B + C + D + E。</p>
<h3 id="f---closest-pair">1635F - Closest Pair</h3>
<p><span class="math inline">\(n\)</span> 个二元组 <span class="math inline">\((x_i, w_i)\)</span>，<span class="math inline">\(|x_i|,w_i\le 10^9\)</span>，<span class="math inline">\(n\le 3\times 10^5\)</span>，<span class="math inline">\(x_i\)</span> 升序。<span class="math inline">\(q\le 3\times 10^5\)</span> 次询问，给出 <span class="math inline">\([l,r]\)</span>，求 <span class="math display">\[
\min_{l\le i&lt;j\le r}|x_i - x_j|(w_i + w_j)
\]</span> 一眼数据结构题，静态询问考虑离线。</p>
<p>考虑哪些 <span class="math inline">\((i,j)\)</span> 是不优的。</p>
<ul>
<li>若存在 <span class="math inline">\(p\)</span> 和 <span class="math inline">\(q\)</span>，使得 <span class="math inline">\(x_p &lt; x_q\land w_p &gt; w_q\)</span>，则 <span class="math inline">\(q\)</span> 作为 <span class="math inline">\(i\)</span> 一定比 <span class="math inline">\(p\)</span> 优。</li>
<li>若存在 <span class="math inline">\(p\)</span> 和 <span class="math inline">\(q\)</span>，使得 <span class="math inline">\(x_p &lt; x_q\land w_p&lt;w_q\)</span>，则 <span class="math inline">\(p\)</span> 作为 <span class="math inline">\(j\)</span> 一定比 <span class="math inline">\(q\)</span> 优。</li>
</ul>
<p>于是，令 <span class="math inline">\(L_i = \max\{j:j&lt;i\land w_j\le w_i\}\)</span>，<span class="math inline">\(R_i = \min\{j:j&gt;i\land w_j\le w_i\}\)</span>，答案就只能取形如 <span class="math inline">\([i, R_i]\)</span> 或 <span class="math inline">\([L_i, i]\)</span> 的区间。这样的区间一共有 <span class="math inline">\(2n\)</span> 个。</p>
<p>先用单调栈求出所有的 <span class="math inline">\(L_i\)</span> 和 <span class="math inline">\(R_i\)</span>，再计算出这 <span class="math inline">\(2n\)</span> 个区间 <span class="math inline">\([l_i, r_i]\)</span> 的价值 <span class="math inline">\(c_i\)</span>，在每个 <span class="math inline">\(r_i\)</span> 上挂上标记 <span class="math inline">\((l_i, c_i)\)</span>，在每个询问 <span class="math inline">\((i, ql, qr)\)</span> 的 <span class="math inline">\(qr\)</span> 上挂上标记 <span class="math inline">\((ql, i)\)</span>。然后扫描线扫右端点，线段树或者树状数组维护一下 RMQ 和单点修改，这题就做完了。</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb30-1"><a aria-hidden="true" href="#cb30-1"></a><span class="kw">using</span> ll = <span class="dt">long</span> <span class="dt">long</span>;</span>
<span id="cb30-2"><a aria-hidden="true" href="#cb30-2"></a><span class="kw">using</span> pll = pair&lt;ll, ll&gt;;</span>
<span id="cb30-3"><a aria-hidden="true" href="#cb30-3"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">3e5</span> + <span class="dv">5</span>;</span>
<span id="cb30-4"><a aria-hidden="true" href="#cb30-4"></a><span class="dt">int</span> n, m, L[maxn], R[maxn], stk[maxn], top;</span>
<span id="cb30-5"><a aria-hidden="true" href="#cb30-5"></a>ll t[maxn &lt;&lt; <span class="dv">2</span>], ans[maxn];</span>
<span id="cb30-6"><a aria-hidden="true" href="#cb30-6"></a>pll a[maxn];</span>
<span id="cb30-7"><a aria-hidden="true" href="#cb30-7"></a>vector&lt;pll&gt; op[maxn], q[maxn];</span>
<span id="cb30-8"><a aria-hidden="true" href="#cb30-8"></a></span>
<span id="cb30-9"><a aria-hidden="true" href="#cb30-9"></a>il ll calc(<span class="dt">int</span> i, <span class="dt">int</span> j) {<span class="cf">return</span> myabs(a[i].first - a[j].first) * (a[i].second + a[j].second);}</span>
<span id="cb30-10"><a aria-hidden="true" href="#cb30-10"></a></span>
<span id="cb30-11"><a aria-hidden="true" href="#cb30-11"></a><span class="pp">#define L </span>(k<span class="pp"> </span>&lt;&lt;<span class="pp"> </span><span class="dv">1</span>)</span>
<span id="cb30-12"><a aria-hidden="true" href="#cb30-12"></a><span class="pp">#define R </span>(L<span class="pp"> </span>|<span class="pp"> </span><span class="dv">1</span>)</span>
<span id="cb30-13"><a aria-hidden="true" href="#cb30-13"></a><span class="pp">#define M </span>((i<span class="pp"> </span>+<span class="pp"> </span>j)<span class="pp"> </span>&gt;&gt;<span class="pp"> </span><span class="dv">1</span>)</span>
<span id="cb30-14"><a aria-hidden="true" href="#cb30-14"></a></span>
<span id="cb30-15"><a aria-hidden="true" href="#cb30-15"></a><span class="dt">void</span> modify(<span class="dt">int</span> i, <span class="dt">int</span> j, <span class="dt">int</span> k, <span class="dt">int</span> x, ll v) {</span>
<span id="cb30-16"><a aria-hidden="true" href="#cb30-16"></a>    <span class="cf">if</span> (i == j) {</span>
<span id="cb30-17"><a aria-hidden="true" href="#cb30-17"></a>        chkmin(t[k], v);</span>
<span id="cb30-18"><a aria-hidden="true" href="#cb30-18"></a>        <span class="cf">return</span>;</span>
<span id="cb30-19"><a aria-hidden="true" href="#cb30-19"></a>    }</span>
<span id="cb30-20"><a aria-hidden="true" href="#cb30-20"></a>    <span class="cf">if</span> (x &lt;= M) modify(i, M, L, x, v);</span>
<span id="cb30-21"><a aria-hidden="true" href="#cb30-21"></a>    <span class="cf">else</span> modify(M + <span class="dv">1</span>, j, R, x, v);</span>
<span id="cb30-22"><a aria-hidden="true" href="#cb30-22"></a>    t[k] = min(t[L], t[R]);</span>
<span id="cb30-23"><a aria-hidden="true" href="#cb30-23"></a>    <span class="cf">return</span>;</span>
<span id="cb30-24"><a aria-hidden="true" href="#cb30-24"></a>}</span>
<span id="cb30-25"><a aria-hidden="true" href="#cb30-25"></a></span>
<span id="cb30-26"><a aria-hidden="true" href="#cb30-26"></a>ll query(<span class="dt">int</span> i, <span class="dt">int</span> j, <span class="dt">int</span> k, <span class="dt">int</span> x, <span class="dt">int</span> y) {</span>
<span id="cb30-27"><a aria-hidden="true" href="#cb30-27"></a>    <span class="cf">if</span> (x &lt;= i &amp;&amp; y &gt;= j) <span class="cf">return</span> t[k];</span>
<span id="cb30-28"><a aria-hidden="true" href="#cb30-28"></a>    ll ret = <span class="fl">2e18</span>;</span>
<span id="cb30-29"><a aria-hidden="true" href="#cb30-29"></a>    <span class="cf">if</span> (x &lt;= M) chkmin(ret, query(i, M, L, x, y));</span>
<span id="cb30-30"><a aria-hidden="true" href="#cb30-30"></a>    <span class="cf">if</span> (y &gt; M) chkmin(ret, query(M + <span class="dv">1</span>, j, R, x, y));</span>
<span id="cb30-31"><a aria-hidden="true" href="#cb30-31"></a>    <span class="cf">return</span> ret;</span>
<span id="cb30-32"><a aria-hidden="true" href="#cb30-32"></a>}</span>
<span id="cb30-33"><a aria-hidden="true" href="#cb30-33"></a></span>
<span id="cb30-34"><a aria-hidden="true" href="#cb30-34"></a><span class="pp">#undef L</span></span>
<span id="cb30-35"><a aria-hidden="true" href="#cb30-35"></a><span class="pp">#undef R</span></span>
<span id="cb30-36"><a aria-hidden="true" href="#cb30-36"></a><span class="pp">#undef M</span></span>
<span id="cb30-37"><a aria-hidden="true" href="#cb30-37"></a></span>
<span id="cb30-38"><a aria-hidden="true" href="#cb30-38"></a><span class="dt">int</span> main() {</span>
<span id="cb30-39"><a aria-hidden="true" href="#cb30-39"></a>    read(n, m);</span>
<span id="cb30-40"><a aria-hidden="true" href="#cb30-40"></a>    FOR(i, <span class="dv">1</span>, n) read(a[i].first, a[i].second);</span>
<span id="cb30-41"><a aria-hidden="true" href="#cb30-41"></a>    FOR(i, <span class="dv">1</span>, m) {</span>
<span id="cb30-42"><a aria-hidden="true" href="#cb30-42"></a>        <span class="dt">int</span> l, r; read(l, r);</span>
<span id="cb30-43"><a aria-hidden="true" href="#cb30-43"></a>        q[r].push_back({l, i});</span>
<span id="cb30-44"><a aria-hidden="true" href="#cb30-44"></a>    }</span>
<span id="cb30-45"><a aria-hidden="true" href="#cb30-45"></a>    FOR(i, <span class="dv">1</span>, n) {</span>
<span id="cb30-46"><a aria-hidden="true" href="#cb30-46"></a>        <span class="cf">while</span> (top &gt; <span class="dv">0</span> &amp;&amp; a[stk[top]].second &gt; a[i].second) --top;</span>
<span id="cb30-47"><a aria-hidden="true" href="#cb30-47"></a>        L[i] = stk[top], stk[++top] = i;</span>
<span id="cb30-48"><a aria-hidden="true" href="#cb30-48"></a>    }</span>
<span id="cb30-49"><a aria-hidden="true" href="#cb30-49"></a>    top = <span class="dv">0</span>;</span>
<span id="cb30-50"><a aria-hidden="true" href="#cb30-50"></a>    DEC(i, n, <span class="dv">1</span>) {</span>
<span id="cb30-51"><a aria-hidden="true" href="#cb30-51"></a>        <span class="cf">while</span> (top &gt; <span class="dv">0</span> &amp;&amp; a[stk[top]].second &gt; a[i].second) --top;</span>
<span id="cb30-52"><a aria-hidden="true" href="#cb30-52"></a>        R[i] = stk[top], stk[++top] = i;</span>
<span id="cb30-53"><a aria-hidden="true" href="#cb30-53"></a>    }</span>
<span id="cb30-54"><a aria-hidden="true" href="#cb30-54"></a>    FOR(i, <span class="dv">1</span>, n) {</span>
<span id="cb30-55"><a aria-hidden="true" href="#cb30-55"></a>        <span class="cf">if</span> (L[i]) op[i].push_back({L[i], calc(L[i], i)});</span>
<span id="cb30-56"><a aria-hidden="true" href="#cb30-56"></a>        <span class="cf">if</span> (R[i]) op[R[i]].push_back({i, calc(i, R[i])});</span>
<span id="cb30-57"><a aria-hidden="true" href="#cb30-57"></a>    }</span>
<span id="cb30-58"><a aria-hidden="true" href="#cb30-58"></a></span>
<span id="cb30-59"><a aria-hidden="true" href="#cb30-59"></a>    memset(t, <span class="bn">0x3f</span>, <span class="kw">sizeof</span> t);</span>
<span id="cb30-60"><a aria-hidden="true" href="#cb30-60"></a>    FOR(i, <span class="dv">1</span>, n) {</span>
<span id="cb30-61"><a aria-hidden="true" href="#cb30-61"></a>        <span class="cf">for</span> (<span class="kw">auto</span> &amp;p : op[i]) modify(<span class="dv">1</span>, n, <span class="dv">1</span>, p.first, p.second);</span>
<span id="cb30-62"><a aria-hidden="true" href="#cb30-62"></a>        <span class="cf">for</span> (<span class="kw">auto</span> &amp;p : q[i]) ans[p.second] = query(<span class="dv">1</span>, n, <span class="dv">1</span>, p.first, i);</span>
<span id="cb30-63"><a aria-hidden="true" href="#cb30-63"></a>    }</span>
<span id="cb30-64"><a aria-hidden="true" href="#cb30-64"></a>    FOR(i, <span class="dv">1</span>, m) print(ans[i]);</span>
<span id="cb30-65"><a aria-hidden="true" href="#cb30-65"></a>    <span class="cf">return</span> output(), <span class="dv">0</span>;</span>
<span id="cb30-66"><a aria-hidden="true" href="#cb30-66"></a>}</span></code></pre></div>
<h2 id="educational-codeforces-round-123-rated-for-div.-2">Educational Codeforces Round 123 (Rated for Div. 2)</h2>
<p>下小分场。</p>
<h2 id="codeforces-round-773-div.-1">Codeforces Round #773 (Div. 1)</h2>
<h3 id="b---repetitions-decoding">1641B - Repetitions Decoding</h3>
<p>其实这题出的很不错来着，但是毒瘤是真的毒瘤。</p>
<p>给定长度为 <span class="math inline">\(n\)</span>（<span class="math inline">\(1\le n\le 500\)</span>）的正整数序列 <span class="math inline">\(a\)</span>，可以进行形如 <span class="math inline">\((x, c)\)</span> 的操作：在 <span class="math inline">\(a_x\)</span> 后面插入<strong>两个连续的</strong>正整数 <span class="math inline">\(c\)</span>（<span class="math inline">\(x\in[0, \text{the length of }a]\)</span>）。构造操作方案使得 <span class="math inline">\(a\)</span> 最后可以拆分为若干个连续的子段，这些子段满足：长度为 <span class="math inline">\(2k\)</span>，<span class="math inline">\(k\)</span> 为任意正整数，且 <span class="math inline">\(\forall i\in [1, k]\)</span> 有 <span class="math inline">\(a_i = a_{i + k}\)</span>。</p>
<p>保证 <span class="math inline">\(\sum n^2\le 2.5\times 10^5\)</span>，操作次数需 <span class="math inline">\(\le 2n^2\)</span>，若无解则报告之。</p>
<p>首先，注意到每种数字的出现次数必须为偶数次，因为添加数字一定是给某种数字添加两个，若存在出现了奇数次的数字则无论如何都没办法找到与之配对的数，所以无解。</p>
<p>然后可以注意到，我们可以对一个前缀做翻转操作，具体地，看下面的例子：</p>
<pre class="plain"><code>1 2 3 1 3 2
1 2 3 - 1 2 3 3 2 1 - 1 3 2 // 这一步可以通过 3 次操作实现
(1 2 3 | 1 2 3) - 3 2 1 1 3 2 // 即我们构造一个回文串，然后将前面的合并到一段，前缀就成功被翻转了。</code></pre>
<p>而通过这样，我们就可以将两个 <span class="math inline">\(1\)</span> 放在一起，再反转一下：</p>
<pre class="plain"><code>(1 2 3 | 1 2 3) - (3 2 1 1 | 3 2 1 1) - 1 1 2 3 - 3 2</code></pre>
<p>然后两个 <span class="math inline">\(1\)</span> 就顺理成章的在一起了，可以放在一段消掉了。</p>
<pre class="plain"><code>(1 2 3 | 1 2 3) - (3 2 1 1 | 3 2 1 1) - (1 | 1) 2 3 3 2</code></pre>
<p>接下来就解决 <code>2 3 3 2</code> 就行了，思路是一样的。</p>
<p>通过这样的操作，我们就能在 <span class="math inline">\(O(n^2)\)</span> 的操作次数下，将两个数“两两合并”，解决这道题目。</p>
<p>输出方案比较毒瘤，大家写的时候需要注意细节。</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb34-1"><a aria-hidden="true" href="#cb34-1"></a><span class="kw">using</span> pii = pair&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt;;</span>
<span id="cb34-2"><a aria-hidden="true" href="#cb34-2"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="dv">505</span>;</span>
<span id="cb34-3"><a aria-hidden="true" href="#cb34-3"></a><span class="dt">int</span> n, a[maxn], alreadyLen, now;</span>
<span id="cb34-4"><a aria-hidden="true" href="#cb34-4"></a>vector&lt;pii&gt; op;</span>
<span id="cb34-5"><a aria-hidden="true" href="#cb34-5"></a>vector&lt;<span class="dt">int</span>&gt; ans;</span>
<span id="cb34-6"><a aria-hidden="true" href="#cb34-6"></a>map&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt; vis;</span>
<span id="cb34-7"><a aria-hidden="true" href="#cb34-7"></a></span>
<span id="cb34-8"><a aria-hidden="true" href="#cb34-8"></a><span class="dt">void</span> rev(<span class="dt">int</span> pos) {</span>
<span id="cb34-9"><a aria-hidden="true" href="#cb34-9"></a>    FOR(i, now + <span class="dv">1</span>, pos - <span class="dv">1</span>) op.push_back({i - now + alreadyLen + pos - <span class="dv">2</span>, a[i]});</span>
<span id="cb34-10"><a aria-hidden="true" href="#cb34-10"></a>    ans.push_back(<span class="dv">2</span> * (pos - now - <span class="dv">1</span>));</span>
<span id="cb34-11"><a aria-hidden="true" href="#cb34-11"></a>    alreadyLen += <span class="dv">2</span> * (pos - now - <span class="dv">1</span>);</span>
<span id="cb34-12"><a aria-hidden="true" href="#cb34-12"></a>    reverse(a + now + <span class="dv">1</span>, a + pos);</span>
<span id="cb34-13"><a aria-hidden="true" href="#cb34-13"></a>    <span class="cf">return</span>;</span>
<span id="cb34-14"><a aria-hidden="true" href="#cb34-14"></a>}</span>
<span id="cb34-15"><a aria-hidden="true" href="#cb34-15"></a></span>
<span id="cb34-16"><a aria-hidden="true" href="#cb34-16"></a><span class="dt">int</span> main() {</span>
<span id="cb34-17"><a aria-hidden="true" href="#cb34-17"></a>    <span class="dt">int</span> T; read(T);</span>
<span id="cb34-18"><a aria-hidden="true" href="#cb34-18"></a>    <span class="cf">while</span> (T--) {</span>
<span id="cb34-19"><a aria-hidden="true" href="#cb34-19"></a>        read(n);</span>
<span id="cb34-20"><a aria-hidden="true" href="#cb34-20"></a>        <span class="kw">decltype</span>(vis)().swap(vis);</span>
<span id="cb34-21"><a aria-hidden="true" href="#cb34-21"></a>        FOR(i, <span class="dv">1</span>, n) read(a[i]), ++vis[a[i]];</span>
<span id="cb34-22"><a aria-hidden="true" href="#cb34-22"></a>        <span class="dt">bool</span> flg = <span class="dv">1</span>;</span>
<span id="cb34-23"><a aria-hidden="true" href="#cb34-23"></a>        <span class="cf">for</span> (<span class="kw">auto</span> &amp;p : vis) <span class="cf">if</span> (p.second &amp; <span class="dv">1</span>) flg = <span class="dv">0</span>;</span>
<span id="cb34-24"><a aria-hidden="true" href="#cb34-24"></a>        <span class="cf">if</span> (!flg) {</span>
<span id="cb34-25"><a aria-hidden="true" href="#cb34-25"></a>            print(-<span class="dv">1</span>);</span>
<span id="cb34-26"><a aria-hidden="true" href="#cb34-26"></a>            <span class="cf">continue</span>;</span>
<span id="cb34-27"><a aria-hidden="true" href="#cb34-27"></a>        }</span>
<span id="cb34-28"><a aria-hidden="true" href="#cb34-28"></a>        <span class="kw">decltype</span>(op)().swap(op);</span>
<span id="cb34-29"><a aria-hidden="true" href="#cb34-29"></a>        <span class="kw">decltype</span>(ans)().swap(ans);</span>
<span id="cb34-30"><a aria-hidden="true" href="#cb34-30"></a>        alreadyLen = <span class="dv">0</span>, now = <span class="dv">0</span>;</span>
<span id="cb34-31"><a aria-hidden="true" href="#cb34-31"></a></span>
<span id="cb34-32"><a aria-hidden="true" href="#cb34-32"></a>        <span class="cf">while</span> (now &lt; n) {</span>
<span id="cb34-33"><a aria-hidden="true" href="#cb34-33"></a>            <span class="cf">if</span> (now == n - <span class="dv">2</span>) {</span>
<span id="cb34-34"><a aria-hidden="true" href="#cb34-34"></a>                ans.push_back(<span class="dv">2</span>);</span>
<span id="cb34-35"><a aria-hidden="true" href="#cb34-35"></a>                <span class="cf">break</span>;</span>
<span id="cb34-36"><a aria-hidden="true" href="#cb34-36"></a>            }</span>
<span id="cb34-37"><a aria-hidden="true" href="#cb34-37"></a>            <span class="dt">int</span> pos = <span class="dv">0</span>;</span>
<span id="cb34-38"><a aria-hidden="true" href="#cb34-38"></a>            FOR(i, now + <span class="dv">2</span>, n) <span class="cf">if</span> (a[i] == a[now + <span class="dv">1</span>]) {</span>
<span id="cb34-39"><a aria-hidden="true" href="#cb34-39"></a>                pos = i;</span>
<span id="cb34-40"><a aria-hidden="true" href="#cb34-40"></a>                <span class="cf">break</span>;</span>
<span id="cb34-41"><a aria-hidden="true" href="#cb34-41"></a>            }</span>
<span id="cb34-42"><a aria-hidden="true" href="#cb34-42"></a>            rev(pos), rev(pos + <span class="dv">1</span>);</span>
<span id="cb34-43"><a aria-hidden="true" href="#cb34-43"></a>            ans.push_back(<span class="dv">2</span>);</span>
<span id="cb34-44"><a aria-hidden="true" href="#cb34-44"></a>            now += <span class="dv">2</span>;</span>
<span id="cb34-45"><a aria-hidden="true" href="#cb34-45"></a>        }</span>
<span id="cb34-46"><a aria-hidden="true" href="#cb34-46"></a></span>
<span id="cb34-47"><a aria-hidden="true" href="#cb34-47"></a>        print(op.size());</span>
<span id="cb34-48"><a aria-hidden="true" href="#cb34-48"></a>        <span class="cf">for</span> (<span class="kw">auto</span> &amp;p : op) print(p.first, p.second);</span>
<span id="cb34-49"><a aria-hidden="true" href="#cb34-49"></a>        print(ans.size());</span>
<span id="cb34-50"><a aria-hidden="true" href="#cb34-50"></a>        <span class="cf">for</span> (<span class="kw">auto</span> x : ans) print(x, <span class="ch">' '</span>);</span>
<span id="cb34-51"><a aria-hidden="true" href="#cb34-51"></a>        putchar(<span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span>);</span>
<span id="cb34-52"><a aria-hidden="true" href="#cb34-52"></a>    }</span>
<span id="cb34-53"><a aria-hidden="true" href="#cb34-53"></a>    <span class="cf">return</span> output(), <span class="dv">0</span>;</span>
<span id="cb34-54"><a aria-hidden="true" href="#cb34-54"></a>}</span></code></pre></div>
<h2 id="codeforces-round-781-div.-2">Codeforces Round #781 (Div. 2)</h2>
<p>rnm退钱。</p>
<h3 id="c---tree-infection">1665C - Tree Infection</h3>
<p><del>读错题就一直想呗，想呗，哈哈。</del></p>
<p>直接转化成一个节点的儿子个数的问题。显然从儿子最多的挨个点传染。所以模拟一下这个过程即可。</p>
<h3 id="d---gcd-guess">1665D - GCD Guess</h3>
<p>猜 <span class="math inline">\(1\le x\le 10^9\)</span>，最多 <span class="math inline">\(30\)</span> 次询问，每次可以查询 <span class="math inline">\(\gcd(x + a, x + b)\)</span>。要求 <span class="math inline">\(a\ne b,1\le a,b\le 2\times 10^9\)</span>。</p>
<p>注意到 <span class="math inline">\(30\)</span> 次询问非常灵性，相当于明示我们要按位考虑。具体地我们可以思考 <span class="math inline">\(x\bmod 2^k\)</span> 的值。</p>
<p>首先我们知道 <span class="math inline">\(x\bmod 2^0 = 0\)</span>，考虑如何从 <span class="math inline">\(x\bmod 2^k\)</span> 推得 <span class="math inline">\(x\bmod 2^{k+1}\)</span>。其中间的差值要么是 <span class="math inline">\(0\)</span> 要么是 <span class="math inline">\(2^k\)</span>，那么不妨令 <span class="math inline">\(x \bmod 2^k = r\)</span>，则我们询问 <span class="math inline">\(\gcd(x + 2^k - r, 2^{k + 1})\)</span>，若结果为 <span class="math inline">\(2^{k + 1}\)</span> 则 <span class="math inline">\(x\bmod 2^{k + 1} = r + 2^k\)</span>。</p>
<p>具体地询问就是问 <span class="math inline">\(\gcd(x + 2^k - r, x + 2^k + 2^{k+1}-r)\)</span>，可以发现刚好问 <span class="math inline">\(30\)</span> 次。</p>
<h3 id="e---minimizor">1665E - MinimizOR</h3>
<p>静态查询区间 <span class="math inline">\([l, r]\)</span> 内 <span class="math inline">\(\min_{i\ne j,l\le i,j\le r}\{a_i\lor a_j\}\)</span>。<span class="math inline">\(n\le 10^5\)</span>，<span class="math inline">\(0\le a_i&lt; 2^{30}\)</span></p>
<p>牛逼结论题。。结论是 <span class="math inline">\(&lt; 2^k\)</span> 的数字中的答案只可能从最小的 <span class="math inline">\(k + 1\)</span> 个数字中产生。于是线段树维护一下区间内最小的 <span class="math inline">\(31\)</span> 个数即可，时间复杂度 <span class="math inline">\(O(n\log^2n)\)</span>。</p>
<p>下面用归纳法证明：</p>
<ul>
<li><p>当 <span class="math inline">\(k = 1\)</span> 时，所有数都为 <span class="math inline">\(0\)</span>，显然成立。</p></li>
<li><p>下面说明 <span class="math inline">\(k\to k + 1\)</span>：</p>
<p>若第 <span class="math inline">\(k\)</span> 位的 <span class="math inline">\(0\)</span> 的个数 <span class="math inline">\(\le 1\)</span>，则这一位最后或起来肯定是 <span class="math inline">\(1\)</span>，问题变为 <span class="math inline">\(&lt; 2^k\)</span> 的情况，<span class="math inline">\(k + 1\)</span> 个数字即可，<span class="math inline">\(k + 2\)</span> 个肯定也可以。</p>
<p>否则第 <span class="math inline">\(k\)</span> 位我们贪心地强制其为 <span class="math inline">\(0\)</span>，故答案只与第 <span class="math inline">\(k\)</span> 位为 <span class="math inline">\(0\)</span> 的数字有关。显然 <span class="math inline">\(k + 2\)</span> 个也能满足需求。</p></li>
</ul>
<p>证毕。</p>
<h2 id="educational-codeforces-round-126-rated-for-div.-2">Educational Codeforces Round 126 (Rated for Div. 2)</h2>
<h3 id="e---narrow-components">1661E - Narrow Components</h3>
<p><span class="math inline">\(3\times n\)</span> 的 0-1 矩阵，<span class="math inline">\(q\)</span> 次询问 <span class="math inline">\([l_i, r_i]\)</span> 列内的四连通块个数。<span class="math inline">\(n\le 5\times 10^5\)</span>。</p>
<p>考虑用线段树维护。在每个区间对应的节点内维护左端点/右端点对应的并查集，然后对应合并即可。</p>
<p>注意细节，合并的时候要开 12 个节点分别对应左区间/右区间的左右端点。而为了防止有连通块从左边连到右边所以考虑令其并查集编号为 <span class="math inline">\(1\sim 6\)</span>。</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb35-1"><a aria-hidden="true" href="#cb35-1"></a><span class="kw">struct</span> Node {</span>
<span id="cb35-2"><a aria-hidden="true" href="#cb35-2"></a>    <span class="dt">int</span> l[<span class="dv">4</span>], r[<span class="dv">4</span>], lc[<span class="dv">4</span>], rc[<span class="dv">4</span>], sum;</span>
<span id="cb35-3"><a aria-hidden="true" href="#cb35-3"></a>    <span class="dt">void</span> init(<span class="dt">int</span> pos) {</span>
<span id="cb35-4"><a aria-hidden="true" href="#cb35-4"></a>        FOR(i, <span class="dv">1</span>, m) lc[i] = rc[i] = a[i][pos] - <span class="ch">'0'</span>, sum += lc[i], fa[i] = i;</span>
<span id="cb35-5"><a aria-hidden="true" href="#cb35-5"></a>        FOR(i, <span class="dv">1</span>, m - <span class="dv">1</span>) <span class="cf">if</span> (lc[i] == lc[i + <span class="dv">1</span>] &amp;&amp; lc[i]) sum -= merge(i, i + <span class="dv">1</span>);</span>
<span id="cb35-6"><a aria-hidden="true" href="#cb35-6"></a>        FOR(i, <span class="dv">1</span>, m) l[i] = r[i] = find(i);</span>
<span id="cb35-7"><a aria-hidden="true" href="#cb35-7"></a>    }</span>
<span id="cb35-8"><a aria-hidden="true" href="#cb35-8"></a>} t[maxn &lt;&lt; <span class="dv">2</span>], tmp;</span>
<span id="cb35-9"><a aria-hidden="true" href="#cb35-9"></a></span>
<span id="cb35-10"><a aria-hidden="true" href="#cb35-10"></a>Node merge(<span class="at">const</span> Node &amp;l, <span class="at">const</span> Node &amp;r) {</span>
<span id="cb35-11"><a aria-hidden="true" href="#cb35-11"></a>    tmp.sum = l.sum + r.sum;</span>
<span id="cb35-12"><a aria-hidden="true" href="#cb35-12"></a>    FOR(i, <span class="dv">1</span>, m) tmp.lc[i] = l.lc[i], tmp.rc[i] = r.rc[i];</span>
<span id="cb35-13"><a aria-hidden="true" href="#cb35-13"></a>    FOR(i, <span class="dv">1</span>, m) tmp.l[i] = tmp.r[i] = <span class="dv">0</span>;</span>
<span id="cb35-14"><a aria-hidden="true" href="#cb35-14"></a></span>
<span id="cb35-15"><a aria-hidden="true" href="#cb35-15"></a>    FOR(i, <span class="dv">1</span>, m * <span class="dv">4</span>) fa[i] = i;</span>
<span id="cb35-16"><a aria-hidden="true" href="#cb35-16"></a>    FOR(i, <span class="dv">1</span>, m) {</span>
<span id="cb35-17"><a aria-hidden="true" href="#cb35-17"></a>        merge(i, l.l[i]), merge(i + m, l.r[i]);</span>
<span id="cb35-18"><a aria-hidden="true" href="#cb35-18"></a>        merge(i + <span class="dv">2</span> * m, r.l[i] + <span class="dv">2</span> * m), merge(i + <span class="dv">3</span> * m, r.r[i] + m * <span class="dv">2</span>);</span>
<span id="cb35-19"><a aria-hidden="true" href="#cb35-19"></a>    }</span>
<span id="cb35-20"><a aria-hidden="true" href="#cb35-20"></a>    FOR(i, <span class="dv">1</span>, m) <span class="cf">if</span> (l.rc[i] == r.lc[i] &amp;&amp; l.rc[i]) </span>
<span id="cb35-21"><a aria-hidden="true" href="#cb35-21"></a>        tmp.sum -= merge(i + m, i + m * <span class="dv">2</span>);</span>
<span id="cb35-22"><a aria-hidden="true" href="#cb35-22"></a>    memset(b, <span class="dv">0</span>, <span class="kw">sizeof</span> b);</span>
<span id="cb35-23"><a aria-hidden="true" href="#cb35-23"></a>    FOR(i, <span class="dv">1</span>, m) {</span>
<span id="cb35-24"><a aria-hidden="true" href="#cb35-24"></a>        <span class="cf">if</span> (!b[find(i)]) b[find(i)] = i;</span>
<span id="cb35-25"><a aria-hidden="true" href="#cb35-25"></a>        tmp.l[i] = b[find(i)];</span>
<span id="cb35-26"><a aria-hidden="true" href="#cb35-26"></a>    }</span>
<span id="cb35-27"><a aria-hidden="true" href="#cb35-27"></a>    FOR(i, m * <span class="dv">3</span> + <span class="dv">1</span>, m * <span class="dv">4</span>) {</span>
<span id="cb35-28"><a aria-hidden="true" href="#cb35-28"></a>        <span class="cf">if</span> (!b[find(i)]) b[find(i)] = i - <span class="dv">2</span> * m;</span>
<span id="cb35-29"><a aria-hidden="true" href="#cb35-29"></a>        tmp.r[i - m * <span class="dv">3</span>] = b[find(i)];</span>
<span id="cb35-30"><a aria-hidden="true" href="#cb35-30"></a>    }</span>
<span id="cb35-31"><a aria-hidden="true" href="#cb35-31"></a>    <span class="cf">return</span> tmp;</span>
<span id="cb35-32"><a aria-hidden="true" href="#cb35-32"></a>}</span></code></pre></div>
<h3 id="f---teleporters">1661F - Teleporters</h3>
<p>一条直线上有 <span class="math inline">\(n+1\)</span> 个传送机，位于点 <span class="math inline">\(0,a_1,a_2,a_3,...,a_n\)</span>。如果在 <span class="math inline">\(x\)</span> 点和 <span class="math inline">\(y\)</span> 点都有传送机，那么可以从 <span class="math inline">\(x\)</span> 点传送到 <span class="math inline">\(y\)</span> 点，能量开销为 <span class="math inline">\((x-y)^2\)</span>。现可以在整点安装额外的传送机，要求使得从 <span class="math inline">\(0\)</span> 传送到 <span class="math inline">\(a_n\)</span> 的代价 <span class="math inline">\(\le m\)</span>。问最少安装多少额外传送机。</p>
<p><span class="math inline">\(n\le 2\times 10^5\)</span>，<span class="math inline">\(1\le a_1&lt;a_2&lt;\cdots&lt;a_n\le 10^9\)</span>，<span class="math inline">\(a_n\le m\le 10^{18}\)</span>。</p>
<p>根据均值不等式，在最优策略下，我们一定是将传送机尽可能“平均”安排。所以每个 <span class="math inline">\(a\)</span> 分的段可以独立考虑。</p>
<p>令 <span class="math inline">\(f(x, k)\)</span> 表示考虑长度为 <span class="math inline">\(x\)</span> 的一段，放 <span class="math inline">\(k\)</span> 个传送机，能达到的最小代价，则我们划分出的 <span class="math inline">\(k + 1\)</span> 段的长度肯定要么是 <span class="math inline">\(\left\lfloor\dfrac{x}{k + 1}\right\rfloor\)</span>，要么是 <span class="math inline">\(\left\lceil\dfrac{x}{k + 1}\right\rceil\)</span>。前者有 <span class="math inline">\(k + 1 - x\bmod(k + 1)\)</span> 段，后者有 <span class="math inline">\(x\bmod(k + 1)\)</span> 段。所以f <span class="math display">\[
f(x, k) = (x\bmod(k + 1))\cdot\left\lceil\frac{x}{k + 1}\right\rceil^2 +(k + 1 - x\bmod(k + 1))\cdot\left\lfloor\dfrac{x}{k + 1}\right\rfloor^2
\]</span> 而如果不考虑整点限制的话，这个 <span class="math inline">\(f\)</span> 是关于 <span class="math inline">\(k\)</span> 有凸性的，即每一段每增加一个传送机，代价的减少量是不增的。</p>
<p>而根据我们的直觉，我们每次都会往能减少最多代价的一段加传送机，所以我们可以二分一个最小的减少量 <span class="math inline">\(d\)</span>，对于每一段，二分求出 <span class="math inline">\(f(x, k - 1) - f(x, k)\ge d\)</span> 的最大的 <span class="math inline">\(x\)</span>，并且在这段放 <span class="math inline">\(x\)</span> 个传送机。设这样子的总代价为 <span class="math inline">\(g(d)\)</span>，则我们可以二分出一个刚好 <span class="math inline">\(\le m\)</span> 的最大的 <span class="math inline">\(d\)</span>。</p>
<p>然而 <span class="math inline">\(d\)</span> 是不一定要全部加进去的，有可能我们可以在 <span class="math inline">\(d + 1\)</span> 的基础上放几个 <span class="math inline">\(d\)</span> 就可以使得总代价 <span class="math inline">\(\le m\)</span>。</p>
<p>所以先算出 <span class="math inline">\(g(d + 1)\)</span> 然后再放 <span class="math inline">\(\left\lceil\dfrac{g(d + 1) - m}{d}\right\rceil\)</span> 个传送机就可以了。</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb36-1"><a aria-hidden="true" href="#cb36-1"></a><span class="kw">using</span> ll = <span class="dt">long</span> <span class="dt">long</span>;</span>
<span id="cb36-2"><a aria-hidden="true" href="#cb36-2"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">2e5</span> + <span class="dv">5</span>;</span>
<span id="cb36-3"><a aria-hidden="true" href="#cb36-3"></a><span class="dt">int</span> n, a[maxn];</span>
<span id="cb36-4"><a aria-hidden="true" href="#cb36-4"></a>ll m;</span>
<span id="cb36-5"><a aria-hidden="true" href="#cb36-5"></a><span class="kw">using</span> pll = pair&lt;ll, ll&gt;;</span>
<span id="cb36-6"><a aria-hidden="true" href="#cb36-6"></a></span>
<span id="cb36-7"><a aria-hidden="true" href="#cb36-7"></a>il ll f(ll x, ll k) {</span>
<span id="cb36-8"><a aria-hidden="true" href="#cb36-8"></a>    <span class="cf">return</span> (x % (k + <span class="dv">1</span>)) * ((x + k) / (k + <span class="dv">1</span>)) * ((x + k) / (k + <span class="dv">1</span>)) + (k + <span class="dv">1</span> - (x % (k + <span class="dv">1</span>))) * (x / (k + <span class="dv">1</span>)) * (x / (k + <span class="dv">1</span>));</span>
<span id="cb36-9"><a aria-hidden="true" href="#cb36-9"></a>}</span>
<span id="cb36-10"><a aria-hidden="true" href="#cb36-10"></a></span>
<span id="cb36-11"><a aria-hidden="true" href="#cb36-11"></a>pll calc(ll x, ll d) {</span>
<span id="cb36-12"><a aria-hidden="true" href="#cb36-12"></a>    ll l = <span class="dv">1</span>, r = x - <span class="dv">1</span>, ret = <span class="dv">0</span>;</span>
<span id="cb36-13"><a aria-hidden="true" href="#cb36-13"></a>    <span class="cf">while</span> (l &lt;= r) {</span>
<span id="cb36-14"><a aria-hidden="true" href="#cb36-14"></a>        <span class="kw">auto</span> mid = (l + r) &gt;&gt; <span class="dv">1</span>;</span>
<span id="cb36-15"><a aria-hidden="true" href="#cb36-15"></a>        <span class="cf">if</span> (f(x, mid - <span class="dv">1</span>) - f(x, mid) &gt;= d)</span>
<span id="cb36-16"><a aria-hidden="true" href="#cb36-16"></a>            ret = mid, l = mid + <span class="dv">1</span>;</span>
<span id="cb36-17"><a aria-hidden="true" href="#cb36-17"></a>        <span class="cf">else</span> r = mid - <span class="dv">1</span>;</span>
<span id="cb36-18"><a aria-hidden="true" href="#cb36-18"></a>    }</span>
<span id="cb36-19"><a aria-hidden="true" href="#cb36-19"></a>    <span class="cf">return</span> {f(x, ret), ret};</span>
<span id="cb36-20"><a aria-hidden="true" href="#cb36-20"></a>}</span>
<span id="cb36-21"><a aria-hidden="true" href="#cb36-21"></a></span>
<span id="cb36-22"><a aria-hidden="true" href="#cb36-22"></a>pll check(ll mid) {</span>
<span id="cb36-23"><a aria-hidden="true" href="#cb36-23"></a>    pll res;</span>
<span id="cb36-24"><a aria-hidden="true" href="#cb36-24"></a>    FOR(i, <span class="dv">1</span>, n) {</span>
<span id="cb36-25"><a aria-hidden="true" href="#cb36-25"></a>        <span class="kw">auto</span> now = calc(a[i], mid);</span>
<span id="cb36-26"><a aria-hidden="true" href="#cb36-26"></a>        res.first += now.first, res.second += now.second;</span>
<span id="cb36-27"><a aria-hidden="true" href="#cb36-27"></a>    }</span>
<span id="cb36-28"><a aria-hidden="true" href="#cb36-28"></a>    <span class="cf">return</span> res;</span>
<span id="cb36-29"><a aria-hidden="true" href="#cb36-29"></a>}</span>
<span id="cb36-30"><a aria-hidden="true" href="#cb36-30"></a></span>
<span id="cb36-31"><a aria-hidden="true" href="#cb36-31"></a><span class="dt">int</span> main() {</span>
<span id="cb36-32"><a aria-hidden="true" href="#cb36-32"></a>    is &gt;&gt; n;</span>
<span id="cb36-33"><a aria-hidden="true" href="#cb36-33"></a>    FOR(i, <span class="dv">1</span>, n) is &gt;&gt; a[i];</span>
<span id="cb36-34"><a aria-hidden="true" href="#cb36-34"></a>    DEC(i, n, <span class="dv">1</span>) a[i] -= a[i - <span class="dv">1</span>];</span>
<span id="cb36-35"><a aria-hidden="true" href="#cb36-35"></a>    is &gt;&gt; m;</span>
<span id="cb36-36"><a aria-hidden="true" href="#cb36-36"></a>    ll l = <span class="dv">0</span>, r = <span class="fl">1e18</span>, d;</span>
<span id="cb36-37"><a aria-hidden="true" href="#cb36-37"></a>    <span class="cf">while</span> (l &lt;= r) {</span>
<span id="cb36-38"><a aria-hidden="true" href="#cb36-38"></a>        ll mid = (l + r) &gt;&gt; <span class="dv">1</span>;</span>
<span id="cb36-39"><a aria-hidden="true" href="#cb36-39"></a>        <span class="cf">if</span> (check(mid).first &lt;= m) l = mid + <span class="dv">1</span>, d = mid;</span>
<span id="cb36-40"><a aria-hidden="true" href="#cb36-40"></a>        <span class="cf">else</span> r = mid - <span class="dv">1</span>;</span>
<span id="cb36-41"><a aria-hidden="true" href="#cb36-41"></a>    }</span>
<span id="cb36-42"><a aria-hidden="true" href="#cb36-42"></a>    <span class="kw">auto</span> res = check(d + <span class="dv">1</span>);</span>
<span id="cb36-43"><a aria-hidden="true" href="#cb36-43"></a>    cout &lt;&lt; res.second + (res.first - m + d - <span class="dv">1</span>) / d;</span>
<span id="cb36-44"><a aria-hidden="true" href="#cb36-44"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb36-45"><a aria-hidden="true" href="#cb36-45"></a>}</span></code></pre></div>
<h2 id="codeforces-round-796">Codeforces Round #796</h2>
<h3 id="c---sanae-and-giant-robot">1687C - Sanae and Giant Robot</h3>
<p>给定数列 <span class="math inline">\(a,b\)</span> 和 <span class="math inline">\(m\)</span> 个区间 <span class="math inline">\([l_i, r_i]\)</span>，每次操作的时候可以选择一个区间 <span class="math inline">\([l,r]\)</span> 然后 <span class="math inline">\(\forall l\le i\le r\)</span> 执行 <span class="math inline">\(a_i\leftarrow b_i\)</span>，当且仅当 <span class="math inline">\(\displaystyle\sum_{i=l}^r a_i\)</span> 不变。问能否经过若干次操作将 <span class="math inline">\(a\)</span> 转化为 <span class="math inline">\(b\)</span>。</p>
<p>思考 <span class="math inline">\(b_i = 0\)</span> 的情况。则若我们令 <span class="math inline">\(s_i\)</span> 为 <span class="math inline">\(a_i\)</span> 的前缀和的话，我们每次就可以选择 <span class="math inline">\(s_r - s_{l - 1} = 0\)</span> 的区间 <span class="math inline">\([l, r]\)</span>，然后将 <span class="math inline">\(s_l,s_{l+1},\cdots,s_{r - 1}\)</span> 全部赋值为 <span class="math inline">\(s_r\)</span>。而最终的目标是让所有的 <span class="math inline">\(s_i = 0\)</span>。</p>
<p>那么我们就每次选择 <span class="math inline">\(s_{l-1} = s_r = 0\)</span> 的区间 <span class="math inline">\([l,r]\)</span>，然后将 <span class="math inline">\([l, r - 1]\)</span> 内的 <span class="math inline">\(s_i\)</span> 全部赋值为 <span class="math inline">\(0\)</span>。可以随便维护一下这个过程（例如使用 <code>set</code> + bfs）。</p>
<p>而对于 <span class="math inline">\(b_i\ne 0\)</span> 的情况呢？将 <span class="math inline">\(a_i \leftarrow a_i - b_i\)</span> 之后就能变成和上面一样的问题了。每个点至多被删除一次，时间复杂度 <span class="math inline">\(O((n+m)\log n)\)</span>。</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb37-1"><a aria-hidden="true" href="#cb37-1"></a><span class="pp">#include </span><span class="im">&lt;bits/stdc++.h&gt;</span></span>
<span id="cb37-2"><a aria-hidden="true" href="#cb37-2"></a><span class="pp">#include </span><span class="im">&lt;fastio.hpp&gt;</span></span>
<span id="cb37-3"><a aria-hidden="true" href="#cb37-3"></a><span class="pp">#define FOR</span>(i,<span class="pp"> </span>a,<span class="pp"> </span>b)<span class="pp"> </span><span class="cf">for</span><span class="pp"> </span>(<span class="dt">int</span><span class="pp"> </span>i<span class="pp"> </span>=<span class="pp"> </span>(a);<span class="pp"> </span>i<span class="pp"> </span>&lt;=<span class="pp"> </span>(b);<span class="pp"> </span>++i)</span>
<span id="cb37-4"><a aria-hidden="true" href="#cb37-4"></a></span>
<span id="cb37-5"><a aria-hidden="true" href="#cb37-5"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb37-6"><a aria-hidden="true" href="#cb37-6"></a><span class="kw">using</span> YangTY::fastIO::is;</span>
<span id="cb37-7"><a aria-hidden="true" href="#cb37-7"></a><span class="kw">using</span> YangTY::fastIO::os;</span>
<span id="cb37-8"><a aria-hidden="true" href="#cb37-8"></a><span class="kw">using</span> ll = <span class="dt">long</span> <span class="dt">long</span>;</span>
<span id="cb37-9"><a aria-hidden="true" href="#cb37-9"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">2e5</span> + <span class="dv">5</span>;</span>
<span id="cb37-10"><a aria-hidden="true" href="#cb37-10"></a><span class="dt">int</span> n, m, deg[maxn];</span>
<span id="cb37-11"><a aria-hidden="true" href="#cb37-11"></a>ll a[maxn], b[maxn];</span>
<span id="cb37-12"><a aria-hidden="true" href="#cb37-12"></a>vector&lt;<span class="dt">int</span>&gt; G[maxn];</span>
<span id="cb37-13"><a aria-hidden="true" href="#cb37-13"></a>pair&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt; e[maxn];</span>
<span id="cb37-14"><a aria-hidden="true" href="#cb37-14"></a></span>
<span id="cb37-15"><a aria-hidden="true" href="#cb37-15"></a><span class="dt">int</span> main() {</span>
<span id="cb37-16"><a aria-hidden="true" href="#cb37-16"></a>    <span class="dt">int</span> T; is &gt;&gt; T;</span>
<span id="cb37-17"><a aria-hidden="true" href="#cb37-17"></a>    <span class="cf">while</span> (T--) {</span>
<span id="cb37-18"><a aria-hidden="true" href="#cb37-18"></a>        is &gt;&gt; n &gt;&gt; m;</span>
<span id="cb37-19"><a aria-hidden="true" href="#cb37-19"></a>        FOR(i, <span class="dv">1</span>, n) is &gt;&gt; a[i];</span>
<span id="cb37-20"><a aria-hidden="true" href="#cb37-20"></a>        FOR(i, <span class="dv">1</span>, n) is &gt;&gt; b[i], a[i] -= b[i], a[i] += a[i - <span class="dv">1</span>];</span>
<span id="cb37-21"><a aria-hidden="true" href="#cb37-21"></a>        set&lt;<span class="dt">int</span>&gt; S;</span>
<span id="cb37-22"><a aria-hidden="true" href="#cb37-22"></a>        FOR(i, <span class="dv">0</span>, n) S.insert(i), vector&lt;<span class="dt">int</span>&gt;().swap(G[i]);</span>
<span id="cb37-23"><a aria-hidden="true" href="#cb37-23"></a>        FOR(i, <span class="dv">1</span>, m) {</span>
<span id="cb37-24"><a aria-hidden="true" href="#cb37-24"></a>            <span class="dt">int</span> &amp;l = e[i].first, &amp;r = e[i].second;</span>
<span id="cb37-25"><a aria-hidden="true" href="#cb37-25"></a>            is &gt;&gt; l &gt;&gt; r;</span>
<span id="cb37-26"><a aria-hidden="true" href="#cb37-26"></a>            G[l - <span class="dv">1</span>].push_back(i), G[r].push_back(i);</span>
<span id="cb37-27"><a aria-hidden="true" href="#cb37-27"></a>            deg[i] = <span class="dv">2</span>;</span>
<span id="cb37-28"><a aria-hidden="true" href="#cb37-28"></a>        }</span>
<span id="cb37-29"><a aria-hidden="true" href="#cb37-29"></a>        queue&lt;<span class="dt">int</span>&gt; q;</span>
<span id="cb37-30"><a aria-hidden="true" href="#cb37-30"></a>        FOR(i, <span class="dv">0</span>, n) <span class="cf">if</span> (!a[i]) q.push(i), S.erase(i);</span>
<span id="cb37-31"><a aria-hidden="true" href="#cb37-31"></a>        <span class="cf">while</span> (!q.empty()) {</span>
<span id="cb37-32"><a aria-hidden="true" href="#cb37-32"></a>            <span class="dt">int</span> x = q.front(); q.pop();</span>
<span id="cb37-33"><a aria-hidden="true" href="#cb37-33"></a>            <span class="cf">for</span> (<span class="dt">int</span> id : G[x]) <span class="cf">if</span> (!--deg[id]) {</span>
<span id="cb37-34"><a aria-hidden="true" href="#cb37-34"></a>                <span class="dt">int</span> l = e[id].first, r = e[id].second;</span>
<span id="cb37-35"><a aria-hidden="true" href="#cb37-35"></a>                <span class="kw">auto</span> lt = S.lower_bound(l), rt = S.upper_bound(r);</span>
<span id="cb37-36"><a aria-hidden="true" href="#cb37-36"></a>                <span class="cf">for</span> (<span class="kw">auto</span> it = lt; it != rt; ++it) q.push(*it);</span>
<span id="cb37-37"><a aria-hidden="true" href="#cb37-37"></a>                S.erase(lt, rt);</span>
<span id="cb37-38"><a aria-hidden="true" href="#cb37-38"></a>            }</span>
<span id="cb37-39"><a aria-hidden="true" href="#cb37-39"></a>        }</span>
<span id="cb37-40"><a aria-hidden="true" href="#cb37-40"></a>        os &lt;&lt; (S.empty() ? <span class="st">"YES"</span> : <span class="st">"NO"</span>) &lt;&lt; <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span>;</span>
<span id="cb37-41"><a aria-hidden="true" href="#cb37-41"></a>    }</span>
<span id="cb37-42"><a aria-hidden="true" href="#cb37-42"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb37-43"><a aria-hidden="true" href="#cb37-43"></a>}</span></code></pre></div>
<h3 id="d---cute-number">1687D - Cute number</h3>
<p>定义 <span class="math inline">\(f(x)\)</span> 为严格大于 <span class="math inline">\(x\)</span> 的最小完全平方数，<span class="math inline">\(g(x)\)</span> 为小于等于 <span class="math inline">\(x\)</span> 的最大完全平方数。定义一个正整数 <span class="math inline">\(x\)</span> 是可爱的，当且仅当 <span class="math inline">\(x - g(x) &lt; f(x) - x\)</span>。给定一个长度为 <span class="math inline">\(n\)</span> 的正整数序列 <span class="math inline">\(a\)</span>，求一个最小的非负整数 <span class="math inline">\(k\)</span> 满足 <span class="math inline">\(\forall 1\le i\le n\)</span> 满足 <span class="math inline">\(a_i + k\)</span> 为可爱的。</p>
<p><span class="math inline">\(n\le 10^6\)</span>，<span class="math inline">\(1\le a_i\le 2\times 10^6\)</span>。</p>
<p>首先大力观察，根据 <span class="math inline">\((x^2)' = 2x\)</span> 得到可爱的数一定在 <span class="math inline">\([k^2, k^2 + k]\)</span> 内，成一段一段的分布，第 <span class="math inline">\(i\)</span> 段可爱的数的长度为 <span class="math inline">\(i + 1\)</span>，第 <span class="math inline">\(i\)</span> 段不可爱的数长度为 <span class="math inline">\(i\)</span>。不妨令 <span class="math inline">\([k^2, k^2 + k]\)</span> 为第 <span class="math inline">\(k\)</span> 段。</p>
<p>首先，若 <span class="math inline">\(a_1 + k\)</span> 在第 <span class="math inline">\(a_n\)</span> 段的段头的话，一定是可以的。所以枚举所有 <span class="math inline">\(&lt; a_n\)</span> 的段判断是否可以就行了。</p>
<p>若 <span class="math inline">\(a_1 + k\)</span> 在第 <span class="math inline">\(i\)</span> 段，则 <span class="math inline">\(k\)</span> 一共会有 <span class="math inline">\(i + 1\)</span> 个可取的值，而当 <span class="math inline">\(k\)</span> 逐渐变化的时候，某个 <span class="math inline">\(a_i + k\)</span> 可能会从可爱变到不可爱，也有可能从不可爱变得可爱。也即：我们要把所有不可爱的数变得可爱，也不能把任何可爱的数变得不可爱。不难发现这实际上给 <span class="math inline">\(k\)</span> 卡了一个上下界。</p>
<p>如何计算？初始时令 <span class="math inline">\(a_1 + k\)</span> 为第 <span class="math inline">\(i\)</span> 段段首，即 <span class="math inline">\(k=i^2 - a_1\)</span>，考虑对于每个不可爱的段，找到里面最小的 <span class="math inline">\(a\)</span>，这限制了 <span class="math inline">\(k\)</span> 的下界；对每个可爱的段找到最大的 <span class="math inline">\(a\)</span>，这限制了 <span class="math inline">\(k\)</span> 的上界。由于每段长度都 <span class="math inline">\(\ge i\)</span>，所以一共只会枚举 <span class="math inline">\(\dfrac{a_n}{i}\)</span> 段。所以总时间复杂度调和 <span class="math inline">\(a_n\log a_n\)</span>。</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb38-1"><a aria-hidden="true" href="#cb38-1"></a><span class="pp">#define int </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb38-2"><a aria-hidden="true" href="#cb38-2"></a></span>
<span id="cb38-3"><a aria-hidden="true" href="#cb38-3"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">4e6</span> + <span class="dv">6</span>, N = <span class="fl">4e6</span>;</span>
<span id="cb38-4"><a aria-hidden="true" href="#cb38-4"></a><span class="dt">int</span> n, a[maxn], vis[maxn], pre[maxn], suf[maxn];</span>
<span id="cb38-5"><a aria-hidden="true" href="#cb38-5"></a></span>
<span id="cb38-6"><a aria-hidden="true" href="#cb38-6"></a><span class="dt">signed</span> main() {</span>
<span id="cb38-7"><a aria-hidden="true" href="#cb38-7"></a>    cin &gt;&gt; n;</span>
<span id="cb38-8"><a aria-hidden="true" href="#cb38-8"></a>    FOR(i, <span class="dv">1</span>, n) cin &gt;&gt; a[i], vis[a[i] - a[<span class="dv">1</span>]] = <span class="dv">1</span>;</span>
<span id="cb38-9"><a aria-hidden="true" href="#cb38-9"></a>    pre[<span class="dv">0</span>] = -<span class="dv">1</span>, suf[N] = N;</span>
<span id="cb38-10"><a aria-hidden="true" href="#cb38-10"></a>    FOR(i, <span class="dv">1</span>, N) <span class="cf">if</span> (vis[i]) pre[i] = i; <span class="cf">else</span> pre[i] = pre[i - <span class="dv">1</span>];</span>
<span id="cb38-11"><a aria-hidden="true" href="#cb38-11"></a>    DEC(i, N - <span class="dv">1</span>, <span class="dv">1</span>) <span class="cf">if</span> (vis[i]) suf[i] = i; <span class="cf">else</span> suf[i] = suf[i + <span class="dv">1</span>];</span>
<span id="cb38-12"><a aria-hidden="true" href="#cb38-12"></a>    FOR(i, <span class="dv">1</span>, a[n]) {</span>
<span id="cb38-13"><a aria-hidden="true" href="#cb38-13"></a>        <span class="cf">if</span> (i * (i + <span class="dv">1</span>) &lt; a[<span class="dv">1</span>]) <span class="cf">continue</span>;</span>
<span id="cb38-14"><a aria-hidden="true" href="#cb38-14"></a>        <span class="dt">int</span> lb = <span class="dv">0</span>, rb = i;</span>
<span id="cb38-15"><a aria-hidden="true" href="#cb38-15"></a>        <span class="cf">if</span> (a[<span class="dv">1</span>] &gt; i * i) lb = a[<span class="dv">1</span>] - i * i;</span>
<span id="cb38-16"><a aria-hidden="true" href="#cb38-16"></a>        <span class="dt">int</span> l = <span class="dv">0</span>, r = i;</span>
<span id="cb38-17"><a aria-hidden="true" href="#cb38-17"></a>        FOR(j, i, a[n]) {</span>
<span id="cb38-18"><a aria-hidden="true" href="#cb38-18"></a>            <span class="cf">if</span> (pre[r] &gt;= l)</span>
<span id="cb38-19"><a aria-hidden="true" href="#cb38-19"></a>                chkmin(rb, r - pre[r]);</span>
<span id="cb38-20"><a aria-hidden="true" href="#cb38-20"></a>            l += <span class="dv">2</span> * j + <span class="dv">1</span>;</span>
<span id="cb38-21"><a aria-hidden="true" href="#cb38-21"></a>            <span class="cf">if</span> (suf[r + <span class="dv">1</span>] &lt; l)</span>
<span id="cb38-22"><a aria-hidden="true" href="#cb38-22"></a>                chkmax(lb, l - suf[r + <span class="dv">1</span>]);</span>
<span id="cb38-23"><a aria-hidden="true" href="#cb38-23"></a>            r += <span class="dv">2</span> * j + <span class="dv">2</span>;</span>
<span id="cb38-24"><a aria-hidden="true" href="#cb38-24"></a>            <span class="cf">if</span> (l &gt; a[n] - a[<span class="dv">1</span>]) <span class="cf">break</span>;</span>
<span id="cb38-25"><a aria-hidden="true" href="#cb38-25"></a>        }</span>
<span id="cb38-26"><a aria-hidden="true" href="#cb38-26"></a>        <span class="cf">if</span> (lb &lt;= rb) {</span>
<span id="cb38-27"><a aria-hidden="true" href="#cb38-27"></a>            cout &lt;&lt; i * i + lb - a[<span class="dv">1</span>] &lt;&lt; endl;</span>
<span id="cb38-28"><a aria-hidden="true" href="#cb38-28"></a>            <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb38-29"><a aria-hidden="true" href="#cb38-29"></a>        }</span>
<span id="cb38-30"><a aria-hidden="true" href="#cb38-30"></a>    }</span>
<span id="cb38-31"><a aria-hidden="true" href="#cb38-31"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb38-32"><a aria-hidden="true" href="#cb38-32"></a>}</span></code></pre></div>
<h2 id="codeforces-round-801-div.-2-and-epic-institute-of-technology-round">Codeforces Round #801 (Div. 2) and EPIC Institute of Technology Round</h2>
<h3 id="d12---tree-queries-hard-version">1695D1/2 - Tree Queries (Hard Version)</h3>
<p>原题地址：<a href="https://atcoder.jp/contests/apc001/tasks/apc001_e">AtCoder</a>，<a href="https://www.luogu.com.cn/problem/AT3912">洛谷</a>。</p>
<p>首先对于 <span class="math inline">\(n = 1\)</span> 我们可以特判掉。</p>
<p>然后是 <span class="math inline">\(n\le 2000\)</span> 的 D1，发现我们可以枚举根然后钦定选择之，之后贪心扫一遍树计算答案。具体地，若遇到了度数 <span class="math inline">\(\mathrm{deg}(u)\ge 3\)</span> 的节点（即分叉），则至少要有 <span class="math inline">\(\mathrm{deg}(u) - 2\)</span> 个子树内有选择的点（否则无法将所有的子树区分开来）。这个东西可以稍微 dp 一下来做，设 <span class="math inline">\(f_u\)</span> 表示 <span class="math inline">\(u\)</span> 子树内有没有选点，则</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb39-1"><a aria-hidden="true" href="#cb39-1"></a><span class="pp">#include </span><span class="im">&lt;bits/stdc++.h&gt;</span></span>
<span id="cb39-2"><a aria-hidden="true" href="#cb39-2"></a><span class="pp">#define il </span><span class="kw">inline</span></span>
<span id="cb39-3"><a aria-hidden="true" href="#cb39-3"></a><span class="pp">#define FOR</span>(i,<span class="pp"> </span>a,<span class="pp"> </span>b)<span class="pp"> </span><span class="cf">for</span><span class="pp"> </span>(<span class="dt">int</span><span class="pp"> </span>i<span class="pp"> </span>=<span class="pp"> </span>(a);<span class="pp"> </span>i<span class="pp"> </span>&lt;=<span class="pp"> </span>(b);<span class="pp"> </span>++i)</span>
<span id="cb39-4"><a aria-hidden="true" href="#cb39-4"></a></span>
<span id="cb39-5"><a aria-hidden="true" href="#cb39-5"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb39-6"><a aria-hidden="true" href="#cb39-6"></a></span>
<span id="cb39-7"><a aria-hidden="true" href="#cb39-7"></a><span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt; il T chkmin(T &amp;a, <span class="at">const</span> T &amp;b) {<span class="cf">return</span> a = (b &lt; a ? b : a);}</span>
<span id="cb39-8"><a aria-hidden="true" href="#cb39-8"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">2e3</span> + <span class="dv">5</span>;</span>
<span id="cb39-9"><a aria-hidden="true" href="#cb39-9"></a><span class="dt">int</span> n, f[maxn];</span>
<span id="cb39-10"><a aria-hidden="true" href="#cb39-10"></a>vector&lt;<span class="dt">int</span>&gt; G[maxn];</span>
<span id="cb39-11"><a aria-hidden="true" href="#cb39-11"></a></span>
<span id="cb39-12"><a aria-hidden="true" href="#cb39-12"></a><span class="dt">int</span> dfs(<span class="dt">int</span> u, <span class="dt">int</span> fa) {</span>
<span id="cb39-13"><a aria-hidden="true" href="#cb39-13"></a>    <span class="dt">int</span> tmp = <span class="dv">0</span>, ret = <span class="dv">0</span>;</span>
<span id="cb39-14"><a aria-hidden="true" href="#cb39-14"></a>    f[u] = <span class="dv">0</span>;</span>
<span id="cb39-15"><a aria-hidden="true" href="#cb39-15"></a>    <span class="cf">for</span> (<span class="kw">auto</span> &amp;v : G[u]) <span class="cf">if</span> (v != fa) {</span>
<span id="cb39-16"><a aria-hidden="true" href="#cb39-16"></a>        ret += dfs(v, u);</span>
<span id="cb39-17"><a aria-hidden="true" href="#cb39-17"></a>        tmp += !f[v], f[u] |= f[v];</span>
<span id="cb39-18"><a aria-hidden="true" href="#cb39-18"></a>    }</span>
<span id="cb39-19"><a aria-hidden="true" href="#cb39-19"></a>    <span class="cf">if</span> (tmp &gt; <span class="dv">1</span>) ret += tmp - <span class="dv">1</span>, f[u] = <span class="dv">1</span>;</span>
<span id="cb39-20"><a aria-hidden="true" href="#cb39-20"></a>    <span class="cf">return</span> ret;</span>
<span id="cb39-21"><a aria-hidden="true" href="#cb39-21"></a>}</span>
<span id="cb39-22"><a aria-hidden="true" href="#cb39-22"></a></span>
<span id="cb39-23"><a aria-hidden="true" href="#cb39-23"></a><span class="dt">int</span> main() {</span>
<span id="cb39-24"><a aria-hidden="true" href="#cb39-24"></a>    ios::sync_with_stdio(<span class="kw">false</span>);</span>
<span id="cb39-25"><a aria-hidden="true" href="#cb39-25"></a>    <span class="dt">int</span> T; cin &gt;&gt; T;</span>
<span id="cb39-26"><a aria-hidden="true" href="#cb39-26"></a>    <span class="cf">while</span> (T--) {</span>
<span id="cb39-27"><a aria-hidden="true" href="#cb39-27"></a>        cin &gt;&gt; n;</span>
<span id="cb39-28"><a aria-hidden="true" href="#cb39-28"></a>        FOR(i, <span class="dv">1</span>, n) vector&lt;<span class="dt">int</span>&gt;().swap(G[i]);</span>
<span id="cb39-29"><a aria-hidden="true" href="#cb39-29"></a>        <span class="cf">if</span> (n == <span class="dv">1</span>) {</span>
<span id="cb39-30"><a aria-hidden="true" href="#cb39-30"></a>            cout &lt;&lt; <span class="dv">0</span> &lt;&lt; <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span>;</span>
<span id="cb39-31"><a aria-hidden="true" href="#cb39-31"></a>            <span class="cf">continue</span>;</span>
<span id="cb39-32"><a aria-hidden="true" href="#cb39-32"></a>        }</span>
<span id="cb39-33"><a aria-hidden="true" href="#cb39-33"></a>        FOR(i, <span class="dv">1</span>, n - <span class="dv">1</span>) {</span>
<span id="cb39-34"><a aria-hidden="true" href="#cb39-34"></a>            <span class="dt">int</span> u, v; cin &gt;&gt; u &gt;&gt; v;</span>
<span id="cb39-35"><a aria-hidden="true" href="#cb39-35"></a>            G[u].push_back(v), G[v].push_back(u);</span>
<span id="cb39-36"><a aria-hidden="true" href="#cb39-36"></a>        }</span>
<span id="cb39-37"><a aria-hidden="true" href="#cb39-37"></a>        <span class="dt">int</span> ans = <span class="fl">1e9</span>;</span>
<span id="cb39-38"><a aria-hidden="true" href="#cb39-38"></a>        FOR(i, <span class="dv">1</span>, n) chkmin(ans, dfs(i, <span class="dv">0</span>) + <span class="dv">1</span>);</span>
<span id="cb39-39"><a aria-hidden="true" href="#cb39-39"></a>        cout &lt;&lt; ans &lt;&lt; <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span>;</span>
<span id="cb39-40"><a aria-hidden="true" href="#cb39-40"></a>    }</span>
<span id="cb39-41"><a aria-hidden="true" href="#cb39-41"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb39-42"><a aria-hidden="true" href="#cb39-42"></a>}</span></code></pre></div>
<p>然后会发现，我们这样做的本质是，对于一个以 <span class="math inline">\(u\)</span> 为根的子树，我们保证了他的外面至少有一个点被选（即至少选了根），以确定 <span class="math inline">\(u\)</span> 的位置。而当我们选择一个度数 <span class="math inline">\(\ge 3\)</span> 的点作为根时，我们会发现即使不选根，对于根的每一个子树都可以满足上述性质（子树外面也至少选了一个点），所以随便选一个度数 <span class="math inline">\(\ge 3\)</span> 的根跑一遍这个 dp 就能得到答案（注意这个时候就不选根了）。</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb40-1"><a aria-hidden="true" href="#cb40-1"></a><span class="pp">#include </span><span class="im">&lt;bits/stdc++.h&gt;</span></span>
<span id="cb40-2"><a aria-hidden="true" href="#cb40-2"></a><span class="pp">#define FOR</span>(i,<span class="pp"> </span>a,<span class="pp"> </span>b)<span class="pp"> </span><span class="cf">for</span><span class="pp"> </span>(<span class="dt">int</span><span class="pp"> </span>i<span class="pp"> </span>=<span class="pp"> </span>(a);<span class="pp"> </span>i<span class="pp"> </span>&lt;=<span class="pp"> </span>(b);<span class="pp"> </span>++i)</span>
<span id="cb40-3"><a aria-hidden="true" href="#cb40-3"></a><span class="pp">#define DEC</span>(i,<span class="pp"> </span>a,<span class="pp"> </span>b)<span class="pp"> </span><span class="cf">for</span><span class="pp"> </span>(<span class="dt">int</span><span class="pp"> </span>i<span class="pp"> </span>=<span class="pp"> </span>(a);<span class="pp"> </span>i<span class="pp"> </span>&gt;=<span class="pp"> </span>(b);<span class="pp"> </span>--i)</span>
<span id="cb40-4"><a aria-hidden="true" href="#cb40-4"></a></span>
<span id="cb40-5"><a aria-hidden="true" href="#cb40-5"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb40-6"><a aria-hidden="true" href="#cb40-6"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">2e5</span> + <span class="dv">5</span>;</span>
<span id="cb40-7"><a aria-hidden="true" href="#cb40-7"></a><span class="dt">int</span> n, f[maxn], ans;</span>
<span id="cb40-8"><a aria-hidden="true" href="#cb40-8"></a>vector&lt;<span class="dt">int</span>&gt; G[maxn];</span>
<span id="cb40-9"><a aria-hidden="true" href="#cb40-9"></a></span>
<span id="cb40-10"><a aria-hidden="true" href="#cb40-10"></a><span class="dt">void</span> dfs(<span class="dt">int</span> u, <span class="dt">int</span> fa) {</span>
<span id="cb40-11"><a aria-hidden="true" href="#cb40-11"></a>    <span class="dt">int</span> tmp = <span class="dv">0</span>;</span>
<span id="cb40-12"><a aria-hidden="true" href="#cb40-12"></a>    <span class="cf">for</span> (<span class="kw">auto</span> &amp;v : G[u]) <span class="cf">if</span> (v != fa) {</span>
<span id="cb40-13"><a aria-hidden="true" href="#cb40-13"></a>        dfs(v, u);</span>
<span id="cb40-14"><a aria-hidden="true" href="#cb40-14"></a>        tmp += !f[v], f[u] |= f[v];</span>
<span id="cb40-15"><a aria-hidden="true" href="#cb40-15"></a>    }</span>
<span id="cb40-16"><a aria-hidden="true" href="#cb40-16"></a>    <span class="cf">if</span> (tmp &gt; <span class="dv">1</span>) ans += tmp - <span class="dv">1</span>, f[u] = <span class="dv">1</span>;</span>
<span id="cb40-17"><a aria-hidden="true" href="#cb40-17"></a>    <span class="cf">return</span>;</span>
<span id="cb40-18"><a aria-hidden="true" href="#cb40-18"></a>}</span>
<span id="cb40-19"><a aria-hidden="true" href="#cb40-19"></a></span>
<span id="cb40-20"><a aria-hidden="true" href="#cb40-20"></a><span class="dt">int</span> main() {</span>
<span id="cb40-21"><a aria-hidden="true" href="#cb40-21"></a>    ios::sync_with_stdio(<span class="kw">false</span>);</span>
<span id="cb40-22"><a aria-hidden="true" href="#cb40-22"></a>    <span class="dt">int</span> T; cin &gt;&gt; T;</span>
<span id="cb40-23"><a aria-hidden="true" href="#cb40-23"></a>    <span class="cf">while</span> (T--) {</span>
<span id="cb40-24"><a aria-hidden="true" href="#cb40-24"></a>        cin &gt;&gt; n;</span>
<span id="cb40-25"><a aria-hidden="true" href="#cb40-25"></a>        FOR(i, <span class="dv">1</span>, n) vector&lt;<span class="dt">int</span>&gt;().swap(G[i]), f[i] = <span class="dv">0</span>;</span>
<span id="cb40-26"><a aria-hidden="true" href="#cb40-26"></a>        <span class="cf">if</span> (n == <span class="dv">1</span>) {</span>
<span id="cb40-27"><a aria-hidden="true" href="#cb40-27"></a>            cout &lt;&lt; <span class="dv">0</span> &lt;&lt; <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span>;</span>
<span id="cb40-28"><a aria-hidden="true" href="#cb40-28"></a>            <span class="cf">continue</span>;</span>
<span id="cb40-29"><a aria-hidden="true" href="#cb40-29"></a>        }</span>
<span id="cb40-30"><a aria-hidden="true" href="#cb40-30"></a>        FOR(i, <span class="dv">1</span>, n - <span class="dv">1</span>) {</span>
<span id="cb40-31"><a aria-hidden="true" href="#cb40-31"></a>            <span class="dt">int</span> u, v; cin &gt;&gt; u &gt;&gt; v;</span>
<span id="cb40-32"><a aria-hidden="true" href="#cb40-32"></a>            G[u].push_back(v), G[v].push_back(u);</span>
<span id="cb40-33"><a aria-hidden="true" href="#cb40-33"></a>        }</span>
<span id="cb40-34"><a aria-hidden="true" href="#cb40-34"></a>        <span class="dt">int</span> rt = <span class="dv">0</span>;</span>
<span id="cb40-35"><a aria-hidden="true" href="#cb40-35"></a>        FOR(i, <span class="dv">1</span>, n) <span class="cf">if</span> (G[i].size() &gt; <span class="dv">2</span>) {</span>
<span id="cb40-36"><a aria-hidden="true" href="#cb40-36"></a>            rt = i;</span>
<span id="cb40-37"><a aria-hidden="true" href="#cb40-37"></a>            <span class="cf">break</span>;</span>
<span id="cb40-38"><a aria-hidden="true" href="#cb40-38"></a>        }</span>
<span id="cb40-39"><a aria-hidden="true" href="#cb40-39"></a>        ans = <span class="dv">0</span>;</span>
<span id="cb40-40"><a aria-hidden="true" href="#cb40-40"></a>        <span class="cf">if</span> (!rt) cout &lt;&lt; <span class="dv">1</span> &lt;&lt; <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span>;</span>
<span id="cb40-41"><a aria-hidden="true" href="#cb40-41"></a>        <span class="cf">else</span> cout &lt;&lt; (dfs(rt, <span class="dv">0</span>), ans) &lt;&lt; <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span>;</span>
<span id="cb40-42"><a aria-hidden="true" href="#cb40-42"></a>    }</span>
<span id="cb40-43"><a aria-hidden="true" href="#cb40-43"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb40-44"><a aria-hidden="true" href="#cb40-44"></a>}</span></code></pre></div>
<hr/>
<p>当然本题还可以从另外一个角度出发，即思考问题的结构。</p>
<p>首先我们考虑选了 <span class="math inline">\(k\)</span> 个关键点之后，什么情况下能区分每个点。</p>
<p>发现若令选出来的 <span class="math inline">\(k\)</span> 个关键点在树上生成一张“连通子图”，连通子图内部的点是两两可区分的，而则其伸出去的子树中，同一深度的点是不可区分的。所以<strong>连通子图伸出去的部分必须是链</strong>。</p>
<p>那么回到原问题，显然我们可以钦定一开始选择所有叶子作为关键点，即将连通子图初始化为整棵树，然后会注意到我们可以删一些原树中从叶子连到内部点的链，同时不破坏上面“伸出去的部分要是链”的性质。</p>
<p>所以从叶子节点往上搜，搜到度 <span class="math inline">\(\ge 3\)</span> 的节点停下来打标记（意味着这个子树里面可以删掉一条链）。用总叶子数量减去打了标记的点的数量就是答案。注意特判链的情况，下面代码是 APC001E 的，和 CF 的有些许出入。</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb41-1"><a aria-hidden="true" href="#cb41-1"></a><span class="pp">#include </span><span class="im">&lt;bits/stdc++.h&gt;</span></span>
<span id="cb41-2"><a aria-hidden="true" href="#cb41-2"></a><span class="pp">#define FOR</span>(i,<span class="pp"> </span>a,<span class="pp"> </span>b)<span class="pp"> </span><span class="cf">for</span><span class="pp"> </span>(<span class="dt">int</span><span class="pp"> </span>i<span class="pp"> </span>=<span class="pp"> </span>(a);<span class="pp"> </span>i<span class="pp"> </span>&lt;=<span class="pp"> </span>(b);<span class="pp"> </span>++i)</span>
<span id="cb41-3"><a aria-hidden="true" href="#cb41-3"></a></span>
<span id="cb41-4"><a aria-hidden="true" href="#cb41-4"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb41-5"><a aria-hidden="true" href="#cb41-5"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">1e5</span> + <span class="dv">5</span>;</span>
<span id="cb41-6"><a aria-hidden="true" href="#cb41-6"></a><span class="dt">int</span> n, vis[maxn], ans;</span>
<span id="cb41-7"><a aria-hidden="true" href="#cb41-7"></a>vector&lt;<span class="dt">int</span>&gt; G[maxn];</span>
<span id="cb41-8"><a aria-hidden="true" href="#cb41-8"></a></span>
<span id="cb41-9"><a aria-hidden="true" href="#cb41-9"></a><span class="dt">int</span> dfs(<span class="dt">int</span> u, <span class="dt">int</span> fa) {</span>
<span id="cb41-10"><a aria-hidden="true" href="#cb41-10"></a>    <span class="cf">if</span> (G[u].size() &gt; <span class="dv">2</span>) <span class="cf">return</span> u;</span>
<span id="cb41-11"><a aria-hidden="true" href="#cb41-11"></a>    <span class="cf">for</span> (<span class="kw">auto</span> &amp;v : G[u]) <span class="cf">if</span> (v != fa) <span class="cf">return</span> dfs(v, u);</span>
<span id="cb41-12"><a aria-hidden="true" href="#cb41-12"></a>    <span class="cf">return</span> u;</span>
<span id="cb41-13"><a aria-hidden="true" href="#cb41-13"></a>}</span>
<span id="cb41-14"><a aria-hidden="true" href="#cb41-14"></a></span>
<span id="cb41-15"><a aria-hidden="true" href="#cb41-15"></a><span class="dt">int</span> main() {</span>
<span id="cb41-16"><a aria-hidden="true" href="#cb41-16"></a>    ios::sync_with_stdio(<span class="kw">false</span>);</span>
<span id="cb41-17"><a aria-hidden="true" href="#cb41-17"></a>    cin &gt;&gt; n;</span>
<span id="cb41-18"><a aria-hidden="true" href="#cb41-18"></a>    FOR(i, <span class="dv">1</span>, n - <span class="dv">1</span>) {</span>
<span id="cb41-19"><a aria-hidden="true" href="#cb41-19"></a>        <span class="dt">int</span> u, v; cin &gt;&gt; u &gt;&gt; v;</span>
<span id="cb41-20"><a aria-hidden="true" href="#cb41-20"></a>        ++u, ++v;</span>
<span id="cb41-21"><a aria-hidden="true" href="#cb41-21"></a>        G[u].push_back(v), G[v].push_back(u);</span>
<span id="cb41-22"><a aria-hidden="true" href="#cb41-22"></a>    }</span>
<span id="cb41-23"><a aria-hidden="true" href="#cb41-23"></a>    FOR(i, <span class="dv">1</span>, n) <span class="cf">if</span> (G[i].size() == <span class="dv">1</span>) vis[dfs(i, <span class="dv">0</span>)] = <span class="dv">1</span>, ++ans;</span>
<span id="cb41-24"><a aria-hidden="true" href="#cb41-24"></a>    FOR(i, <span class="dv">1</span>, n) ans -= vis[i];</span>
<span id="cb41-25"><a aria-hidden="true" href="#cb41-25"></a>    cout &lt;&lt; (ans ? ans : <span class="dv">1</span>) &lt;&lt; endl;</span>
<span id="cb41-26"><a aria-hidden="true" href="#cb41-26"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb41-27"><a aria-hidden="true" href="#cb41-27"></a>}</span></code></pre></div>
<h3 id="e---ambiguous-dominoes">1695E - Ambiguous Dominoes</h3>
<p>题意：有 <span class="math inline">\(n\)</span> 个多米诺骨牌，每张骨牌上有两个数字，要求构造两个将这 <span class="math inline">\(n\)</span> 个骨牌不重叠放入 <span class="math inline">\(m\times k = 2n\)</span> 的棋盘 <span class="math inline">\(a_{m\times k}\)</span> 中的方案，满足对应位置上的数字一样，且要求两种方案中骨牌的位置全部不一样，或报告无解。<span class="math inline">\(n\le 3\times 10^5\)</span>。</p>
<p>有点流氓了哈，牛逼构造。</p>
<p>对于每张多米诺骨牌 <span class="math inline">\((x_i, y_i)\)</span>，连一条无向边 <span class="math inline">\(x\to y\)</span>。然后会发现，若一个连通分量里面恰好只有 <span class="math inline">\(1\)</span> 条边，说明这条边代表的多米诺骨牌只有一种摆法，因此无解。</p>
<p>否则总能构造出一个 <span class="math inline">\(2\times k\)</span> 的棋盘（<span class="math inline">\(k\)</span> 为连通分量内边数），见下。</p>
<p>我们随便对这张图进行欧拉遍历（就是 dfs 遍历没有遍历的边，然后将经过的边存下来），然后会发现每条边都恰好在这个欧拉序中出现两次（考虑欧拉序的性质），并且<strong>两次出现的位置的奇偶性不一样</strong>。</p>
<p>如何证明？考虑边 <span class="math inline">\(e=u\to v\)</span>，若我们的 dfs 直接返回，则欧拉序列中会形成 <span class="math inline">\(e,e\)</span>，两次出现位置的奇偶性显然不同。如果还要继续遍历，由于我们之后遍历的边一定经历了回溯过程，所以两个 <span class="math inline">\(e\)</span> 中间夹着偶数条边，<span class="math inline">\(e\)</span> 出现位置的奇偶性仍然不同。</p>
<p>如果考虑点的遍历序，则我们得到一个长度为 <span class="math inline">\(2k + 1\)</span> 的首尾相接的序列（还是考虑欧拉序的性质），然后将最后一个元素去掉并将其依次顺时针放入 <span class="math inline">\(2\times k\)</span> 的棋盘中，现在骨牌们对应的 <span class="math inline">\(k\)</span> 条边就形成了长 <span class="math inline">\(2n\)</span> 的环。因为每张骨牌<strong>出现位置的奇偶性不一样</strong>，所以下面的两种构造总会是合法的（图源官方题解）：</p>
<p><img src="https://espresso.codeforces.com/8d975bc11693b0864bbc0b6e19423e4954b1b282.png"/></p>
<p>于是对于一个连通块我们就搞定了。对于多个连通块的情况，把得到的 <span class="math inline">\(2\times k\)</span> 棋盘们拼一起即可，时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>
<p><img src="https://espresso.codeforces.com/211398dfdf9487ee70a6b189aa834b35c0dd601f.png"/></p>
<p>（可能有上面的图更好理解些）</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb42-1"><a aria-hidden="true" href="#cb42-1"></a><span class="pp">#include </span><span class="im">&lt;bits/stdc++.h&gt;</span></span>
<span id="cb42-2"><a aria-hidden="true" href="#cb42-2"></a><span class="pp">#define il </span><span class="kw">inline</span></span>
<span id="cb42-3"><a aria-hidden="true" href="#cb42-3"></a><span class="pp">#define FOR</span>(i,<span class="pp"> </span>a,<span class="pp"> </span>b)<span class="pp"> </span><span class="cf">for</span><span class="pp"> </span>(<span class="dt">int</span><span class="pp"> </span>i<span class="pp"> </span>=<span class="pp"> </span>(a);<span class="pp"> </span>i<span class="pp"> </span>&lt;=<span class="pp"> </span>(b);<span class="pp"> </span>++i)</span>
<span id="cb42-4"><a aria-hidden="true" href="#cb42-4"></a><span class="pp">#define DEC</span>(i,<span class="pp"> </span>a,<span class="pp"> </span>b)<span class="pp"> </span><span class="cf">for</span><span class="pp"> </span>(<span class="dt">int</span><span class="pp"> </span>i<span class="pp"> </span>=<span class="pp"> </span>(a);<span class="pp"> </span>i<span class="pp"> </span>&gt;=<span class="pp"> </span>(b);<span class="pp"> </span>--i)</span>
<span id="cb42-5"><a aria-hidden="true" href="#cb42-5"></a></span>
<span id="cb42-6"><a aria-hidden="true" href="#cb42-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb42-7"><a aria-hidden="true" href="#cb42-7"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">3e5</span> + <span class="dv">5</span>;</span>
<span id="cb42-8"><a aria-hidden="true" href="#cb42-8"></a><span class="dt">int</span> head[maxn &lt;&lt; <span class="dv">1</span>], to[maxn &lt;&lt; <span class="dv">2</span>], nxt[maxn &lt;&lt; <span class="dv">2</span>], cnte = <span class="dv">1</span>;</span>
<span id="cb42-9"><a aria-hidden="true" href="#cb42-9"></a><span class="dt">int</span> n, vis[maxn &lt;&lt; <span class="dv">1</span>], vise[maxn &lt;&lt; <span class="dv">2</span>];</span>
<span id="cb42-10"><a aria-hidden="true" href="#cb42-10"></a></span>
<span id="cb42-11"><a aria-hidden="true" href="#cb42-11"></a>il <span class="dt">void</span> add(<span class="dt">int</span> u, <span class="dt">int</span> v) {</span>
<span id="cb42-12"><a aria-hidden="true" href="#cb42-12"></a>    to[++cnte] = v;</span>
<span id="cb42-13"><a aria-hidden="true" href="#cb42-13"></a>    nxt[cnte] = head[u];</span>
<span id="cb42-14"><a aria-hidden="true" href="#cb42-14"></a>    head[u] = cnte;</span>
<span id="cb42-15"><a aria-hidden="true" href="#cb42-15"></a>    <span class="cf">return</span>;</span>
<span id="cb42-16"><a aria-hidden="true" href="#cb42-16"></a>}</span>
<span id="cb42-17"><a aria-hidden="true" href="#cb42-17"></a></span>
<span id="cb42-18"><a aria-hidden="true" href="#cb42-18"></a>vector&lt;<span class="dt">int</span>&gt; path;</span>
<span id="cb42-19"><a aria-hidden="true" href="#cb42-19"></a></span>
<span id="cb42-20"><a aria-hidden="true" href="#cb42-20"></a><span class="dt">void</span> dfs(<span class="dt">int</span> u, <span class="dt">int</span> pre) {</span>
<span id="cb42-21"><a aria-hidden="true" href="#cb42-21"></a>    path.push_back(u);</span>
<span id="cb42-22"><a aria-hidden="true" href="#cb42-22"></a>    <span class="cf">if</span> (vis[u]) <span class="cf">return</span>;</span>
<span id="cb42-23"><a aria-hidden="true" href="#cb42-23"></a>    vis[u] = <span class="dv">1</span>;</span>
<span id="cb42-24"><a aria-hidden="true" href="#cb42-24"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = head[u]; i; i = nxt[i]) <span class="cf">if</span> (!vise[i]) {</span>
<span id="cb42-25"><a aria-hidden="true" href="#cb42-25"></a>        vise[i] = vise[i ^ <span class="dv">1</span>] = <span class="dv">1</span>;</span>
<span id="cb42-26"><a aria-hidden="true" href="#cb42-26"></a>        dfs(to[i], i);</span>
<span id="cb42-27"><a aria-hidden="true" href="#cb42-27"></a>        path.push_back(u);</span>
<span id="cb42-28"><a aria-hidden="true" href="#cb42-28"></a>    }</span>
<span id="cb42-29"><a aria-hidden="true" href="#cb42-29"></a>    <span class="cf">return</span>;</span>
<span id="cb42-30"><a aria-hidden="true" href="#cb42-30"></a>}</span>
<span id="cb42-31"><a aria-hidden="true" href="#cb42-31"></a></span>
<span id="cb42-32"><a aria-hidden="true" href="#cb42-32"></a><span class="dt">int</span> ans[<span class="dv">2</span>][maxn];</span>
<span id="cb42-33"><a aria-hidden="true" href="#cb42-33"></a><span class="dt">char</span> sol1[<span class="dv">2</span>][maxn], sol2[<span class="dv">2</span>][maxn];</span>
<span id="cb42-34"><a aria-hidden="true" href="#cb42-34"></a></span>
<span id="cb42-35"><a aria-hidden="true" href="#cb42-35"></a><span class="dt">int</span> main() {</span>
<span id="cb42-36"><a aria-hidden="true" href="#cb42-36"></a>    ios::sync_with_stdio(<span class="kw">false</span>);</span>
<span id="cb42-37"><a aria-hidden="true" href="#cb42-37"></a>    cin &gt;&gt; n;</span>
<span id="cb42-38"><a aria-hidden="true" href="#cb42-38"></a>    FOR(i, <span class="dv">1</span>, n) {</span>
<span id="cb42-39"><a aria-hidden="true" href="#cb42-39"></a>        <span class="dt">int</span> x, y; cin &gt;&gt; x &gt;&gt; y;</span>
<span id="cb42-40"><a aria-hidden="true" href="#cb42-40"></a>        add(x, y), add(y, x);</span>
<span id="cb42-41"><a aria-hidden="true" href="#cb42-41"></a>    }</span>
<span id="cb42-42"><a aria-hidden="true" href="#cb42-42"></a>    <span class="dt">int</span> col = <span class="dv">0</span>;</span>
<span id="cb42-43"><a aria-hidden="true" href="#cb42-43"></a>    FOR(i, <span class="dv">1</span>, n &lt;&lt; <span class="dv">1</span>) <span class="cf">if</span> (!vis[i]) {</span>
<span id="cb42-44"><a aria-hidden="true" href="#cb42-44"></a>        vector&lt;<span class="dt">int</span>&gt;().swap(path);</span>
<span id="cb42-45"><a aria-hidden="true" href="#cb42-45"></a>        dfs(i, <span class="dv">0</span>);</span>
<span id="cb42-46"><a aria-hidden="true" href="#cb42-46"></a>        <span class="cf">if</span> (path.size() == <span class="dv">3</span>) <span class="cf">return</span> puts(<span class="st">"-1"</span>), <span class="dv">0</span>;</span>
<span id="cb42-47"><a aria-hidden="true" href="#cb42-47"></a>        <span class="cf">else</span> <span class="cf">if</span> (path.size() &lt; <span class="dv">3</span>) <span class="cf">continue</span>;</span>
<span id="cb42-48"><a aria-hidden="true" href="#cb42-48"></a>        path.pop_back();</span>
<span id="cb42-49"><a aria-hidden="true" href="#cb42-49"></a>        <span class="dt">int</span> k = path.size() &gt;&gt; <span class="dv">1</span>;</span>
<span id="cb42-50"><a aria-hidden="true" href="#cb42-50"></a>        <span class="kw">auto</span> it = path.begin();</span>
<span id="cb42-51"><a aria-hidden="true" href="#cb42-51"></a>        FOR(i, <span class="dv">1</span>, k) ans[<span class="dv">0</span>][i + col] = *it++;</span>
<span id="cb42-52"><a aria-hidden="true" href="#cb42-52"></a>        DEC(i, k, <span class="dv">1</span>) ans[<span class="dv">1</span>][i + col] = *it++;</span>
<span id="cb42-53"><a aria-hidden="true" href="#cb42-53"></a>        <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">2</span>; i &lt;= k; i += <span class="dv">2</span>) sol1[<span class="dv">0</span>][col + i] = sol1[<span class="dv">1</span>][col + i] = <span class="ch">'R'</span>, sol1[<span class="dv">0</span>][col + i - <span class="dv">1</span>] = sol1[<span class="dv">1</span>][col + i - <span class="dv">1</span>] = <span class="ch">'L'</span>;</span>
<span id="cb42-54"><a aria-hidden="true" href="#cb42-54"></a>        <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">3</span>; i &lt;= k; i += <span class="dv">2</span>) sol2[<span class="dv">0</span>][col + i] = sol2[<span class="dv">1</span>][col + i] = <span class="ch">'R'</span>, sol2[<span class="dv">0</span>][col + i - <span class="dv">1</span>] = sol2[<span class="dv">1</span>][col + i - <span class="dv">1</span>] = <span class="ch">'L'</span>;</span>
<span id="cb42-55"><a aria-hidden="true" href="#cb42-55"></a>        <span class="cf">if</span> (k &amp; <span class="dv">1</span>) sol1[<span class="dv">0</span>][col + k] = <span class="ch">'U'</span>, sol1[<span class="dv">1</span>][col + k] = <span class="ch">'D'</span>;</span>
<span id="cb42-56"><a aria-hidden="true" href="#cb42-56"></a>        <span class="cf">else</span> sol2[<span class="dv">0</span>][col + k] = <span class="ch">'U'</span>, sol2[<span class="dv">1</span>][col + k] = <span class="ch">'D'</span>;</span>
<span id="cb42-57"><a aria-hidden="true" href="#cb42-57"></a>        sol2[<span class="dv">0</span>][col + <span class="dv">1</span>] = <span class="ch">'U'</span>, sol2[<span class="dv">1</span>][col + <span class="dv">1</span>] = <span class="ch">'D'</span>;</span>
<span id="cb42-58"><a aria-hidden="true" href="#cb42-58"></a>        col += k;</span>
<span id="cb42-59"><a aria-hidden="true" href="#cb42-59"></a>    }</span>
<span id="cb42-60"><a aria-hidden="true" href="#cb42-60"></a>    cout &lt;&lt; <span class="dv">2</span> &lt;&lt; <span class="ch">' '</span> &lt;&lt; col &lt;&lt; <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span>;</span>
<span id="cb42-61"><a aria-hidden="true" href="#cb42-61"></a>    FOR(i, <span class="dv">0</span>, <span class="dv">1</span>) {</span>
<span id="cb42-62"><a aria-hidden="true" href="#cb42-62"></a>        FOR(j, <span class="dv">1</span>, col) cout &lt;&lt; ans[i][j] &lt;&lt; <span class="ch">' '</span>;</span>
<span id="cb42-63"><a aria-hidden="true" href="#cb42-63"></a>        cout &lt;&lt; <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span>;</span>
<span id="cb42-64"><a aria-hidden="true" href="#cb42-64"></a>    }</span>
<span id="cb42-65"><a aria-hidden="true" href="#cb42-65"></a>    FOR(i, <span class="dv">0</span>, <span class="dv">1</span>) {</span>
<span id="cb42-66"><a aria-hidden="true" href="#cb42-66"></a>        FOR(j, <span class="dv">1</span>, col) cout &lt;&lt; sol1[i][j];</span>
<span id="cb42-67"><a aria-hidden="true" href="#cb42-67"></a>        cout &lt;&lt; <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span>;</span>
<span id="cb42-68"><a aria-hidden="true" href="#cb42-68"></a>    }</span>
<span id="cb42-69"><a aria-hidden="true" href="#cb42-69"></a>    FOR(i, <span class="dv">0</span>, <span class="dv">1</span>) {</span>
<span id="cb42-70"><a aria-hidden="true" href="#cb42-70"></a>        FOR(j, <span class="dv">1</span>, col) cout &lt;&lt; sol2[i][j];</span>
<span id="cb42-71"><a aria-hidden="true" href="#cb42-71"></a>        cout &lt;&lt; <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span>;</span>
<span id="cb42-72"><a aria-hidden="true" href="#cb42-72"></a>    }</span>
<span id="cb42-73"><a aria-hidden="true" href="#cb42-73"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb42-74"><a aria-hidden="true" href="#cb42-74"></a>}</span></code></pre></div>
<h2 id="codeforces-round-802-div.-2">Codeforces Round #802 (Div. 2)</h2>
<h3 id="e---serega-the-pirate">1700E - Serega the Pirate</h3>
<p>首先 <span class="math inline">\(0\)</span> 容易判，下面考虑如何判断 <span class="math inline">\(1\)</span> 和 <span class="math inline">\(2\)</span> 以及对方案计数。</p>
<p>容易发现整个矩阵可解等价于对于每个 <span class="math inline">\(&gt;1\)</span> 的格子都存在权值小于他的格子与其四联通，充分性可使用归纳证明。</p>
<p>那么我们现在就将那些四周不存在比他小且 <span class="math inline">\(&gt; 1\)</span> 的格子为坏的。</p>
<p>一次交换我们最多可以改变 <span class="math inline">\(10\)</span> 个格子的状态（两个本身，以及他们四周），所以坏点多于 <span class="math inline">\(10\)</span> 个答案必然是 No。</p>
<p>并且，一次交换的时候，我们交换的其中一个点必然是某个坏点或其旁边的四个格子，一共 <span class="math inline">\(5\)</span> 个格子，考虑枚举之。</p>
<p>然后 <span class="math inline">\(O(nm)\)</span> 枚举另一个点，交换的时候我们只需判断</p>
<ul>
<li>所有的坏点是否被都覆盖到了（最多 <span class="math inline">\(10\)</span> 个）；</li>
<li>交换之后影响到的格子是否合法（最多 <span class="math inline">\(10\)</span> 个）。</li>
</ul>
<p>所以时间复杂度 <span class="math inline">\(O(nm)\)</span>，带一个 <span class="math inline">\(20\times 5\)</span> 的常数。为 <span class="math inline">\(1\)</span> 的情况跑的时候顺便就可以计数，如果跑不出来那么就是 <span class="math inline">\(2\)</span>。</p>
<p>实际实现需要注意常数问题，以及<strong>跑点对的时候要去重</strong>。</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb43-1"><a aria-hidden="true" href="#cb43-1"></a><span class="pp">#include </span><span class="im">&lt;bits/stdc++.h&gt;</span></span>
<span id="cb43-2"><a aria-hidden="true" href="#cb43-2"></a><span class="pp">#define il </span><span class="kw">inline</span></span>
<span id="cb43-3"><a aria-hidden="true" href="#cb43-3"></a><span class="pp">#define FOR</span>(i,<span class="pp"> </span>a,<span class="pp"> </span>b)<span class="pp"> </span><span class="cf">for</span><span class="pp"> </span>(<span class="dt">int</span><span class="pp"> </span>i<span class="pp"> </span>=<span class="pp"> </span>(a);<span class="pp"> </span>i<span class="pp"> </span>&lt;=<span class="pp"> </span>(b);<span class="pp"> </span>++i)</span>
<span id="cb43-4"><a aria-hidden="true" href="#cb43-4"></a><span class="pp">#define szof</span>(a)<span class="pp"> </span>((<span class="dt">int</span>)<span class="pp"> </span>(a).size())</span>
<span id="cb43-5"><a aria-hidden="true" href="#cb43-5"></a></span>
<span id="cb43-6"><a aria-hidden="true" href="#cb43-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb43-7"><a aria-hidden="true" href="#cb43-7"></a><span class="kw">using</span> pii = pair&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt;;</span>
<span id="cb43-8"><a aria-hidden="true" href="#cb43-8"></a><span class="dt">int</span> n, m, ans;</span>
<span id="cb43-9"><a aria-hidden="true" href="#cb43-9"></a>vector&lt;vector&lt;<span class="dt">int</span>&gt; &gt; a, vis, val;</span>
<span id="cb43-10"><a aria-hidden="true" href="#cb43-10"></a>vector&lt;pii&gt; bad;</span>
<span id="cb43-11"><a aria-hidden="true" href="#cb43-11"></a><span class="at">const</span> <span class="dt">int</span> fx[] = {<span class="dv">1</span>, -<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>};</span>
<span id="cb43-12"><a aria-hidden="true" href="#cb43-12"></a><span class="at">const</span> <span class="dt">int</span> fy[] = {<span class="dv">0</span>, <span class="dv">0</span>, -<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>};</span>
<span id="cb43-13"><a aria-hidden="true" href="#cb43-13"></a></span>
<span id="cb43-14"><a aria-hidden="true" href="#cb43-14"></a>il <span class="dt">bool</span> bound(<span class="dt">int</span> x, <span class="dt">int</span> y) {</span>
<span id="cb43-15"><a aria-hidden="true" href="#cb43-15"></a>    <span class="cf">return</span> x &lt;= n &amp;&amp; y &lt;= m &amp;&amp; x &gt;= <span class="dv">1</span> &amp;&amp; y &gt;= <span class="dv">1</span>;</span>
<span id="cb43-16"><a aria-hidden="true" href="#cb43-16"></a>}</span>
<span id="cb43-17"><a aria-hidden="true" href="#cb43-17"></a></span>
<span id="cb43-18"><a aria-hidden="true" href="#cb43-18"></a>il <span class="dt">bool</span> check(<span class="dt">int</span> x, <span class="dt">int</span> y) {</span>
<span id="cb43-19"><a aria-hidden="true" href="#cb43-19"></a>    <span class="cf">return</span> a[x][y] == <span class="dv">1</span> ||</span>
<span id="cb43-20"><a aria-hidden="true" href="#cb43-20"></a>           (x + <span class="dv">1</span> &lt;= n &amp;&amp; a[x][y] &gt; a[x + <span class="dv">1</span>][y]) ||</span>
<span id="cb43-21"><a aria-hidden="true" href="#cb43-21"></a>           (x - <span class="dv">1</span> &gt;= <span class="dv">1</span> &amp;&amp; a[x][y] &gt; a[x - <span class="dv">1</span>][y]) ||</span>
<span id="cb43-22"><a aria-hidden="true" href="#cb43-22"></a>           (y + <span class="dv">1</span> &lt;= m &amp;&amp; a[x][y] &gt; a[x][y + <span class="dv">1</span>]) ||</span>
<span id="cb43-23"><a aria-hidden="true" href="#cb43-23"></a>           (y - <span class="dv">1</span> &gt;= <span class="dv">1</span> &amp;&amp; a[x][y] &gt; a[x][y - <span class="dv">1</span>]);</span>
<span id="cb43-24"><a aria-hidden="true" href="#cb43-24"></a>}</span>
<span id="cb43-25"><a aria-hidden="true" href="#cb43-25"></a></span>
<span id="cb43-26"><a aria-hidden="true" href="#cb43-26"></a><span class="dt">bool</span> check(<span class="dt">int</span> x1, <span class="dt">int</span> y1, <span class="dt">int</span> x2, <span class="dt">int</span> y2) {</span>
<span id="cb43-27"><a aria-hidden="true" href="#cb43-27"></a>    swap(a[x1][y1], a[x2][y2]);</span>
<span id="cb43-28"><a aria-hidden="true" href="#cb43-28"></a>    <span class="dt">int</span> cnt = <span class="dv">0</span>;</span>
<span id="cb43-29"><a aria-hidden="true" href="#cb43-29"></a>    FOR(k, <span class="dv">0</span>, <span class="dv">4</span>) {</span>
<span id="cb43-30"><a aria-hidden="true" href="#cb43-30"></a>        <span class="dt">int</span> x = x1 + fx[k], y = y1 + fy[k];</span>
<span id="cb43-31"><a aria-hidden="true" href="#cb43-31"></a>        <span class="cf">if</span> (!bound(x, y) || vis[x][y]) <span class="cf">continue</span>;</span>
<span id="cb43-32"><a aria-hidden="true" href="#cb43-32"></a>        vis[x][y] = <span class="dv">1</span>, cnt += val[x][y] - (!check(x, y));</span>
<span id="cb43-33"><a aria-hidden="true" href="#cb43-33"></a>    }</span>
<span id="cb43-34"><a aria-hidden="true" href="#cb43-34"></a>    FOR(k, <span class="dv">0</span>, <span class="dv">4</span>) {</span>
<span id="cb43-35"><a aria-hidden="true" href="#cb43-35"></a>        <span class="dt">int</span> x = x2 + fx[k], y = y2 + fy[k];</span>
<span id="cb43-36"><a aria-hidden="true" href="#cb43-36"></a>        <span class="cf">if</span> (!bound(x, y) || vis[x][y]) <span class="cf">continue</span>;</span>
<span id="cb43-37"><a aria-hidden="true" href="#cb43-37"></a>        vis[x][y] = <span class="dv">1</span>, cnt += val[x][y] - (!check(x, y));</span>
<span id="cb43-38"><a aria-hidden="true" href="#cb43-38"></a>    }</span>
<span id="cb43-39"><a aria-hidden="true" href="#cb43-39"></a>    FOR(k, <span class="dv">0</span>, <span class="dv">4</span>) {</span>
<span id="cb43-40"><a aria-hidden="true" href="#cb43-40"></a>        <span class="dt">int</span> x = x1 + fx[k], y = y1 + fy[k];</span>
<span id="cb43-41"><a aria-hidden="true" href="#cb43-41"></a>        <span class="cf">if</span> (bound(x, y)) vis[x][y] = <span class="dv">0</span>;</span>
<span id="cb43-42"><a aria-hidden="true" href="#cb43-42"></a>        x = x2 + fx[k], y = y2 + fy[k];</span>
<span id="cb43-43"><a aria-hidden="true" href="#cb43-43"></a>        <span class="cf">if</span> (bound(x, y)) vis[x][y] = <span class="dv">0</span>;</span>
<span id="cb43-44"><a aria-hidden="true" href="#cb43-44"></a>    }</span>
<span id="cb43-45"><a aria-hidden="true" href="#cb43-45"></a>    swap(a[x1][y1], a[x2][y2]);</span>
<span id="cb43-46"><a aria-hidden="true" href="#cb43-46"></a>    <span class="cf">return</span> cnt == bad.size();</span>
<span id="cb43-47"><a aria-hidden="true" href="#cb43-47"></a>}</span>
<span id="cb43-48"><a aria-hidden="true" href="#cb43-48"></a></span>
<span id="cb43-49"><a aria-hidden="true" href="#cb43-49"></a>unordered_set&lt;<span class="dt">long</span> <span class="dt">long</span>&gt; S;</span>
<span id="cb43-50"><a aria-hidden="true" href="#cb43-50"></a></span>
<span id="cb43-51"><a aria-hidden="true" href="#cb43-51"></a><span class="dt">int</span> main() {</span>
<span id="cb43-52"><a aria-hidden="true" href="#cb43-52"></a>    ios::sync_with_stdio(<span class="kw">false</span>);</span>
<span id="cb43-53"><a aria-hidden="true" href="#cb43-53"></a>    cin &gt;&gt; n &gt;&gt; m;</span>
<span id="cb43-54"><a aria-hidden="true" href="#cb43-54"></a>    a.resize(n + <span class="dv">1</span>), vis.resize(n + <span class="dv">1</span>), val.resize(n + <span class="dv">1</span>);</span>
<span id="cb43-55"><a aria-hidden="true" href="#cb43-55"></a>    FOR(i, <span class="dv">1</span>, n) {</span>
<span id="cb43-56"><a aria-hidden="true" href="#cb43-56"></a>        a[i].resize(m + <span class="dv">1</span>), vis[i].resize(m + <span class="dv">1</span>), val[i].resize(m + <span class="dv">1</span>);</span>
<span id="cb43-57"><a aria-hidden="true" href="#cb43-57"></a>        FOR(j, <span class="dv">1</span>, m) cin &gt;&gt; a[i][j];</span>
<span id="cb43-58"><a aria-hidden="true" href="#cb43-58"></a>    }</span>
<span id="cb43-59"><a aria-hidden="true" href="#cb43-59"></a>    FOR(x, <span class="dv">1</span>, n) FOR(y, <span class="dv">1</span>, m) <span class="cf">if</span> (!check(x, y)) bad.push_back({x, y}), val[x][y] = <span class="dv">1</span>;</span>
<span id="cb43-60"><a aria-hidden="true" href="#cb43-60"></a>    <span class="cf">if</span> (bad.size() &gt; <span class="dv">10</span>) <span class="cf">return</span> puts(<span class="st">"2"</span>), <span class="dv">0</span>;</span>
<span id="cb43-61"><a aria-hidden="true" href="#cb43-61"></a>    <span class="cf">else</span> <span class="cf">if</span> (bad.empty()) <span class="cf">return</span> puts(<span class="st">"0"</span>), <span class="dv">0</span>;</span>
<span id="cb43-62"><a aria-hidden="true" href="#cb43-62"></a>    FOR(k, <span class="dv">0</span>, <span class="dv">4</span>) {</span>
<span id="cb43-63"><a aria-hidden="true" href="#cb43-63"></a>        <span class="dt">int</span> x = bad[<span class="dv">0</span>].first + fx[k], y = bad[<span class="dv">0</span>].second + fy[k];</span>
<span id="cb43-64"><a aria-hidden="true" href="#cb43-64"></a>        <span class="cf">if</span> (!bound(x, y)) <span class="cf">continue</span>;</span>
<span id="cb43-65"><a aria-hidden="true" href="#cb43-65"></a>        FOR(i, <span class="dv">1</span>, n) FOR(j, <span class="dv">1</span>, m) {</span>
<span id="cb43-66"><a aria-hidden="true" href="#cb43-66"></a>            <span class="dt">long</span> <span class="dt">long</span> hsh1 = ((<span class="dv">1</span><span class="bu">ll</span> * (x - <span class="dv">1</span>) * m + y) * (n * m)) + ((i - <span class="dv">1</span>) * m + j),</span>
<span id="cb43-67"><a aria-hidden="true" href="#cb43-67"></a>                    hsh2 = ((<span class="dv">1</span><span class="bu">ll</span> * (i - <span class="dv">1</span>) * m + j) * (n * m)) + ((x - <span class="dv">1</span>) * m + y);</span>
<span id="cb43-68"><a aria-hidden="true" href="#cb43-68"></a>            <span class="cf">if</span> (!S.count(hsh1) &amp;&amp; !S.count(hsh2)) ans += check(x, y, i, j), S.insert(hsh1), S.insert(hsh2);</span>
<span id="cb43-69"><a aria-hidden="true" href="#cb43-69"></a>        }</span>
<span id="cb43-70"><a aria-hidden="true" href="#cb43-70"></a>    }</span>
<span id="cb43-71"><a aria-hidden="true" href="#cb43-71"></a>    <span class="cf">if</span> (!ans) puts(<span class="st">"2"</span>);</span>
<span id="cb43-72"><a aria-hidden="true" href="#cb43-72"></a>    <span class="cf">else</span> printf(<span class="st">"1 </span><span class="sc">%d\n</span><span class="st">"</span>, ans);</span>
<span id="cb43-73"><a aria-hidden="true" href="#cb43-73"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb43-74"><a aria-hidden="true" href="#cb43-74"></a>}</span></code></pre></div>
<h2 id="codeforces-round-807-div-2.">Codeforces Round #807 (Div 2.)</h2>
<h3 id="f---mark-and-the-online-exam">1705F - Mark and the Online Exam</h3>
<p>题意：猜一个长度为 <span class="math inline">\(n\le 1000\)</span> 的 0-1 序列，最多猜 <span class="math inline">\(675\)</span> 次，交互库会返回猜对的位置数。</p>
<p><a href="https://www.luogu.com.cn/problem/T183641">原题</a>，<a href="https://www.luogu.com.cn/problem/P7848">原题</a>，<a href="https://www.luogu.com.cn/blog/1973224568qq/kao-shi-2021-coe-iii-d#">题解</a>，其对于 <span class="math inline">\(n=5000\)</span> 的限制为 <span class="math inline">\(q\le 1026\)</span>，即 <span class="math inline">\(n / \log n\)</span> 级别。</p>
<p>此处浅翻译一下官方题解的 <span class="math inline">\(q \approx 2/3n\)</span> 的做法。</p>
<p>首先预处理询问 <code>TTT...TTT</code> 和 <code>TFTFTF...TF</code>，然后对于 <span class="math inline">\(i= 1,2,\cdots, \lfloor n /3\rfloor\)</span>，我们可以轻松计算 <span class="math inline">\(2i - 1\)</span> 和 <span class="math inline">\(2i\)</span> 的答案，具体地我们将其设为 <code>F</code>，其他都是 <code>T</code>，然后算得的答案和全 <code>T</code> 的比较：</p>
<ul>
<li><span class="math inline">\(+2\)</span>，则两个都是 <code>F</code>。</li>
<li><span class="math inline">\(-1\)</span>，则两个都是 <code>T</code>。</li>
<li><span class="math inline">\(0\)</span>，则要么 <code>FT</code> 要么 <code>TR</code>。</li>
</ul>
<p>对于另外一种情况，我们可以用一次额外的询问来判断，即将其与 <code>TFTFTF...</code> 的比较： <span class="math display">\[
\begin{aligned}
\mathrm{TFTF}...\mathrm{TF}...\mathrm{T}...\mathrm{TF}\\
\mathrm{TFTF}...\mathrm{\color{red}FT}...\mathrm{\color{red}F}...\mathrm{TF}\\
\end{aligned}
\]</span></p>
<ul>
<li>答案为 <code>TFT</code>，则差距为 <span class="math inline">\(-3\)</span>；</li>
<li>答案为 <code>TFF</code>，则差距为 <span class="math inline">\(-1\)</span>；</li>
<li>答案为 <code>FTT</code>，则差距为 <span class="math inline">\(+1\)</span>；</li>
<li>答案为 <code>FTF</code>，则差距为 <span class="math inline">\(+3\)</span>；</li>
</ul>
<p>于是我们往右边多询问一位就可以得到答案了。解决 <span class="math inline">\(3\)</span> 个位置需要两个问题，所以 <span class="math inline">\(q\)</span> 的级别大概是 <span class="math inline">\(2/3q\)</span>，足以通过本题。</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb44-1"><a aria-hidden="true" href="#cb44-1"></a><span class="pp">#include </span><span class="im">&lt;bits/stdc++.h&gt;</span></span>
<span id="cb44-2"><a aria-hidden="true" href="#cb44-2"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb44-3"><a aria-hidden="true" href="#cb44-3"></a></span>
<span id="cb44-4"><a aria-hidden="true" href="#cb44-4"></a><span class="dt">int</span> n;</span>
<span id="cb44-5"><a aria-hidden="true" href="#cb44-5"></a></span>
<span id="cb44-6"><a aria-hidden="true" href="#cb44-6"></a><span class="dt">int</span> query(string s) {</span>
<span id="cb44-7"><a aria-hidden="true" href="#cb44-7"></a>    cout &lt;&lt; s &lt;&lt; endl;</span>
<span id="cb44-8"><a aria-hidden="true" href="#cb44-8"></a>    cout.flush();</span>
<span id="cb44-9"><a aria-hidden="true" href="#cb44-9"></a>    <span class="dt">int</span> x; cin &gt;&gt; x;</span>
<span id="cb44-10"><a aria-hidden="true" href="#cb44-10"></a>    <span class="cf">if</span> (x == n) puts(n &gt; <span class="dv">100</span> ? <span class="st">"sb"</span> : <span class="st">""</span>), exit(<span class="dv">0</span>);</span>
<span id="cb44-11"><a aria-hidden="true" href="#cb44-11"></a>    <span class="cf">return</span> x;</span>
<span id="cb44-12"><a aria-hidden="true" href="#cb44-12"></a>}</span>
<span id="cb44-13"><a aria-hidden="true" href="#cb44-13"></a></span>
<span id="cb44-14"><a aria-hidden="true" href="#cb44-14"></a><span class="dt">int</span> main() {</span>
<span id="cb44-15"><a aria-hidden="true" href="#cb44-15"></a>    cin &gt;&gt; n;</span>
<span id="cb44-16"><a aria-hidden="true" href="#cb44-16"></a>    string allT(n, <span class="ch">'T'</span>), ans(n, <span class="ch">'?'</span>);</span>
<span id="cb44-17"><a aria-hidden="true" href="#cb44-17"></a>    <span class="dt">int</span> cntT = query(allT);</span>
<span id="cb44-18"><a aria-hidden="true" href="#cb44-18"></a></span>
<span id="cb44-19"><a aria-hidden="true" href="#cb44-19"></a>    string allTF(n, <span class="ch">'T'</span>);</span>
<span id="cb44-20"><a aria-hidden="true" href="#cb44-20"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt; n; i += <span class="dv">2</span>) allTF[i] = <span class="ch">'F'</span>;</span>
<span id="cb44-21"><a aria-hidden="true" href="#cb44-21"></a>    <span class="dt">int</span> cntTF = query(allTF);</span>
<span id="cb44-22"><a aria-hidden="true" href="#cb44-22"></a></span>
<span id="cb44-23"><a aria-hidden="true" href="#cb44-23"></a>    <span class="dt">int</span> l = <span class="dv">0</span>, r = n - <span class="dv">1</span>;</span>
<span id="cb44-24"><a aria-hidden="true" href="#cb44-24"></a>    <span class="cf">while</span> (r &gt;= l) {</span>
<span id="cb44-25"><a aria-hidden="true" href="#cb44-25"></a>        <span class="cf">if</span> (r == l) {</span>
<span id="cb44-26"><a aria-hidden="true" href="#cb44-26"></a>            string s(allT);</span>
<span id="cb44-27"><a aria-hidden="true" href="#cb44-27"></a>            s[l] = <span class="ch">'F'</span>;</span>
<span id="cb44-28"><a aria-hidden="true" href="#cb44-28"></a>            <span class="dt">int</span> k = query(s);</span>
<span id="cb44-29"><a aria-hidden="true" href="#cb44-29"></a>            <span class="cf">if</span> (k &gt; cntT) ans[l] = <span class="ch">'F'</span>;</span>
<span id="cb44-30"><a aria-hidden="true" href="#cb44-30"></a>            <span class="cf">else</span> ans[l] = <span class="ch">'T'</span>;</span>
<span id="cb44-31"><a aria-hidden="true" href="#cb44-31"></a>            ++l, --r;</span>
<span id="cb44-32"><a aria-hidden="true" href="#cb44-32"></a>        } <span class="cf">else</span> {</span>
<span id="cb44-33"><a aria-hidden="true" href="#cb44-33"></a>            string s(allT);</span>
<span id="cb44-34"><a aria-hidden="true" href="#cb44-34"></a>            s[l] = <span class="ch">'F'</span>, s[l + <span class="dv">1</span>] = <span class="ch">'F'</span>;</span>
<span id="cb44-35"><a aria-hidden="true" href="#cb44-35"></a>            <span class="dt">int</span> k = query(s) - cntT;</span>
<span id="cb44-36"><a aria-hidden="true" href="#cb44-36"></a>            <span class="cf">if</span> (k == <span class="dv">2</span>) {</span>
<span id="cb44-37"><a aria-hidden="true" href="#cb44-37"></a>                ans[l] = ans[l + <span class="dv">1</span>] = <span class="ch">'F'</span>;</span>
<span id="cb44-38"><a aria-hidden="true" href="#cb44-38"></a>                l += <span class="dv">2</span>;</span>
<span id="cb44-39"><a aria-hidden="true" href="#cb44-39"></a>            } <span class="cf">else</span> <span class="cf">if</span> (k == -<span class="dv">2</span>) {</span>
<span id="cb44-40"><a aria-hidden="true" href="#cb44-40"></a>                ans[l] = ans[l + <span class="dv">1</span>] = <span class="ch">'T'</span>;</span>
<span id="cb44-41"><a aria-hidden="true" href="#cb44-41"></a>                l += <span class="dv">2</span>;</span>
<span id="cb44-42"><a aria-hidden="true" href="#cb44-42"></a>            } <span class="cf">else</span> {</span>
<span id="cb44-43"><a aria-hidden="true" href="#cb44-43"></a>                <span class="cf">if</span> (r == l + <span class="dv">1</span>) {</span>
<span id="cb44-44"><a aria-hidden="true" href="#cb44-44"></a>                    s = allT, s[l] = <span class="ch">'F'</span>;</span>
<span id="cb44-45"><a aria-hidden="true" href="#cb44-45"></a>                    <span class="dt">int</span> k = query(s);</span>
<span id="cb44-46"><a aria-hidden="true" href="#cb44-46"></a>                    <span class="cf">if</span> (k &gt; cntT) ans[l] = <span class="ch">'F'</span>, ans[l + <span class="dv">1</span>] = <span class="ch">'T'</span>;</span>
<span id="cb44-47"><a aria-hidden="true" href="#cb44-47"></a>                    <span class="cf">else</span> ans[l] = <span class="ch">'T'</span>, ans[l + <span class="dv">1</span>] = <span class="ch">'F'</span>;</span>
<span id="cb44-48"><a aria-hidden="true" href="#cb44-48"></a>                    l += <span class="dv">2</span>;</span>
<span id="cb44-49"><a aria-hidden="true" href="#cb44-49"></a>                } <span class="cf">else</span> {</span>
<span id="cb44-50"><a aria-hidden="true" href="#cb44-50"></a>                    s = allTF;</span>
<span id="cb44-51"><a aria-hidden="true" href="#cb44-51"></a>                    s[l] = <span class="ch">'F'</span>, s[l + <span class="dv">1</span>] = <span class="ch">'T'</span>;</span>
<span id="cb44-52"><a aria-hidden="true" href="#cb44-52"></a>                    <span class="cf">if</span> (s[r] == <span class="ch">'F'</span>) s[r] = <span class="ch">'T'</span>;</span>
<span id="cb44-53"><a aria-hidden="true" href="#cb44-53"></a>                    <span class="cf">else</span> s[r] = <span class="ch">'F'</span>;</span>
<span id="cb44-54"><a aria-hidden="true" href="#cb44-54"></a></span>
<span id="cb44-55"><a aria-hidden="true" href="#cb44-55"></a>                    <span class="dt">int</span> k = query(s) - cntTF;</span>
<span id="cb44-56"><a aria-hidden="true" href="#cb44-56"></a>                    <span class="cf">if</span> (k == <span class="dv">3</span>) ans[l] = <span class="ch">'F'</span>, ans[l + <span class="dv">1</span>] = <span class="ch">'T'</span>, ans[r] = s[r];</span>
<span id="cb44-57"><a aria-hidden="true" href="#cb44-57"></a>                    <span class="cf">else</span> <span class="cf">if</span> (k == <span class="dv">1</span>) ans[l] = <span class="ch">'F'</span>, ans[l + <span class="dv">1</span>] = <span class="ch">'T'</span>, ans[r] = allTF[r];</span>
<span id="cb44-58"><a aria-hidden="true" href="#cb44-58"></a>                    <span class="cf">else</span> <span class="cf">if</span> (k == -<span class="dv">1</span>) ans[l] = <span class="ch">'T'</span>, ans[l + <span class="dv">1</span>] = <span class="ch">'F'</span>, ans[r] = s[r];</span>
<span id="cb44-59"><a aria-hidden="true" href="#cb44-59"></a>                    <span class="cf">else</span> ans[l] = <span class="ch">'T'</span>, ans[l + <span class="dv">1</span>] = <span class="ch">'F'</span>, ans[r] = allTF[r];</span>
<span id="cb44-60"><a aria-hidden="true" href="#cb44-60"></a></span>
<span id="cb44-61"><a aria-hidden="true" href="#cb44-61"></a>                    l += <span class="dv">2</span>, --r;</span>
<span id="cb44-62"><a aria-hidden="true" href="#cb44-62"></a>                }</span>
<span id="cb44-63"><a aria-hidden="true" href="#cb44-63"></a>            }</span>
<span id="cb44-64"><a aria-hidden="true" href="#cb44-64"></a>        }</span>
<span id="cb44-65"><a aria-hidden="true" href="#cb44-65"></a>    }</span>
<span id="cb44-66"><a aria-hidden="true" href="#cb44-66"></a>    query(ans);</span>
<span id="cb44-67"><a aria-hidden="true" href="#cb44-67"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb44-68"><a aria-hidden="true" href="#cb44-68"></a>}</span></code></pre></div>
<h2 id="codeton-round-2">CodeTON Round 2</h2>
<h3 id="f---colouring-game">1704F - Colouring Game</h3>
<p>在有 <code>RB</code> 和 <code>BR</code> 的时候，双方策略都是先直接去消这个，因为这样能尽可能消耗对面的字母。</p>
<p>然后没有相邻红蓝方格之后，这个肯定就是后手必胜了。所以只考虑第一阶段，公平组合游戏，求 SG，打表</p>
<h2 id="codeforces-round-813-div.-2">Codeforces Round #813 (Div. 2)</h2>
<h3 id="e2---lcm-sum-hard-version">1712E2 - LCM Sum (hard version)</h3>
<p>题意：问满足 <span class="math inline">\(l\le i&lt; j &lt; k\le r\)</span> 且 <span class="math inline">\(\operatorname{lcm}(i,j,k)\ge i + j + k\)</span> 的 <span class="math inline">\((i,j,k)\)</span> 对数。<span class="math inline">\(T\le 2\times 10^5\)</span> 组询问，<span class="math inline">\(l,r\le 2\times 10^5\)</span>。</p>
<p>考虑 E1，即 <span class="math inline">\(T\)</span> 很小的情况。首先转化为数 <span class="math inline">\([i,j,k] &lt; i + j +k\)</span> 的情况，而这样的 <span class="math inline">\([i,j,k]\)</span> 显然 <span class="math inline">\(&lt; 3k\)</span>，所以取值只能为 <span class="math inline">\(k\)</span> 或 <span class="math inline">\(2k\)</span>。那么考虑枚举 <span class="math inline">\(k\)</span>，则 <span class="math inline">\([i,j,k] = k\)</span> 的情况很好处理，即 <span class="math inline">\(i,j\)</span> 需要为 <span class="math inline">\(k\)</span> 的因数，此时显然 <span class="math inline">\(k&lt;i + j + k\)</span>，可以 <span class="math inline">\(O(n\log n)\)</span> 计算。</p>
<p>对于 <span class="math inline">\(\operatorname{lcm} = 2k\)</span> 的情况，<span class="math inline">\(i,j,k\)</span> 只可能形如 <span class="math inline">\(3t,4t,6t\)</span> 或者 <span class="math inline">\(6t, 10t, 15t\)</span> 的形式（打表可以发现），下面给出证明：</p>
<p>因为 <span class="math inline">\(i+j &gt; k \land i &lt; j\)</span>，所以 <span class="math inline">\(j &gt; k / 2\)</span>，设 <span class="math inline">\(2k = j\times p\)</span>，所以 <span class="math inline">\(k/2 &lt; 2k/p &lt; k\)</span>，解得 <span class="math inline">\(2&lt;p&lt;4\)</span>，故 <span class="math inline">\(p = 3\)</span>，<span class="math inline">\(j = 2k/3\)</span>。由 <span class="math inline">\(i + j &gt; k\)</span>，<span class="math inline">\(i &gt; k / 3\)</span>，设 <span class="math inline">\(2k = i \times q\)</span>，则 <span class="math inline">\(k / 3 &lt; 2k/q &lt; k\)</span>，解得 <span class="math inline">\(3&lt;q&lt;6\)</span>，故 <span class="math inline">\(q= 4\)</span> 或 <span class="math inline">\(5\)</span>，对应的 <span class="math inline">\(i = k / 2\)</span> 或 <span class="math inline">\(2k / 5\)</span>。证毕。</p>
<p>所以对于 <span class="math inline">\(15\mid k\)</span> 和 <span class="math inline">\(6\mid k\)</span> 的时候，特判一下即可。</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb45-1"><a aria-hidden="true" href="#cb45-1"></a><span class="pp">#include </span><span class="im">&lt;bits/stdc++.h&gt;</span></span>
<span id="cb45-2"><a aria-hidden="true" href="#cb45-2"></a><span class="pp">#define il </span><span class="kw">inline</span></span>
<span id="cb45-3"><a aria-hidden="true" href="#cb45-3"></a><span class="pp">#define FOR</span>(i,<span class="pp"> </span>a,<span class="pp"> </span>b)<span class="pp"> </span><span class="cf">for</span><span class="pp"> </span>(<span class="dt">int</span><span class="pp"> </span>i<span class="pp"> </span>=<span class="pp"> </span>(a);<span class="pp"> </span>i<span class="pp"> </span>&lt;=<span class="pp"> </span>(b);<span class="pp"> </span>++i)</span>
<span id="cb45-4"><a aria-hidden="true" href="#cb45-4"></a><span class="pp">#define szof</span>(a)<span class="pp"> </span>((<span class="dt">int</span>)<span class="pp"> </span>(a).size())</span>
<span id="cb45-5"><a aria-hidden="true" href="#cb45-5"></a></span>
<span id="cb45-6"><a aria-hidden="true" href="#cb45-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb45-7"><a aria-hidden="true" href="#cb45-7"></a><span class="kw">using</span> ll = <span class="dt">long</span> <span class="dt">long</span>;</span>
<span id="cb45-8"><a aria-hidden="true" href="#cb45-8"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">4e5</span> + <span class="dv">5</span>, N = <span class="fl">4e5</span>;</span>
<span id="cb45-9"><a aria-hidden="true" href="#cb45-9"></a>vector&lt;<span class="dt">int</span>&gt; fact[maxn];</span>
<span id="cb45-10"><a aria-hidden="true" href="#cb45-10"></a></span>
<span id="cb45-11"><a aria-hidden="true" href="#cb45-11"></a>ll binom(<span class="dt">int</span> n) {<span class="cf">return</span> (n - <span class="dv">2</span><span class="bu">ll</span>) * (n - <span class="dv">1</span><span class="bu">ll</span>) * n / <span class="dv">6</span>;}</span>
<span id="cb45-12"><a aria-hidden="true" href="#cb45-12"></a></span>
<span id="cb45-13"><a aria-hidden="true" href="#cb45-13"></a>ll solve(<span class="dt">int</span> l, <span class="dt">int</span> r) { <span class="co">// count lcm(i, j, k) &lt; i + j + k</span></span>
<span id="cb45-14"><a aria-hidden="true" href="#cb45-14"></a>    ll ret = <span class="dv">0</span>;</span>
<span id="cb45-15"><a aria-hidden="true" href="#cb45-15"></a>    FOR(k, l + <span class="dv">2</span>, r) {</span>
<span id="cb45-16"><a aria-hidden="true" href="#cb45-16"></a>        <span class="dt">int</span> cnt = <span class="dv">0</span>;</span>
<span id="cb45-17"><a aria-hidden="true" href="#cb45-17"></a>        <span class="cf">for</span> (<span class="dt">int</span> x : fact[k]) <span class="cf">if</span> (x &gt;= l &amp;&amp; x &lt; k) ++cnt;</span>
<span id="cb45-18"><a aria-hidden="true" href="#cb45-18"></a>        ret += cnt * (cnt - <span class="dv">1</span><span class="bu">ll</span>) / <span class="dv">2</span>; <span class="co">// lcm = k</span></span>
<span id="cb45-19"><a aria-hidden="true" href="#cb45-19"></a>        <span class="cf">if</span> (k % <span class="dv">6</span> == <span class="dv">0</span> &amp;&amp; k / <span class="dv">2</span> &gt;= l) ++ret;</span>
<span id="cb45-20"><a aria-hidden="true" href="#cb45-20"></a>        <span class="cf">if</span> (k % <span class="dv">15</span> == <span class="dv">0</span> &amp;&amp; k * <span class="dv">2</span> / <span class="dv">5</span> &gt;= l) ++ret; <span class="co">// lcm = 2k</span></span>
<span id="cb45-21"><a aria-hidden="true" href="#cb45-21"></a>    }</span>
<span id="cb45-22"><a aria-hidden="true" href="#cb45-22"></a>    <span class="cf">return</span> ret;</span>
<span id="cb45-23"><a aria-hidden="true" href="#cb45-23"></a>}</span>
<span id="cb45-24"><a aria-hidden="true" href="#cb45-24"></a></span>
<span id="cb45-25"><a aria-hidden="true" href="#cb45-25"></a><span class="dt">int</span> main() {</span>
<span id="cb45-26"><a aria-hidden="true" href="#cb45-26"></a>    FOR(i, <span class="dv">1</span>, N) <span class="cf">for</span> (<span class="dt">int</span> j = i; j &lt;= N; j += i) fact[j].emplace_back(i);</span>
<span id="cb45-27"><a aria-hidden="true" href="#cb45-27"></a>    <span class="dt">int</span> T; cin &gt;&gt; T;</span>
<span id="cb45-28"><a aria-hidden="true" href="#cb45-28"></a>    <span class="cf">while</span> (T--) {</span>
<span id="cb45-29"><a aria-hidden="true" href="#cb45-29"></a>        <span class="dt">int</span> l, r; cin &gt;&gt; l &gt;&gt; r;</span>
<span id="cb45-30"><a aria-hidden="true" href="#cb45-30"></a>        cout &lt;&lt; binom(r - l + <span class="dv">1</span>) - solve(l, r) &lt;&lt; endl;</span>
<span id="cb45-31"><a aria-hidden="true" href="#cb45-31"></a>    }</span>
<span id="cb45-32"><a aria-hidden="true" href="#cb45-32"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb45-33"><a aria-hidden="true" href="#cb45-33"></a>}</span></code></pre></div>
<p>对于 E2，我们将上面这个过程离线下来扫描线即可，倒序枚举 <span class="math inline">\(l\)</span>，维护 <span class="math inline">\(r\)</span> 的答案。相当于我们其实需要维护因数集合的大小，发现 <span class="math inline">\(x(x-1)/2\)</span> 和 <span class="math inline">\((x+1)x/2\)</span> 之间相差 <span class="math inline">\(x\)</span>，所以用树状数组还是比较好维护的。而对于 <span class="math inline">\(\operatorname{lcm} = 2k\)</span> 的情况，因为我们枚举的是 <span class="math inline">\(i\)</span>，所以在 <span class="math inline">\(3\mid i\)</span> 和 <span class="math inline">\(6\mid i\)</span> 的时候判一下就可以了。</p>
<h2 id="codeforces-round-815-div.-2">Codeforces Round #815 (Div. 2)</h2>
<p>A FST 了，本来能打出 2400+ 的 perf 的 <img src="https://啧.tk/tuu"/>。</p>
<h3 id="e---misha-and-paintings">1720E - Misha and Paintings</h3>
<p>有一个 <span class="math inline">\(n\times n\)</span> 的矩阵，<span class="math inline">\(n\le 500\)</span>，每个位置有一个值 <span class="math inline">\(v\)</span>，且 <span class="math inline">\(1\le v\le n^2\)</span>，每次操作可以选择一个子方阵然后直接染色，要求 <span class="math inline">\(1\le x\le n^2\)</span>。现在给定一个 <span class="math inline">\(k\)</span>，问最少多少次操作使得矩阵中不同的数刚好有 <span class="math inline">\(k\)</span> 个。</p>
<p>首先，设一开始有 <span class="math inline">\(m\)</span> 种不同的数，则若 <span class="math inline">\(m \le k\)</span>，则显然答案为 <span class="math inline">\(k - m\)</span>。</p>
<p>现在考虑 <span class="math inline">\(k &lt; m\)</span> 的情况，下面给出答案不超过 <span class="math inline">\(2\)</span> 的构造证明。</p>
<ul>
<li><p>选一个长度为 <span class="math inline">\(L\)</span> 的尽可能大的正方形，将里面全部涂为一个未出现的颜色，使得现在不同的数恰 <span class="math inline">\(\ge k\)</span> 个。</p></li>
<li><p>然后这个正方形的右下角开始（相当于 <span class="math inline">\((L + 1, L + 1)\)</span> 扩展），涂为一个未出现的颜色，使得现在不同的数恰 <span class="math inline">\(\le k\)</span> 个。</p>
<p>容易发现这样相当于一次扩展两格，最后不同的数只可能有 <span class="math inline">\(k\)</span> 个或 <span class="math inline">\(k - 1\)</span> 个，对于后者我们把涂的颜色变为一个已出现的即可。</p></li>
</ul>
<p>于是只需要判断答案是否为 <span class="math inline">\(1\)</span>。于是需要对于 <span class="math inline">\(O(n^3)\)</span> 个正方形找到其完全包含了多少数字，这个可以用二维前缀和什么的处理一下。总时间复杂度 <span class="math inline">\(O(n^3)\)</span>。</p>
</section>
<footer class="article-footer">
<section class="article-tags">
<a href="/tags/Codeforces/">Codeforces</a>
<a href="/tags/OI/">OI</a>
<a href="/tags/solution/">解题报告</a>
<a href="/tags/implementation/">模拟</a>
<a href="/tags/constructive/">构造</a>
<a href="/tags/greedy/">贪心</a>
<a href="/tags/game-theory/">博弈论</a>
<a href="/tags/dp/">动态规划</a>
<a href="/tags/combinatorics/">组合数学</a>
<a href="/tags/gf/">生成函数</a>
<a href="/tags/segtree/">线段树</a>
<a href="/tags/bi-graph/">二分图</a>
<a href="/tags/binary-search/">二分答案</a>
<a href="/tags/toposort/">拓扑排序</a>
<a href="/tags/scc/">强连通分量</a>
<a href="/tags/lld/">长链剖分</a>
<a href="/tags/number-theory/">数论</a>
<a href="/tags/sqrt-division/">根号分治</a>
</section>
<section class="article-copyright">
<svg class="icon icon-tabler icon-tabler-copyright" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<circle cx="12" cy="12" r="9"></circle>
<path d="M14.5 9a3.5 4 0 1 0 0 6"></path>
</svg>
<span>Licensed under CC BY-NC-SA 4.0</span>
</section>
</footer>
<link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css" integrity="sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn" rel="stylesheet"/><script crossorigin="anonymous" defer="" integrity="sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8" src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js">
</script><script crossorigin="anonymous" defer="" integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js">
</script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.querySelector(`.article-content`), {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ]
        });})
</script>
</article>
<aside class="related-contents--wrapper">
<h2 class="section-title">相关文章</h2>
<div class="related-contents">
<div class="flex article-list--tile">
<article class="has-image">
<a href="/summary-atcoder/">
<div class="article-image">
<img data-hash="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg70.webp" data-key="" loading="lazy" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg70.webp"/>
</div>
<div class="article-details">
<h2 class="article-title">AtCoder 比赛日记</h2>
</div>
</a>
</article>
<article class="has-image">
<a href="/sol-cf431d/">
<div class="article-image">
<img data-hash="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg66.webp" data-key="" loading="lazy" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg66.webp"/>
</div>
<div class="article-details">
<h2 class="article-title">CF431D Random Task</h2>
</div>
</a>
</article>
<article class="has-image">
<a href="/sol-agc010e/">
<div class="article-image">
<img data-hash="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg41.webp" data-key="" loading="lazy" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg41.webp"/>
</div>
<div class="article-details">
<h2 class="article-title">AGC010E - Rearranging</h2>
</div>
</a>
</article>
<article class="has-image">
<a href="/sol-loj2838/">
<div class="article-image">
<img data-hash="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg23.webp" data-key="" loading="lazy" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg23.webp"/>
</div>
<div class="article-details">
<h2 class="article-title">LOJ#2838. 「JOISC 2018 Day 3」比太郎的聚会</h2>
</div>
</a>
</article>
<article class="has-image">
<a href="/sol-past-noip/">
<div class="article-image">
<img data-hash="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg35.webp" data-key="" loading="lazy" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg35.webp"/>
</div>
<div class="article-details">
<h2 class="article-title">历年联赛真题选做</h2>
</div>
</a>
</article>
</div>
</div>
</aside>
<footer class="site-footer">
<section class="copyright">
        © 
        
            2019 - 
        
        2024 清烛的博客
    </section>
<section class="powerby">
        Built with <a href="https://gohugo.io/" rel="noopener" target="_blank">Hugo</a> <br/>
        主题 <b><a data-version="3.11.0" href="https://github.com/CaiJimmy/hugo-theme-stack" rel="noopener" target="_blank">Stack</a></b> 由 <a href="https://jimmycai.com" rel="noopener" target="_blank">Jimmy</a> 设计
    </section>
</footer>
<div aria-hidden="true" class="pswp" role="dialog" tabindex="-1">
<div class="pswp__bg"></div>
<div class="pswp__scroll-wrap">
<div class="pswp__container">
<div class="pswp__item"></div>
<div class="pswp__item"></div>
<div class="pswp__item"></div>
</div>
<div class="pswp__ui pswp__ui--hidden">
<div class="pswp__top-bar">
<div class="pswp__counter"></div>
<button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title="Share"></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
<div class="pswp__preloader">
<div class="pswp__preloader__icn">
<div class="pswp__preloader__cut">
<div class="pswp__preloader__donut"></div>
</div>
</div>
</div>
</div>
<div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
<div class="pswp__share-tooltip"></div>
</div>
<button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
</button>
<div class="pswp__caption">
<div class="pswp__caption__center"></div>
</div>
</div>
</div>
</div><script crossorigin="anonymous" defer="" integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js">
</script><script crossorigin="anonymous" defer="" integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js">
</script><link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css" integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" rel="stylesheet"/><link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css" integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" rel="stylesheet"/>
</main>
</div>
<script crossorigin="anonymous" integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js">
</script><script defer="" src="/ts/main.js" type="text/javascript"></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>
</body>
</html>

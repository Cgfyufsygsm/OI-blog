<!DOCTYPE html>
<html dir="ltr" lang="zh-CN">
<head><meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/><meta content="前言 省选/NOI 的个人复习资料。
全凭个人喜好来搞。
不会写的很严谨，实战导向型。
线段树基础 线段树简介 定义 建立在长度为 \(n\) 的一维序列上的树形数据结构。每个节点表示一段区间，\(n\) 个叶子节点对应长度为 \(1\) 的区间。非叶节点均有两个孩子节点，且其表示的区间为两个孩子节点的并。
标准的线段树要求 \([l, r]\) 节点的左儿子为 \([l, m]\)，右儿子为 \((m, r]\)，其中 \(m = \lfloor\frac{l + r}2\rfloor\)。而广义线段树的 \(m\) 可以为 \([l, r)\) 中任意整数。下面只讨论标准线段树。
可以注意到，线段树上每个节点表示的区间要么包含要么不交，而每个区间都可以表示为若干个线段树上区间的并，且其为 \(O(\log n)\) 级别的。这里就不严谨证明了。
线段树可以维护满足结合律的信息，例如区间和/积/最大公因数/最值。不满足结合律的例子有区间众数等。
即我们维护的是满足半群性质（封闭性，结合律，存在单位元）的信息。
线段树的一个节点 \([l, r]\) 上维护的信息 \(f([l, r])\) 一般可以由其两个儿子节点（如果有的话）经过简单运算合并得到。
同时，根据区间拆分的性质，我们可以使用线段树来进行区间的修改/查询操作。
递归式实现 我们将线段树的节点按照层级从左到右编号便会发现一个很好的性质：对于编号为 \(k\) 的节点，其左儿子的编号为 \(2k\)，右儿子的编号为 \(2k + 1\)。于是我们就可以通过一个递归的过程从上而下拆分整个区间。
具体来说，我们一般开 \(4\) 倍的存储空间。
可以发现，这个想法很自然，很好理解，也不容易出错。速度在一般情况下够用，并且适用范围比非递归式的要广。
非递归式实现（zkw 线段树） 注意到，递归式线段树的常数较大，于是非递归式的实现在一部分对常数要求高的场景就发挥出了其优势，其有一定的局限性。参考 清华大学 张昆玮 《统计的力量》。
优势：速度快，码量小。劣势：不如递归式的直观，不支持绝对标记（下文会提到）。
首先为了方便，需要将序列长度扩展为 \(2^k\)，使得线段树为一满二叉树，这样就能方便找到叶子节点的编号。
int t[maxn &amp;lt;&amp;lt; 2]; // 与递归式无异 int n, N = 1; // n 为序列原本的长度，N 为扩展 然后建树的过程如下：" name="description"/><title>数据结构复习 1 （简单树形数据结构）</title>
<link href="https://oi.imyangty.com/summary-ds1/" rel="canonical"/>
<link href="/scss/style.min.a5821f3d3ab84ce5a0ac21477e347a2e0ca00292e398d16c5e8e36ded6e35a23.css" rel="stylesheet"/><meta content="数据结构复习 1 （简单树形数据结构）" property="og:title"/>
<meta content="前言 省选/NOI 的个人复习资料。
全凭个人喜好来搞。
不会写的很严谨，实战导向型。
线段树基础 线段树简介 定义 建立在长度为 \(n\) 的一维序列上的树形数据结构。每个节点表示一段区间，\(n\) 个叶子节点对应长度为 \(1\) 的区间。非叶节点均有两个孩子节点，且其表示的区间为两个孩子节点的并。
标准的线段树要求 \([l, r]\) 节点的左儿子为 \([l, m]\)，右儿子为 \((m, r]\)，其中 \(m = \lfloor\frac{l + r}2\rfloor\)。而广义线段树的 \(m\) 可以为 \([l, r)\) 中任意整数。下面只讨论标准线段树。
可以注意到，线段树上每个节点表示的区间要么包含要么不交，而每个区间都可以表示为若干个线段树上区间的并，且其为 \(O(\log n)\) 级别的。这里就不严谨证明了。
线段树可以维护满足结合律的信息，例如区间和/积/最大公因数/最值。不满足结合律的例子有区间众数等。
即我们维护的是满足半群性质（封闭性，结合律，存在单位元）的信息。
线段树的一个节点 \([l, r]\) 上维护的信息 \(f([l, r])\) 一般可以由其两个儿子节点（如果有的话）经过简单运算合并得到。
同时，根据区间拆分的性质，我们可以使用线段树来进行区间的修改/查询操作。
递归式实现 我们将线段树的节点按照层级从左到右编号便会发现一个很好的性质：对于编号为 \(k\) 的节点，其左儿子的编号为 \(2k\)，右儿子的编号为 \(2k + 1\)。于是我们就可以通过一个递归的过程从上而下拆分整个区间。
具体来说，我们一般开 \(4\) 倍的存储空间。
可以发现，这个想法很自然，很好理解，也不容易出错。速度在一般情况下够用，并且适用范围比非递归式的要广。
非递归式实现（zkw 线段树） 注意到，递归式线段树的常数较大，于是非递归式的实现在一部分对常数要求高的场景就发挥出了其优势，其有一定的局限性。参考 清华大学 张昆玮 《统计的力量》。
优势：速度快，码量小。劣势：不如递归式的直观，不支持绝对标记（下文会提到）。
首先为了方便，需要将序列长度扩展为 \(2^k\)，使得线段树为一满二叉树，这样就能方便找到叶子节点的编号。
int t[maxn &amp;lt;&amp;lt; 2]; // 与递归式无异 int n, N = 1; // n 为序列原本的长度，N 为扩展 然后建树的过程如下：" property="og:description"/>
<meta content="https://oi.imyangty.com/summary-ds1/" property="og:url"/>
<meta content="清烛的博客" property="og:site_name"/>
<meta content="article" property="og:type"/><meta content="Post" property="article:section"/><meta content="OI" property="article:tag"/><meta content="笔记" property="article:tag"/><meta content="2022-02-07T20:17:02+08:00" property="article:published_time"/><meta content="2022-02-07T20:17:02+08:00" property="article:modified_time"/><meta content="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg5.webp" property="og:image"/>
<meta content="数据结构复习 1 （简单树形数据结构）" name="twitter:title"/>
<meta content="前言 省选/NOI 的个人复习资料。
全凭个人喜好来搞。
不会写的很严谨，实战导向型。
线段树基础 线段树简介 定义 建立在长度为 \(n\) 的一维序列上的树形数据结构。每个节点表示一段区间，\(n\) 个叶子节点对应长度为 \(1\) 的区间。非叶节点均有两个孩子节点，且其表示的区间为两个孩子节点的并。
标准的线段树要求 \([l, r]\) 节点的左儿子为 \([l, m]\)，右儿子为 \((m, r]\)，其中 \(m = \lfloor\frac{l + r}2\rfloor\)。而广义线段树的 \(m\) 可以为 \([l, r)\) 中任意整数。下面只讨论标准线段树。
可以注意到，线段树上每个节点表示的区间要么包含要么不交，而每个区间都可以表示为若干个线段树上区间的并，且其为 \(O(\log n)\) 级别的。这里就不严谨证明了。
线段树可以维护满足结合律的信息，例如区间和/积/最大公因数/最值。不满足结合律的例子有区间众数等。
即我们维护的是满足半群性质（封闭性，结合律，存在单位元）的信息。
线段树的一个节点 \([l, r]\) 上维护的信息 \(f([l, r])\) 一般可以由其两个儿子节点（如果有的话）经过简单运算合并得到。
同时，根据区间拆分的性质，我们可以使用线段树来进行区间的修改/查询操作。
递归式实现 我们将线段树的节点按照层级从左到右编号便会发现一个很好的性质：对于编号为 \(k\) 的节点，其左儿子的编号为 \(2k\)，右儿子的编号为 \(2k + 1\)。于是我们就可以通过一个递归的过程从上而下拆分整个区间。
具体来说，我们一般开 \(4\) 倍的存储空间。
可以发现，这个想法很自然，很好理解，也不容易出错。速度在一般情况下够用，并且适用范围比非递归式的要广。
非递归式实现（zkw 线段树） 注意到，递归式线段树的常数较大，于是非递归式的实现在一部分对常数要求高的场景就发挥出了其优势，其有一定的局限性。参考 清华大学 张昆玮 《统计的力量》。
优势：速度快，码量小。劣势：不如递归式的直观，不支持绝对标记（下文会提到）。
首先为了方便，需要将序列长度扩展为 \(2^k\)，使得线段树为一满二叉树，这样就能方便找到叶子节点的编号。
int t[maxn &amp;lt;&amp;lt; 2]; // 与递归式无异 int n, N = 1; // n 为序列原本的长度，N 为扩展 然后建树的过程如下：" name="twitter:description"/><meta content="summary_large_image" name="twitter:card"/>
<meta content="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg5.webp" name="twitter:image"/>
<link href="https://q1.qlogo.cn/g?b=qq&amp;nk=375836877&amp;s=5" rel="shortcut icon"/>
<link href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/styles/github-dark-dimmed.min.css" rel="stylesheet"/>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
</head>
<body class="article-page">
<script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky">
<button aria-label="切换菜单" class="hamburger hamburger--spin" id="toggle-menu" type="button">
<span class="hamburger-box">
<span class="hamburger-inner"></span>
</span>
</button>
<header>
<figure class="site-avatar">
<a href="/">
<img alt="Avatar" class="site-logo" height="300" loading="lazy" src="/img/avatar_huea3ce2119467b51fdd2a81393644a76d_51594_300x0_resize_q75_box.jpg" width="300"/>
</a>
<span class="emoji">😅</span>
</figure>
<div class="site-meta">
<h1 class="site-name"><a href="/">清烛的博客</a></h1>
<h2 class="site-description">烟火已谢，笙歌未停</h2>
</div>
</header><ol class="social-menu">
<li>
<a href="mailto:i@imyangty.com" target="_blank" title="email">
<svg class="icon icon-tabler icon-tabler-mail" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
<rect height="14" rx="2" width="18" x="3" y="5"></rect>
<polyline points="3 7 12 13 21 7"></polyline>
</svg>
</a>
</li>
<li>
<a href="https://github.com/Cgfyufsygsm" target="_blank" title="GitHub">
<svg class="icon icon-tabler icon-tabler-brand-github" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
<path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5"></path>
</svg>
</a>
</li>
<li>
<a href="https://t.me/Cgfyufsygsm" target="_blank" title="Telegram">
<svg class="icon icon-tabler icon-tabler-brand-telegram" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
<path d="M15 10l-4 4l6 6l4 -16l-18 7l4 2l2 6l3 -4"></path>
</svg>
</a>
</li>
<li>
<a href="https://twitter.com/Cgfyufsygsm" target="_blank" title="Twitter">
<svg class="icon icon-tabler icon-tabler-brand-twitter" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
<path d="M22 4.01c-1 .49 -1.98 .689 -3 .99c-1.121 -1.265 -2.783 -1.335 -4.38 -.737s-2.643 2.06 -2.62 3.737v1c-3.245 .083 -6.135 -1.395 -8 -4c0 0 -4.182 7.433 4 11c-1.872 1.247 -3.739 2.088 -6 2c3.308 1.803 6.913 2.423 10.034 1.517c3.58 -1.04 6.522 -3.723 7.651 -7.742a13.84 13.84 0 0 0 .497 -3.753c-.002 -.249 1.51 -2.772 1.818 -4.013z"></path>
</svg>
</a>
</li>
</ol><ol class="menu" id="main-menu">
<li>
<a href="/">
<svg class="icon icon-tabler icon-tabler-home" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<polyline points="5 12 3 12 12 3 21 12 19 12"></polyline>
<path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7"></path>
<path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6"></path>
</svg>
<span>主页</span>
</a>
</li>
<li>
<a href="/about/">
<svg class="icon icon-tabler icon-tabler-user" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<circle cx="12" cy="7" r="4"></circle>
<path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2"></path>
</svg>
<span>关于</span>
</a>
</li>
<li>
<a href="/idx/">
<svg class="icon icon-tabler icon-tabler-hash" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<line x1="5" x2="19" y1="9" y2="9"></line>
<line x1="5" x2="19" y1="15" y2="15"></line>
<line x1="11" x2="7" y1="4" y2="20"></line>
<line x1="17" x2="13" y1="4" y2="20"></line>
</svg>
<span>导航</span>
</a>
</li>
<li>
<a href="/archives/">
<svg class="icon icon-tabler icon-tabler-archive" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<rect height="4" rx="2" width="18" x="3" y="4"></rect>
<path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10"></path>
<line x1="10" x2="14" y1="12" y2="12"></line>
</svg>
<span>归档</span>
</a>
</li>
<li>
<a href="/search/">
<svg class="icon icon-tabler icon-tabler-search" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<circle cx="10" cy="10" r="7"></circle>
<line x1="21" x2="15" y1="21" y2="15"></line>
</svg>
<span>搜索</span>
</a>
</li>
<li>
<a href="/friends/">
<svg class="icon icon-tabler icon-tabler-link" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5"></path>
<path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5"></path>
</svg>
<span>友链</span>
</a>
</li>
<li>
<a href="https://blog.imyangty.com" target="_blank">
<svg class="icon icon-tabler icon-tabler-home" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<polyline points="5 12 3 12 12 3 21 12 19 12"></polyline>
<path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7"></path>
<path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6"></path>
</svg>
<span>主博客</span>
</a>
</li>
<div class="menu-bottom-section">
<li id="dark-mode-toggle">
<svg class="icon icon-tabler icon-tabler-toggle-left" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<circle cx="8" cy="12" r="2"></circle>
<rect height="12" rx="6" width="20" x="2" y="6"></rect>
</svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<circle cx="16" cy="12" r="2"></circle>
<rect height="12" rx="6" width="20" x="2" y="6"></rect>
</svg>
<span>暗色模式</span>
</li>
</div>
</ol>
</aside>
<main class="main full-width">
<article class="has-image main-article">
<header class="article-header">
<div class="article-image">
<a href="/summary-ds1/">
<img alt="Featured image of post 数据结构复习 1 （简单树形数据结构）" loading="lazy" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg5.webp"/>
</a>
</div>
<div class="article-details">
<header class="article-category">
<a href="/categories/oi/">
                OI
            </a>
<a href="/categories/summary/">
                总结
            </a>
</header>
<div class="article-title-wrapper">
<h2 class="article-title">
<a href="/summary-ds1/">数据结构复习 1 （简单树形数据结构）</a>
</h2>
</div>
<footer class="article-time">
<div>
<svg class="icon icon-tabler icon-tabler-calendar-time" fill="none" height="56" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="56" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4"></path>
<circle cx="18" cy="18" r="4"></circle>
<path d="M15 3v4"></path>
<path d="M7 3v4"></path>
<path d="M3 11h16"></path>
<path d="M18 16.496v1.504l1 1"></path>
</svg>
<time class="article-time--published">Feb 07, 2022</time>
</div>
<div>
<svg class="icon icon-tabler icon-tabler-clock" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<circle cx="12" cy="12" r="9"></circle>
<polyline points="12 7 12 12 15 15"></polyline>
</svg>
<time class="article-time--reading">
                    阅读时长: 15 分钟
                </time>
</div>
</footer>
</div>
</header>
<section class="article-content">
<h2 id="前言">前言</h2>
<p>省选/NOI 的个人复习资料。</p>
<p>全凭个人喜好来搞。</p>
<p>不会写的很严谨，实战导向型。</p>
<h2 id="线段树基础">线段树基础</h2>
<h3 id="线段树简介">线段树简介</h3>
<h4 id="定义">定义</h4>
<p>建立在长度为 <span class="math inline">\(n\)</span> 的一维序列上的树形数据结构。每个节点表示一段区间，<span class="math inline">\(n\)</span> 个叶子节点对应长度为 <span class="math inline">\(1\)</span> 的区间。非叶节点均有两个孩子节点，且其表示的区间为两个孩子节点的并。</p>
<p>标准的线段树要求 <span class="math inline">\([l, r]\)</span> 节点的左儿子为 <span class="math inline">\([l, m]\)</span>，右儿子为 <span class="math inline">\((m, r]\)</span>，其中 <span class="math inline">\(m = \lfloor\frac{l + r}2\rfloor\)</span>。而广义线段树的 <span class="math inline">\(m\)</span> 可以为 <span class="math inline">\([l, r)\)</span> 中任意整数。下面只讨论标准线段树。</p>
<p>可以注意到，线段树上每个节点表示的区间要么包含要么不交，而每个区间都可以表示为若干个线段树上区间的并，且其为 <span class="math inline">\(O(\log n)\)</span> 级别的。这里就不严谨证明了。</p>
<p>线段树可以维护满足结合律的信息，例如区间和/积/最大公因数/最值。不满足结合律的例子有区间众数等。</p>
<p>即我们维护的是满足半群性质（封闭性，结合律，存在单位元）的信息。</p>
<p>线段树的一个节点 <span class="math inline">\([l, r]\)</span> 上维护的信息 <span class="math inline">\(f([l, r])\)</span> 一般可以由其两个儿子节点（如果有的话）经过简单运算合并得到。</p>
<p>同时，根据区间拆分的性质，我们可以使用线段树来进行区间的修改/查询操作。</p>
<h4 id="递归式实现">递归式实现</h4>
<p>我们将线段树的节点按照层级从左到右编号便会发现一个很好的性质：<strong>对于编号为 <span class="math inline">\(k\)</span> 的节点，其左儿子的编号为 <span class="math inline">\(2k\)</span>，右儿子的编号为 <span class="math inline">\(2k + 1\)</span></strong>。于是我们就可以通过一个递归的过程从上而下拆分整个区间。</p>
<p>具体来说，我们一般开 <span class="math inline">\(4\)</span> 倍的存储空间。</p>
<p>可以发现，这个想法很自然，很好理解，也不容易出错。速度在一般情况下够用，并且适用范围比非递归式的要广。</p>
<h4 id="非递归式实现zkw-线段树">非递归式实现（zkw 线段树）</h4>
<p>注意到，递归式线段树的常数较大，于是非递归式的实现在一部分对常数要求高的场景就发挥出了其优势，其有一定的局限性。参考 <em>清华大学 张昆玮 《统计的力量》</em>。</p>
<p>优势：速度快，码量小。劣势：不如递归式的直观，不支持绝对标记（下文会提到）。</p>
<p>首先为了方便，需要将序列长度扩展为 <span class="math inline">\(2^k\)</span>，使得线段树为一满二叉树，这样就能方便找到叶子节点的编号。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a aria-hidden="true" href="#cb1-1"></a><span class="dt">int</span> t[maxn &lt;&lt; <span class="dv">2</span>]; <span class="co">// 与递归式无异</span></span>
<span id="cb1-2"><a aria-hidden="true" href="#cb1-2"></a><span class="dt">int</span> n, N = <span class="dv">1</span>; <span class="co">// n 为序列原本的长度，N 为扩展</span></span></code></pre></div>
<p>然后建树的过程如下：</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a aria-hidden="true" href="#cb2-1"></a><span class="dt">void</span> build() {</span>
<span id="cb2-2"><a aria-hidden="true" href="#cb2-2"></a>    <span class="cf">for</span> (; N &lt;= n + <span class="dv">1</span>; N &lt;&lt;= <span class="dv">1</span>);</span>
<span id="cb2-3"><a aria-hidden="true" href="#cb2-3"></a>    FOR(i, N + <span class="dv">1</span>, N + n) read(t[i]);</span>
<span id="cb2-4"><a aria-hidden="true" href="#cb2-4"></a>    DEC(i, N - <span class="dv">1</span>, <span class="dv">1</span>) t[i] = t[L] + t[R];</span>
<span id="cb2-5"><a aria-hidden="true" href="#cb2-5"></a>    <span class="cf">return</span>;</span>
<span id="cb2-6"><a aria-hidden="true" href="#cb2-6"></a>}</span></code></pre></div>
<p>对于单点修改，实现很简单，<code>for (x += N; x; x &gt;&gt;= 1) t[x] += v</code> 即可，单点查询直接找到叶子就行。</p>
<p>而对于没有打标记的区间查询，设两个指针 <span class="math inline">\(s\)</span> 和 <span class="math inline">\(t\)</span> 分别指向 <span class="math inline">\(l - 1\)</span> 和 <span class="math inline">\(r + 1\)</span>，然后逐级往上跳，跳到两者父亲相同位置。在此期间，<strong>若 <span class="math inline">\(s\)</span> 指向的节点为左儿子，则统计右儿子的贡献，若 <span class="math inline">\(t\)</span> 指向的节点为右儿子，则统计左儿子的贡献</strong>，可以画图理解下。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a aria-hidden="true" href="#cb3-1"></a><span class="dt">int</span> query(<span class="dt">int</span> l, <span class="dt">int</span> r) {</span>
<span id="cb3-2"><a aria-hidden="true" href="#cb3-2"></a>    <span class="dt">int</span> ret = <span class="dv">0</span>;</span>
<span id="cb3-3"><a aria-hidden="true" href="#cb3-3"></a>    <span class="cf">for</span> (l += N - <span class="dv">1</span>, r += N - <span class="dv">1</span>; l ^ r ^ <span class="dv">1</span>; l &gt;&gt;= <span class="dv">1</span>, r &gt;&gt;= <span class="dv">1</span>) {</span>
<span id="cb3-4"><a aria-hidden="true" href="#cb3-4"></a>        <span class="cf">if</span> (~l &amp; <span class="dv">1</span>) ret += t[l ^ <span class="dv">1</span>];</span>
<span id="cb3-5"><a aria-hidden="true" href="#cb3-5"></a>        <span class="cf">if</span> (r &amp; <span class="dv">1</span>) ret += t[r ^ <span class="dv">1</span>];</span>
<span id="cb3-6"><a aria-hidden="true" href="#cb3-6"></a>    }</span>
<span id="cb3-7"><a aria-hidden="true" href="#cb3-7"></a>    <span class="cf">return</span> ret;</span>
<span id="cb3-8"><a aria-hidden="true" href="#cb3-8"></a>}</span></code></pre></div>
<p>对于带懒标记的 zkw 线段树下面会写。</p>
<h4 id="动态开点">动态开点</h4>
<p>线段树的堆式存储比较耗费空间，而且对于值域很大的情况下除了离线 + 离散化无解，所以动态开点线段树应运而生。</p>
<p>动态开点其实也没多什么，就是对于一个编号为 <span class="math inline">\(k\)</span> 的节点，它的左儿子不再是 <span class="math inline">\(2k\)</span>，右儿子不再是 <span class="math inline">\(2k+1\)</span>，而是我们自行记录的 <span class="math inline">\(l(k)\)</span> 和 <span class="math inline">\(r(k)\)</span>。</p>
<p>当我们需要这个节点的时候，再开这个节点。</p>
<p>存线段树的数组一般<strong>题目给多大空间开多大，或者随便估计一下</strong>。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a aria-hidden="true" href="#cb4-1"></a><span class="kw">struct</span> node {</span>
<span id="cb4-2"><a aria-hidden="true" href="#cb4-2"></a>    <span class="dt">int</span> ch[<span class="dv">2</span>];<span class="co">//存左右儿子，默认指向空（0）</span></span>
<span id="cb4-3"><a aria-hidden="true" href="#cb4-3"></a>    <span class="dt">int</span> val;<span class="co">// 维护的信息</span></span>
<span id="cb4-4"><a aria-hidden="true" href="#cb4-4"></a>} t[maxn * <span class="dv">50</span>];</span></code></pre></div>
<h3 id="基础信息维护">基础信息维护</h3>
<h4 id="静态查询单点修改">静态查询/单点修改</h4>
<p>一般来说，比较的简单。</p>
<p>有些时候会遇到比较复杂信息，这时候使用结构体并重载加号会省很多事。</p>
<ul>
<li><p>典例 1：区间求和，很简单，<span class="math inline">\(f([l, r]) = f([l, mid]) + f([mid + 1, r])\)</span>。</p></li>
<li><p>典例 2：区间 gcd，<span class="math inline">\(f([l, r]) = \gcd(f([l, mid]), f[mid + 1, r])\)</span>。</p></li>
<li><p>典例 3：区间最大子段和。</p>
<p>这个问题很经典，需要同时维护最大前后缀和以及最大子段和，转移就不写了。</p></li>
</ul>
<p>所以有些时候不是一个值就能存下所有信息的。需要维护的东西视题目而定。</p>
<p>而对于序列上一个元素的修改，发现只会影响 <span class="math inline">\(O(\log n)\)</span> 个节点，所以修改后自下而上更新即可。</p>
<p><strong>若维护的信息满足可减性，请使用树状数组</strong>。</p>
<h4 id="区间修改懒标记">区间修改/懒标记</h4>
<p>对于区间修改就不能一个个元素来了，我们的思想是将一个区间划分为若干段（用线段树上的节点表示），不难发现也是 <span class="math inline">\(O(\log n)\)</span> 段。这里需要使用一些标记来维护修改，这个技巧称为<strong>懒标记</strong>。</p>
<p>对每个节点额外维护一些信息，<span class="math inline">\(g([l, r])\)</span>，修改这个节点代表的区间时，可以只修改 <span class="math inline">\(f([l, r])\)</span> 并将修改信息缓存在 <span class="math inline">\(g([l, r])\)</span> 中，当再次走到这个节点并且需要往其儿子节点走时再<strong>下传标记（pushdown）</strong>。</p>
<p>标记分为<strong>绝对标记</strong>和和<strong>相对标记</strong>：后者可以共存（即满足交换律），与顺序无关，例如区间加某数；前者，打标记的顺序会直接影响结果，例如区间赋值，所以在修改前要进行<strong>标记下传</strong>。</p>
<p>同时多个标记存在时要注意标记的优先级。例如赋值标记一定优先于加法标记，乘法标记优先于加法标记。</p>
<p>标记永久化，即<strong>递归到一个区间时记录修改对其产生的影响</strong>，到了完全被待修区间包含的节点就将标记直接打在节点上并，<strong>不进行下传</strong>。<strong>查询的时候自上而下递归的时候对标记进行累加</strong>。这一技巧常用在树套树和主席树当中，他们若是 pushdown 会有新的节点开销。</p>
<p>zkw 线段树<strong>无法处理绝对标记</strong>，其需要使用标记永久化。以区间加区间求和为例，需要记录两个指针当前包含的区间长度，并将修改上推到根节点。查询时也需要考虑加法标记带来的影响并且往上推到根节点。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a aria-hidden="true" href="#cb5-1"></a><span class="dt">int</span> n, N, m;</span>
<span id="cb5-2"><a aria-hidden="true" href="#cb5-2"></a>ll t[maxn &lt;&lt; <span class="dv">2</span>], tag[maxn &lt;&lt; <span class="dv">2</span>];</span>
<span id="cb5-3"><a aria-hidden="true" href="#cb5-3"></a></span>
<span id="cb5-4"><a aria-hidden="true" href="#cb5-4"></a><span class="dt">void</span> modify(<span class="dt">int</span> x, <span class="dt">int</span> y, ll k) {</span>
<span id="cb5-5"><a aria-hidden="true" href="#cb5-5"></a>    <span class="dt">int</span> lNum = <span class="dv">0</span>, rNum = <span class="dv">0</span>, nNum = <span class="dv">1</span>;</span>
<span id="cb5-6"><a aria-hidden="true" href="#cb5-6"></a>    <span class="cf">for</span> (x += N - <span class="dv">1</span>, y += N + <span class="dv">1</span>; x ^ y ^ <span class="dv">1</span>; x &gt;&gt;= <span class="dv">1</span>, y &gt;&gt;= <span class="dv">1</span>, nNum &lt;&lt;= <span class="dv">1</span>) {</span>
<span id="cb5-7"><a aria-hidden="true" href="#cb5-7"></a>        t[x] += k * lNum, t[y] += k * rNum;</span>
<span id="cb5-8"><a aria-hidden="true" href="#cb5-8"></a>        <span class="cf">if</span> (~x &amp; <span class="dv">1</span>) tag[x ^ <span class="dv">1</span>] += k, t[x ^ <span class="dv">1</span>] += k * nNum, lNum += nNum;</span>
<span id="cb5-9"><a aria-hidden="true" href="#cb5-9"></a>        <span class="cf">if</span> (y &amp; <span class="dv">1</span>) tag[y ^ <span class="dv">1</span>] += k, t[y ^ <span class="dv">1</span>] += k * nNum, rNum += nNum;</span>
<span id="cb5-10"><a aria-hidden="true" href="#cb5-10"></a>    }</span>
<span id="cb5-11"><a aria-hidden="true" href="#cb5-11"></a>    <span class="cf">for</span> (; x; x &gt;&gt;= <span class="dv">1</span>, y &gt;&gt;= <span class="dv">1</span>) t[x] += k * lNum, t[y] += k * rNum;</span>
<span id="cb5-12"><a aria-hidden="true" href="#cb5-12"></a>    <span class="cf">return</span>;</span>
<span id="cb5-13"><a aria-hidden="true" href="#cb5-13"></a>}</span>
<span id="cb5-14"><a aria-hidden="true" href="#cb5-14"></a></span>
<span id="cb5-15"><a aria-hidden="true" href="#cb5-15"></a>ll query(<span class="dt">int</span> x, <span class="dt">int</span> y) {</span>
<span id="cb5-16"><a aria-hidden="true" href="#cb5-16"></a>    <span class="dt">int</span> lNum = <span class="dv">0</span>, rNum = <span class="dv">0</span>, nNum = <span class="dv">1</span>;</span>
<span id="cb5-17"><a aria-hidden="true" href="#cb5-17"></a>    ll ret = <span class="dv">0</span>;</span>
<span id="cb5-18"><a aria-hidden="true" href="#cb5-18"></a>    <span class="cf">for</span> (x += N - <span class="dv">1</span>, y += N + <span class="dv">1</span>; x ^ y ^ <span class="dv">1</span>; x &gt;&gt;= <span class="dv">1</span>, y &gt;&gt;= <span class="dv">1</span>, nNum &lt;&lt;= <span class="dv">1</span>) {</span>
<span id="cb5-19"><a aria-hidden="true" href="#cb5-19"></a>        <span class="cf">if</span> (tag[x]) ret += lNum * tag[x];</span>
<span id="cb5-20"><a aria-hidden="true" href="#cb5-20"></a>        <span class="cf">if</span> (tag[y]) ret += rNum * tag[y];</span>
<span id="cb5-21"><a aria-hidden="true" href="#cb5-21"></a>        <span class="cf">if</span> (~x &amp; <span class="dv">1</span>) ret += t[x ^ <span class="dv">1</span>], lNum += nNum;</span>
<span id="cb5-22"><a aria-hidden="true" href="#cb5-22"></a>        <span class="cf">if</span> (y &amp; <span class="dv">1</span>) ret += t[y ^ <span class="dv">1</span>], rNum += nNum;</span>
<span id="cb5-23"><a aria-hidden="true" href="#cb5-23"></a>    }</span>
<span id="cb5-24"><a aria-hidden="true" href="#cb5-24"></a>    <span class="cf">for</span> (; x; x &gt;&gt;= <span class="dv">1</span>, y &gt;&gt;= <span class="dv">1</span>) ret += tag[x] * lNum + tag[y] * rNum;</span>
<span id="cb5-25"><a aria-hidden="true" href="#cb5-25"></a>    <span class="cf">return</span> ret;</span>
<span id="cb5-26"><a aria-hidden="true" href="#cb5-26"></a>}</span></code></pre></div>
<blockquote>
<p>例题 <span class="math inline">\(1\)</span>：<a href="https://www.luogu.com.cn/problem/P3373">P3373 【模板】线段树 2</a></p>
<p>区间乘，区间加，区间和。</p>
</blockquote>
<p>本题需要维护乘法标记和加法标记，注意乘法和加法标记的顺序问题（先乘后加，否则会引发精度问题），以及乘法标记下传的时候要影响儿子节点的加法标记。</p>
<blockquote>
<p>例题 <span class="math inline">\(2\)</span>：<a href="https://www.luogu.com.cn/problem/P6327">P6327 区间加区间 sin 和</a></p>
<p>如标题。<del>这还是前 Ynoi 来着，淦</del>。</p>
</blockquote>
<p>根据和角公式 <span class="math inline">\(\sin(\alpha + \beta) = \sin\alpha\cos\beta + \cos\alpha\sin\beta\)</span> 可知需要维护区间 <span class="math inline">\(\sin\)</span> 和以及 <span class="math inline">\(\cos\)</span> 和。加法标记较为平凡。</p>
<h4 id="势能均摊">势能均摊</h4>
<p>对于区间开平方/区间取模一类的操作，我们只能暴力进行。但是这些操作进行的次数有一定的上限，所以时间复杂度能得到保障。由势能分析可得复杂度为 <span class="math inline">\(O(nC\log n)\)</span>，其中 <span class="math inline">\(C\)</span> 为操作次数的上界。</p>
<blockquote>
<p>例题 <span class="math inline">\(3\)</span>：<a href="https://www.luogu.com.cn/problem/CF438D">CF438D The Child and Sequence</a></p>
<p>区间取模，单点修改，区间和。<span class="math inline">\(n\le 10^5\)</span>，值域 <span class="math inline">\([1, 10^9]\)</span>。</p>
</blockquote>
<p>注意到对于 <span class="math inline">\(p &lt; x\)</span>，一定有 <span class="math inline">\(x\bmod p &lt; \dfrac x2\)</span>，所以取模最多会进行 <span class="math inline">\(\log A\)</span> 次。同时若 <span class="math inline">\(p &gt; x\)</span> 则对其取模没有意义，所以记录一下区间最大值，若区间最大值 $ &lt; p$ 就直接返回。时间复杂度 <span class="math inline">\(O(n\log n\log A)\)</span>。</p>
<blockquote>
<p>例题 <span class="math inline">\(4\)</span>：<a href="https://www.luogu.com.cn/problem/P4145">P4145 上帝造题的七分钟 2 / 花神游历各国</a></p>
<p>区间开方（下取整）区间和。<span class="math inline">\(n\le 10^5\)</span>，值域 <span class="math inline">\((0, 10^{12}]\)</span>。</p>
</blockquote>
<p>注意到大小为 <span class="math inline">\(A\)</span> 的正整数最多开 <span class="math inline">\(O(\log\log A)\)</span> 次后就会变成 <span class="math inline">\(1\)</span>，之后怎么开都还是 <span class="math inline">\(1\)</span>。对于本题，每个数最多被开方六次。</p>
<p>所以同样维护区间最大值，若其 <span class="math inline">\(\le 1\)</span> 则直接返回，否则就暴力往下递归开方，时间复杂度 <span class="math inline">\(O(n\log n\log\log A)\)</span>。</p>
<blockquote>
<p>例题 <span class="math inline">\(5\)</span>：<a href="https://loj.ac/problem/6029">LOJ#6029. 「雅礼集训 2017 Day1」市场</a></p>
<p><span class="math inline">\(n\le 10^5\)</span>，维护：</p>
<ul>
<li>区间加</li>
<li>区间除 <span class="math inline">\(d\)</span> 并向下取整</li>
<li>求区间最小值</li>
<li>求区间和。</li>
</ul>
</blockquote>
<p>考虑一类均摊方法：容均摊。</p>
<blockquote>
<p>找出一种概括信息量的特征值，证明其消长与时间消耗有关，最终通过求和得到复杂度。</p>
<p>—— command_block</p>
</blockquote>
<p>定义线段树上一个节点的信息复杂度为<strong>容</strong>。本题中，定义节点内数字的<em>极差</em>为其容。</p>
<p>若极差为 <span class="math inline">\(0\)</span>，则区间除可以转化为区间减，可以直接打标记跑路；否则递归下去。由上文可以知道最多除 <span class="math inline">\(\log A\)</span> 次容就会变为 <span class="math inline">\(0\)</span>，分析复杂度可得 <span class="math inline">\(O(n\log n + m\log n\log A)\)</span>。</p>
<p>但是需要注意，当极差为 <span class="math inline">\(1\)</span> 时，下取整会带来最大 <span class="math inline">\(1\)</span> 的误差，除完之后极差可能不变，例如：<span class="math inline">\(5,6,5,6\)</span> 在除以 <span class="math inline">\(3\)</span> 之后还是 <span class="math inline">\(1,2,1,2\)</span>，加上 <span class="math inline">\(4\)</span> 就变回来了，复杂度会退化。</p>
<p>所以需要特殊处理一下，当极差为 <span class="math inline">\(1\)</span> 的时候，若除完后极差仍为 <span class="math inline">\(1\)</span>，就同样变成区间减操作跑路。挺好写的，代码不放了。</p>
<blockquote>
<p>例题 <span class="math inline">\(6\)</span>：<a href="http://uoj.ac/problem/228">UOJ#228. 基础数据结构练习题</a></p>
<p>在花神游历各国的基础上，加上区间加操作。</p>
</blockquote>
<p>同样定义容为极差，则一次整体开根操作至少可以让极差开根。</p>
<p>浅证一下：原来的容为 <span class="math inline">\(x^2 - y^2\)</span>，开根后为 <span class="math inline">\(x - y\)</span>，由 <span class="math inline">\(x^2 - y^2 = (x+y)(x-y)\)</span> 且 <span class="math inline">\(x + y\ge x - y\)</span>，所以 <span class="math inline">\(x - y\le \sqrt{x^2 - y^2}\)</span>。复杂度 <span class="math inline">\(O(n\log n+m\log n\log\log A)\)</span>。</p>
<p>但是仍然需要注意极差为 <span class="math inline">\(1\)</span> 的情况，下取整可能造成偏差，类似上题用加法标记规避即可。（实际上稍微改一下上题代码就可以过了）</p>
<p>更多内容见后文 Segment Tree Beats。</p>
<h4 id="矩阵乘法">矩阵乘法</h4>
<p>矩阵乘法满足结合律，因此可以使用线段树来进行维护。</p>
<p>用一个列向量 <span class="math inline">\(\boldsymbol v\)</span> 来表示一个“状态”，用矩阵来表示转移（即施线性变换）。用一段区间矩阵的连乘积乘上 <span class="math inline">\(\boldsymbol v\)</span> 即得到终态，也就是我们要的答案。</p>
<p>需要注意：本节内容相当卡常。</p>
<blockquote>
<p>例题 <span class="math inline">\(7\)</span>：<a href="https://www.luogu.com.cn/problem/P7453">P7453 [THUSCH2017] 大魔法师</a></p>
</blockquote>
<p>可以见<a href="/note-ddp/">此处</a>。</p>
<h3 id="权值线段树与-0-1-trie">权值线段树与 0-1 Trie</h3>
<p>此时线段树是建立在值域区间上的，<strong>每个节点代表了一个值域</strong>。其可以解决一些针对值域的修改和查询操作。最为经典的是一类关于查询排名的问题</p>
<p>对于值域大的情况，考虑离散化或者动态开点即可。</p>
<p>而如果我们维护的值域是形如 <span class="math inline">\([0, 2^k - 1]\)</span> 的区间，则其等价于一个 0-1 Trie。</p>
<blockquote>
<p>0-1 Trie 通常可以拿来解决异或最大问题。</p>
<p>具体地，例如需要查询从 <span class="math inline">\(S\)</span> 中选一个数，要与 <span class="math inline">\(x\)</span> 异或起来最大。</p>
<p>做法是，将 <span class="math inline">\(S\)</span> 中所有的元素插入一棵 0-1 Trie，然后从根往下走，每次尽可能走与 <span class="math inline">\(x\)</span> 的对应位相反的位。正确性显然。</p>
</blockquote>
<h2 id="平衡树基础">平衡树基础</h2>
<h3 id="平衡树简介">平衡树简介</h3>
<p>二叉搜索树（BST） 是一种常用的数据结构，每个节点储存着一个可以比较大小的权值，并且其满足如下性质：对于任意节点 <span class="math inline">\(u\)</span>，其左子树（如果存在）内所有节点的权值均小于 <span class="math inline">\(u\)</span> 的权值，其右子树（如果存在）内所有节点的权值均大于 <span class="math inline">\(u\)</span> 的权值。</p>
<p>不难发现这棵树可以做很多事情：这棵树的中序遍历就是排好序的序列，并且可以很方便的进行插入删除和查找操作（只需层层递归即可），同时可以统计一个元素的排名（只需看左边有多少节点）。</p>
<p>然而，如果插入的序列是一个递增的序列，则 BST 的复杂度可以退化到 <span class="math inline">\(O(n)\)</span>，这样的话查找一个元素的复杂度和在线性表内查找就没有什么区别了，需要进行优化。</p>
<p>不难发现，对于一个集合，如果我们将他建构成一棵 BST，可以有很多情况，而很明显地：左右平衡的结构是相对比较优的，这样子的话操作的期望复杂度为 <span class="math inline">\(O(\log n)\)</span>，达到了我们的目的。大多数平衡树使用<strong>旋转</strong>操作来维持相对平衡。</p>
<p>而所谓的平衡树的全称就是“平衡二叉搜索树”。</p>
<p>一般来说，平衡树分为“名次树”和“序列树”两种类型。名次树相当于一个集合（类比 <code>std::set</code>），而序列树的中序遍历即为它维护的序列。</p>
<p>名次树可以支持的操作有：</p>
<ul>
<li>插入/删除元素</li>
<li>查找最小/最大值</li>
<li>求元素的排名/求给定排名的元素</li>
<li>求元素的前驱/后继</li>
</ul>
<p>维护序列的平衡树则在序列问题上显得尤为强大，其可以像线段树一样支持懒标记，也可以直接将一段区间提出来甚至交换其位置，也可以在序列的任意一个位置插入/删除元素。</p>
<h3 id="番外笛卡尔树">番外：笛卡尔树</h3>
<p>笛卡尔树是一种每个节点的键值为一个点对 <span class="math inline">\((k, v)\)</span> 的二叉树，其中 <span class="math inline">\(k\)</span> 满足 BST 的性质，<span class="math inline">\(v\)</span> 满足堆的性质，下面讲的 Treap 本质上就是一种笛卡尔树。</p>
<p>若每个 <span class="math inline">\((k, v)\)</span> 都确定且 <span class="math inline">\(k\)</span> 两两不同，<span class="math inline">\(v\)</span> 两两不同，则笛卡尔树的形态是唯一的。</p>
<p>若 <span class="math inline">\(k\)</span> 维护的是序列的下标，<span class="math inline">\(v\)</span> 维护序列的值，则称这棵笛卡尔树是对这个序列建立的，<strong>一棵子树内的下标是连续的</strong>。</p>
<p>可以 <span class="math inline">\(O(n)\)</span> 构建一个序列的笛卡尔树。具体地，注意到我们插入的数的下标已经单调增了，所以新插入的点只能是前面的点的右儿子，或者前面的点是现在的点的左儿子。</p>
<p>拿单调栈来维护递增的<strong>右子树链</strong>，（假设构造满足小根堆性质的笛卡尔树）：</p>
<ol type="1">
<li>插入一个新节点 <span class="math inline">\(v\)</span>。</li>
<li>若栈顶元素 <span class="math inline">\(u\)</span> 的值小于 <span class="math inline">\(v\)</span>，弹出 <span class="math inline">\(u\)</span>，将其设为 <span class="math inline">\(v\)</span> 的左儿子，否则 <span class="math inline">\(u\)</span> 为 <span class="math inline">\(v\)</span> 的右儿子。</li>
<li>最后栈底元素为树根。</li>
</ol>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a aria-hidden="true" href="#cb6-1"></a>FOR(i, <span class="dv">1</span>, n) read(a[i]);</span>
<span id="cb6-2"><a aria-hidden="true" href="#cb6-2"></a>stk[top = <span class="dv">1</span>] = <span class="dv">1</span>;</span>
<span id="cb6-3"><a aria-hidden="true" href="#cb6-3"></a>FOR(i, <span class="dv">2</span>, n) {</span>
<span id="cb6-4"><a aria-hidden="true" href="#cb6-4"></a>    <span class="cf">while</span> (a[stk[top]] &gt; a[i] &amp;&amp; top) --top;</span>
<span id="cb6-5"><a aria-hidden="true" href="#cb6-5"></a>    <span class="cf">if</span> (!top) ls[i] = stk[top + <span class="dv">1</span>];</span>
<span id="cb6-6"><a aria-hidden="true" href="#cb6-6"></a>    <span class="cf">else</span> ls[i] = rs[stk[top]], rs[stk[top]] = i;</span>
<span id="cb6-7"><a aria-hidden="true" href="#cb6-7"></a>    stk[++top] = i;</span>
<span id="cb6-8"><a aria-hidden="true" href="#cb6-8"></a>}</span></code></pre></div>
<p>笛卡尔树的应用主要依赖如下性质：</p>
<ul>
<li>中序遍历为原序列。</li>
<li>任意一个节点的值都大于/小于（取决于堆的种类）其子树内元素的值。</li>
<li>笛卡尔树上做 LCA 相当于原序列上做 RMQ。</li>
<li>可以 <span class="math inline">\(O(n)\)</span> 建立 Treap（虽然意义不大）。</li>
</ul>
<blockquote>
<p>例题 1：<a href="https://www.luogu.com.cn/problem/P1377">P1377 [TJOI2011]树的序</a></p>
<p>给定一棵 BST 的插入元素顺序，问一个字典序最小的插入元素顺序，使得得到的 BST 和原来同构。</p>
</blockquote>
<p>同构的要求就是，原树中的父亲要先于儿子被插入。那么可以考虑使用笛卡尔树来维护，以元素的值为下标（满足 BST 性质），插入时间为键值（满足小根堆性质）建笛卡尔树，然后其先序遍历就是需要的字典序最小的插入元素顺序。</p>
<blockquote>
<p>例题 2：<a href="https://www.luogu.com.cn/problem/CF1580D">CF1580D Subsequence</a></p>
<p>给定长度为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(a\)</span>，所有元素两两不同。需要选择一个长度为 <span class="math inline">\(m\)</span> 的子序列 <span class="math inline">\(a_{b_1}, a_{b_2},\cdots, a_{b_m}\)</span>，要使得其代价最大。子序列的价值被定义为 <span class="math display">\[
\sum_{i=1}^m(m\cdot a_{b_i}) - \sum_{i=1}^m\sum_{j=1}^mf(\min(b_i, b_j), \max(b_i, b_j))
\]</span> 其中 <span class="math inline">\(f(x, y)\)</span> 表示 <span class="math inline">\(\min_{x\le i\le y}\{a_i \}\)</span>。<span class="math inline">\(1\le m\le n\le 4000\)</span>。</p>
</blockquote>
<p>化简式子可以得到 <span class="math inline">\(\sum_{i=1}^{m-1}\sum_{j=i+1}^m a_{b_i} + a_{b_j} - 2f(b_i, b_j)\)</span>，考虑到 <span class="math inline">\(f\)</span> 函数就是个 RMQ，且 <span class="math inline">\(a_{b_i} + a_{b_j} - 2f(b_i, b_j)\)</span> 的形式很像两点间树上距离，所以对序列建出笛卡尔树，发现就是要求两两点间距离之和最大，树形背包即可，<span class="math inline">\(O(n^2)\)</span>。</p>
<h3 id="无旋-treap">无旋 Treap</h3>
<p>由范浩强大佬发明的神级数据结构，相比于 Treap 不用旋转，且增添了两个核心操作：分裂（split）与合并（merge），这两个操作是无旋 Treap 的核心操作，其余的所有操作都是基于 split 和 merge 的。</p>
<h4 id="基本定义">基本定义</h4>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a aria-hidden="true" href="#cb7-1"></a><span class="kw">struct</span> Node {</span>
<span id="cb7-2"><a aria-hidden="true" href="#cb7-2"></a>    <span class="dt">int</span> size, ch[<span class="dv">2</span>], val, key;</span>
<span id="cb7-3"><a aria-hidden="true" href="#cb7-3"></a><span class="pp">#define L </span>t[u].ch[<span class="dv">0</span>]</span>
<span id="cb7-4"><a aria-hidden="true" href="#cb7-4"></a><span class="pp">#define R </span>t[u].ch[<span class="dv">1</span>]</span>
<span id="cb7-5"><a aria-hidden="true" href="#cb7-5"></a>} t[maxn];</span>
<span id="cb7-6"><a aria-hidden="true" href="#cb7-6"></a></span>
<span id="cb7-7"><a aria-hidden="true" href="#cb7-7"></a><span class="dt">int</span> root, tot;</span></code></pre></div>
<p>两个值相同的元素放在两个节点内维护，无需维护 <code>cnt</code>。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a aria-hidden="true" href="#cb8-1"></a><span class="dt">int</span> newnode(<span class="dt">int</span> val) {</span>
<span id="cb8-2"><a aria-hidden="true" href="#cb8-2"></a>    t[++tot].val = val;</span>
<span id="cb8-3"><a aria-hidden="true" href="#cb8-3"></a>    t[tot].key = rand();</span>
<span id="cb8-4"><a aria-hidden="true" href="#cb8-4"></a>    t[tot].size = <span class="dv">1</span>;</span>
<span id="cb8-5"><a aria-hidden="true" href="#cb8-5"></a>    <span class="cf">return</span> tot;</span>
<span id="cb8-6"><a aria-hidden="true" href="#cb8-6"></a>}</span></code></pre></div>
<p>初始化节点的时候记得随机一个键值。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a aria-hidden="true" href="#cb9-1"></a><span class="dt">void</span> pushUp(<span class="dt">int</span> u) {</span>
<span id="cb9-2"><a aria-hidden="true" href="#cb9-2"></a>    t[k].size = t[L].size + t[R].size + <span class="dv">1</span>;</span>
<span id="cb9-3"><a aria-hidden="true" href="#cb9-3"></a>    <span class="cf">return</span>;</span>
<span id="cb9-4"><a aria-hidden="true" href="#cb9-4"></a>}</span></code></pre></div>
<p>以及每次操作完之后不能忘记 <code>pushUp</code>。</p>
<h4 id="分裂合并">分裂/合并</h4>
<p>该操作把一棵 Treap 分裂成两棵，有两种分裂方法：按值分裂以及按大小分裂。这里先考虑按值分裂。</p>
<p>该种分裂方式按照一个阈值 <span class="math inline">\(k\)</span> 把一棵 Treap 分裂成两棵，满足左树的所有元素值均<strong>小于等于</strong> <span class="math inline">\(k\)</span>，右树的所有元素值均<strong>大于</strong> <span class="math inline">\(k\)</span>。由于 Treap 满足堆的性质，所以直接分裂即可，不需要特殊维护。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a aria-hidden="true" href="#cb10-1"></a><span class="dt">void</span> split(<span class="dt">int</span> u, <span class="dt">int</span> k, <span class="dt">int</span> &amp;x, <span class="dt">int</span> &amp;y) {</span>
<span id="cb10-2"><a aria-hidden="true" href="#cb10-2"></a>    <span class="cf">if</span> (!u) <span class="cf">return</span> x = y = <span class="dv">0</span>, <span class="dt">void</span>();</span>
<span id="cb10-3"><a aria-hidden="true" href="#cb10-3"></a>    <span class="cf">if</span> (t[u].val &lt;= k) x = u, split(R, k, R, y);</span>
<span id="cb10-4"><a aria-hidden="true" href="#cb10-4"></a>    <span class="cf">else</span> y = u, split(L, k, x, L);</span>
<span id="cb10-5"><a aria-hidden="true" href="#cb10-5"></a>    <span class="cf">return</span> pushUp(u);</span>
<span id="cb10-6"><a aria-hidden="true" href="#cb10-6"></a>}</span></code></pre></div>
<p>记忆：<code>x</code> 和 <code>y</code> 分别代表左树和右树的指针，若当前节点应被划入左树，则其左儿子一定在左树内，所以递归分裂右子树，而右子树中划分给左树的部分会接到 <span class="math inline">\(u\)</span> 的右儿子，所以是 <code>split(R, k, R, y)</code>。反之亦然。</p>
<p>同时，对于序列树，按大小分裂的代码如下：</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a aria-hidden="true" href="#cb11-1"></a><span class="dt">void</span> split(<span class="dt">int</span> u, <span class="dt">int</span> size, <span class="dt">int</span> &amp;x, <span class="dt">int</span> &amp;y) {</span>
<span id="cb11-2"><a aria-hidden="true" href="#cb11-2"></a>    <span class="cf">if</span> (!u) <span class="cf">return</span> x = y = <span class="dv">0</span>, <span class="dt">void</span>();</span>
<span id="cb11-3"><a aria-hidden="true" href="#cb11-3"></a>    <span class="co">// pushDown(u); // if necessary</span></span>
<span id="cb11-4"><a aria-hidden="true" href="#cb11-4"></a>    <span class="cf">if</span> (t[L].size &lt; size) x = u, split(R, size - t[L].size - <span class="dv">1</span>, R, y);</span>
<span id="cb11-5"><a aria-hidden="true" href="#cb11-5"></a>    <span class="cf">else</span> y = u, split(L, size, x, L);</span>
<span id="cb11-6"><a aria-hidden="true" href="#cb11-6"></a>    pushup(u);</span>
<span id="cb11-7"><a aria-hidden="true" href="#cb11-7"></a>    <span class="cf">return</span>;</span>
<span id="cb11-8"><a aria-hidden="true" href="#cb11-8"></a>}</span></code></pre></div>
<p>其代表的是，将整棵树划为两棵，满足左树的大小为 <code>size</code>。</p>
<p>记忆：左子树的大小小于要求大小的时候说明要递归划分右子树，需要的大小要扣掉左子树以及 <span class="math inline">\(u\)</span> 自身。</p>
<p>合并的时候是把两棵 FHQ-Treap <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 合并成一棵，必须满足：<span class="math inline">\(x\)</span> 中所有节点的值小于等于 <span class="math inline">\(y\)</span> 中所有节点的值，然后合并的结果也要满足 Treap 的性质（即堆的性质）。</p>
<p>合并函数 <code>int merge(int x, int y)</code> 返回合并后的树根，<span class="math inline">\(x,y\)</span> 分别为两棵待合并树的根。由于要维护堆的性质，实现如下：</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a aria-hidden="true" href="#cb12-1"></a><span class="dt">int</span> merge(<span class="dt">int</span> x, <span class="dt">int</span> y) {</span>
<span id="cb12-2"><a aria-hidden="true" href="#cb12-2"></a>    <span class="cf">if</span> (!x || !y) <span class="cf">return</span> x + y;</span>
<span id="cb12-3"><a aria-hidden="true" href="#cb12-3"></a>    <span class="cf">if</span> (t[x].key &lt; t[y].key)</span>
<span id="cb12-4"><a aria-hidden="true" href="#cb12-4"></a>        <span class="cf">return</span> pushDown(x), t[x].ch[<span class="dv">1</span>] = merge(t[x].ch[<span class="dv">1</span>], y), pushUp(x), x;</span>
<span id="cb12-5"><a aria-hidden="true" href="#cb12-5"></a>    <span class="cf">else</span> <span class="cf">return</span> pushDown(y), t[y].ch[<span class="dv">0</span>] = merge(x, t[y].ch[<span class="dv">0</span>]), pushUp(y), y;</span>
<span id="cb12-6"><a aria-hidden="true" href="#cb12-6"></a>}</span></code></pre></div>
<p>记忆：遇到空节点就直接合并，否则按照键值来合并子树，不要忘记 <code>pushDown</code> 和 <code>pushUp</code>。</p>
<blockquote>
<p>牢记：<code>merge</code> 操作的返回值一定是会用得到的，没有写 <code>root = merge(...)</code> 是很常见的错误！！</p>
</blockquote>
<h4 id="插入删除排名kmathrmth">插入/删除/排名/<span class="math inline">\(k^{\mathrm{th}}\)</span></h4>
<p>假设要插入 <span class="math inline">\(v\)</span>，则将整棵树按照阈值 <span class="math inline">\(v\)</span> 分割成两部分，然后和新节点合并起来即可。</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a aria-hidden="true" href="#cb13-1"></a><span class="dt">void</span> insert(<span class="dt">int</span> val) {</span>
<span id="cb13-2"><a aria-hidden="true" href="#cb13-2"></a>    <span class="dt">int</span> x, y;</span>
<span id="cb13-3"><a aria-hidden="true" href="#cb13-3"></a>    split(root, val, x, y);</span>
<span id="cb13-4"><a aria-hidden="true" href="#cb13-4"></a>    root = merge(merge(x, newNode(val)), y);</span>
<span id="cb13-5"><a aria-hidden="true" href="#cb13-5"></a>    <span class="cf">return</span>;</span>
<span id="cb13-6"><a aria-hidden="true" href="#cb13-6"></a>}</span></code></pre></div>
<p>删除操作则是，将值为 <span class="math inline">\(v\)</span> 的划分成单独一棵树，然后删除根节点：</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a aria-hidden="true" href="#cb14-1"></a><span class="dt">void</span> delNode(<span class="dt">int</span> val) {</span>
<span id="cb14-2"><a aria-hidden="true" href="#cb14-2"></a>    <span class="dt">int</span> x, y, z;</span>
<span id="cb14-3"><a aria-hidden="true" href="#cb14-3"></a>    split(root, val - <span class="dv">1</span>, x, y);</span>
<span id="cb14-4"><a aria-hidden="true" href="#cb14-4"></a>    split(y, val, y, z);</span>
<span id="cb14-5"><a aria-hidden="true" href="#cb14-5"></a>    y = merge(t[y].ch[<span class="dv">0</span>], t[y].ch[<span class="dv">1</span>]);</span>
<span id="cb14-6"><a aria-hidden="true" href="#cb14-6"></a>    root = merge(merge(x, y), z);</span>
<span id="cb14-7"><a aria-hidden="true" href="#cb14-7"></a>    <span class="cf">return</span>;</span>
<span id="cb14-8"><a aria-hidden="true" href="#cb14-8"></a>}</span></code></pre></div>
<p>本质上都是基于分裂和合并操作的。</p>
<p>查询排名很类似于删除操作，但只需要分裂出小于 <span class="math inline">\(val\)</span> 的树然后返回其大小加一的值即可。</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a aria-hidden="true" href="#cb15-1"></a><span class="dt">int</span> rank(<span class="dt">int</span> val) {</span>
<span id="cb15-2"><a aria-hidden="true" href="#cb15-2"></a>    <span class="dt">int</span> x, y;</span>
<span id="cb15-3"><a aria-hidden="true" href="#cb15-3"></a>    split(root, val - <span class="dv">1</span>, x, y);</span>
<span id="cb15-4"><a aria-hidden="true" href="#cb15-4"></a>    <span class="dt">int</span> ans = t[x].size + <span class="dv">1</span>;</span>
<span id="cb15-5"><a aria-hidden="true" href="#cb15-5"></a>    root = merge(x, y);</span>
<span id="cb15-6"><a aria-hidden="true" href="#cb15-6"></a>    <span class="cf">return</span> ans;</span>
<span id="cb15-7"><a aria-hidden="true" href="#cb15-7"></a>}</span></code></pre></div>
<p>然而查询 <span class="math inline">\(k\text{th}\)</span> 时就不能分裂/合并了，老老实实按照大多数平衡树的写法就可以了，建议非递归，常数小一些。</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a aria-hidden="true" href="#cb16-1"></a><span class="dt">int</span> kth(<span class="dt">int</span> k) {</span>
<span id="cb16-2"><a aria-hidden="true" href="#cb16-2"></a>    <span class="dt">int</span> u = root;</span>
<span id="cb16-3"><a aria-hidden="true" href="#cb16-3"></a>    <span class="cf">while</span> (<span class="kw">true</span>) {</span>
<span id="cb16-4"><a aria-hidden="true" href="#cb16-4"></a>        <span class="dt">int</span> lsize = <span class="dv">0</span>;</span>
<span id="cb16-5"><a aria-hidden="true" href="#cb16-5"></a>        <span class="cf">if</span> (L)</span>
<span id="cb16-6"><a aria-hidden="true" href="#cb16-6"></a>            lsize = t[L].size;</span>
<span id="cb16-7"><a aria-hidden="true" href="#cb16-7"></a>        <span class="cf">if</span> (k &lt;= lsize)</span>
<span id="cb16-8"><a aria-hidden="true" href="#cb16-8"></a>            u = L;</span>
<span id="cb16-9"><a aria-hidden="true" href="#cb16-9"></a>        <span class="cf">else</span> <span class="cf">if</span> (k &gt; lsize + <span class="dv">1</span>)</span>
<span id="cb16-10"><a aria-hidden="true" href="#cb16-10"></a>            k -= lsize + <span class="dv">1</span>, u = R;</span>
<span id="cb16-11"><a aria-hidden="true" href="#cb16-11"></a>        <span class="cf">else</span> <span class="cf">return</span> t[u].val;</span>
<span id="cb16-12"><a aria-hidden="true" href="#cb16-12"></a>    }</span>
<span id="cb16-13"><a aria-hidden="true" href="#cb16-13"></a>}</span></code></pre></div>
<h3 id="splay">Splay</h3>
<h3 id="小技巧">小技巧</h3>
<h4 id="快速定位序列中元素">快速定位序列中元素</h4>
<p>当我们在使用 FHQ-Treap 维护一段序列时，有时需要快速找出某元素在序列中的位置，怎么办呢？</p>
<p>此时可以在建树时记录下这个元素在树中的节点编号，然后在找寻其排名时自底而上记录在它左边的节点个数。具体可以这样：</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a aria-hidden="true" href="#cb17-1"></a><span class="dt">int</span> getrank(<span class="dt">int</span> u)</span>
<span id="cb17-2"><a aria-hidden="true" href="#cb17-2"></a>{</span>
<span id="cb17-3"><a aria-hidden="true" href="#cb17-3"></a>    <span class="dt">int</span> ret = t[L].size + <span class="dv">1</span>;</span>
<span id="cb17-4"><a aria-hidden="true" href="#cb17-4"></a>    <span class="cf">while</span> (t[u].fa)</span>
<span id="cb17-5"><a aria-hidden="true" href="#cb17-5"></a>    {</span>
<span id="cb17-6"><a aria-hidden="true" href="#cb17-6"></a>        <span class="cf">if</span> (t[t[u].fa].ch[<span class="dv">1</span>] == u)</span>
<span id="cb17-7"><a aria-hidden="true" href="#cb17-7"></a>            ret += t[t[t[u].fa].ch[<span class="dv">0</span>]].size + <span class="dv">1</span>;</span>
<span id="cb17-8"><a aria-hidden="true" href="#cb17-8"></a>        u = t[u].fa;</span>
<span id="cb17-9"><a aria-hidden="true" href="#cb17-9"></a>    }</span>
<span id="cb17-10"><a aria-hidden="true" href="#cb17-10"></a>    <span class="cf">return</span> ret;</span>
<span id="cb17-11"><a aria-hidden="true" href="#cb17-11"></a>}</span></code></pre></div>
<p>对于一个节点 <span class="math inline">\(u\)</span>，首先它的排名就是其左子树大小加一，然后往上跳，在跳的过程中判断一下它是父亲节点的左儿子还是右儿子，如果是右儿子的话，<strong>父亲本身和其兄弟节点都会产生贡献</strong>，一路搜到根即可。</p>
<p><strong>同时 pushup 的时候要更新父亲</strong>，pushup 一个节点的时候顺带更新其两个儿子的父亲（需要判断是否存在）</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a aria-hidden="true" href="#cb18-1"></a><span class="kw">inline</span> <span class="dt">void</span> pushup(<span class="dt">int</span> u)</span>
<span id="cb18-2"><a aria-hidden="true" href="#cb18-2"></a>{</span>
<span id="cb18-3"><a aria-hidden="true" href="#cb18-3"></a>    t[u].size = <span class="dv">1</span>;</span>
<span id="cb18-4"><a aria-hidden="true" href="#cb18-4"></a>    <span class="cf">if</span> (L)</span>
<span id="cb18-5"><a aria-hidden="true" href="#cb18-5"></a>        t[u].size += t[L].size, t[L].fa = u;</span>
<span id="cb18-6"><a aria-hidden="true" href="#cb18-6"></a>    <span class="cf">if</span> (R)</span>
<span id="cb18-7"><a aria-hidden="true" href="#cb18-7"></a>        t[u].size += t[R].size, t[R].fa = u;</span>
<span id="cb18-8"><a aria-hidden="true" href="#cb18-8"></a>    <span class="cf">return</span>;</span>
<span id="cb18-9"><a aria-hidden="true" href="#cb18-9"></a>}</span></code></pre></div>
<h4 id="启发式合并">启发式合并</h4>
<p>此处的合并与之前的 merge 操作不同，此处合并的两棵树就是两棵一般的树，不能简单地直接 <span class="math inline">\(O(\log n)\)</span> 合并。此时我们能做的就是将小树暴力递归加入到大树中，复杂度 <span class="math inline">\(O(\log^2 n)\)</span>。具体实现如下：</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a aria-hidden="true" href="#cb19-1"></a><span class="dt">void</span> insert(<span class="dt">int</span>&amp; root, <span class="dt">int</span> u) { <span class="co">//表示将 u 节点加入 root 为根的新树中</span></span>
<span id="cb19-2"><a aria-hidden="true" href="#cb19-2"></a>    <span class="dt">int</span> x, y;</span>
<span id="cb19-3"><a aria-hidden="true" href="#cb19-3"></a>    <span class="dt">int</span> val = t[u].val;</span>
<span id="cb19-4"><a aria-hidden="true" href="#cb19-4"></a>    split(root, val, x, y);</span>
<span id="cb19-5"><a aria-hidden="true" href="#cb19-5"></a>    root = merge(merge(x, u), y);</span>
<span id="cb19-6"><a aria-hidden="true" href="#cb19-6"></a>    <span class="cf">return</span>;</span>
<span id="cb19-7"><a aria-hidden="true" href="#cb19-7"></a>}</span>
<span id="cb19-8"><a aria-hidden="true" href="#cb19-8"></a></span>
<span id="cb19-9"><a aria-hidden="true" href="#cb19-9"></a><span class="dt">void</span> dfs(<span class="dt">int</span> u, <span class="dt">int</span>&amp; root) { <span class="co">//这个 root 的引用是新树的树根</span></span>
<span id="cb19-10"><a aria-hidden="true" href="#cb19-10"></a>    <span class="cf">if</span> (!u)</span>
<span id="cb19-11"><a aria-hidden="true" href="#cb19-11"></a>        <span class="cf">return</span>;</span>
<span id="cb19-12"><a aria-hidden="true" href="#cb19-12"></a>    dfs(L, root);<span class="co">//先把左子树加入</span></span>
<span id="cb19-13"><a aria-hidden="true" href="#cb19-13"></a>    dfs(R, root);<span class="co">//加入右子树</span></span>
<span id="cb19-14"><a aria-hidden="true" href="#cb19-14"></a>    L = R = <span class="dv">0</span>;<span class="co">//清空儿子，这一步不写会出问题</span></span>
<span id="cb19-15"><a aria-hidden="true" href="#cb19-15"></a>    insert(root, u);<span class="co">//再加入自己</span></span>
<span id="cb19-16"><a aria-hidden="true" href="#cb19-16"></a>    <span class="cf">return</span>;</span>
<span id="cb19-17"><a aria-hidden="true" href="#cb19-17"></a>}</span>
<span id="cb19-18"><a aria-hidden="true" href="#cb19-18"></a></span>
<span id="cb19-19"><a aria-hidden="true" href="#cb19-19"></a><span class="dt">int</span> join(<span class="dt">int</span> x, <span class="dt">int</span> y) {</span>
<span id="cb19-20"><a aria-hidden="true" href="#cb19-20"></a>    <span class="cf">if</span> (t[x].size &gt; t[y].size)</span>
<span id="cb19-21"><a aria-hidden="true" href="#cb19-21"></a>        swap(x, y);</span>
<span id="cb19-22"><a aria-hidden="true" href="#cb19-22"></a>    dfs(x, y);<span class="co">//使 x 成为小树然后递归加入 y 中</span></span>
<span id="cb19-23"><a aria-hidden="true" href="#cb19-23"></a>    <span class="cf">return</span> y;<span class="co">//返回新的根 y</span></span>
<span id="cb19-24"><a aria-hidden="true" href="#cb19-24"></a>}</span></code></pre></div>
<h3 id="简单应用">简单应用</h3>
<h2 id="堆">堆</h2>
<h3 id="堆简介">堆简介</h3>
<p>堆是一棵树，每个节点上有一个权值，其满足父亲节点的权值 <span class="math inline">\(\ge\)</span> 或 $$ 儿子节点的权值，以此分为大根堆和小根堆两种种类。<strong><code>std::priority_queue</code> 是大根堆，需要重载小于号</strong>。</p>
<p>堆可以维护一个数集，支持：插入，删除最值，查询最值，合并两个堆等。</p>
<p>一些可并堆可以高效完成合并操作，甚至还可以完成可持久化。</p>
<p>OI 中常用的堆有二叉堆和左偏树。手写二叉堆由于在 OI 中的实战意义不大（完全可以用 <code>std::priority_queue</code> 代替）这里略去。另外，堆还可以用平衡树代替，如 <code>std::set</code> 也能实现二叉堆的功能（甚至还更强大），只是常数会更大。下面主要介绍左偏树。</p>
<p>左偏树的意义在于它可以支持懒标记和可持久化。（不然直接启发式合并 <code>std::set</code> 也就多一个 <span class="math inline">\(\log\)</span> 而已）</p>
<h3 id="左偏树">左偏树</h3>
<p>前置定义：在二叉树中，定义<strong>外节点</strong>为左儿子或右儿子为空的节点，定义一个外节点的 <span class="math inline">\(\mathrm{dist} = 1\)</span>，一个不是外节点的 <span class="math inline">\(\mathrm{dist}\)</span> 为其到子树中最近的外节点的距离 <span class="math inline">\(+1\)</span>。空节点的 <span class="math inline">\(\mathrm{dist} = 0\)</span>。一棵 <span class="math inline">\(n\)</span> 个点的二叉树的根的 <span class="math inline">\(\mathrm{dist}\le \lceil\log(n + 1) \rceil\)</span>，因为一棵根的 <span class="math inline">\(\mathrm{dist} = x\)</span> 的二叉树至少有 <span class="math inline">\(x - 1\)</span> 层是满的，则至少有 <span class="math inline">\(2^x - 1\)</span> 个节点。</p>
<p>左偏树是一棵二叉树，其不仅具有堆的性质，还满足<em>左偏</em>：左儿子的 <span class="math inline">\(\mathrm{dist}\)</span> 大于右儿子的 <span class="math inline">\(\mathrm{dist}\)</span>。所以每个非外节点的 <span class="math inline">\(\mathrm{dist}\)</span> 都为右儿子的 <span class="math inline">\(\mathrm{dist} + 1\)</span>。<strong>左偏树的深度是没有保证的</strong>，<span class="math inline">\(\mathrm{dist}\)</span> 不是深度，左偏树的树高可以达到 <span class="math inline">\(O(n)\)</span> 级别。</p>
<p>左偏树最关键的操作是合并操作，其实很像无旋 Treap 的合并。<code>int merge(int x, int y)</code> 表示合并 <span class="math inline">\(x\)</span> 子树和 <span class="math inline">\(y\)</span> 子树，返回值为合并后的根。首先取值较小（考虑小根堆）的为根，然后将根的左儿子作为合并后的左儿子，拿右儿子和另一个节点递归合并。然后若左偏性质被破坏，修复之。</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a aria-hidden="true" href="#cb20-1"></a><span class="dt">int</span> merge(<span class="dt">int</span> x, <span class="dt">int</span> y) {</span>
<span id="cb20-2"><a aria-hidden="true" href="#cb20-2"></a>    <span class="cf">if</span> (!x || !y)</span>
<span id="cb20-3"><a aria-hidden="true" href="#cb20-3"></a>        <span class="cf">return</span> x + y;</span>
<span id="cb20-4"><a aria-hidden="true" href="#cb20-4"></a>    <span class="cf">if</span> (t[x].val &gt; t[y].val || (t[x].val == t[y].val &amp;&amp; x &gt; y))</span>
<span id="cb20-5"><a aria-hidden="true" href="#cb20-5"></a>        swap(x, y);</span>
<span id="cb20-6"><a aria-hidden="true" href="#cb20-6"></a>    t[x].R = merge(t[x].R, y);</span>
<span id="cb20-7"><a aria-hidden="true" href="#cb20-7"></a>    <span class="cf">if</span> (t[t[x].L].dis &lt; t[t[x].R].dis)</span>
<span id="cb20-8"><a aria-hidden="true" href="#cb20-8"></a>        swap(t[x].L, t[x].R);</span>
<span id="cb20-9"><a aria-hidden="true" href="#cb20-9"></a>    t[t[x].R].rt = x;</span>
<span id="cb20-10"><a aria-hidden="true" href="#cb20-10"></a>    t[x].dis = t[t[x].R].dis + <span class="dv">1</span>;</span>
<span id="cb20-11"><a aria-hidden="true" href="#cb20-11"></a>    <span class="cf">return</span> x;</span>
<span id="cb20-12"><a aria-hidden="true" href="#cb20-12"></a>}</span></code></pre></div>
<p>另外，若是要快速查找堆顶，则需要像并查集一样路径压缩维护（上面提到，树高可能为 <span class="math inline">\(O(n)\)</span> 级别）。掌握了合并操作后，插入和删除堆顶的操作都是平凡的。</p>
<p><del>其实随机合并的复杂度也是正确的，还不需要计算 <span class="math inline">\(\mathrm{dist}\)</span> 了</del>，以后都写随机堆了。</p>
<blockquote>
<p>常见错误：</p>
<ul>
<li>合并两个在同一棵树中的节点。</li>
<li><strong>路径压缩后删点需要特别注意</strong>，将删掉的点的祖先指针指向子树合并后的结果，不然子树往上溯的时候会寄。</li>
<li>待补充。</li>
</ul>
</blockquote>
<p>可持久化可并堆的一大应用是 <span class="math inline">\(k\)</span> 短路，<a href="/summary-graph1/#k-短路">见此</a>。</p>
<h2 id="可持久化数据结构">可持久化数据结构</h2>
<h3 id="可持久化简介">可持久化简介</h3>
<p>对于一个数据结构，想维护其所有的历史版本，其中每操作一次就会产生一个新的历史版本。</p>
<p>部分可持久化：允许访问历史版本，不能修改历史版本。</p>
<p>完全可持久化：允许把目前版本替换为历史版本。</p>
<p>算法竞赛中最常见的是对值域线段树的可持久化（又称为主席树？），对于线段树，一般采用 path copy 的方法，即一次单点修改只会导致一条链和之前的版本发生改变，所以只需要复制这一条链（所以必然是动态开点）即可。一般来说空间复杂度是 <span class="math inline">\(O(n\log n)\)</span>（一次操作新建一条链）。</p>
<blockquote>
<p>note：对于区间修改的情况，一般采用标记永久化，而对于下传懒标记的情况，算空间的时候需要算上查询操作带来的下传懒标记的影响，还有 <span class="math inline">\(4\)</span> 倍的常数，总之空间常数巨大。</p>
<p>from 论文哥：还有一种方案是查询的路上下传时复制节点，查完就直接回收掉。</p>
</blockquote>
<p>一般来说，可持久化线段树的应用主要有以下两种：</p>
<ul>
<li>维护一个数组的历史版本，比如可持久化并查集。</li>
<li>充当<strong>线段树的前缀和</strong>来解决一些高维问题。</li>
</ul>
<h3 id="可持久化线段树0-1-tri">可持久化线段树/0-1 Tri</h3>
<blockquote>
<p>例题 1：<a href="https://www.luogu.com.cn/problem/P3919">P3919 【模板】可持久化线段树 1（可持久化数组）</a></p>
<p>带版本的单点修改单点查询，每次操作产生一个新版本。</p>
</blockquote>
<p>太弱智了，裸板子。</p>
<blockquote>
<p>例题 2：<a href="https://www.luogu.com.cn/problem/P3402">P3402 可持久化并查集</a></p>
<p>合并，查询，回退到某个版本。</p>
</blockquote>
<p>拿可持久化线段树维护一下并查集的 <code>fa</code> 数组。但是需要注意，由于我们每个版本之间要保证相差的只是一条链，所以路径压缩是绝对不行的，只能按秩合并，那就额外维护一下一个连通块的秩即可。</p>
<blockquote>
<p>例题 3：<a href="https://www.luogu.com.cn/problem/SP11470">SP11470 TTM - To the moon</a></p>
<p>区间加区间和，历史版本区间和，版本回退</p>
</blockquote>
<p><strong>标记永久化</strong>的应用，剩下的就是普通可持久化的写法。</p>
<p>上面几道题都是可持久化线段树在维护数组版本上的一些应用，下面考虑其作为“线段树的前缀和”的用法。一般地，维护的是值域线段树的前缀和，区间查询的时候转为两个线段树的前缀相减。所谓的“主席树”一般说的都是这个东西。</p>
<p>主席树一般用于<strong>静态高维问题</strong>的降维，例如二维数点就是用前缀和去掉了一维（动态二维数点考虑树套树），一般会减少一个 <span class="math inline">\(\log\)</span>。</p>
<blockquote>
<p>例题 4：<a href="https://www.luogu.com.cn/problem/P3834">P3834 【模板】可持久化线段树 2</a></p>
<p>静态区间第 <span class="math inline">\(k\)</span> 小。</p>
</blockquote>
<p>主席树的经典应用，我们考虑在值域上二分答案，然后用后一棵线段树（<span class="math inline">\(r\)</span>）减去前一棵线段树（<span class="math inline">\(l - 1\)</span>）得到该 <span class="math inline">\([l, r]\)</span> 上在该值域内的数有多少，即<strong>在两棵线段树上同时二分</strong>，时间复杂度是 <span class="math inline">\(O(n\log n)\)</span> 的。</p>
<p>这一类问题是可以上树的，只不过我们把普通的前缀和变成树上前缀和就行了。</p>
<h3 id="可持久化平衡树">可持久化平衡树</h3>
<p>首先，复杂度均摊的数据结构不太好可持久化（说的就是 Splay），所以考虑对<del>又可爱又好写</del>的 fhq-treap 进行可持久化。</p>
<p>对于 merge 和 split 操作，我们可以通过对这些过程经过的节点进行复制以达到可持久化的效果。</p>
<p>其相比普通的平衡树，是没有什么改变的：</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a aria-hidden="true" href="#cb21-1"></a><span class="dt">void</span> split(<span class="dt">int</span> u, <span class="dt">int</span> k, <span class="dt">int</span>&amp; x, <span class="dt">int</span>&amp; y) {</span>
<span id="cb21-2"><a aria-hidden="true" href="#cb21-2"></a>    <span class="cf">if</span> (!u) {</span>
<span id="cb21-3"><a aria-hidden="true" href="#cb21-3"></a>        x = y = <span class="dv">0</span>;</span>
<span id="cb21-4"><a aria-hidden="true" href="#cb21-4"></a>        <span class="cf">return</span>;</span>
<span id="cb21-5"><a aria-hidden="true" href="#cb21-5"></a>    }</span>
<span id="cb21-6"><a aria-hidden="true" href="#cb21-6"></a>    <span class="cf">if</span> (t[u].val &lt;= k) {</span>
<span id="cb21-7"><a aria-hidden="true" href="#cb21-7"></a>        x = clone(u);<span class="co">//*****************</span></span>
<span id="cb21-8"><a aria-hidden="true" href="#cb21-8"></a>        split(t[x].ch[<span class="dv">1</span>], k, t[x].ch[<span class="dv">1</span>], y);</span>
<span id="cb21-9"><a aria-hidden="true" href="#cb21-9"></a>        pushup(x);</span>
<span id="cb21-10"><a aria-hidden="true" href="#cb21-10"></a>    } <span class="cf">else</span> {</span>
<span id="cb21-11"><a aria-hidden="true" href="#cb21-11"></a>        y = clone(u);<span class="co">//*****************</span></span>
<span id="cb21-12"><a aria-hidden="true" href="#cb21-12"></a>        split(t[y].ch[<span class="dv">0</span>], k, x, t[y].ch[<span class="dv">0</span>]);</span>
<span id="cb21-13"><a aria-hidden="true" href="#cb21-13"></a>        pushup(y);</span>
<span id="cb21-14"><a aria-hidden="true" href="#cb21-14"></a>    }</span>
<span id="cb21-15"><a aria-hidden="true" href="#cb21-15"></a>    <span class="cf">return</span>;</span>
<span id="cb21-16"><a aria-hidden="true" href="#cb21-16"></a>}</span></code></pre></div>
<p>对比一下普通版的：</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a aria-hidden="true" href="#cb22-1"></a><span class="dt">void</span> split(<span class="dt">int</span> u, <span class="dt">int</span> k, <span class="dt">int</span> &amp;x, <span class="dt">int</span> &amp;y) {</span>
<span id="cb22-2"><a aria-hidden="true" href="#cb22-2"></a>    <span class="cf">if</span> (!u) {</span>
<span id="cb22-3"><a aria-hidden="true" href="#cb22-3"></a>        x = y = <span class="dv">0</span>;</span>
<span id="cb22-4"><a aria-hidden="true" href="#cb22-4"></a>        <span class="cf">return</span>;</span>
<span id="cb22-5"><a aria-hidden="true" href="#cb22-5"></a>    }</span>
<span id="cb22-6"><a aria-hidden="true" href="#cb22-6"></a>    <span class="cf">if</span> (t[u].val &lt;= k)</span>
<span id="cb22-7"><a aria-hidden="true" href="#cb22-7"></a>        x = u, split(R, k, R, y);</span>
<span id="cb22-8"><a aria-hidden="true" href="#cb22-8"></a>    <span class="cf">else</span></span>
<span id="cb22-9"><a aria-hidden="true" href="#cb22-9"></a>        y = u, split(L, k, x, L);</span>
<span id="cb22-10"><a aria-hidden="true" href="#cb22-10"></a>    pushup(u);</span>
<span id="cb22-11"><a aria-hidden="true" href="#cb22-11"></a>    <span class="cf">return</span>;</span>
<span id="cb22-12"><a aria-hidden="true" href="#cb22-12"></a>}</span></code></pre></div>
<p>注意一下星号的几行。其本质也就是对进行了修改的节点进行增加并且复制。</p>
<p>由于我们进行修改的时候，split 和 merge 是成对存在的，所以在 merge 的时候就不需要再复制一遍节点了。</p>
<p>容易出错的地方：</p>
<ul>
<li>如果存在 pushdown 操作，那么 pushdown 的时候也要复制一遍节点。</li>
<li>注意哪里要 pushdown 以及哪里不要 pushdown。</li>
<li>思考清楚各个数据间被调用的先后顺序及关系。</li>
</ul>
<h2 id="线段树高阶应用">线段树高阶应用</h2>
<h3 id="线段树的合并与分裂">线段树的合并与分裂</h3>
<h4 id="简介实现">简介/实现</h4>
<p>有一部分问题（树上问题偏多），会需要我们维护很多棵动态开点权值线段树然后需要合并这些树的信息，一般地，每棵树一开始都是一条链，即 <span class="math inline">\(n\)</span> 棵只有一个元素的线段树。</p>
<p>一般来说，启发式合并是对大部分数据结构通用的合并方法，但是会多出一个 <span class="math inline">\(\log\)</span>，而对于这些动态开点线段树，可以通过在两棵树上同时 dfs 来完成 <span class="math inline">\(O(n\log n)\)</span> 的合并。下面的 <code>merge(k1, k2, i, j)</code> 函数代表将 <span class="math inline">\(k_1\)</span> 和 <span class="math inline">\(k_2\)</span> 节点的信息合并然后扔掉 <span class="math inline">\(k_2\)</span> 节点。</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a aria-hidden="true" href="#cb23-1"></a><span class="dt">int</span> merge(<span class="dt">int</span> k1, <span class="dt">int</span> k2, <span class="dt">int</span> i, <span class="dt">int</span> j) {</span>
<span id="cb23-2"><a aria-hidden="true" href="#cb23-2"></a>    <span class="cf">if</span> (!k1 || !k2) <span class="cf">return</span> k1 + k2;<span class="co">// 如果其中一方为空</span></span>
<span id="cb23-3"><a aria-hidden="true" href="#cb23-3"></a>    <span class="cf">if</span> (i == j) {</span>
<span id="cb23-4"><a aria-hidden="true" href="#cb23-4"></a>        <span class="co">// 将 k2 的信息合并到 k1 上</span></span>
<span id="cb23-5"><a aria-hidden="true" href="#cb23-5"></a>        <span class="cf">return</span> k1;</span>
<span id="cb23-6"><a aria-hidden="true" href="#cb23-6"></a>    }</span>
<span id="cb23-7"><a aria-hidden="true" href="#cb23-7"></a>    t[k1].ls = merge(t[k1].ls, t[k2].ls, i, M); <span class="co">// 分别合并左右儿子</span></span>
<span id="cb23-8"><a aria-hidden="true" href="#cb23-8"></a>    t[k1].rs = merge(t[k1].rs, t[k2].rs, M + <span class="dv">1</span>, j);</span>
<span id="cb23-9"><a aria-hidden="true" href="#cb23-9"></a>    pushup(k1);</span>
<span id="cb23-10"><a aria-hidden="true" href="#cb23-10"></a>    <span class="cf">return</span> k1; <span class="co">// 再返回 k1</span></span>
<span id="cb23-11"><a aria-hidden="true" href="#cb23-11"></a>}</span></code></pre></div>
<p>另外，有合并，就有分裂。分裂非常类似 FHQ-Treap 的分裂，即为将一棵线段树按照值域或者大小分裂开来。</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb24-1"><a aria-hidden="true" href="#cb24-1"></a><span class="dt">void</span> split(<span class="dt">int</span> k1, <span class="dt">int</span> &amp;k2, ll k)</span>
<span id="cb24-2"><a aria-hidden="true" href="#cb24-2"></a>{</span>
<span id="cb24-3"><a aria-hidden="true" href="#cb24-3"></a>    <span class="cf">if</span> (!k1) <span class="cf">return</span>;</span>
<span id="cb24-4"><a aria-hidden="true" href="#cb24-4"></a>    k2 = newnode();</span>
<span id="cb24-5"><a aria-hidden="true" href="#cb24-5"></a>    ll v = t[L(k1)].sum;</span>
<span id="cb24-6"><a aria-hidden="true" href="#cb24-6"></a>    <span class="cf">if</span> (k &gt; v) split(R(k1), R(k2), k - v);</span>
<span id="cb24-7"><a aria-hidden="true" href="#cb24-7"></a>    <span class="cf">else</span> swap(R(k1), R(k2));</span>
<span id="cb24-8"><a aria-hidden="true" href="#cb24-8"></a>    <span class="cf">if</span> (k &lt; v) split(L(k1), L(k2), k);</span>
<span id="cb24-9"><a aria-hidden="true" href="#cb24-9"></a>    t[k2].sum = t[k1].sum - k;</span>
<span id="cb24-10"><a aria-hidden="true" href="#cb24-10"></a>    t[k1].sum = k;</span>
<span id="cb24-11"><a aria-hidden="true" href="#cb24-11"></a>    <span class="cf">return</span>;</span>
<span id="cb24-12"><a aria-hidden="true" href="#cb24-12"></a>}</span></code></pre></div>
<h4 id="简单应用-1">简单应用</h4>
<blockquote>
<p>例题 1：<a href="https://www.luogu.com.cn/problem/P4556">P4556 [Vani有约会]雨天的尾巴 /【模板】线段树合并</a></p>
<p>一棵树，<span class="math inline">\(n\)</span> 点，每个点上维护一个可重集。<span class="math inline">\(m\)</span> 次操作，每次操作给一条树链上的所有集合添加一个数，最后问每个点上点集中最小的众数。</p>
</blockquote>
<p>树上差分一下，然后用权值线段树维护一下每棵树的点集然后从下往上合并即可。</p>
<blockquote>
<p>例题 2：<a href="https://www.luogu.com.cn/problem/P3521">P3521 [POI2011]ROT-Tree Rotations</a></p>
<p>给定一颗有 <span class="math inline">\(n\)</span> 个<strong>叶节点</strong>的二叉树。每个叶节点都有一个权值 <span class="math inline">\(p_i\)</span>（注意，根不是叶节点），所有叶节点的权值构成了一个 <span class="math inline">\(1 \sim n\)</span> 的排列。 对于这棵二叉树的任何一个结点，保证其要么是叶节点，要么左右两个孩子都存在。 现在你可以任选一些节点，交换这些节点的左右子树。 在最终的树上，按照先序遍历遍历整棵树并依次写下遇到的叶结点的权值构成一个长度为 <span class="math inline">\(n\)</span> 的排列，你需要最小化这个排列的逆序对数。</p>
</blockquote>
<p>逆序对有<strong>在子树内产生</strong>和<strong>跨越子树</strong>两种产生方式，交换左右子树只会对跨越的那一部分产生影响，而且对于先序遍历，交换操作对之前的部分是没有影响的，所以我们可以在线段树合并的时候随便计算一下逆序对数然后取个最小值即可。</p>
<blockquote>
<p>例题 3：<a href="https://www.luogu.com.cn/problem/P2824">P2824 [HEOI2016/TJOI2016]排序</a></p>
<p>原题意：多次区间排序，最后问某个位置上的值。</p>
</blockquote>
<p>二分答案然后将原序列变为 0-1 序列之后的做法较为平凡，<span class="math inline">\(O(n\log^2n)\)</span>。</p>
<p>而线段树合并+分裂的做法可以达到 <span class="math inline">\(O(n\log n)\)</span> 并且求出整个序列。</p>
<p>考虑一个权值线段树维护的就是一段值域内的数集。所以考虑类比珂朵莉树，用 <code>set</code> 维护一下所有有序连续段，然后各个连续段用线段树维护。</p>
<h4 id="进阶应用">进阶应用</h4>
<p>主要是线段树合并维护 dp 转移什么的（听说又叫做“整体 dp”？），有些用到了比较高妙的技巧。</p>
<p>一般来说，就是像诸如 <span class="math inline">\(f_{x, i}\)</span> 这样看似要 <span class="math inline">\(O(n^2)\)</span> 的树上 dp，然后叶子节点上有值的 dp 值又很少，又能快速转移之类的巴拉巴拉。</p>
<blockquote>
<p>例题 4：<a href="https://www.luogu.com.cn/problem/P5298">P5298 [PKUWC2018]Minimax</a></p>
<p><span class="math inline">\(n\)</span> 个节点的二叉树，根为 <span class="math inline">\(1\)</span>，每个节点最多两个儿子。</p>
<p>定义 <span class="math inline">\(x\)</span> 的权值为：</p>
<ul>
<li><span class="math inline">\(x\)</span> 没有子节点，则输入给出其权值，<strong>保证所有权值互不相同</strong>。</li>
<li>若 <span class="math inline">\(x\)</span> 有子节点，则其权值有 <span class="math inline">\(p_x\)</span> 的概率为子节点权值的最大值，<span class="math inline">\(1 - p_x\)</span> 的概率为子节点权值的最小值。</li>
</ul>
<p>假设 <span class="math inline">\(1\)</span> 号节点的权值有 <span class="math inline">\(m\)</span> 种可能性，权值第 <span class="math inline">\(i\)</span> 小的可能性的权值为 <span class="math inline">\(V_i\)</span>，概率为 <span class="math inline">\(D_i\)</span>，求 <span class="math display">\[
\sum_{i=1}^mi\times V_i\times D_i^2
\]</span> 答案模 <span class="math inline">\(998244353\)</span>。<span class="math inline">\(1\le n\le 3\times 10^5\)</span>，权值范围 <span class="math inline">\([1, 10^9]\)</span>，概率 <span class="math inline">\(\in(0,1)\)</span>。</p>
</blockquote>
<p>比较高妙的题，详见<a href="/sol-luogu-p5298/">我的题解</a>。先离散化权值，设 <span class="math inline">\(P(u, i)\)</span> 为 <span class="math inline">\(u\)</span> 的权值为 <span class="math inline">\(i\)</span> 的概率，容易得到如下转移： <span class="math display">\[
P(u, i) = P(v_1, i)P(v_2, i) + p_u\left(\sum_{j &lt; i}P(v_1, i)P(v_2, j) + P(v_1, j)P(v_2, i)\right)\\ + (1-p_u)\left(\sum_{j&gt; i}P(v_1, i)P(v_2, j)+P(v_1, j)P(v_2, i)\right)
\]</span> 考虑利用线段树合并维护这个东西。由于 <span class="math inline">\(P(v_1, i)\)</span> 和 <span class="math inline">\(P(v_2, i)\)</span> 必有一个为 <span class="math inline">\(0\)</span>（假设后者），所以其实就是 <span class="math display">\[
P(u, i) = P(v_1, i)\left(p_u\sum_{j&lt;i}P(v_2, j) + (1 - p_u)\sum_{j&gt;i}P(v_2, j)\right)
\]</span> 合并的过程中记录前/后缀和，然后到了一方有节点一方无节点的时候就打上乘法标记，完成转移。</p>
<blockquote>
<p>例题 5：<a href="https://www.luogu.com.cn/problem/P6773">P6773 [NOI2020] 命运</a></p>
<p>给定 <span class="math inline">\(n\)</span> 个点的树，<span class="math inline">\(m\)</span> 条祖先到后代的链，问有多少种给树边黑白染色的方案使得每条给定的链上都至少有一条黑边，答案模 <span class="math inline">\(998244353\)</span>。<span class="math inline">\(1\le n,m\le 5\times 10^5\)</span>。</p>
</blockquote>
<p>详见<a href="/sol-luogu-p6773">我的题解</a>。直接说正解，考虑一个 <span class="math inline">\(O(n^2)\)</span> 的 dp，设 <span class="math inline">\(f_{u, i}\)</span> 为 <span class="math inline">\(u\)</span> 子树内的限制已满足，未被满足的跨越 <span class="math inline">\(u\)</span> 的限制的最深深度为 <span class="math inline">\(i\)</span> 的方案数，则考虑 <span class="math inline">\((u, v)\)</span> 连边染色与否可以得到转移 <span class="math display">\[
f_{u,i}\leftarrow f_{u,i}\times(g_{v, dep_v - 1} + g_{v, i}) + g_{u, i - 1}\times f_{v, i}, dep_{anc_{x}}\le i &lt; dep_x
\]</span> 类似上题处理方法记录前缀和，打乘法标记即可。</p>
<h3 id="李超线段树">李超线段树</h3>
<h4 id="简介实现-1">简介/实现</h4>
<p>可以维护平面内若干一次函数的最值。支持插入一个一次函数和查询某点处最大值的功能。</p>
<p>由于是标记永久化的思想，所以可以可持久化。插入的一次函数也可以有定义域（即插入线段）。</p>
<p>关键思想是当前节点上维护一个“优势线段”，其被定义为完整覆盖了当前区间且在区间中点处纵坐标最大的线段。</p>
<p>插入一个线段 <span class="math inline">\(u\)</span> 的时候，假设其能完整覆盖当前节点的区间 <span class="math inline">\([i, j]\)</span>。然后取原来区间的最优线段 <span class="math inline">\(v\)</span>，比较 <span class="math inline">\(k_u\)</span> 和 <span class="math inline">\(k_v\)</span> 后再分类讨论一波，若能作为当前区间的最优线段则直接覆盖掉，再用 <span class="math inline">\(v\)</span> 递归另一半边还“有希望”的区间，反之拿 <span class="math inline">\(u\)</span> 递归有希望的区间。<em>可以画图理解</em>。</p>
<p>可以发现，若是单纯插入一次函数，则复杂度为 <span class="math inline">\(O(\log n)\)</span>，若是插入带左右端点的线段，则复杂度为 <span class="math inline">\(O(\log^2n)\)</span> 但常数较小。下面是对于插入一次函数的，一种比较简洁的写法，可以减少分类讨论。</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a aria-hidden="true" href="#cb25-1"></a><span class="dt">void</span> insert(<span class="dt">int</span> &amp;k, <span class="dt">int</span> i, <span class="dt">int</span> j, <span class="dt">int</span> u) {</span>
<span id="cb25-2"><a aria-hidden="true" href="#cb25-2"></a>    <span class="cf">if</span> (!k) <span class="cf">return</span> k = ++tot, t[k] = u, <span class="dt">void</span>();</span>
<span id="cb25-3"><a aria-hidden="true" href="#cb25-3"></a>    <span class="cf">if</span> (calc(M, t[k]) &gt; calc(M, u)) swap(u, t[k]);</span>
<span id="cb25-4"><a aria-hidden="true" href="#cb25-4"></a>    <span class="cf">if</span> (calc(i, t[k]) &lt;= calc(i, u) &amp;&amp; calc(j, t[k]) &lt;= calc(j, u)) <span class="cf">return</span>; <span class="co">// 一个可以优化常数的小剪枝，即若当前线段被全面吊打则寄。</span></span>
<span id="cb25-5"><a aria-hidden="true" href="#cb25-5"></a>    <span class="cf">if</span> (calc(i, t[k]) &gt; calc(i, u)) insert(ls[k], i, M, u);</span>
<span id="cb25-6"><a aria-hidden="true" href="#cb25-6"></a>    <span class="cf">else</span> insert(rs[k], M + <span class="dv">1</span>, j, u);</span>
<span id="cb25-7"><a aria-hidden="true" href="#cb25-7"></a>    <span class="cf">return</span>;</span>
<span id="cb25-8"><a aria-hidden="true" href="#cb25-8"></a>}</span></code></pre></div>
<p>对于查询操作，可以从上往下递归查询遇到的每个区间上的最优线段的对应取值，可以发现是最优的。</p>
<h4 id="应用">应用</h4>
<p>主要应用场景是维护形如一堆一次函数的最值的问题。</p>
<p>有 <a href="https://darkbzoj.tk/problem/3938">BZOJ#3938. Robot</a>，转化题意后就是维护一堆分段一次函数的最值，<strong>需要注意如果将横坐标离散化了，算中点（为了算优势线段）一定要算离散化意义下的中点，因为我们基于此来进行线段树操作的递归</strong>。</p>
<p>还可以套上树剖或者点分治来维护树上的一次函数（或者说，等差数列）的信息，如 <a href="https://www.luogu.com.cn/problem/P4069">P4069 [SDOI2016]游戏</a> 和 <a href="https://www.luogu.com.cn/problem/CF1303G">CF1303G Sum of Prefix Sums</a>。</p>
<p>当然最常见的肯定是拿来优化斜率优化。有些横坐标和斜率不满足单调性的斜率优化式子一看就是一个一次函数，可以直接拿李超树维护，比 cdq 和 splay 好写得多。最简单的例子是 <a href="https://www.luogu.com.cn/problem/P4655">P4655 [CEOI2017]Building Bridges</a>。</p>
<p>部分毒瘤的树上斜率优化需要支持李超树的合并，其实可以很暴力地每合并一个节点就将 <span class="math inline">\(y\)</span> 的优势线段插入 <span class="math inline">\(x\)</span>，<span class="math inline">\(O(n\log^2n)\)</span> 也不慢，如 <a href="https://www.luogu.com.cn/problem/CF932F">CF932F Escape Through Leaf</a>。</p>
<h3 id="区间最值操作区间历史最值">区间最值操作/区间历史最值</h3>
<h4 id="简介">简介</h4>
<p>详见吉如一老师 2016 年国家集训队论文《区间最值操作与历史最值问题》。</p>
<p>说的是一种将区间进行“最值操作”和维护区间历史最值的线段树方法。</p>
<p>具体的时间复杂度证明需要势能分析，而我不会。</p>
<h4 id="区间最值操作">区间最值操作</h4>
<p>考虑模板题：</p>
<blockquote>
<p>例题 1：<a href="https://www.luogu.com.cn/problem/P6242">P6242 【模板】线段树 3</a>（部分）给定一个序列 <span class="math inline">\(A\)</span>，支持如下操作：</p>
<ul>
<li><code>2 l r v</code>：<span class="math inline">\(\forall i\in[l,r]\)</span>，<span class="math inline">\(A_i\leftarrow \min(A_i, v)\)</span></li>
<li><code>3 l r</code>：求 <span class="math inline">\([l,r]\)</span> 区间和。</li>
<li><code>4 l r</code>：求 <span class="math inline">\([l,r]\)</span> 区间最大值。</li>
</ul>
</blockquote>
<p>类似于这种区间对某个数取最值的操作就叫做区间最值操作。我们会发现使用常规的方法是不好进行维护的，下面讲解吉如一的做法。</p>
<p>考虑到对 <span class="math inline">\(v\)</span> 取 <span class="math inline">\(\min\)</span> 只会对最大值 <span class="math inline">\(&gt; v\)</span> 的节点产生影响，可以从这方面入手。在线段树的节点维护三个信息：区间最大值 <span class="math inline">\(mx\)</span>，最大值出现次数 <span class="math inline">\(cnt\)</span> 和区间严格次大值 <span class="math inline">\(se\)</span>。我们进行操作的时候分为三种情况：</p>
<ul>
<li><span class="math inline">\(v \ge mx\)</span>，直接返回。</li>
<li><span class="math inline">\(se&lt;v&lt;mx\)</span>，此时所有最大值都会被修改为 <span class="math inline">\(v\)</span>，并且 <span class="math inline">\(cnt\)</span> 不会改变，所以将区间和减去 <span class="math inline">\(cnt\times(mx-v)\)</span>，然后打上懒标记再返回即可。</li>
<li><span class="math inline">\(v\le se\)</span>，递归操作，无法快速维护。</li>
</ul>
<p>根据吉老师的证明，其时间复杂度为 <span class="math inline">\(O(m\log n)\)</span>。</p>
<blockquote>
<p>例题 2：<a href="https://www.luogu.com.cn/problem/P6242">P6242 【模板】线段树 3</a>（部分）</p>
<p>在上面的基础上，支持操作 <code>1 l r v</code>：<span class="math inline">\([l,r]\)</span> 区间加上 <span class="math inline">\(v\)</span>。</p>
</blockquote>
<p>两种思路：</p>
<ul>
<li>将标记换为二元组 <span class="math inline">\((add, v)\)</span>，表示先加上 <span class="math inline">\(add\)</span> 再与 <span class="math inline">\(v\)</span> 取 <span class="math inline">\(\min\)</span>。下传标记的时候将 <span class="math inline">\((add_{ch}, v_{ch})\leftarrow (add_{ch} + add, \min(v_{ch} + add, v))\)</span>。</li>
<li>另一种思路是，发现我们实际上<strong>将节点上维护的元素分为最大值和非最大值两类</strong>，而区间最值操作的标记只会打在 <span class="math inline">\(se&lt;v&lt;mx\)</span> 的节点上，完全可以看成<em>对最大值的加减操作</em>。所以考虑分别维护区间最大值的加法标记和非区间最大值的加法标记，下传的时候判断一下即可。</li>
</ul>
<p>其时间复杂度我也不知道是多少，但应该跑的很快，大概有个 <span class="math inline">\(O(m\log^2 n)\)</span> 的下界。</p>
<blockquote>
<p>例题 3：<a href="https://hydro.ac/d/bzoj/p/4695">BZOJ #4695. 最假女选手</a> 给定序列 <span class="math inline">\(A\)</span>，请支持如下操作：</p>
<ol type="1">
<li>区间加</li>
<li>区间对 <span class="math inline">\(v\)</span> 取 <span class="math inline">\(\max\)</span></li>
<li>区间对 <span class="math inline">\(v\)</span> 取 <span class="math inline">\(\min\)</span></li>
<li>区间求和</li>
<li>区间最大值</li>
<li>区间最小值</li>
</ol>
</blockquote>
<p>可以像上面一样维护三个标记，但是太麻烦了，考虑用<strong>划分数域</strong>的思路，维护最大值、最小值、次大值、次小值、最大值出现次数、最小值出现次数、区间和，以及分别对于最大值、最小值和其他值的加法标记。</p>
<p>对于 <span class="math inline">\(1\)</span> 操作，直接将三种标记都加上，对于 <span class="math inline">\(2\)</span> 操作，找到对应 的节点打上最小值的加法操作即可，<span class="math inline">\(3\)</span> 操作同理。现在这题最麻烦的地方在于标记的下传。因为值域很小的时候可能会出现次大值等于最小值之类的情况，需要分类讨论。</p>
<blockquote>
<p>注：使用结构体线段树可以使得内存访问更连续，减小常数。</p>
</blockquote>
<p>除了直球的维护，有部分问题也可以转化为区间最值操作：</p>
<blockquote>
<p>例题 4：<a href="http://uoj.ac/problem/515">UOJ#515. 【UR #19】前进四</a></p>
<p>给定序列 <span class="math inline">\(A\)</span>，两种操作，<span class="math inline">\(n,q\le 10^6\)</span>，<strong>时限 1s</strong>：</p>
<ol type="1">
<li>单点修改：<span class="math inline">\(A_x\leftarrow v\)</span>。</li>
<li>给定 <span class="math inline">\(x\)</span>，询问 <span class="math inline">\(A_x,A_{x+1},\cdots,A_n\)</span> 的不同后缀最小值个数。</li>
</ol>
</blockquote>
<p>你发现， <a href="https://www.luogu.com.cn/problem/P4198">清华集训2012 楼房重建</a> 问的是前缀最大值的个数，问题是完全等价的。所以也可以用 <span class="math inline">\(O(q\log^2n)\)</span> 的在线算法（见下文）解决。但是注意到数据范围较大而时限较紧，所以我们采用一个效率更高的离线算法。</p>
<p>本题是后缀询问，所以不妨用<em>扫描线</em>从后往前扫，用线段树维护关于时间的后缀最小值。对于扫描到的位置 <span class="math inline">\(i\)</span>，其上面的修改操作会<strong>影响从这个时刻开始，到该位置的下一个修改时刻位置</strong>的时间段，所以将这个时间段的后缀最小值都与 <span class="math inline">\(v\)</span> 取 <span class="math inline">\(\min\)</span>。而询问则是求扫描到 <span class="math inline">\(i\)</span> 时，该询问发生的时刻<strong>被取了多少次后缀最小值</strong>，这个东西可以下传标记的时候顺便维护一下。</p>
<p>上文的核心思想就是<strong>划分数域</strong>，我们将区间最值操作转化成了最值数域上的加减操作。下面将沿用此思想。</p>
<h4 id="区间历史最值">区间历史最值</h4>
<p>对于元素 <span class="math inline">\(A_i\)</span>，其历史最值是指从初始化到当前达到过的最值，其历史版本和指的是每一次修改操作后的值之和。</p>
<p>而区间历史最值则是指求 <span class="math inline">\([l,r]\)</span> 的区间最值的最值或者代数和之类的区间问题。</p>
<p><strong>注意，区间历史最值和可持久化没什么关系</strong>。</p>
<blockquote>
<p>例题 <span class="math inline">\(5\)</span>：<a href="https://www.luogu.com.cn/problem/P4314">P4314 CPU 监控</a></p>
<p>维护序列 <span class="math inline">\(A\)</span>，数据范围 <span class="math inline">\(10^5\)</span>，不会爆 <code>int</code>。</p>
<ul>
<li>询问 <span class="math inline">\([l, r]\)</span> 的区间最大值。</li>
<li>询问 <span class="math inline">\([l,r ]\)</span> 的区间历史最大值。</li>
<li>对 <span class="math inline">\([l, r]\)</span> 区间加 <span class="math inline">\(z\)</span>。</li>
<li>对 <span class="math inline">\([l, r]\)</span> 区间赋值为 <span class="math inline">\(z\)</span>。</li>
</ul>
</blockquote>
<p>使用强大的<strong>懒标记</strong>来解决此类问题。不妨先考虑只有区间加的情况。</p>
<p><em>回忆线段树的懒标记下传机制，若某个点存在标记，表示该子树内在标记存在的时间段内都未被更新</em>。所以问题的核心就在于分析一个点上标记的影响。</p>
<p>对于和历史最值无关的题目，我们<strong>只关注当前</strong>的标记是什么，所以标记可以简单合并。但是在历史最值问题中，我们不仅要考虑该节点现在的结果，还需考虑<strong>历史标记</strong>的依次作用（以时间先后为序）。那么为了简化问题，我们<em>暂且不合并</em>标记，而是假装有一个队列存着曾经推过来的所有标记。</p>
<p>首先，显然需要维护区间最值 <span class="math inline">\(\mathrm{mx}\)</span> 和历史最值 <span class="math inline">\(\mathrm{mx}'\)</span>，每次有一个区间加 <span class="math inline">\(d\)</span> 标记推过来时，显然有 <span class="math inline">\(\mathrm{mx}:=\max(\mathrm{mx}, \mathrm{mx} + d)\)</span> 然后 <span class="math inline">\(\mathrm{mx}' := \max(\mathrm{mx}, \mathrm{mx}')\)</span>。</p>
<p>这么做一定是正确的，但是我们<em>不可能不合并标记</em>，所以需要寻找一个方法来<strong>概括这个标记队列的影响</strong>。</p>
<p>先考虑单个节点打上若干标记，记标记的值为 <span class="math inline">\(t_{1,\cdots, k}\)</span>，前缀和为 <span class="math inline">\(S_{1,\cdots, k}\)</span>。则对于每次 <span class="math inline">\(i\)</span> 显然有 <span class="math inline">\(x:=x + t_i\)</span> 故 <span class="math inline">\(\mathrm{mx}' = \max_{i=0}^k\{x + S_i\} = x + \max S_i\)</span>。</p>
<p>所以记录 <span class="math inline">\(\max S_i\)</span> 即可得知队列对节点的影响。而若我们每次合并加法标记时直接求和，则 <span class="math inline">\(\max S_i\)</span> 说的就是<strong>历史最大加法标记</strong>。</p>
<p>现在考虑标记下传（显然是将两个队列合并）时，如何处理。假设为 <span class="math inline">\(A_{1,\cdots, k_1}\)</span> 和 <span class="math inline">\(B_{1,\cdots, k_2}\)</span>，前缀和分别为 <span class="math inline">\(R_{1,\cdots, k_1}\)</span> 和 <span class="math inline">\(T_{1,\cdots, k_2}\)</span>。合并的结果为 <span class="math inline">\(C_{1,\cdots, k_1 + k_2}\)</span>。</p>
<p>注意到 <span class="math inline">\(S_i = \begin{cases}R_i&amp;1\le i\le k_1\\R_{k_1} + T_{i - k_1}&amp;k_1 &lt; i\le k_1 + k_2\end{cases}\)</span>，故 <span class="math inline">\(\max S_i = \max(\max_{i=0}^{k_1}R_i, R_{k_1} + \max_{i=0}^{k_2}T_i)\)</span>，而 <span class="math inline">\(R_{k_1}\)</span> 正是当前加法标记的值，前面的 <span class="math inline">\(\max R_i\)</span> 即为当前的加法标记历史最大值。</p>
<p>所以我们下传标记的时候：</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb26-1"><a aria-hidden="true" href="#cb26-1"></a><span class="kw">struct</span> Node {</span>
<span id="cb26-2"><a aria-hidden="true" href="#cb26-2"></a>    <span class="dt">int</span> add, addh, mx, mxh;</span>
<span id="cb26-3"><a aria-hidden="true" href="#cb26-3"></a>} t[maxn &lt;&lt; <span class="dv">2</span>];</span>
<span id="cb26-4"><a aria-hidden="true" href="#cb26-4"></a></span>
<span id="cb26-5"><a aria-hidden="true" href="#cb26-5"></a><span class="dt">void</span> pushAdd(<span class="dt">int</span> k, <span class="dt">int</span> add, <span class="dt">int</span> addh) {</span>
<span id="cb26-6"><a aria-hidden="true" href="#cb26-6"></a>    chkmax(t[k].addh, t[k].add + addh); <span class="co">// 加法标记历史最大值</span></span>
<span id="cb26-7"><a aria-hidden="true" href="#cb26-7"></a>    chkmax(t[k].mxh, t[k].mx + addh); <span class="co">// 历史最大值</span></span>
<span id="cb26-8"><a aria-hidden="true" href="#cb26-8"></a>    t[k].mx += add; <span class="co">// 最大值</span></span>
<span id="cb26-9"><a aria-hidden="true" href="#cb26-9"></a>    t[k].add += add; <span class="co">// 加法标记</span></span>
<span id="cb26-10"><a aria-hidden="true" href="#cb26-10"></a>    <span class="cf">return</span>;</span>
<span id="cb26-11"><a aria-hidden="true" href="#cb26-11"></a>}</span></code></pre></div>
<p>那么考虑赋值标记。<strong>在一般的线段树题目中，可以不思考两种标记的相互作用，但是在维护历史版本的线段树中需要完整地考虑每个标记造成的历史影响。</strong></p>
<p>可以发现若存在一个赋值标记，区间就会变成同一个数，标记队列中后面的标记全部会被转化为赋值标记。所以标记队列可以转化为若干加法标记 + 若干赋值标记。对于赋值标记，维护一个<em>历史最大赋值标记</em>即可。<del><strong>不要写挂</strong></del></p>
<div class="sourceCode" id="cb27"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb27-1"><a aria-hidden="true" href="#cb27-1"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">1e5</span> + <span class="dv">5</span>;</span>
<span id="cb27-2"><a aria-hidden="true" href="#cb27-2"></a></span>
<span id="cb27-3"><a aria-hidden="true" href="#cb27-3"></a><span class="kw">struct</span> Node {</span>
<span id="cb27-4"><a aria-hidden="true" href="#cb27-4"></a>    <span class="dt">int</span> add, addh, cov, covh, vis, mx, mxh;</span>
<span id="cb27-5"><a aria-hidden="true" href="#cb27-5"></a>} t[maxn &lt;&lt; <span class="dv">2</span>];</span>
<span id="cb27-6"><a aria-hidden="true" href="#cb27-6"></a></span>
<span id="cb27-7"><a aria-hidden="true" href="#cb27-7"></a><span class="pp">#define L </span>(k<span class="pp"> </span>&lt;&lt;<span class="pp"> </span><span class="dv">1</span>)</span>
<span id="cb27-8"><a aria-hidden="true" href="#cb27-8"></a><span class="pp">#define R </span>(L<span class="pp"> </span>|<span class="pp"> </span><span class="dv">1</span>)</span>
<span id="cb27-9"><a aria-hidden="true" href="#cb27-9"></a><span class="pp">#define M </span>((i<span class="pp"> </span>+<span class="pp"> </span>j)<span class="pp"> </span>&gt;&gt;<span class="pp"> </span><span class="dv">1</span>)</span>
<span id="cb27-10"><a aria-hidden="true" href="#cb27-10"></a></span>
<span id="cb27-11"><a aria-hidden="true" href="#cb27-11"></a><span class="dt">void</span> pushAdd(<span class="dt">int</span> k, <span class="dt">int</span> add, <span class="dt">int</span> addh) {</span>
<span id="cb27-12"><a aria-hidden="true" href="#cb27-12"></a>    <span class="cf">if</span> (t[k].vis) { <span class="co">// 注意这里的分类讨论</span></span>
<span id="cb27-13"><a aria-hidden="true" href="#cb27-13"></a>        chkmax(t[k].covh, t[k].cov + addh);</span>
<span id="cb27-14"><a aria-hidden="true" href="#cb27-14"></a>        chkmax(t[k].mxh, t[k].mx + addh);</span>
<span id="cb27-15"><a aria-hidden="true" href="#cb27-15"></a>        t[k].mx += add, t[k].cov += add;</span>
<span id="cb27-16"><a aria-hidden="true" href="#cb27-16"></a>    } <span class="cf">else</span> {</span>
<span id="cb27-17"><a aria-hidden="true" href="#cb27-17"></a>        chkmax(t[k].addh, t[k].add + addh);</span>
<span id="cb27-18"><a aria-hidden="true" href="#cb27-18"></a>        chkmax(t[k].mxh, t[k].mx + addh);</span>
<span id="cb27-19"><a aria-hidden="true" href="#cb27-19"></a>        t[k].mx += add, t[k].add += add;</span>
<span id="cb27-20"><a aria-hidden="true" href="#cb27-20"></a>    }</span>
<span id="cb27-21"><a aria-hidden="true" href="#cb27-21"></a>    <span class="cf">return</span>;</span>
<span id="cb27-22"><a aria-hidden="true" href="#cb27-22"></a>}</span>
<span id="cb27-23"><a aria-hidden="true" href="#cb27-23"></a></span>
<span id="cb27-24"><a aria-hidden="true" href="#cb27-24"></a><span class="dt">void</span> pushCov(<span class="dt">int</span> k, <span class="dt">int</span> cov, <span class="dt">int</span> covh) {</span>
<span id="cb27-25"><a aria-hidden="true" href="#cb27-25"></a>    <span class="cf">if</span> (t[k].vis) chkmax(t[k].covh, covh);</span>
<span id="cb27-26"><a aria-hidden="true" href="#cb27-26"></a>    <span class="cf">else</span> t[k].vis = <span class="dv">1</span>, t[k].covh = covh;</span>
<span id="cb27-27"><a aria-hidden="true" href="#cb27-27"></a>    t[k].mx = t[k].cov = cov;</span>
<span id="cb27-28"><a aria-hidden="true" href="#cb27-28"></a>    chkmax(t[k].mxh, covh);</span>
<span id="cb27-29"><a aria-hidden="true" href="#cb27-29"></a>    <span class="cf">return</span>;</span>
<span id="cb27-30"><a aria-hidden="true" href="#cb27-30"></a>}</span>
<span id="cb27-31"><a aria-hidden="true" href="#cb27-31"></a></span>
<span id="cb27-32"><a aria-hidden="true" href="#cb27-32"></a><span class="dt">void</span> pushDown(<span class="dt">int</span> k) {</span>
<span id="cb27-33"><a aria-hidden="true" href="#cb27-33"></a>    pushAdd(L, t[k].add, t[k].addh);</span>
<span id="cb27-34"><a aria-hidden="true" href="#cb27-34"></a>    pushAdd(R, t[k].add, t[k].addh);</span>
<span id="cb27-35"><a aria-hidden="true" href="#cb27-35"></a>    t[k].add = t[k].addh = <span class="dv">0</span>;</span>
<span id="cb27-36"><a aria-hidden="true" href="#cb27-36"></a>    <span class="cf">if</span> (t[k].vis) {</span>
<span id="cb27-37"><a aria-hidden="true" href="#cb27-37"></a>        pushCov(L, t[k].cov, t[k].covh);</span>
<span id="cb27-38"><a aria-hidden="true" href="#cb27-38"></a>        pushCov(R, t[k].cov, t[k].covh);</span>
<span id="cb27-39"><a aria-hidden="true" href="#cb27-39"></a>        t[k].vis = t[k].cov = t[k].covh = <span class="dv">0</span>;</span>
<span id="cb27-40"><a aria-hidden="true" href="#cb27-40"></a>    }</span>
<span id="cb27-41"><a aria-hidden="true" href="#cb27-41"></a>    <span class="cf">return</span>;</span>
<span id="cb27-42"><a aria-hidden="true" href="#cb27-42"></a>}</span>
<span id="cb27-43"><a aria-hidden="true" href="#cb27-43"></a></span>
<span id="cb27-44"><a aria-hidden="true" href="#cb27-44"></a><span class="dt">void</span> pushUp(<span class="dt">int</span> k) {</span>
<span id="cb27-45"><a aria-hidden="true" href="#cb27-45"></a>    t[k].mx = max(t[L].mx, t[R].mx);</span>
<span id="cb27-46"><a aria-hidden="true" href="#cb27-46"></a>    t[k].mxh = max(t[L].mxh, t[R].mxh);</span>
<span id="cb27-47"><a aria-hidden="true" href="#cb27-47"></a>    <span class="cf">return</span>;</span>
<span id="cb27-48"><a aria-hidden="true" href="#cb27-48"></a>}</span>
<span id="cb27-49"><a aria-hidden="true" href="#cb27-49"></a></span>
<span id="cb27-50"><a aria-hidden="true" href="#cb27-50"></a><span class="dt">void</span> add(<span class="dt">int</span> i, <span class="dt">int</span> j, <span class="dt">int</span> k, <span class="dt">int</span> x, <span class="dt">int</span> y, <span class="dt">int</span> v) {</span>
<span id="cb27-51"><a aria-hidden="true" href="#cb27-51"></a>    <span class="cf">if</span> (x &lt;= i &amp;&amp; y &gt;= j) {</span>
<span id="cb27-52"><a aria-hidden="true" href="#cb27-52"></a>        pushAdd(k, v, v);</span>
<span id="cb27-53"><a aria-hidden="true" href="#cb27-53"></a>        <span class="cf">return</span>;</span>
<span id="cb27-54"><a aria-hidden="true" href="#cb27-54"></a>    }</span>
<span id="cb27-55"><a aria-hidden="true" href="#cb27-55"></a>    pushDown(k);</span>
<span id="cb27-56"><a aria-hidden="true" href="#cb27-56"></a>    <span class="cf">if</span> (x &lt;= M) add(i, M, L, x, y, v);</span>
<span id="cb27-57"><a aria-hidden="true" href="#cb27-57"></a>    <span class="cf">if</span> (y &gt; M) add(M + <span class="dv">1</span>, j, R, x, y, v);</span>
<span id="cb27-58"><a aria-hidden="true" href="#cb27-58"></a>    <span class="cf">return</span> pushUp(k);</span>
<span id="cb27-59"><a aria-hidden="true" href="#cb27-59"></a>}</span>
<span id="cb27-60"><a aria-hidden="true" href="#cb27-60"></a></span>
<span id="cb27-61"><a aria-hidden="true" href="#cb27-61"></a><span class="dt">void</span> cover(<span class="dt">int</span> i, <span class="dt">int</span> j, <span class="dt">int</span> k, <span class="dt">int</span> x, <span class="dt">int</span> y, <span class="dt">int</span> v) {</span>
<span id="cb27-62"><a aria-hidden="true" href="#cb27-62"></a>    <span class="cf">if</span> (x &lt;= i &amp;&amp; y &gt;= j) {</span>
<span id="cb27-63"><a aria-hidden="true" href="#cb27-63"></a>        pushCov(k, v, v);</span>
<span id="cb27-64"><a aria-hidden="true" href="#cb27-64"></a>        <span class="cf">return</span>;</span>
<span id="cb27-65"><a aria-hidden="true" href="#cb27-65"></a>    }</span>
<span id="cb27-66"><a aria-hidden="true" href="#cb27-66"></a>    pushDown(k);</span>
<span id="cb27-67"><a aria-hidden="true" href="#cb27-67"></a>    <span class="cf">if</span> (x &lt;= M) cover(i, M, L, x, y, v);</span>
<span id="cb27-68"><a aria-hidden="true" href="#cb27-68"></a>    <span class="cf">if</span> (y &gt; M) cover(M + <span class="dv">1</span>, j, R, x, y, v);</span>
<span id="cb27-69"><a aria-hidden="true" href="#cb27-69"></a>    <span class="cf">return</span> pushUp(k);</span>
<span id="cb27-70"><a aria-hidden="true" href="#cb27-70"></a>}</span>
<span id="cb27-71"><a aria-hidden="true" href="#cb27-71"></a></span>
<span id="cb27-72"><a aria-hidden="true" href="#cb27-72"></a><span class="dt">int</span> query(<span class="dt">int</span> i, <span class="dt">int</span> j, <span class="dt">int</span> k, <span class="dt">int</span> x, <span class="dt">int</span> y, <span class="dt">int</span> op) {</span>
<span id="cb27-73"><a aria-hidden="true" href="#cb27-73"></a>    <span class="cf">if</span> (x &lt;= i &amp;&amp; y &gt;= j) <span class="cf">return</span> op ? t[k].mxh : t[k].mx;</span>
<span id="cb27-74"><a aria-hidden="true" href="#cb27-74"></a>    pushDown(k);</span>
<span id="cb27-75"><a aria-hidden="true" href="#cb27-75"></a>    <span class="dt">int</span> ret = -<span class="fl">2e9</span>;</span>
<span id="cb27-76"><a aria-hidden="true" href="#cb27-76"></a>    <span class="cf">if</span> (x &lt;= M) chkmax(ret, query(i, M, L, x, y, op));</span>
<span id="cb27-77"><a aria-hidden="true" href="#cb27-77"></a>    <span class="cf">if</span> (y &gt; M) chkmax(ret, query(M + <span class="dv">1</span>, j, R, x, y, op));</span>
<span id="cb27-78"><a aria-hidden="true" href="#cb27-78"></a>    <span class="cf">return</span> ret;</span>
<span id="cb27-79"><a aria-hidden="true" href="#cb27-79"></a>}</span>
<span id="cb27-80"><a aria-hidden="true" href="#cb27-80"></a></span>
<span id="cb27-81"><a aria-hidden="true" href="#cb27-81"></a><span class="dt">void</span> build(<span class="dt">int</span> i, <span class="dt">int</span> j, <span class="dt">int</span> k) {</span>
<span id="cb27-82"><a aria-hidden="true" href="#cb27-82"></a>    <span class="cf">if</span> (i == j) {</span>
<span id="cb27-83"><a aria-hidden="true" href="#cb27-83"></a>        <span class="dt">int</span> x; is &gt;&gt; x;</span>
<span id="cb27-84"><a aria-hidden="true" href="#cb27-84"></a>        t[k].mx = t[k].mxh = x;</span>
<span id="cb27-85"><a aria-hidden="true" href="#cb27-85"></a>        <span class="cf">return</span>;</span>
<span id="cb27-86"><a aria-hidden="true" href="#cb27-86"></a>    }</span>
<span id="cb27-87"><a aria-hidden="true" href="#cb27-87"></a>    build(i, M, L), build(M + <span class="dv">1</span>, j, R);</span>
<span id="cb27-88"><a aria-hidden="true" href="#cb27-88"></a>    <span class="cf">return</span> pushUp(k);</span>
<span id="cb27-89"><a aria-hidden="true" href="#cb27-89"></a>}</span>
<span id="cb27-90"><a aria-hidden="true" href="#cb27-90"></a></span>
<span id="cb27-91"><a aria-hidden="true" href="#cb27-91"></a><span class="dt">int</span> n, m;</span>
<span id="cb27-92"><a aria-hidden="true" href="#cb27-92"></a><span class="dt">char</span> s[<span class="dv">2</span>];</span>
<span id="cb27-93"><a aria-hidden="true" href="#cb27-93"></a></span>
<span id="cb27-94"><a aria-hidden="true" href="#cb27-94"></a><span class="dt">int</span> main() {</span>
<span id="cb27-95"><a aria-hidden="true" href="#cb27-95"></a>    is &gt;&gt; n;</span>
<span id="cb27-96"><a aria-hidden="true" href="#cb27-96"></a>    build(<span class="dv">1</span>, n, <span class="dv">1</span>);</span>
<span id="cb27-97"><a aria-hidden="true" href="#cb27-97"></a>    is &gt;&gt; m;</span>
<span id="cb27-98"><a aria-hidden="true" href="#cb27-98"></a>    <span class="cf">while</span> (m--) {</span>
<span id="cb27-99"><a aria-hidden="true" href="#cb27-99"></a>        <span class="dt">int</span> x, y, z;</span>
<span id="cb27-100"><a aria-hidden="true" href="#cb27-100"></a>        is &gt;&gt; s &gt;&gt; x &gt;&gt; y;</span>
<span id="cb27-101"><a aria-hidden="true" href="#cb27-101"></a>        <span class="cf">if</span> (s[<span class="dv">0</span>] == <span class="ch">'Q'</span>) os &lt;&lt; query(<span class="dv">1</span>, n, <span class="dv">1</span>, x, y, <span class="dv">0</span>) &lt;&lt; <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span>;</span>
<span id="cb27-102"><a aria-hidden="true" href="#cb27-102"></a>        <span class="cf">else</span> <span class="cf">if</span> (s[<span class="dv">0</span>] == <span class="ch">'A'</span>) os &lt;&lt; query(<span class="dv">1</span>, n, <span class="dv">1</span>, x, y, <span class="dv">1</span>) &lt;&lt; <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span>;</span>
<span id="cb27-103"><a aria-hidden="true" href="#cb27-103"></a>        <span class="cf">else</span> {</span>
<span id="cb27-104"><a aria-hidden="true" href="#cb27-104"></a>            is &gt;&gt; z;</span>
<span id="cb27-105"><a aria-hidden="true" href="#cb27-105"></a>            <span class="cf">if</span> (s[<span class="dv">0</span>] == <span class="ch">'P'</span>) add(<span class="dv">1</span>, n, <span class="dv">1</span>, x, y, z);</span>
<span id="cb27-106"><a aria-hidden="true" href="#cb27-106"></a>            <span class="cf">else</span> cover(<span class="dv">1</span>, n, <span class="dv">1</span>, x, y, z);</span>
<span id="cb27-107"><a aria-hidden="true" href="#cb27-107"></a>        }</span>
<span id="cb27-108"><a aria-hidden="true" href="#cb27-108"></a>    }</span>
<span id="cb27-109"><a aria-hidden="true" href="#cb27-109"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb27-110"><a aria-hidden="true" href="#cb27-110"></a>}</span></code></pre></div>
<p>区间历史最值操作也可以与区间最值操作相结合：</p>
<p>首先考虑最值操作与历史最值同向（同为求最大/最小值）的情况</p>
<blockquote>
<p>例题 <span class="math inline">\(6\)</span>：<a href="http://uoj.ac/problem/164">UOJ#164. 【清华集训2015】V</a></p>
<p>维护长度 <span class="math inline">\(n\le 5\times 10^5\)</span> 的序列 <span class="math inline">\(A\)</span> 和辅助序列 <span class="math inline">\(B\)</span>（初始时和 <span class="math inline">\(A\)</span> 相同）。<span class="math inline">\(m\le 5\times 10^5\)</span> 次操作：</p>
<ol type="1">
<li><span class="math inline">\([l, r]\)</span> 加 <span class="math inline">\(k\)</span>；</li>
<li><span class="math inline">\([l, r]\)</span> 中所有 <span class="math inline">\(A_i:= \max(A_i - k, 0)\)</span>；</li>
<li><span class="math inline">\([l, r]\)</span> 赋值为 <span class="math inline">\(k\)</span>；</li>
<li>求 <span class="math inline">\(A_p\)</span>；</li>
<li>求 <span class="math inline">\(B_p\)</span>。</li>
</ol>
<p>每次操作后让 <span class="math inline">\(B_i:=\max(B_i, A_i)\)</span>。</p>
</blockquote>
<p>不妨定义标记 <span class="math inline">\((d, v)\)</span> 表示加上 <span class="math inline">\(d\)</span> 后与 <span class="math inline">\(v\)</span> 取最大值，则三种操作等价于 <span class="math inline">\((k, 0)\)</span>，<span class="math inline">\((-k, 0)\)</span> 和 <span class="math inline">\((-\infty, k)\)</span>。</p>
<p>将 <span class="math inline">\((d_1, v_1)\)</span> 和 <span class="math inline">\((d_2, v_2)\)</span> 合并后得到的结果是 <span class="math inline">\((d_1 + d_2, \max(v_1 + d_2, v_2))\)</span>。现在的问题就是如何维护历史最大值。注意到历史最大值实际上是标记前缀和的 <span class="math inline">\(\max\)</span>，和前面 CPU 监控是一个玩法。</p>
<p><strong>按照值域考虑每个数接受标记后会变成什么</strong>，发现是如下图的折线（by <a href="https://www.luogu.com.cn/blog/Hakurei-Reimu/seg-beats">灵梦</a>）：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/e4okisk5.png"/></p>
<p>（实际上是将标记视为自变量是当前值的函数）其前半段水平，后半段斜率为 <span class="math inline">\(1\)</span>，更新历史最大标记的时候相当于是将两个函数取 <span class="math inline">\(\max\)</span>（黑线 <span class="math inline">\(\to\)</span> 红线）。而 <span class="math inline">\(\max((d_1, v_1), (d_2, v_2)) = \max(\max(d_1, d_2), \max(v_1, v_2))\)</span>，所以对于历史最大标记就直接取最大值即可。</p>
<blockquote>
<p>例题 <span class="math inline">\(6\)</span>：<a href="https://www.luogu.com.cn/problem/P6242">P6242 【模板】线段树 3</a></p>
<p>给定一个序列 <span class="math inline">\(A\)</span>，和辅助序列 <span class="math inline">\(B\)</span>，初始 <span class="math inline">\(A = B\)</span>。支持如下操作：</p>
<ul>
<li><code>1 l r k</code>：对于所有的 <span class="math inline">\(i\in[l,r]\)</span>，将 <span class="math inline">\(A_i\)</span> 加上 <span class="math inline">\(k\)</span>（<span class="math inline">\(k\)</span> 可以为负数）。</li>
<li><code>2 l r v</code>：对于所有的 <span class="math inline">\(i\in[l,r]\)</span>，将 <span class="math inline">\(A_i\)</span> 变成 <span class="math inline">\(\min(A_i,v)\)</span>。</li>
<li><code>3 l r</code>：求 <span class="math inline">\(\sum_{i=l}^{r}A_i\)</span>。</li>
<li><code>4 l r</code>：对于所有的 <span class="math inline">\(i\in[l,r]\)</span>，求 <span class="math inline">\(A_i\)</span> 的最大值。</li>
<li><code>5 l r</code>：对于所有的 <span class="math inline">\(i\in[l,r]\)</span>，求 <span class="math inline">\(B_i\)</span> 的最大值。</li>
</ul>
<p>每次操作后让 <span class="math inline">\(B_i:=\max(B_i, A_i)\)</span>。</p>
</blockquote>
<blockquote>
<p>SP1557 GSS2 - Can you answer these queries II</p>
</blockquote>
<h3 id="单侧递归类问题兔队线段树">单侧递归类问题（兔队线段树）</h3>
<h3 id="优化建图">优化建图</h3>
<p>对于区间连边一类问题，暴力连边的复杂度显然为 <span class="math inline">\(O(n^2)\)</span>，不优，考虑利用线段树的性质降低复杂度，将一些点<strong>合并在线段树的虚点上</strong>。</p>
<p>考虑线段树的每个节点代表一个区间，然后给节点编号，每次处理加边操作就使对应编号的节点连边就行了。然而我们发现一棵线段树好像并不能解决问题，所以考虑两棵线段树，一棵处理出，一棵处理入。</p>
<figure>
<img alt="" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/segoptout.png"/><figcaption>出树</figcaption>
</figure>
<figure>
<img alt="" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/segoptin.png"/><figcaption>入树</figcaption>
</figure>
<p><strong>然后线段树内连虚边，权为 <span class="math inline">\(0\)</span></strong>，<strong>注意连边的方向</strong>，可以这样想：处理出的线段树中，<span class="math inline">\([l,r]\)</span> 肯定是可以出到 <span class="math inline">\([l,mid]\)</span> 和 <span class="math inline">\([mid+1, r]\)</span> 的，所以出线段树是向下连边，同理，入线段树是向上连边。同时在建树的过程中给节点编号，为了方便跑最短路，<strong>所有叶子节点的编号即为其代表图中节点的编号</strong>，然后至于维护区间的点使用一个 <code>cnt</code> 时间戳即可。</p>
<p>思想不难，注意实现细节，例题 <a href="https://www.luogu.com.cn/problem/CF786B">CF786B Legacy</a>。</p>
<h3 id="优化-dp">优化 dp</h3>
<p>当序列上 DP 的转移可以通过前面一段确定区间来进行时，可以使用一个维护下标对应最优值的线段树来将单次 <span class="math inline">\(O(n)\)</span> 的转移优化到 <span class="math inline">\(O(\log n)\)</span>，使得总时间复杂度在一个可接受的范围内。</p>
<p>思想较为简单，例子就懒得举了。</p>
<h2 id="references">References</h2>
<p>感谢以下参考资料的作者们：</p>
<ul>
<li>ix35：<a href="https://www.luogu.com.cn/blog/ix-35/noi-yi-lun-fu-xi-iii-shuo-ju-jie-gou">NOI 一轮复习 III：数据结构</a></li>
<li>岩之痕：<a href="https://blog.csdn.net/zearot/article/details/48299459">线段树详解 （原理，实现与应用）</a></li>
<li>Tiphereth-A：<a href="https://www.luogu.com.cn/blog/82152/Introduction-of-zkwSegmentTree">线段树的扩展之浅谈zkw线段树</a></li>
<li>灵梦：<a href="https://www.luogu.com.cn/blog/Hakurei-Reimu/seg-beats">区间最值操作与区间历史最值详解</a></li>
<li>cmd_block：<a href="https://www.luogu.com.cn/blog/command-block/guan-yu-xian-duan-shu-shang-di-yi-suo-jin-jie-cao-zuo">关于线段树上的一些进阶操作</a></li>
</ul>
</section>
<footer class="article-footer">
<section class="article-tags">
<a href="/tags/OI/">OI</a>
<a href="/tags/note/">笔记</a>
</section>
<section class="article-copyright">
<svg class="icon icon-tabler icon-tabler-copyright" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<circle cx="12" cy="12" r="9"></circle>
<path d="M14.5 9a3.5 4 0 1 0 0 6"></path>
</svg>
<span>Licensed under CC BY-NC-SA 4.0</span>
</section>
</footer>
<link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css" integrity="sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn" rel="stylesheet"/><script crossorigin="anonymous" defer="" integrity="sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8" src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js">
</script><script crossorigin="anonymous" defer="" integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js">
</script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.querySelector(`.article-content`), {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ]
        });})
</script>
</article>
<aside class="related-contents--wrapper">
<h2 class="section-title">相关文章</h2>
<div class="related-contents">
<div class="flex article-list--tile">
<article class="has-image">
<a href="/note-gf/">
<div class="article-image">
<img data-hash="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg28.webp" data-key="" loading="lazy" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg28.webp"/>
</div>
<div class="article-details">
<h2 class="article-title">生成函数胡扯</h2>
</div>
</a>
</article>
<article class="has-image">
<a href="/note-set-power-series/">
<div class="article-image">
<img data-hash="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg39.webp" data-key="" loading="lazy" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg39.webp"/>
</div>
<div class="article-details">
<h2 class="article-title">集合幂级数胡扯</h2>
</div>
</a>
</article>
<article class="has-image">
<a href="/note-linear-basis/">
<div class="article-image">
<img data-hash="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg19.webp" data-key="" loading="lazy" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg19.webp"/>
</div>
<div class="article-details">
<h2 class="article-title">线性基学习笔记</h2>
</div>
</a>
</article>
<article class="has-image">
<a href="/note-wqs/">
<div class="article-image">
<img data-hash="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg28.webp" data-key="" loading="lazy" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg28.webp"/>
</div>
<div class="article-details">
<h2 class="article-title">wqs 二分学习笔记</h2>
</div>
</a>
</article>
<article class="has-image">
<a href="/note-builtin/">
<div class="article-image">
<img data-hash="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg9.webp" data-key="" loading="lazy" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg9.webp"/>
</div>
<div class="article-details">
<h2 class="article-title">__builtin 系列函数总结</h2>
</div>
</a>
</article>
</div>
</div>
</aside>
<footer class="site-footer">
<section class="copyright">
        © 
        
            2019 - 
        
        2024 清烛的博客
    </section>
<section class="powerby">
        Built with <a href="https://gohugo.io/" rel="noopener" target="_blank">Hugo</a> <br/>
        主题 <b><a data-version="3.11.0" href="https://github.com/CaiJimmy/hugo-theme-stack" rel="noopener" target="_blank">Stack</a></b> 由 <a href="https://jimmycai.com" rel="noopener" target="_blank">Jimmy</a> 设计
    </section>
</footer>
<div aria-hidden="true" class="pswp" role="dialog" tabindex="-1">
<div class="pswp__bg"></div>
<div class="pswp__scroll-wrap">
<div class="pswp__container">
<div class="pswp__item"></div>
<div class="pswp__item"></div>
<div class="pswp__item"></div>
</div>
<div class="pswp__ui pswp__ui--hidden">
<div class="pswp__top-bar">
<div class="pswp__counter"></div>
<button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title="Share"></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
<div class="pswp__preloader">
<div class="pswp__preloader__icn">
<div class="pswp__preloader__cut">
<div class="pswp__preloader__donut"></div>
</div>
</div>
</div>
</div>
<div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
<div class="pswp__share-tooltip"></div>
</div>
<button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
</button>
<div class="pswp__caption">
<div class="pswp__caption__center"></div>
</div>
</div>
</div>
</div><script crossorigin="anonymous" defer="" integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js">
</script><script crossorigin="anonymous" defer="" integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js">
</script><link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css" integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" rel="stylesheet"/><link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css" integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" rel="stylesheet"/>
</main>
</div>
<script crossorigin="anonymous" integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js">
</script><script defer="" src="/ts/main.js" type="text/javascript"></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>
</body>
</html>

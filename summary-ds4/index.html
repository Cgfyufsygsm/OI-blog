<!DOCTYPE html>
<html dir="ltr" lang="zh-CN">
<head><meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/><meta content="前言 省选/NOI（如果能进省队）的个人复习资料。
全凭个人喜好来搞。
不会写的很严谨，实战导向型。
本文内容概览：
莫队相关 普通莫队 带修莫队 回滚莫队 莫队二次离线 根号分治思想 分块 下若不说明则默认数据范围为 \(10^5\)。
分块概论 分块问题可以分为两类，一种是静态分块，一种是动态分块。静态分块的思想是使用分块预处理信息以加速查询，但不支持修改，（若可以离线，则静态分块是莫队的子集）。动态分块则是将序列划分为若干小块来整体维护，在离散和批量之间找到一个平衡点。
根号平衡 实际上就是平衡修改和询问的时间复杂度。
\(O(1)\) 单点修改，\(O(\sqrt n)\) 区间和。
使用分块维护块内和，每次修改的时候 \(O(1)\) 修改对应块的和以及对应的数，查询对于整块直接累加对于散块暴力加。
\(O(\sqrt n)\) 单点修改，\(O(1)\) 区间和。
使用分块分别维护前 \(i\) 个块的和以及块内前 \(i\) 个数的和，单点修改的时候就直接修改往后的 \(O(\sqrt n)\) 个块外前缀和和自己内部的块内前缀和，查询就直接块外和块内拼起来。
\(O(\sqrt n)\) 区间加，\(O(1)\) 单点查。
直接分块维护，懒标记。
\(O(1)\) 区间加，\(O(\sqrt n)\) 单点查。
差分一下，然后类似上面的，在块内和块外打上标记，最后扫一遍过来即可。
维护集合，\(O(1)\) 插入，\(O(\sqrt n)\) 第 \(k\) 小，值域 \(O(n)\)。
离散化，对值域分块。维护第 \(i\) 个块里面有多少数，查询的时候先挨个块挨个块的来然后再跑散的。
维护集合，\(O(\sqrt n)\) 插入，\(O(1)\) 第 \(k\) 小。
没看懂，咕咕咕。
动态分块基础 我们将长度为 \(n\) 的序列划分成大小为 \(B\) 的小块，那么整块就有 \(O(n / B)\) 块，一个散块就有 \(O(B)\) 个元素。" name="description"/><title>数据结构复习 4 （根号数据结构）</title>
<link href="https://oi.imyangty.com/summary-ds4/" rel="canonical"/>
<link href="/scss/style.min.a5821f3d3ab84ce5a0ac21477e347a2e0ca00292e398d16c5e8e36ded6e35a23.css" rel="stylesheet"/><meta content="数据结构复习 4 （根号数据结构）" property="og:title"/>
<meta content="前言 省选/NOI（如果能进省队）的个人复习资料。
全凭个人喜好来搞。
不会写的很严谨，实战导向型。
本文内容概览：
莫队相关 普通莫队 带修莫队 回滚莫队 莫队二次离线 根号分治思想 分块 下若不说明则默认数据范围为 \(10^5\)。
分块概论 分块问题可以分为两类，一种是静态分块，一种是动态分块。静态分块的思想是使用分块预处理信息以加速查询，但不支持修改，（若可以离线，则静态分块是莫队的子集）。动态分块则是将序列划分为若干小块来整体维护，在离散和批量之间找到一个平衡点。
根号平衡 实际上就是平衡修改和询问的时间复杂度。
\(O(1)\) 单点修改，\(O(\sqrt n)\) 区间和。
使用分块维护块内和，每次修改的时候 \(O(1)\) 修改对应块的和以及对应的数，查询对于整块直接累加对于散块暴力加。
\(O(\sqrt n)\) 单点修改，\(O(1)\) 区间和。
使用分块分别维护前 \(i\) 个块的和以及块内前 \(i\) 个数的和，单点修改的时候就直接修改往后的 \(O(\sqrt n)\) 个块外前缀和和自己内部的块内前缀和，查询就直接块外和块内拼起来。
\(O(\sqrt n)\) 区间加，\(O(1)\) 单点查。
直接分块维护，懒标记。
\(O(1)\) 区间加，\(O(\sqrt n)\) 单点查。
差分一下，然后类似上面的，在块内和块外打上标记，最后扫一遍过来即可。
维护集合，\(O(1)\) 插入，\(O(\sqrt n)\) 第 \(k\) 小，值域 \(O(n)\)。
离散化，对值域分块。维护第 \(i\) 个块里面有多少数，查询的时候先挨个块挨个块的来然后再跑散的。
维护集合，\(O(\sqrt n)\) 插入，\(O(1)\) 第 \(k\) 小。
没看懂，咕咕咕。
动态分块基础 我们将长度为 \(n\) 的序列划分成大小为 \(B\) 的小块，那么整块就有 \(O(n / B)\) 块，一个散块就有 \(O(B)\) 个元素。" property="og:description"/>
<meta content="https://oi.imyangty.com/summary-ds4/" property="og:url"/>
<meta content="清烛的博客" property="og:site_name"/>
<meta content="article" property="og:type"/><meta content="Post" property="article:section"/><meta content="OI" property="article:tag"/><meta content="笔记" property="article:tag"/><meta content="2022-02-08T23:40:18+08:00" property="article:published_time"/><meta content="2022-02-08T23:40:18+08:00" property="article:modified_time"/><meta content="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg8.webp" property="og:image"/>
<meta content="数据结构复习 4 （根号数据结构）" name="twitter:title"/>
<meta content="前言 省选/NOI（如果能进省队）的个人复习资料。
全凭个人喜好来搞。
不会写的很严谨，实战导向型。
本文内容概览：
莫队相关 普通莫队 带修莫队 回滚莫队 莫队二次离线 根号分治思想 分块 下若不说明则默认数据范围为 \(10^5\)。
分块概论 分块问题可以分为两类，一种是静态分块，一种是动态分块。静态分块的思想是使用分块预处理信息以加速查询，但不支持修改，（若可以离线，则静态分块是莫队的子集）。动态分块则是将序列划分为若干小块来整体维护，在离散和批量之间找到一个平衡点。
根号平衡 实际上就是平衡修改和询问的时间复杂度。
\(O(1)\) 单点修改，\(O(\sqrt n)\) 区间和。
使用分块维护块内和，每次修改的时候 \(O(1)\) 修改对应块的和以及对应的数，查询对于整块直接累加对于散块暴力加。
\(O(\sqrt n)\) 单点修改，\(O(1)\) 区间和。
使用分块分别维护前 \(i\) 个块的和以及块内前 \(i\) 个数的和，单点修改的时候就直接修改往后的 \(O(\sqrt n)\) 个块外前缀和和自己内部的块内前缀和，查询就直接块外和块内拼起来。
\(O(\sqrt n)\) 区间加，\(O(1)\) 单点查。
直接分块维护，懒标记。
\(O(1)\) 区间加，\(O(\sqrt n)\) 单点查。
差分一下，然后类似上面的，在块内和块外打上标记，最后扫一遍过来即可。
维护集合，\(O(1)\) 插入，\(O(\sqrt n)\) 第 \(k\) 小，值域 \(O(n)\)。
离散化，对值域分块。维护第 \(i\) 个块里面有多少数，查询的时候先挨个块挨个块的来然后再跑散的。
维护集合，\(O(\sqrt n)\) 插入，\(O(1)\) 第 \(k\) 小。
没看懂，咕咕咕。
动态分块基础 我们将长度为 \(n\) 的序列划分成大小为 \(B\) 的小块，那么整块就有 \(O(n / B)\) 块，一个散块就有 \(O(B)\) 个元素。" name="twitter:description"/><meta content="summary_large_image" name="twitter:card"/>
<meta content="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg8.webp" name="twitter:image"/>
<link href="https://q1.qlogo.cn/g?b=qq&amp;nk=375836877&amp;s=5" rel="shortcut icon"/>
<link href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/styles/github-dark-dimmed.min.css" rel="stylesheet"/>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
</head>
<body class="article-page">
<script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky">
<button aria-label="切换菜单" class="hamburger hamburger--spin" id="toggle-menu" type="button">
<span class="hamburger-box">
<span class="hamburger-inner"></span>
</span>
</button>
<header>
<figure class="site-avatar">
<a href="/">
<img alt="Avatar" class="site-logo" height="300" loading="lazy" src="/img/avatar_huea3ce2119467b51fdd2a81393644a76d_51594_300x0_resize_q75_box.jpg" width="300"/>
</a>
<span class="emoji">😅</span>
</figure>
<div class="site-meta">
<h1 class="site-name"><a href="/">清烛的博客</a></h1>
<h2 class="site-description">烟火已谢，笙歌未停</h2>
</div>
</header><ol class="social-menu">
<li>
<a href="mailto:i@imyangty.com" target="_blank" title="email">
<svg class="icon icon-tabler icon-tabler-mail" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
<rect height="14" rx="2" width="18" x="3" y="5"></rect>
<polyline points="3 7 12 13 21 7"></polyline>
</svg>
</a>
</li>
<li>
<a href="https://github.com/Cgfyufsygsm" target="_blank" title="GitHub">
<svg class="icon icon-tabler icon-tabler-brand-github" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
<path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5"></path>
</svg>
</a>
</li>
<li>
<a href="https://t.me/Cgfyufsygsm" target="_blank" title="Telegram">
<svg class="icon icon-tabler icon-tabler-brand-telegram" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
<path d="M15 10l-4 4l6 6l4 -16l-18 7l4 2l2 6l3 -4"></path>
</svg>
</a>
</li>
<li>
<a href="https://twitter.com/Cgfyufsygsm" target="_blank" title="Twitter">
<svg class="icon icon-tabler icon-tabler-brand-twitter" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
<path d="M22 4.01c-1 .49 -1.98 .689 -3 .99c-1.121 -1.265 -2.783 -1.335 -4.38 -.737s-2.643 2.06 -2.62 3.737v1c-3.245 .083 -6.135 -1.395 -8 -4c0 0 -4.182 7.433 4 11c-1.872 1.247 -3.739 2.088 -6 2c3.308 1.803 6.913 2.423 10.034 1.517c3.58 -1.04 6.522 -3.723 7.651 -7.742a13.84 13.84 0 0 0 .497 -3.753c-.002 -.249 1.51 -2.772 1.818 -4.013z"></path>
</svg>
</a>
</li>
</ol><ol class="menu" id="main-menu">
<li>
<a href="/">
<svg class="icon icon-tabler icon-tabler-home" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<polyline points="5 12 3 12 12 3 21 12 19 12"></polyline>
<path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7"></path>
<path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6"></path>
</svg>
<span>主页</span>
</a>
</li>
<li>
<a href="/about/">
<svg class="icon icon-tabler icon-tabler-user" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<circle cx="12" cy="7" r="4"></circle>
<path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2"></path>
</svg>
<span>关于</span>
</a>
</li>
<li>
<a href="/idx/">
<svg class="icon icon-tabler icon-tabler-hash" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<line x1="5" x2="19" y1="9" y2="9"></line>
<line x1="5" x2="19" y1="15" y2="15"></line>
<line x1="11" x2="7" y1="4" y2="20"></line>
<line x1="17" x2="13" y1="4" y2="20"></line>
</svg>
<span>导航</span>
</a>
</li>
<li>
<a href="/archives/">
<svg class="icon icon-tabler icon-tabler-archive" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<rect height="4" rx="2" width="18" x="3" y="4"></rect>
<path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10"></path>
<line x1="10" x2="14" y1="12" y2="12"></line>
</svg>
<span>归档</span>
</a>
</li>
<li>
<a href="/search/">
<svg class="icon icon-tabler icon-tabler-search" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<circle cx="10" cy="10" r="7"></circle>
<line x1="21" x2="15" y1="21" y2="15"></line>
</svg>
<span>搜索</span>
</a>
</li>
<li>
<a href="/friends/">
<svg class="icon icon-tabler icon-tabler-link" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5"></path>
<path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5"></path>
</svg>
<span>友链</span>
</a>
</li>
<li>
<a href="https://blog.imyangty.com" target="_blank">
<svg class="icon icon-tabler icon-tabler-home" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<polyline points="5 12 3 12 12 3 21 12 19 12"></polyline>
<path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7"></path>
<path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6"></path>
</svg>
<span>主博客</span>
</a>
</li>
<div class="menu-bottom-section">
<li id="dark-mode-toggle">
<svg class="icon icon-tabler icon-tabler-toggle-left" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<circle cx="8" cy="12" r="2"></circle>
<rect height="12" rx="6" width="20" x="2" y="6"></rect>
</svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<circle cx="16" cy="12" r="2"></circle>
<rect height="12" rx="6" width="20" x="2" y="6"></rect>
</svg>
<span>暗色模式</span>
</li>
</div>
</ol>
</aside>
<main class="main full-width">
<article class="has-image main-article">
<header class="article-header">
<div class="article-image">
<a href="/summary-ds4/">
<img alt="Featured image of post 数据结构复习 4 （根号数据结构）" loading="lazy" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg8.webp"/>
</a>
</div>
<div class="article-details">
<header class="article-category">
<a href="/categories/oi/">
                OI
            </a>
<a href="/categories/summary/">
                总结
            </a>
</header>
<div class="article-title-wrapper">
<h2 class="article-title">
<a href="/summary-ds4/">数据结构复习 4 （根号数据结构）</a>
</h2>
</div>
<footer class="article-time">
<div>
<svg class="icon icon-tabler icon-tabler-calendar-time" fill="none" height="56" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="56" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4"></path>
<circle cx="18" cy="18" r="4"></circle>
<path d="M15 3v4"></path>
<path d="M7 3v4"></path>
<path d="M3 11h16"></path>
<path d="M18 16.496v1.504l1 1"></path>
</svg>
<time class="article-time--published">Feb 08, 2022</time>
</div>
<div>
<svg class="icon icon-tabler icon-tabler-clock" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<circle cx="12" cy="12" r="9"></circle>
<polyline points="12 7 12 12 15 15"></polyline>
</svg>
<time class="article-time--reading">
                    阅读时长: 15 分钟
                </time>
</div>
</footer>
</div>
</header>
<section class="article-content">
<h2 id="前言">前言</h2>
<p>省选/NOI（如果能进省队）的个人复习资料。</p>
<p>全凭个人喜好来搞。</p>
<p>不会写的很严谨，实战导向型。</p>
<p>本文内容概览：</p>
<ul>
<li>莫队相关
<ul>
<li>普通莫队</li>
<li>带修莫队</li>
<li>回滚莫队</li>
<li>莫队二次离线</li>
</ul></li>
<li>根号分治思想</li>
<li>分块</li>
</ul>
<p>下若不说明则默认数据范围为 <span class="math inline">\(10^5\)</span>。</p>
<h2 id="分块概论">分块概论</h2>
<p>分块问题可以分为两类，一种是静态分块，一种是动态分块。静态分块的思想是使用分块预处理信息以加速查询，但不支持修改，（若可以离线，则静态分块是莫队的子集）。动态分块则是将序列划分为若干小块来整体维护，在<strong>离散和批量之间找到一个平衡点</strong>。</p>
<h2 id="根号平衡">根号平衡</h2>
<p>实际上就是平衡修改和询问的时间复杂度。</p>
<ul>
<li><p><span class="math inline">\(O(1)\)</span> 单点修改，<span class="math inline">\(O(\sqrt n)\)</span> 区间和。</p>
<p>使用分块维护块内和，每次修改的时候 <span class="math inline">\(O(1)\)</span> 修改对应块的和以及对应的数，查询对于整块直接累加对于散块暴力加。</p></li>
<li><p><span class="math inline">\(O(\sqrt n)\)</span> 单点修改，<span class="math inline">\(O(1)\)</span> 区间和。</p>
<p>使用分块分别维护前 <span class="math inline">\(i\)</span> 个块的和以及块内前 <span class="math inline">\(i\)</span> 个数的和，单点修改的时候就直接修改往后的 <span class="math inline">\(O(\sqrt n)\)</span> 个块外前缀和和自己内部的块内前缀和，查询就直接块外和块内拼起来。</p></li>
<li><p><span class="math inline">\(O(\sqrt n)\)</span> 区间加，<span class="math inline">\(O(1)\)</span> 单点查。</p>
<p>直接分块维护，懒标记。</p></li>
<li><p><span class="math inline">\(O(1)\)</span> 区间加，<span class="math inline">\(O(\sqrt n)\)</span> 单点查。</p>
<p>差分一下，然后类似上面的，在块内和块外打上标记，最后扫一遍过来即可。</p></li>
<li><p>维护集合，<span class="math inline">\(O(1)\)</span> 插入，<span class="math inline">\(O(\sqrt n)\)</span> 第 <span class="math inline">\(k\)</span> 小，值域 <span class="math inline">\(O(n)\)</span>。</p>
<p>离散化，对值域分块。维护第 <span class="math inline">\(i\)</span> 个块里面有多少数，查询的时候先挨个块挨个块的来然后再跑散的。</p></li>
<li><p>维护集合，<span class="math inline">\(O(\sqrt n)\)</span> 插入，<span class="math inline">\(O(1)\)</span> 第 <span class="math inline">\(k\)</span> 小。</p>
<p>没看懂，咕咕咕。</p></li>
</ul>
<h2 id="动态分块基础">动态分块基础</h2>
<p>我们将长度为 <span class="math inline">\(n\)</span> 的序列划分成大小为 <span class="math inline">\(B\)</span> 的小块，那么整块就有 <span class="math inline">\(O(n / B)\)</span> 块，一个散块就有 <span class="math inline">\(O(B)\)</span> 个元素。</p>
<p>一般来说操作区间会覆盖若干个整块和两端的小散块，对于整块我们整体处理，对于散块就采用暴力遍历，这便是分块的一般方法。</p>
<p>做分块题时通常可以考虑预处理出某元素所在块的编号 <code>bl[i]</code>，以及一些其他的按照整块预处理的信息。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a aria-hidden="true" href="#cb1-1"></a><span class="dt">int</span> a[maxn], bl[maxn], tag[maxn], block;</span></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a aria-hidden="true" href="#cb2-1"></a><span class="dt">int</span> n = read();</span>
<span id="cb2-2"><a aria-hidden="true" href="#cb2-2"></a>block = sqrt(n);<span class="co">//块大小一般为根号 n</span></span>
<span id="cb2-3"><a aria-hidden="true" href="#cb2-3"></a>FOR(i, <span class="dv">1</span>, n) a[i] = read(), bl[i] = (i - <span class="dv">1</span>) / block + <span class="dv">1</span>;</span></code></pre></div>
<p><strong>需要特别注意越界的问题，时刻铭记下标变量代表的是元素下标还是块的编号</strong>。</p>
<blockquote>
<p>例题 <span class="math inline">\(1\)</span>：<a href="https://loj.ac/p/6277">LOJ 数列分块入门 1</a>、<a href="https://loj.ac/p/6280">LOJ 数列分块入门 4</a> 以及 <a href="https://www.luogu.com.cn/problem/P3372">P3372 【模板】线段树 1</a>（三倍经验）</p>
<p>区间加区间和。</p>
</blockquote>
<p>这个问题中由于信息可以高效合并所以使用分块没有什么优势，但是可以通过这个问题来简单了解分块的思想。</p>
<ul>
<li><p>区间查询</p>
<p>对于整块，累加整块的和（预先维护好），对于散块，暴力遍历加。不难发现这样的时间复杂度为 <span class="math inline">\(O(B + n / B)\)</span>。</p></li>
<li><p>区间加</p>
<p>对于散块直接加；对于整块维护加法标记（像线段树那样）。不难发现时间复杂度还是 <span class="math inline">\(O(B + n /B)\)</span>。</p></li>
</ul>
<p>根据均值不等式，<span class="math inline">\(B\)</span> 取 <span class="math inline">\(\sqrt n\)</span> 的时候能达到最优复杂度 <span class="math inline">\(O(n\sqrt n)\)</span>。其实你会发现这就是“二叉”线段树改成了只有 <span class="math inline">\(3\)</span> 层的 <span class="math inline">\(\sqrt n\)</span> 叉线段树。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a aria-hidden="true" href="#cb3-1"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="dv">50005</span>;</span>
<span id="cb3-2"><a aria-hidden="true" href="#cb3-2"></a><span class="dt">int</span> a[maxn], bl[maxn], sum[maxn], tag[maxn], block, n;</span>
<span id="cb3-3"><a aria-hidden="true" href="#cb3-3"></a></span>
<span id="cb3-4"><a aria-hidden="true" href="#cb3-4"></a><span class="dt">void</span> add(<span class="dt">int</span> l, <span class="dt">int</span> r, <span class="dt">int</span> val)</span>
<span id="cb3-5"><a aria-hidden="true" href="#cb3-5"></a>{</span>
<span id="cb3-6"><a aria-hidden="true" href="#cb3-6"></a>    FOR(i, l, min(r, bl[l] * block))</span>
<span id="cb3-7"><a aria-hidden="true" href="#cb3-7"></a>        a[i] += val, sum[bl[l]] += val;</span>
<span id="cb3-8"><a aria-hidden="true" href="#cb3-8"></a>    <span class="cf">if</span> (bl[l] != bl[r])</span>
<span id="cb3-9"><a aria-hidden="true" href="#cb3-9"></a>        FOR(i, (bl[r] - <span class="dv">1</span>) * block + <span class="dv">1</span>, r)</span>
<span id="cb3-10"><a aria-hidden="true" href="#cb3-10"></a>            a[i] += val, sum[bl[r]] += val;</span>
<span id="cb3-11"><a aria-hidden="true" href="#cb3-11"></a>    FOR(i, bl[l] + <span class="dv">1</span>, bl[r] - <span class="dv">1</span>)</span>
<span id="cb3-12"><a aria-hidden="true" href="#cb3-12"></a>        tag[i] += val;</span>
<span id="cb3-13"><a aria-hidden="true" href="#cb3-13"></a>    <span class="cf">return</span>;</span>
<span id="cb3-14"><a aria-hidden="true" href="#cb3-14"></a>}</span>
<span id="cb3-15"><a aria-hidden="true" href="#cb3-15"></a></span>
<span id="cb3-16"><a aria-hidden="true" href="#cb3-16"></a><span class="dt">int</span> query(<span class="dt">int</span> l, <span class="dt">int</span> r, <span class="dt">int</span> mod)</span>
<span id="cb3-17"><a aria-hidden="true" href="#cb3-17"></a>{</span>
<span id="cb3-18"><a aria-hidden="true" href="#cb3-18"></a>    <span class="dt">int</span> ret = <span class="dv">0</span>;</span>
<span id="cb3-19"><a aria-hidden="true" href="#cb3-19"></a>    FOR(i, l, min(r, bl[l] * block))</span>
<span id="cb3-20"><a aria-hidden="true" href="#cb3-20"></a>        ret += a[i] + tag[bl[l]], ret %= mod;</span>
<span id="cb3-21"><a aria-hidden="true" href="#cb3-21"></a>    <span class="cf">if</span> (bl[l] != bl[r])</span>
<span id="cb3-22"><a aria-hidden="true" href="#cb3-22"></a>        FOR(i, (bl[r] - <span class="dv">1</span>) * block + <span class="dv">1</span>, r)</span>
<span id="cb3-23"><a aria-hidden="true" href="#cb3-23"></a>            ret += a[i] + tag[bl[r]], ret %= mod;</span>
<span id="cb3-24"><a aria-hidden="true" href="#cb3-24"></a>    FOR(i, bl[l] + <span class="dv">1</span>, bl[r] - <span class="dv">1</span>)</span>
<span id="cb3-25"><a aria-hidden="true" href="#cb3-25"></a>        ret += sum[i] + tag[i] * block % mod, ret %= mod;</span>
<span id="cb3-26"><a aria-hidden="true" href="#cb3-26"></a>    <span class="cf">return</span> ret;</span>
<span id="cb3-27"><a aria-hidden="true" href="#cb3-27"></a>}</span>
<span id="cb3-28"><a aria-hidden="true" href="#cb3-28"></a></span>
<span id="cb3-29"><a aria-hidden="true" href="#cb3-29"></a><span class="dt">signed</span> main()</span>
<span id="cb3-30"><a aria-hidden="true" href="#cb3-30"></a>{</span>
<span id="cb3-31"><a aria-hidden="true" href="#cb3-31"></a>    block = sqrt(n = read());</span>
<span id="cb3-32"><a aria-hidden="true" href="#cb3-32"></a>    FOR(i, <span class="dv">1</span>, n)</span>
<span id="cb3-33"><a aria-hidden="true" href="#cb3-33"></a>        a[i] = read(), bl[i] = (i - <span class="dv">1</span>) / block + <span class="dv">1</span>, sum[bl[i]] += a[i];</span>
<span id="cb3-34"><a aria-hidden="true" href="#cb3-34"></a>    FOR(k, <span class="dv">1</span>, n)</span>
<span id="cb3-35"><a aria-hidden="true" href="#cb3-35"></a>    {</span>
<span id="cb3-36"><a aria-hidden="true" href="#cb3-36"></a>        reg <span class="dt">int</span> opt = read(), l = read(), r = read(), c = read();</span>
<span id="cb3-37"><a aria-hidden="true" href="#cb3-37"></a>        <span class="cf">if</span> (opt == <span class="dv">0</span>)</span>
<span id="cb3-38"><a aria-hidden="true" href="#cb3-38"></a>            add(l, r, c);</span>
<span id="cb3-39"><a aria-hidden="true" href="#cb3-39"></a>        <span class="cf">else</span> printf(<span class="st">"</span><span class="sc">%lld\n</span><span class="st">"</span>, query(l, r, c + <span class="dv">1</span>));</span>
<span id="cb3-40"><a aria-hidden="true" href="#cb3-40"></a>    }</span>
<span id="cb3-41"><a aria-hidden="true" href="#cb3-41"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb3-42"><a aria-hidden="true" href="#cb3-42"></a>}</span></code></pre></div>
<blockquote>
<p>例题 <span class="math inline">\(2\)</span>：<a href="https://loj.ac/p/6278">LOJ 数列分块入门 2</a> 和 <a href="https://www.luogu.com.cn/problem/P2801">P2801 教主的魔法</a></p>
<p>区间加，区间询问小于某数（前者）/大于等于某数（后者）的数的个数</p>
</blockquote>
<p>先考虑如何处理询问，发现对于一整块，若将块内元素排序后通过一次二分是容易算出的，散块就暴力。那么询问的时间复杂度就应该为 <span class="math inline">\(O((n / B)\log n + B)\)</span>。</p>
<p>而对于修改，对于整块我们可以类似地使用加法标记，但是对于散块，修改完之后我们要重建这个块对应的排完序后的序列，时间复杂度 <span class="math inline">\(O(n/B + B\log B)\)</span>，虽然如果考虑归并的话能够做到 <span class="math inline">\(O(n/B + B)\)</span>。</p>
<p>所以若令 <span class="math inline">\((n/B)\log n = B\)</span> 则得到 <span class="math inline">\(\sqrt{n\log n}\)</span>，最优复杂度 <span class="math inline">\(O(q\sqrt{n\log n})\)</span>。</p>
<blockquote>
<p>例题 <span class="math inline">\(3\)</span>：<a href="https://loj.ac/p/6279">LOJ 数列分块入门 3</a></p>
<p>区间加，区间查询某数的前驱。</p>
</blockquote>
<p>和例题 <span class="math inline">\(2\)</span> 很像，直接块内维护 <code>std::set</code>，块两端暴力查询，块内直接用 <code>set::upper_bound</code> 来搞。</p>
<blockquote>
<p>例题 <span class="math inline">\(4\)</span>：<a href="https://www.luogu.com.cn/problem/P5356">P5356 [Ynoi2017] 由乃打扑克</a></p>
<p>区间加，区间 <span class="math inline">\(k\)</span> 小值。<span class="math inline">\(1\le n,m\le 10^5\)</span>。</p>
</blockquote>
<p>首先若用一个二分套上例题 <span class="math inline">\(2\)</span>，则时间复杂度为 <span class="math inline">\(O(m\sqrt{n\log n}\log w)\)</span>，lxl 是卡掉了的。</p>
<p>理性分析一下，发现我们在散块的部分似乎没有必要每次都暴力查找，可以先将其预处理进一个数组里面然后每次进行一次二分。而对每个整块进行二分似乎是省不掉的。于是单次询问时间复杂度为 <span class="math inline">\(O(n / B\log n\log w + B)\)</span>。视 <span class="math inline">\(\log n\)</span> 与 <span class="math inline">\(\log w\)</span> 同阶则 <span class="math inline">\(B = \sqrt n\log n\)</span>。适当调小块长后可以通过。</p>
<p>注意往死里卡常，对于一些没有必要二分（通过最大值/最小值判断）的段可以直接跳过，亲测可以节省很多时间。</p>
<h2 id="静态分块基础">静态分块基础</h2>
<p>主要就是通过预处理信息来实现更好的查询复杂度。由于其是普通莫队的子集，故<strong>如果没有强制在线，则其一定不如普通莫队</strong>。</p>
<blockquote>
<p>例题 <span class="math inline">\(1\)</span>：<a href="https://www.luogu.com.cn/problem/P4135">P4135 作诗</a></p>
<p>给定 <span class="math inline">\(n\)</span> 个 <span class="math inline">\([1,c]\)</span> 的正整数，<span class="math inline">\(m\)</span> 次区间询问 <span class="math inline">\([l,r]\)</span> 内有多少数出现了正偶数次，<strong>强制在线</strong>。</p>
</blockquote>
<p>根据分块“整块处理，边角暴力”的思想，我们自然想处理出一些能够整块合并的信息，同时又能和边角暴力合并。但是最重要的是要能在 <span class="math inline">\(O(n\sqrt n)\)</span> 的时间内预处理。</p>
<p>不妨考虑令 <span class="math inline">\(g_{i,j}\)</span> 为 <span class="math inline">\(j\)</span> 在第 <span class="math inline">\(i\)</span> 块往后的后缀内的出现次数，那么我们在扫描的过程中就能同时把第 <span class="math inline">\(i\)</span> 块到第 <span class="math inline">\(j\)</span> 块内的答案 <span class="math inline">\(f_{i,j}\)</span> 处理出来。询问的时候就合并一下再大暴力就行了。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a aria-hidden="true" href="#cb4-1"></a>FOR(i, <span class="dv">1</span>, bl[n]) {</span>
<span id="cb4-2"><a aria-hidden="true" href="#cb4-2"></a>    <span class="dt">int</span> cur = <span class="dv">0</span>;</span>
<span id="cb4-3"><a aria-hidden="true" href="#cb4-3"></a>    FOR(j, (i - <span class="dv">1</span>) * block + <span class="dv">1</span>, n) {</span>
<span id="cb4-4"><a aria-hidden="true" href="#cb4-4"></a>        ++g[i][j];</span>
<span id="cb4-5"><a aria-hidden="true" href="#cb4-5"></a>        (g[i][j] &amp; <span class="dv">1</span>) ? ((g[i][j] &gt; <span class="dv">1</span>) ? --cur : <span class="dv">0</span>) : ++cur;</span>
<span id="cb4-6"><a aria-hidden="true" href="#cb4-6"></a>        <span class="cf">if</span> (bl[j] != bl[j + <span class="dv">1</span>]) f[i][bl[j]] = cur;</span>
<span id="cb4-7"><a aria-hidden="true" href="#cb4-7"></a>    }</span>
<span id="cb4-8"><a aria-hidden="true" href="#cb4-8"></a>}</span></code></pre></div>
<blockquote>
<p>例题 <span class="math inline">\(2\)</span>：<a href="https://www.luogu.com.cn/problem/P4168">P4168 [Violet]蒲公英</a> also <a href="https://loj.ac/p/6285">LOJ 数列分块入门 9</a></p>
<p>区间众数，强制在线（LOJ 不强制在线），如有多个输出最小的。</p>
</blockquote>
<p>类似上题，考虑提前预处理出 <span class="math inline">\(p_{i,j}\)</span> 表示从块 <span class="math inline">\(i\)</span> 到块 <span class="math inline">\(j\)</span> 中的众数，可以枚举每一个 <span class="math inline">\(i\)</span>，然后往后枚举 <span class="math inline">\(j\)</span>，枚举 <span class="math inline">\(j\)</span> 的过程中枚举每一个元素，复杂度 <span class="math inline">\(O(n\sqrt n)\)</span>。</p>
<p>整块的结果已经弄好了，接下来就要考虑边角的怎么办。因为边角中的数可以成为众数，所以我们需要进行进一步比较。这里我们枚举边角中的每一个数，由于需要快速查询某数在块中的出现个数，所以考虑预处理出数字出现次数的前缀和 <span class="math inline">\(s_{i,j}\)</span>。接下来问题就很简单了，如果待查询区间在同一块内或者相邻，直接暴力做，否则结果就从中间块的众数和边角内的数中产生，枚举边角即可。时空复杂度均为 <span class="math inline">\(O(n\sqrt n)\)</span>。</p>
<blockquote>
<p>例题 <span class="math inline">\(3\)</span>：<a href="https://www.luogu.com.cn/problem/P5048">P5048 [Ynoi2019 模拟赛] Yuno loves sqrt technology III</a></p>
<p>区间众数的出现次数，强制在线，要求空间 <span class="math inline">\(O(n)\)</span>。</p>
</blockquote>
<p>上面那个做法中，空间复杂度的瓶颈是 <span class="math inline">\(s_{i,j}\)</span> 的 <span class="math inline">\(O(n\sqrt n)\)</span>。现在考虑如何优化。首先注意到，其用途主要就是计算散块中的某个数在 <span class="math inline">\([l,r]\)</span> 内是否出现超过 <span class="math inline">\(k\)</span> 次，而我们可以使用 <code>std::vector</code> 存下同一个数的所有出现位置，同时记录 <span class="math inline">\(\mathrm{at}_i\)</span> 表示 <span class="math inline">\(a_i\)</span> 在其对应 <code>std::vector</code> 内的位置。利用这个扫描时调整 <span class="math inline">\(\mathrm{ans}\)</span>，即可通过本题，常数似乎也会小些。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a aria-hidden="true" href="#cb5-1"></a><span class="dt">int</span> query(<span class="dt">int</span> l, <span class="dt">int</span> r) {</span>
<span id="cb5-2"><a aria-hidden="true" href="#cb5-2"></a>    <span class="dt">int</span> ans = <span class="dv">0</span>;</span>
<span id="cb5-3"><a aria-hidden="true" href="#cb5-3"></a>    <span class="cf">if</span> (bl[l] + <span class="dv">1</span> &gt;= bl[r]) {</span>
<span id="cb5-4"><a aria-hidden="true" href="#cb5-4"></a>        FOR(i, l, r) buc[a[i]] = <span class="dv">0</span>;</span>
<span id="cb5-5"><a aria-hidden="true" href="#cb5-5"></a>        FOR(i, l, r) chkmax(ans, ++buc[a[i]]);</span>
<span id="cb5-6"><a aria-hidden="true" href="#cb5-6"></a>    } <span class="cf">else</span> {</span>
<span id="cb5-7"><a aria-hidden="true" href="#cb5-7"></a>        ans = mode[bl[l] + <span class="dv">1</span>][bl[r] - <span class="dv">1</span>];</span>
<span id="cb5-8"><a aria-hidden="true" href="#cb5-8"></a>        FOR(i, l, bl[l] * block) {</span>
<span id="cb5-9"><a aria-hidden="true" href="#cb5-9"></a>            <span class="dt">int</span> p = at[i];</span>
<span id="cb5-10"><a aria-hidden="true" href="#cb5-10"></a>            <span class="cf">while</span> (p + ans &lt; vec[a[i]].size() &amp;&amp; vec[a[i]][p + ans] &lt;= r) ++ans;</span>
<span id="cb5-11"><a aria-hidden="true" href="#cb5-11"></a>        }</span>
<span id="cb5-12"><a aria-hidden="true" href="#cb5-12"></a>        FOR(i, (bl[r] - <span class="dv">1</span>) * block + <span class="dv">1</span>, r) {</span>
<span id="cb5-13"><a aria-hidden="true" href="#cb5-13"></a>            <span class="dt">int</span> p = at[i];</span>
<span id="cb5-14"><a aria-hidden="true" href="#cb5-14"></a>            <span class="cf">while</span> (p - ans &gt;= <span class="dv">0</span> &amp;&amp; vec[a[i]][p - ans] &gt;= l) ++ans;</span>
<span id="cb5-15"><a aria-hidden="true" href="#cb5-15"></a>        }</span>
<span id="cb5-16"><a aria-hidden="true" href="#cb5-16"></a>    }</span>
<span id="cb5-17"><a aria-hidden="true" href="#cb5-17"></a>    <span class="cf">return</span> ans;</span>
<span id="cb5-18"><a aria-hidden="true" href="#cb5-18"></a>}</span></code></pre></div>
<blockquote>
<p>例题：<a href="https://www.luogu.com.cn/problem/P5046">P5046 [Ynoi2019 模拟赛] Yuno loves sqrt technology I</a></p>
<p>排列，区间逆序对数，<strong>强制在线</strong>，<span class="math inline">\(10^5\)</span>，<strong>750ms</strong>。</p>
</blockquote>
<p>如果允许离线，那么这道题就是莫二离的模板题（见下面），但是现在加上了强制在线，所以只能考虑分块预处理。</p>
<p>那么对于一个区间，所有的逆序对是如何贡献而来的呢？下面视 <span class="math inline">\(n,m\)</span> 同阶。</p>
<p>此外，若 <span class="math inline">\(l,r\)</span> 属于同一块，令该块左右端点为 <span class="math inline">\(S,E\)</span>：</p>
<ul>
<li>预处理 <span class="math inline">\(g(i,j)\)</span> 表示 <span class="math inline">\(\sum\limits_{i&lt;k&lt;S+j} [a_k&lt;a_i]\)</span></li>
<li>则答案为 <span class="math inline">\(\sum\limits_{l\le k\le r}g(k, r - S)\)</span></li>
<li><span class="math inline">\(g\)</span> 可以使用值域分块预处理：从右往左一块块扫描，每次把一个元素加入数据结构，然后对 <span class="math inline">\(i\)</span> 左边的元素 <span class="math inline">\(j\)</span> 查询 <span class="math inline">\(&lt;a_j\)</span> 的元素个数 <span class="math inline">\(x\)</span>，则 <span class="math inline">\(g(j, i - S - 1) = ts_j - (E + i - 1 - x)\)</span>。</li>
</ul>
<p>然后就是分属不同块的情况：</p>
<ul>
<li>每个整块内部的；</li>
<li>每个整块之间的；</li>
<li>两散块之间的；</li>
<li>散块到整块的；</li>
<li>两个散块内部的。</li>
</ul>
<p>对于整块内部的和两个散块内部的（本质上就是前缀/后缀），将就用上面的值域分块维护出 <span class="math inline">\(pre_j\)</span> 和 <span class="math inline">\(suf_j\)</span> 即可。</p>
<p>设 <span class="math inline">\(f(i, x)\)</span> 表示第 <span class="math inline">\(x\)</span> 块中有多少小于 <span class="math inline">\(a_i\)</span> 的元素，<span class="math inline">\(s(i,r) = \sum\limits_{l\le r}f(i, l)\)</span> 为其前缀和，则散块到整块的贡献容易处理。设 <span class="math inline">\(t(k,j) = \sum\limits_{bel_i = k}s(i,j)\)</span>，即第 <span class="math inline">\(k\)</span> 块到前 <span class="math inline">\(j\)</span> 块的贡献，则第 <span class="math inline">\(x\sim y\)</span> 个整块间的贡献即为 <span class="math inline">\(\sum\limits_{x\le k\le y}t(k, y) - t(k, k)\)</span>。</p>
<p>那么 <span class="math inline">\(f,s,t,g\)</span> 都是可以一起处理的，时间复杂度 <span class="math inline">\(O(n\sqrt n)\)</span>，这是一种常数相对小的做法。</p>
<h2 id="莫队">莫队</h2>
<p>一种神秘的高效查询信息的高妙暴力。</p>
<h3 id="普通莫队">普通莫队</h3>
<p>假设有两个区间询问 <span class="math inline">\([l_1,r_1]\)</span> 和 <span class="math inline">\([l_2, r_2]\)</span>，若我们可以 <span class="math inline">\(O(x)\)</span> 插入或删除一个元素（从 <span class="math inline">\([l,r]\)</span> 可以转移到 <span class="math inline">\([l\pm1,r]\)</span> 和 <span class="math inline">\([l,r\pm1]\)</span>），那么就意味着我们可以 <span class="math inline">\(O(x\times(|l_1-l_2|+|r_1-r_2|))\)</span> 从 <span class="math inline">\([l_1,r_1]\)</span> 的答案得到 <span class="math inline">\([l_2, r_2]\)</span> 的答案。</p>
<p>而对于<strong>允许离线</strong>的一车这样的询问，我们就可以以某种奇怪的方式回答询问，使得 <span class="math inline">\(\sum(|l_i-l_{i-1}|+|r_i-r_{i-1}|)\)</span> 在一个可以承受的范围内。</p>
<p>我们对原序列分块，然后对于左端点在同一块内的按照右端点排序，否则按照左端点排序，然后按照这个顺序回答每个询问。可以说明这样的复杂度在一个可以承受的范围内。</p>
<p>考虑其复杂度，假设块长为 <span class="math inline">\(B\)</span>，有 <span class="math inline">\(m\)</span> 次询问，则这些询问会被分为 <span class="math inline">\(O(n/B)\)</span> 块，块内右端点有序并且是一起回答的。</p>
<p><span class="math inline">\(r\)</span> 指针不会回跳，复杂度 <span class="math inline">\(O(n)\)</span>，每一块都这样搞，总 <span class="math inline">\(O(n^2/B)\)</span>。每个块内左端点无序但不会相差很远，最多跳 <span class="math inline">\(O(B)\)</span>，<span class="math inline">\(m\)</span> 次询问就跳 <span class="math inline">\(O(mB)\)</span> 次，于是总时间复杂度 <span class="math inline">\(O(n^2/B + mB)\)</span>，取 <span class="math inline">\(B = \sqrt n\)</span> 得到总时间复杂度 <span class="math inline">\(O((n+m)\sqrt n)\)</span>。取 <span class="math inline">\(B = \dfrac{n}{\sqrt m}\)</span> 得到总时间复杂度 <span class="math inline">\(O(n\sqrt m)\)</span>。事实上如果 <span class="math inline">\(n\)</span> 和 <span class="math inline">\(m\)</span> 不同阶的话，不仔细分析块长可能导致复杂度退化。</p>
<p>同时有一个关键的卡常技巧：奇偶块排序。考虑每块询问内 <span class="math inline">\(r\)</span> 指针的移动是单调的，如果每次都要回来重开感觉比较不优，考虑奇数块我们的 <span class="math inline">\(r\)</span> 递增，偶数块 <span class="math inline">\(r\)</span> 递减，这样常数会小一半。同时如果块长开 <span class="math inline">\(\dfrac{n}{\sqrt{\frac23 m}}\)</span> 实战上也会跑的更快。</p>
<blockquote>
<p>例题 <span class="math inline">\(1\)</span>：<a href="https://www.luogu.org/problemnew/show/P2709">P2709 小B的询问</a></p>
<p>值域 <span class="math inline">\([1,k]\)</span> 的序列，区间询问每个数的出现次数的平方和。<span class="math inline">\(1\le n,m,k\le 5\times 10^4\)</span>。</p>
</blockquote>
<p>发现我们维护一个桶，然后对于平方和的移动是很好维护的：</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a aria-hidden="true" href="#cb6-1"></a>il <span class="dt">void</span> add(<span class="dt">int</span> x) {</span>
<span id="cb6-2"><a aria-hidden="true" href="#cb6-2"></a>    tmp += <span class="dv">2</span><span class="bu">ll</span> * cnt[a[x]]++ + <span class="dv">1</span>;</span>
<span id="cb6-3"><a aria-hidden="true" href="#cb6-3"></a>    <span class="cf">return</span>;</span>
<span id="cb6-4"><a aria-hidden="true" href="#cb6-4"></a>}</span>
<span id="cb6-5"><a aria-hidden="true" href="#cb6-5"></a></span>
<span id="cb6-6"><a aria-hidden="true" href="#cb6-6"></a>il <span class="dt">void</span> del(<span class="dt">int</span> x) {</span>
<span id="cb6-7"><a aria-hidden="true" href="#cb6-7"></a>    tmp += <span class="dv">1</span> - <span class="dv">2</span><span class="bu">ll</span> * cnt[a[x]]--;</span>
<span id="cb6-8"><a aria-hidden="true" href="#cb6-8"></a>    <span class="cf">return</span>;</span>
<span id="cb6-9"><a aria-hidden="true" href="#cb6-9"></a>}</span></code></pre></div>
<p>然后就可以随便莫队了：</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a aria-hidden="true" href="#cb7-1"></a><span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> ll;</span>
<span id="cb7-2"><a aria-hidden="true" href="#cb7-2"></a></span>
<span id="cb7-3"><a aria-hidden="true" href="#cb7-3"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">5e4</span> + <span class="dv">5</span>;</span>
<span id="cb7-4"><a aria-hidden="true" href="#cb7-4"></a><span class="dt">int</span> n, m, k, a[maxn], cnt[maxn], block;</span>
<span id="cb7-5"><a aria-hidden="true" href="#cb7-5"></a></span>
<span id="cb7-6"><a aria-hidden="true" href="#cb7-6"></a>ll tmp, ans[maxn];</span>
<span id="cb7-7"><a aria-hidden="true" href="#cb7-7"></a></span>
<span id="cb7-8"><a aria-hidden="true" href="#cb7-8"></a><span class="kw">struct</span> node {</span>
<span id="cb7-9"><a aria-hidden="true" href="#cb7-9"></a>    <span class="dt">int</span> l, r, id;</span>
<span id="cb7-10"><a aria-hidden="true" href="#cb7-10"></a>    il <span class="dt">bool</span> <span class="kw">operator</span>&lt;(<span class="at">const</span> node &amp;b) <span class="at">const</span> {<span class="cf">return</span> (l / block) ^ (b.l / block) ? l &lt; b.l : ((l / block) &amp; <span class="dv">1</span>) ? r &lt; b.r : r &gt; b.r;} <span class="co">// 奇偶性排序</span></span>
<span id="cb7-11"><a aria-hidden="true" href="#cb7-11"></a>} q[maxn];</span>
<span id="cb7-12"><a aria-hidden="true" href="#cb7-12"></a></span>
<span id="cb7-13"><a aria-hidden="true" href="#cb7-13"></a>il <span class="dt">void</span> add(<span class="dt">int</span> x) {</span>
<span id="cb7-14"><a aria-hidden="true" href="#cb7-14"></a>    tmp += <span class="dv">2</span><span class="bu">ll</span> * cnt[a[x]]++ + <span class="dv">1</span>;</span>
<span id="cb7-15"><a aria-hidden="true" href="#cb7-15"></a>    <span class="cf">return</span>;</span>
<span id="cb7-16"><a aria-hidden="true" href="#cb7-16"></a>}</span>
<span id="cb7-17"><a aria-hidden="true" href="#cb7-17"></a></span>
<span id="cb7-18"><a aria-hidden="true" href="#cb7-18"></a>il <span class="dt">void</span> del(<span class="dt">int</span> x) {</span>
<span id="cb7-19"><a aria-hidden="true" href="#cb7-19"></a>    tmp += <span class="dv">1</span> - <span class="dv">2</span><span class="bu">ll</span> * cnt[a[x]]--;</span>
<span id="cb7-20"><a aria-hidden="true" href="#cb7-20"></a>    <span class="cf">return</span>;</span>
<span id="cb7-21"><a aria-hidden="true" href="#cb7-21"></a>}</span>
<span id="cb7-22"><a aria-hidden="true" href="#cb7-22"></a></span>
<span id="cb7-23"><a aria-hidden="true" href="#cb7-23"></a><span class="dt">int</span> main() {</span>
<span id="cb7-24"><a aria-hidden="true" href="#cb7-24"></a>    n = read(), m = read(), k = read();</span>
<span id="cb7-25"><a aria-hidden="true" href="#cb7-25"></a>    FOR(i, <span class="dv">1</span>, n) a[i] = read();</span>
<span id="cb7-26"><a aria-hidden="true" href="#cb7-26"></a>    FOR(i, <span class="dv">1</span>, m) q[i].l = read(), q[i].r = read(), q[i].id = i;</span>
<span id="cb7-27"><a aria-hidden="true" href="#cb7-27"></a>    block = n / sqrt(m * <span class="dv">2</span> / <span class="dv">3</span>);</span>
<span id="cb7-28"><a aria-hidden="true" href="#cb7-28"></a>    <span class="bu">std::</span>sort(q + <span class="dv">1</span>, q + m + <span class="dv">1</span>);</span>
<span id="cb7-29"><a aria-hidden="true" href="#cb7-29"></a>    <span class="dt">int</span> l = <span class="dv">1</span>, r = <span class="dv">0</span>;</span>
<span id="cb7-30"><a aria-hidden="true" href="#cb7-30"></a>    FOR(i, <span class="dv">1</span>, m) {</span>
<span id="cb7-31"><a aria-hidden="true" href="#cb7-31"></a>        <span class="cf">while</span> (l &gt; q[i].l) add(--l); <span class="co">// 注意这里的顺序</span></span>
<span id="cb7-32"><a aria-hidden="true" href="#cb7-32"></a>        <span class="cf">while</span> (r &lt; q[i].r) add(++r);</span>
<span id="cb7-33"><a aria-hidden="true" href="#cb7-33"></a>        <span class="cf">while</span> (l &lt; q[i].l) del(l++);</span>
<span id="cb7-34"><a aria-hidden="true" href="#cb7-34"></a>        <span class="cf">while</span> (r &gt; q[i].r) del(r--);</span>
<span id="cb7-35"><a aria-hidden="true" href="#cb7-35"></a>        ans[q[i].id] = tmp;</span>
<span id="cb7-36"><a aria-hidden="true" href="#cb7-36"></a>    }</span>
<span id="cb7-37"><a aria-hidden="true" href="#cb7-37"></a>    FOR(i, <span class="dv">1</span>, m) printf(<span class="st">"</span><span class="sc">%lld\n</span><span class="st">"</span>, ans[i]);</span>
<span id="cb7-38"><a aria-hidden="true" href="#cb7-38"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb7-39"><a aria-hidden="true" href="#cb7-39"></a>}</span></code></pre></div>
<p>可以发现莫队的实现很简洁，但是需要注意 <span class="math inline">\(4\)</span> 个 <code>while</code> 循环的顺序，其一定是先考虑扩展区间后收缩区间，如果实在记不住那就是先扩展左端右端，再缩减左端右端，否则在一些情况下会<a href="https://oiwiki.org/misc/mo-algo/">引起错误</a>。</p>
<blockquote>
<p>例题 <span class="math inline">\(2\)</span>：<a href="https://www.luogu.com.cn/problem/P4462">P4462 [CQOI2018]异或序列</a></p>
<p>给定序列和参数 <span class="math inline">\(k\)</span>，每次询问 <span class="math inline">\([l,r]\)</span> 内有多少子区间的异或和为 <span class="math inline">\(k\)</span>。<span class="math inline">\(n,m,k,a_i\le 10^5\)</span>。</p>
</blockquote>
<p>首先先做一个前缀异或和，然后问题就变成了在 <span class="math inline">\([l-1, r]\)</span> 中选出 <span class="math inline">\(s_i\)</span> 和 <span class="math inline">\(s_j\)</span> 使得 <span class="math inline">\(s_i\oplus s_j = k\)</span> 的方案数，发现我们可以开桶进行维护，于是直接上莫队，时间复杂度 <span class="math inline">\(O(n\sqrt m)\)</span>。</p>
<blockquote>
<p>例题 <span class="math inline">\(3\)</span>：<a href="https://www.luogu.com.cn/problem/P5268">P5268 [SNOI2017]一个简单的询问</a></p>
<p>给你一个长度为 <span class="math inline">\(N\)</span> 的序列 <span class="math inline">\(a_i\)</span>，<span class="math inline">\(1\leq i\leq N\)</span>，和 <span class="math inline">\(q\)</span> 组询问，每组询问读入 <span class="math inline">\(l_1,r_1,l_2,r_2\)</span>，需输出</p>
<p><span class="math display">\[
\sum\limits_{x=0}^\infty \text{get}(l_1,r_1,x)\times \text{get}(l_2,r_2,x)
\]</span></p>
<p>$ (l,r,x)$ 表示计算区间 <span class="math inline">\([l,r]\)</span> 中，数字 <span class="math inline">\(x\)</span> 出现了多少次。<span class="math inline">\(N,q\le 50000;1\le a_i\le N\)</span>。</p>
</blockquote>
<p>发现如果我们维护四个指针，就有了个很他妈搞笑的 <span class="math inline">\(O(nq^{3/4})\)</span> 做法，没什么戏我的评价是。</p>
<p>考虑差分，设 <span class="math inline">\(c(l, x) = \operatorname{get}(1,l,x)\)</span>，那么上面的式子可以这样拆： <span class="math display">\[
\begin{aligned}
&amp;\operatorname{get}(l_1,r_1,x)\operatorname{get}(l_2,r_2,x)\\
=&amp;(c(r_1, x) - c(l_1 - 1, x))\times(c(r_2,x) - c(l_2 - 1, x))\\
=&amp; c(r_1,x)c(r_2,x) - c(l_1-1,x)c(r_2,x)-c(r_1,x)c(l_2-1,x)+c(l_1-1,x)c(l_2-1,x)
\end{aligned}
\]</span> 是四个形如 <span class="math inline">\(c(r_1,x)c(r_2,x)\)</span> 的子问题，直接莫队带走。加强版 P4689。</p>
<h3 id="带修莫队">带修莫队</h3>
<p>按理来说莫队应该是“无修改”的，但是我们可以强行让状态加一个时间维变成 <span class="math inline">\((l,r,t)\)</span>，然后每一维移动一格都 <span class="math inline">\(O(1)\)</span> 转移。这样的时间复杂度为 <span class="math inline">\(O(n^{5/3})\)</span>，块长取 <span class="math inline">\(n^{2/3}\)</span>。</p>
<blockquote>
<p>例题 <span class="math inline">\(4\)</span>：<a href="https://www.luogu.com.cn/problem/P1903">P1903 [国家集训队]数颜色 / 维护队列</a></p>
<p>单点修改，区间询问不同颜色个数，<span class="math inline">\(n,m\le 133333\)</span>。</p>
</blockquote>
<p>其实也就是单独开一个时间维，如果当前时间不够那就往后推，如果过了就往回撤销。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a aria-hidden="true" href="#cb8-1"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">1.5e5</span> + <span class="dv">5</span>, maxv = <span class="fl">1e6</span> + <span class="dv">5</span>;</span>
<span id="cb8-2"><a aria-hidden="true" href="#cb8-2"></a><span class="dt">int</span> n, m, totq, totc, a[maxn], block, ans[maxn];</span>
<span id="cb8-3"><a aria-hidden="true" href="#cb8-3"></a></span>
<span id="cb8-4"><a aria-hidden="true" href="#cb8-4"></a><span class="dt">int</span> cnt[maxv], tmp;</span>
<span id="cb8-5"><a aria-hidden="true" href="#cb8-5"></a></span>
<span id="cb8-6"><a aria-hidden="true" href="#cb8-6"></a><span class="kw">struct</span> node {</span>
<span id="cb8-7"><a aria-hidden="true" href="#cb8-7"></a>    <span class="dt">int</span> l, r, t, pos, val, id;</span>
<span id="cb8-8"><a aria-hidden="true" href="#cb8-8"></a>} q[maxn], c[maxn];</span>
<span id="cb8-9"><a aria-hidden="true" href="#cb8-9"></a></span>
<span id="cb8-10"><a aria-hidden="true" href="#cb8-10"></a>il <span class="dt">bool</span> cmp(<span class="at">const</span> node &amp;a, <span class="at">const</span> node &amp;b) {</span>
<span id="cb8-11"><a aria-hidden="true" href="#cb8-11"></a>    <span class="cf">if</span> ((a.l / block) ^ (b.l / block)) <span class="cf">return</span> a.l / block &lt; b.l / block;</span>
<span id="cb8-12"><a aria-hidden="true" href="#cb8-12"></a>    <span class="cf">if</span> ((a.r / block) ^ (b.r / block)) <span class="cf">return</span> a.r / block &lt; b.r / block;</span>
<span id="cb8-13"><a aria-hidden="true" href="#cb8-13"></a>    <span class="cf">return</span> a.t &lt; b.t;</span>
<span id="cb8-14"><a aria-hidden="true" href="#cb8-14"></a>}</span>
<span id="cb8-15"><a aria-hidden="true" href="#cb8-15"></a></span>
<span id="cb8-16"><a aria-hidden="true" href="#cb8-16"></a>il <span class="dt">void</span> add(<span class="dt">int</span> x) {</span>
<span id="cb8-17"><a aria-hidden="true" href="#cb8-17"></a>    <span class="cf">if</span> (!cnt[a[x]]++)</span>
<span id="cb8-18"><a aria-hidden="true" href="#cb8-18"></a>        ++tmp;</span>
<span id="cb8-19"><a aria-hidden="true" href="#cb8-19"></a>    <span class="cf">return</span>;</span>
<span id="cb8-20"><a aria-hidden="true" href="#cb8-20"></a>}</span>
<span id="cb8-21"><a aria-hidden="true" href="#cb8-21"></a></span>
<span id="cb8-22"><a aria-hidden="true" href="#cb8-22"></a>il <span class="dt">void</span> del(<span class="dt">int</span> x) {</span>
<span id="cb8-23"><a aria-hidden="true" href="#cb8-23"></a>    <span class="cf">if</span> (!--cnt[a[x]])</span>
<span id="cb8-24"><a aria-hidden="true" href="#cb8-24"></a>        --tmp;</span>
<span id="cb8-25"><a aria-hidden="true" href="#cb8-25"></a>    <span class="cf">return</span>;</span>
<span id="cb8-26"><a aria-hidden="true" href="#cb8-26"></a>}</span>
<span id="cb8-27"><a aria-hidden="true" href="#cb8-27"></a></span>
<span id="cb8-28"><a aria-hidden="true" href="#cb8-28"></a><span class="dt">void</span> work(<span class="dt">int</span> t, <span class="dt">int</span> i) {</span>
<span id="cb8-29"><a aria-hidden="true" href="#cb8-29"></a>    <span class="cf">if</span> (c[t].pos &gt;= q[i].l &amp;&amp; c[t].pos &lt;= q[i].r) {</span>
<span id="cb8-30"><a aria-hidden="true" href="#cb8-30"></a>        <span class="cf">if</span> (!cnt[c[t].val]++)</span>
<span id="cb8-31"><a aria-hidden="true" href="#cb8-31"></a>            ++tmp;</span>
<span id="cb8-32"><a aria-hidden="true" href="#cb8-32"></a>        <span class="cf">if</span> (!--cnt[a[c[t].pos]])</span>
<span id="cb8-33"><a aria-hidden="true" href="#cb8-33"></a>            --tmp;</span>
<span id="cb8-34"><a aria-hidden="true" href="#cb8-34"></a>    }</span>
<span id="cb8-35"><a aria-hidden="true" href="#cb8-35"></a>    <span class="bu">std::</span>swap(c[t].val, a[c[t].pos]);</span>
<span id="cb8-36"><a aria-hidden="true" href="#cb8-36"></a>    <span class="cf">return</span>;</span>
<span id="cb8-37"><a aria-hidden="true" href="#cb8-37"></a>}</span>
<span id="cb8-38"><a aria-hidden="true" href="#cb8-38"></a></span>
<span id="cb8-39"><a aria-hidden="true" href="#cb8-39"></a><span class="dt">int</span> main() {</span>
<span id="cb8-40"><a aria-hidden="true" href="#cb8-40"></a>    n = read(), m = read();</span>
<span id="cb8-41"><a aria-hidden="true" href="#cb8-41"></a>    FOR(i, <span class="dv">1</span>, n) a[i] = read();</span>
<span id="cb8-42"><a aria-hidden="true" href="#cb8-42"></a>    FOR(i, <span class="dv">1</span>, m) {</span>
<span id="cb8-43"><a aria-hidden="true" href="#cb8-43"></a>        <span class="dt">char</span> x = readC();</span>
<span id="cb8-44"><a aria-hidden="true" href="#cb8-44"></a>        <span class="cf">if</span> (x == <span class="ch">'Q'</span>) {</span>
<span id="cb8-45"><a aria-hidden="true" href="#cb8-45"></a>            ++totq;</span>
<span id="cb8-46"><a aria-hidden="true" href="#cb8-46"></a>            q[totq].l = read(), q[totq].r = read(), q[totq].t = totc, q[totq].id = totq;</span>
<span id="cb8-47"><a aria-hidden="true" href="#cb8-47"></a>        } <span class="cf">else</span> {</span>
<span id="cb8-48"><a aria-hidden="true" href="#cb8-48"></a>            ++totc;</span>
<span id="cb8-49"><a aria-hidden="true" href="#cb8-49"></a>            c[totc].pos = read(), c[totc].val = read();</span>
<span id="cb8-50"><a aria-hidden="true" href="#cb8-50"></a>        }</span>
<span id="cb8-51"><a aria-hidden="true" href="#cb8-51"></a>    }</span>
<span id="cb8-52"><a aria-hidden="true" href="#cb8-52"></a>    block = pow(n, <span class="fl">2.0</span> / <span class="fl">3.0</span>);</span>
<span id="cb8-53"><a aria-hidden="true" href="#cb8-53"></a>    <span class="bu">std::</span>sort(q + <span class="dv">1</span>, q + totq + <span class="dv">1</span>, cmp);</span>
<span id="cb8-54"><a aria-hidden="true" href="#cb8-54"></a>    <span class="dt">int</span> now = <span class="dv">0</span>, l = <span class="dv">1</span>, r = <span class="dv">0</span>;</span>
<span id="cb8-55"><a aria-hidden="true" href="#cb8-55"></a>    FOR(i, <span class="dv">1</span>, totq) {</span>
<span id="cb8-56"><a aria-hidden="true" href="#cb8-56"></a>        <span class="cf">while</span> (l &lt; q[i].l) del(l++);</span>
<span id="cb8-57"><a aria-hidden="true" href="#cb8-57"></a>        <span class="cf">while</span> (l &gt; q[i].l) add(--l);</span>
<span id="cb8-58"><a aria-hidden="true" href="#cb8-58"></a>        <span class="cf">while</span> (r &lt; q[i].r) add(++r);</span>
<span id="cb8-59"><a aria-hidden="true" href="#cb8-59"></a>        <span class="cf">while</span> (r &gt; q[i].r) del(r--);</span>
<span id="cb8-60"><a aria-hidden="true" href="#cb8-60"></a></span>
<span id="cb8-61"><a aria-hidden="true" href="#cb8-61"></a>        <span class="cf">while</span> (now &lt; q[i].t) work(++now, i);</span>
<span id="cb8-62"><a aria-hidden="true" href="#cb8-62"></a>        <span class="cf">while</span> (now &gt; q[i].t) work(now--, i);</span>
<span id="cb8-63"><a aria-hidden="true" href="#cb8-63"></a></span>
<span id="cb8-64"><a aria-hidden="true" href="#cb8-64"></a>        ans[q[i].id] = tmp;</span>
<span id="cb8-65"><a aria-hidden="true" href="#cb8-65"></a>    }</span>
<span id="cb8-66"><a aria-hidden="true" href="#cb8-66"></a>    FOR(i, <span class="dv">1</span>, totq) print(ans[i]), putchar(<span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span>);</span>
<span id="cb8-67"><a aria-hidden="true" href="#cb8-67"></a>    <span class="cf">return</span> output(), <span class="dv">0</span>;</span>
<span id="cb8-68"><a aria-hidden="true" href="#cb8-68"></a>}</span></code></pre></div>
<h3 id="树上莫队">树上莫队</h3>
<p>我们考虑用莫队解决树上问题（主要是树链查询）。首先考虑 dfs 序的入序和出序 <span class="math inline">\(st_x, ed_x\)</span>。</p>
<p>则 <span class="math inline">\((x,y)\)</span> 的路径可以被转化为 <span class="math inline">\([ed_x, st_y]\)</span> 中<strong>恰好出现了一次的点与 LCA 的并</strong>，证明不难考虑。所以我们在莫队转移的时候记录一下一个点被访问的次数，第一次访问就加上其贡献，否则删去其贡献。</p>
<blockquote>
<p>例题 <span class="math inline">\(5\)</span>：<a href="https://www.luogu.com.cn/problem/SP10707">SP10707 COT2 - Count on a tree II</a></p>
<p>树链数颜色，<span class="math inline">\(1\le n\le 4\times 10^4\)</span>，<span class="math inline">\(1\le m\le 10^5\)</span>。</p>
</blockquote>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a aria-hidden="true" href="#cb9-1"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">1e5</span> + <span class="dv">5</span>;</span>
<span id="cb9-2"><a aria-hidden="true" href="#cb9-2"></a><span class="dt">int</span> head[maxn], to[maxn &lt;&lt; <span class="dv">1</span>], nxt[maxn &lt;&lt; <span class="dv">1</span>], cnte, block;</span>
<span id="cb9-3"><a aria-hidden="true" href="#cb9-3"></a><span class="dt">int</span> a[maxn], aa[maxn], n, m, st[maxn], ed[maxn], nfd[maxn &lt;&lt; <span class="dv">1</span>], clock;</span>
<span id="cb9-4"><a aria-hidden="true" href="#cb9-4"></a></span>
<span id="cb9-5"><a aria-hidden="true" href="#cb9-5"></a><span class="co">// 树剖部分省略 // </span></span>
<span id="cb9-6"><a aria-hidden="true" href="#cb9-6"></a></span>
<span id="cb9-7"><a aria-hidden="true" href="#cb9-7"></a><span class="kw">struct</span> node {</span>
<span id="cb9-8"><a aria-hidden="true" href="#cb9-8"></a>    <span class="dt">int</span> l, r, lca, id;</span>
<span id="cb9-9"><a aria-hidden="true" href="#cb9-9"></a>    il <span class="dt">bool</span> <span class="kw">operator</span>&lt;(<span class="at">const</span> node &amp;b) <span class="at">const</span> {<span class="cf">return</span> ((l / block) ^ (b.l / block)) ? l &lt; b.l : (((l / block) &amp; <span class="dv">1</span>) ? r &lt; b.r : r &gt; b.r);}</span>
<span id="cb9-10"><a aria-hidden="true" href="#cb9-10"></a>} q[maxn];</span>
<span id="cb9-11"><a aria-hidden="true" href="#cb9-11"></a></span>
<span id="cb9-12"><a aria-hidden="true" href="#cb9-12"></a><span class="dt">int</span> cnt[maxn], used[maxn], nowAns, ans[maxn];</span>
<span id="cb9-13"><a aria-hidden="true" href="#cb9-13"></a></span>
<span id="cb9-14"><a aria-hidden="true" href="#cb9-14"></a>il <span class="dt">void</span> add(<span class="dt">int</span> x) {nowAns += !cnt[a[x]]++;}</span>
<span id="cb9-15"><a aria-hidden="true" href="#cb9-15"></a></span>
<span id="cb9-16"><a aria-hidden="true" href="#cb9-16"></a>il <span class="dt">void</span> del(<span class="dt">int</span> x) {nowAns -= !--cnt[a[x]];}</span>
<span id="cb9-17"><a aria-hidden="true" href="#cb9-17"></a></span>
<span id="cb9-18"><a aria-hidden="true" href="#cb9-18"></a>il <span class="dt">void</span> Add(<span class="dt">int</span> x) {</span>
<span id="cb9-19"><a aria-hidden="true" href="#cb9-19"></a>    used[x] ? del(x) : add(x);</span>
<span id="cb9-20"><a aria-hidden="true" href="#cb9-20"></a>    used[x] ^= <span class="dv">1</span>;</span>
<span id="cb9-21"><a aria-hidden="true" href="#cb9-21"></a>    <span class="cf">return</span>;</span>
<span id="cb9-22"><a aria-hidden="true" href="#cb9-22"></a>}</span>
<span id="cb9-23"><a aria-hidden="true" href="#cb9-23"></a></span>
<span id="cb9-24"><a aria-hidden="true" href="#cb9-24"></a><span class="dt">int</span> main() {</span>
<span id="cb9-25"><a aria-hidden="true" href="#cb9-25"></a>    read(n), read(m), block = <span class="dv">2</span> * n / sqrt(<span class="dv">2</span> * m / <span class="dv">3</span>);</span>
<span id="cb9-26"><a aria-hidden="true" href="#cb9-26"></a></span>
<span id="cb9-27"><a aria-hidden="true" href="#cb9-27"></a>    FOR(i, <span class="dv">1</span>, n) read(aa[i]), a[i] = aa[i];</span>
<span id="cb9-28"><a aria-hidden="true" href="#cb9-28"></a>    <span class="bu">std::</span>sort(aa + <span class="dv">1</span>, aa + n + <span class="dv">1</span>);</span>
<span id="cb9-29"><a aria-hidden="true" href="#cb9-29"></a>    <span class="dt">int</span> tota = <span class="bu">std::</span>unique(aa + <span class="dv">1</span>, aa + n + <span class="dv">1</span>) - aa - <span class="dv">1</span>;</span>
<span id="cb9-30"><a aria-hidden="true" href="#cb9-30"></a>    FOR(i, <span class="dv">1</span>, n) a[i] = <span class="bu">std::</span>lower_bound(aa + <span class="dv">1</span>, aa + tota + <span class="dv">1</span>, a[i]) - aa;</span>
<span id="cb9-31"><a aria-hidden="true" href="#cb9-31"></a></span>
<span id="cb9-32"><a aria-hidden="true" href="#cb9-32"></a>    FOR(i, <span class="dv">1</span>, n - <span class="dv">1</span>) {</span>
<span id="cb9-33"><a aria-hidden="true" href="#cb9-33"></a>        <span class="dt">int</span> u, v; read(u), read(v);</span>
<span id="cb9-34"><a aria-hidden="true" href="#cb9-34"></a>        addEdge(u, v), addEdge(v, u);</span>
<span id="cb9-35"><a aria-hidden="true" href="#cb9-35"></a>    }</span>
<span id="cb9-36"><a aria-hidden="true" href="#cb9-36"></a></span>
<span id="cb9-37"><a aria-hidden="true" href="#cb9-37"></a>    dfs1(<span class="dv">1</span>, <span class="dv">0</span>), dfs2(<span class="dv">1</span>, <span class="dv">1</span>);</span>
<span id="cb9-38"><a aria-hidden="true" href="#cb9-38"></a></span>
<span id="cb9-39"><a aria-hidden="true" href="#cb9-39"></a>    FOR(i, <span class="dv">1</span>, m) {</span>
<span id="cb9-40"><a aria-hidden="true" href="#cb9-40"></a>        <span class="dt">int</span> u, v; read(u), read(v);</span>
<span id="cb9-41"><a aria-hidden="true" href="#cb9-41"></a>        q[i].id = i;</span>
<span id="cb9-42"><a aria-hidden="true" href="#cb9-42"></a>        <span class="cf">if</span> (st[u] &gt; st[v]) <span class="bu">std::</span>swap(u, v);</span>
<span id="cb9-43"><a aria-hidden="true" href="#cb9-43"></a>        <span class="dt">int</span> _lca = getLCA(u, v);</span>
<span id="cb9-44"><a aria-hidden="true" href="#cb9-44"></a>        <span class="cf">if</span> (_lca == u) q[i].l = st[u], q[i].r = st[v];</span>
<span id="cb9-45"><a aria-hidden="true" href="#cb9-45"></a>        <span class="cf">else</span> q[i].l = ed[u], q[i].r = st[v], q[i].lca = _lca;</span>
<span id="cb9-46"><a aria-hidden="true" href="#cb9-46"></a>    }</span>
<span id="cb9-47"><a aria-hidden="true" href="#cb9-47"></a>    <span class="bu">std::</span>sort(q + <span class="dv">1</span>, q + m + <span class="dv">1</span>);</span>
<span id="cb9-48"><a aria-hidden="true" href="#cb9-48"></a></span>
<span id="cb9-49"><a aria-hidden="true" href="#cb9-49"></a>    <span class="dt">int</span> l = <span class="dv">1</span>, r = <span class="dv">0</span>;</span>
<span id="cb9-50"><a aria-hidden="true" href="#cb9-50"></a>    FOR(i, <span class="dv">1</span>, m) {</span>
<span id="cb9-51"><a aria-hidden="true" href="#cb9-51"></a>        <span class="cf">while</span> (l &gt; q[i].l) Add(nfd[--l]);</span>
<span id="cb9-52"><a aria-hidden="true" href="#cb9-52"></a>        <span class="cf">while</span> (r &lt; q[i].r) Add(nfd[++r]);</span>
<span id="cb9-53"><a aria-hidden="true" href="#cb9-53"></a>        <span class="cf">while</span> (l &lt; q[i].l) Add(nfd[l++]);</span>
<span id="cb9-54"><a aria-hidden="true" href="#cb9-54"></a>        <span class="cf">while</span> (r &gt; q[i].r) Add(nfd[r--]);</span>
<span id="cb9-55"><a aria-hidden="true" href="#cb9-55"></a></span>
<span id="cb9-56"><a aria-hidden="true" href="#cb9-56"></a>        <span class="cf">if</span> (q[i].lca) Add(q[i].lca); <span class="co">// 单独处理 LCA 的贡献</span></span>
<span id="cb9-57"><a aria-hidden="true" href="#cb9-57"></a>        ans[q[i].id] = nowAns;</span>
<span id="cb9-58"><a aria-hidden="true" href="#cb9-58"></a>        <span class="cf">if</span> (q[i].lca) Add(q[i].lca);</span>
<span id="cb9-59"><a aria-hidden="true" href="#cb9-59"></a>    }</span>
<span id="cb9-60"><a aria-hidden="true" href="#cb9-60"></a>    FOR(i, <span class="dv">1</span>, m) print(ans[i]), putchar(<span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span>);</span>
<span id="cb9-61"><a aria-hidden="true" href="#cb9-61"></a>    <span class="cf">return</span> output(), <span class="dv">0</span>;</span>
<span id="cb9-62"><a aria-hidden="true" href="#cb9-62"></a>}</span></code></pre></div>
<h3 id="回滚莫队">回滚莫队</h3>
<p>有些时候莫队维护的信息<strong>不具有可减性</strong>，其能很好支持区间的扩展而无法处理区间的收缩（或者很好删而不好增），此时我们使用回滚莫队一样可以做到 <span class="math inline">\(O(n\sqrt m)\)</span>。</p>
<blockquote>
<p>例题 <span class="math inline">\(6\)</span>：<a href="https://www.luogu.com.cn/problem/AT1219">JOISC 2014 歴史の研究</a></p>
<p>区间询问<strong>重要度</strong>最大的数字的重要度。数 <span class="math inline">\(x\)</span> 的重要度定义为在区间内的出现次数乘上 <span class="math inline">\(x\)</span>。</p>
</blockquote>
<p>我们可以发现，当我们扩展区间的时候，答案是很好维护的（新的答案只可能被新加进去的数贡献而来），但是删除数字的话答案根本不好进行维护，所以此时我们需要采用别的回答询问的方法。</p>
<p>注意到即使信息不可减，我们依然可以高效<strong>撤销</strong>。</p>
<p>将所有询问按照左端点所在块排序，同一块内保证右端点单调增。对于每个块，<span class="math inline">\(l\)</span> 指针初始指向<strong>下一个块的开头</strong>，<span class="math inline">\(r\)</span> 指针初始指向 <span class="math inline">\(l - 1\)</span>（表明区间为空）。然后对于右端点，直接往右扩展即可（因为是单调的），然后对于左端点我们也扩展到目标位置然后记录答案。</p>
<p>接下来就要撤回左端点对信息的修改，最多移动 <span class="math inline">\(B\)</span> 步，然后接着回答下一个询问。</p>
<p>需要注意<strong>同一块内的询问需要单独暴力处理（但是只删除版本的回滚莫队不需要），处理到下一块的时候要清空所有信息并重新初始化指针</strong>。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a aria-hidden="true" href="#cb10-1"></a><span class="kw">using</span> ll = <span class="dt">long</span> <span class="dt">long</span>;</span>
<span id="cb10-2"><a aria-hidden="true" href="#cb10-2"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">1e5</span> + <span class="dv">5</span>;</span>
<span id="cb10-3"><a aria-hidden="true" href="#cb10-3"></a><span class="dt">int</span> bel[maxn], n, m, tot, lpos[maxn], rpos[maxn];</span>
<span id="cb10-4"><a aria-hidden="true" href="#cb10-4"></a>ll val[maxn], a[maxn], ans[maxn], cnt[maxn], cnt2[maxn];</span>
<span id="cb10-5"><a aria-hidden="true" href="#cb10-5"></a></span>
<span id="cb10-6"><a aria-hidden="true" href="#cb10-6"></a><span class="kw">struct</span> node {</span>
<span id="cb10-7"><a aria-hidden="true" href="#cb10-7"></a>    <span class="dt">int</span> l, r, id;</span>
<span id="cb10-8"><a aria-hidden="true" href="#cb10-8"></a>} q[maxn];</span>
<span id="cb10-9"><a aria-hidden="true" href="#cb10-9"></a></span>
<span id="cb10-10"><a aria-hidden="true" href="#cb10-10"></a>il <span class="dt">bool</span> cmp(<span class="at">const</span> node &amp;a, <span class="at">const</span> node &amp;b) {</span>
<span id="cb10-11"><a aria-hidden="true" href="#cb10-11"></a>    <span class="cf">if</span> (bel[a.l] ^ bel[b.l]) <span class="cf">return</span> bel[a.l] &lt; bel[b.l];</span>
<span id="cb10-12"><a aria-hidden="true" href="#cb10-12"></a>    <span class="cf">return</span> a.r &lt; b.r;</span>
<span id="cb10-13"><a aria-hidden="true" href="#cb10-13"></a>}</span>
<span id="cb10-14"><a aria-hidden="true" href="#cb10-14"></a></span>
<span id="cb10-15"><a aria-hidden="true" href="#cb10-15"></a><span class="dt">void</span> del(<span class="dt">int</span> x) {--cnt[a[x]];}</span>
<span id="cb10-16"><a aria-hidden="true" href="#cb10-16"></a><span class="dt">void</span> insert(<span class="dt">int</span> x, ll &amp;now) {now = max(now, (++cnt[a[x]]) * val[a[x]]);}</span>
<span id="cb10-17"><a aria-hidden="true" href="#cb10-17"></a></span>
<span id="cb10-18"><a aria-hidden="true" href="#cb10-18"></a><span class="dt">int</span> main() {</span>
<span id="cb10-19"><a aria-hidden="true" href="#cb10-19"></a>    read(n), read(m);</span>
<span id="cb10-20"><a aria-hidden="true" href="#cb10-20"></a>    FOR(i, <span class="dv">1</span>, n) read(val[i]), a[i] = val[i];</span>
<span id="cb10-21"><a aria-hidden="true" href="#cb10-21"></a>    <span class="bu">std::</span>sort(val + <span class="dv">1</span>, val + n + <span class="dv">1</span>);</span>
<span id="cb10-22"><a aria-hidden="true" href="#cb10-22"></a>    tot = <span class="bu">std::</span>unique(val + <span class="dv">1</span>, val + n + <span class="dv">1</span>) - val - <span class="dv">1</span>;</span>
<span id="cb10-23"><a aria-hidden="true" href="#cb10-23"></a>    FOR(i, <span class="dv">1</span>, n) a[i] = <span class="bu">std::</span>lower_bound(val + <span class="dv">1</span>, val + tot + <span class="dv">1</span>, a[i]) - val;</span>
<span id="cb10-24"><a aria-hidden="true" href="#cb10-24"></a></span>
<span id="cb10-25"><a aria-hidden="true" href="#cb10-25"></a>    <span class="dt">int</span> block = sqrt(n), T = n / block;</span>
<span id="cb10-26"><a aria-hidden="true" href="#cb10-26"></a>    FOR(i, <span class="dv">1</span>, T) {</span>
<span id="cb10-27"><a aria-hidden="true" href="#cb10-27"></a>        <span class="cf">if</span> (i * block &gt; n) <span class="cf">break</span>;</span>
<span id="cb10-28"><a aria-hidden="true" href="#cb10-28"></a>        lpos[i] = (i - <span class="dv">1</span>) * block + <span class="dv">1</span>;</span>
<span id="cb10-29"><a aria-hidden="true" href="#cb10-29"></a>        rpos[i] = i * block;</span>
<span id="cb10-30"><a aria-hidden="true" href="#cb10-30"></a>    }</span>
<span id="cb10-31"><a aria-hidden="true" href="#cb10-31"></a>    <span class="cf">if</span> (rpos[T] &lt; n) ++T, lpos[T] = rpos[T - <span class="dv">1</span>] + <span class="dv">1</span>, rpos[T] = n;</span>
<span id="cb10-32"><a aria-hidden="true" href="#cb10-32"></a>    FOR(j, <span class="dv">1</span>, T) FOR(i, lpos[j], rpos[j]) bel[i] = j;</span>
<span id="cb10-33"><a aria-hidden="true" href="#cb10-33"></a></span>
<span id="cb10-34"><a aria-hidden="true" href="#cb10-34"></a>    FOR(i, <span class="dv">1</span>, m) read(q[i].l), read(q[i].r), q[i].id = i;</span>
<span id="cb10-35"><a aria-hidden="true" href="#cb10-35"></a>    <span class="bu">std::</span>sort(q + <span class="dv">1</span>, q + m + <span class="dv">1</span>, cmp);</span>
<span id="cb10-36"><a aria-hidden="true" href="#cb10-36"></a></span>
<span id="cb10-37"><a aria-hidden="true" href="#cb10-37"></a>    <span class="dt">int</span> nowblock = <span class="dv">0</span>, l = <span class="dv">1</span>, r = <span class="dv">0</span>;</span>
<span id="cb10-38"><a aria-hidden="true" href="#cb10-38"></a>    ll nowans;</span>
<span id="cb10-39"><a aria-hidden="true" href="#cb10-39"></a>    FOR(i, <span class="dv">1</span>, m) {</span>
<span id="cb10-40"><a aria-hidden="true" href="#cb10-40"></a>        <span class="cf">if</span> (bel[q[i].l] == bel[q[i].r]) {</span>
<span id="cb10-41"><a aria-hidden="true" href="#cb10-41"></a>            FOR(j, q[i].l, q[i].r) ++cnt2[a[j]];</span>
<span id="cb10-42"><a aria-hidden="true" href="#cb10-42"></a>            ll res = <span class="dv">0</span>;</span>
<span id="cb10-43"><a aria-hidden="true" href="#cb10-43"></a>            FOR(j, q[i].l, q[i].r)</span>
<span id="cb10-44"><a aria-hidden="true" href="#cb10-44"></a>                res = max(res, cnt2[a[j]] * val[a[j]]);</span>
<span id="cb10-45"><a aria-hidden="true" href="#cb10-45"></a>            FOR(j, q[i].l, q[i].r) --cnt2[a[j]];</span>
<span id="cb10-46"><a aria-hidden="true" href="#cb10-46"></a>            ans[q[i].id] = res;</span>
<span id="cb10-47"><a aria-hidden="true" href="#cb10-47"></a>            <span class="cf">continue</span>;</span>
<span id="cb10-48"><a aria-hidden="true" href="#cb10-48"></a>        }</span>
<span id="cb10-49"><a aria-hidden="true" href="#cb10-49"></a>        <span class="cf">if</span> (bel[q[i].l] ^ nowblock) { <span class="co">// 到了新的块要初始化</span></span>
<span id="cb10-50"><a aria-hidden="true" href="#cb10-50"></a>            <span class="cf">while</span> (r &gt; rpos[bel[q[i].l]]) del(r--);</span>
<span id="cb10-51"><a aria-hidden="true" href="#cb10-51"></a>            <span class="cf">while</span> (l &lt; rpos[bel[q[i].l]] + <span class="dv">1</span>) del(l++);</span>
<span id="cb10-52"><a aria-hidden="true" href="#cb10-52"></a>            nowans = <span class="dv">0</span>, nowblock = bel[q[i].l];</span>
<span id="cb10-53"><a aria-hidden="true" href="#cb10-53"></a>        }</span>
<span id="cb10-54"><a aria-hidden="true" href="#cb10-54"></a>        <span class="cf">while</span> (r &lt; q[i].r) insert(++r, nowans);</span>
<span id="cb10-55"><a aria-hidden="true" href="#cb10-55"></a>        ll tmp = nowans; <span class="dt">int</span> _l = l; <span class="co">// 移动左端点</span></span>
<span id="cb10-56"><a aria-hidden="true" href="#cb10-56"></a>        <span class="cf">while</span> (_l &gt; q[i].l) insert(--_l, tmp);</span>
<span id="cb10-57"><a aria-hidden="true" href="#cb10-57"></a>        ans[q[i].id] = tmp;</span>
<span id="cb10-58"><a aria-hidden="true" href="#cb10-58"></a>        <span class="cf">while</span> (_l &lt; l) del(_l++); <span class="co">// 撤销</span></span>
<span id="cb10-59"><a aria-hidden="true" href="#cb10-59"></a>    }</span>
<span id="cb10-60"><a aria-hidden="true" href="#cb10-60"></a>  </span>
<span id="cb10-61"><a aria-hidden="true" href="#cb10-61"></a>    FOR(i, <span class="dv">1</span>, m) print(ans[i], <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span>);</span>
<span id="cb10-62"><a aria-hidden="true" href="#cb10-62"></a>    <span class="cf">return</span> output(), <span class="dv">0</span>;</span>
<span id="cb10-63"><a aria-hidden="true" href="#cb10-63"></a>}</span></code></pre></div>
<p>分析一下时间复杂度，左右端点在同一块内的复杂度是 <span class="math inline">\(O(B)\)</span>，其他询问的话，一块内的右端点最多移动 <span class="math inline">\(O(n)\)</span>，左端点单次移动是 <span class="math inline">\(O(B)\)</span>，一共 <span class="math inline">\(O(n / B)\)</span> 块，所以总时间复杂度是 <span class="math inline">\(O(mB + n^2/B)\)</span>，取 <span class="math inline">\(B = \dfrac{n}{\sqrt m}\)</span> 得到时间复杂度为 <span class="math inline">\(O(n\sqrt m)\)</span>。</p>
<h3 id="莫队二次离线">莫队二次离线</h3>
<p>用于处理一部分无法 <span class="math inline">\(O(1)\)</span> 更新答案的莫队问题。要求一个数的贡献与区间内其他数有关并且满足可减性。通俗来说就是将莫队更新答案的过程给离线下来然后扫描线，故称为“莫二离”。假设更新答案的时间复杂度是 <span class="math inline">\(O(f)\)</span>，朴素莫队是 <span class="math inline">\(O(nf\sqrt m)\)</span>，但使用莫二离可以做到 <span class="math inline">\(O(nf + n\sqrt m)\)</span>。</p>
<p>主要的思路是，令 <span class="math inline">\(x\)</span> 对 <span class="math inline">\([l,r]\)</span> 的贡献为 <span class="math inline">\(f(x, l, r)\)</span>，则考虑区间端点变化对答案的影响。考虑 <span class="math inline">\([l,r]\to [l,r+k]\)</span>，即我们对于 <span class="math inline">\(\forall x\in[r+1,r+k]\)</span>，都要求一遍 <span class="math inline">\(f(x, l, x - 1)\)</span>，并累计入答案中。</p>
<p>对其差分一下，设 <span class="math inline">\(F(x,l) = f(x,1,l)\)</span>，则 <span class="math inline">\(f(x,l,x - 1) = F(x, x - 1) - F(x, l - 1)\)</span>。这样就变为一个数对一个前缀的贡献了，保存下这样所有的询问，扫描线过去就行了，空间复杂度 <span class="math inline">\(O(n\sqrt m)\)</span> 但仍旧不够优秀。发现：</p>
<ul>
<li>减号左边的贡献永远是一个前缀和其后面一个数产生的贡献，这个明显可以一开始就预处理出来。</li>
<li>一次端点移动中，减号右边的贡献的 <span class="math inline">\(x\)</span> 都是不变的，只记录移动的端点就可以了。</li>
</ul>
<p>所以空间复杂度降为 <span class="math inline">\(O(m)\)</span>。</p>
<blockquote>
<p>例题：<a href="https://www.luogu.com.cn/problem/P4887">P4887 【模板】莫队二次离线（第十四分块(前体)）</a></p>
<p>给定序列 <span class="math inline">\(a\)</span>，每次查询给一个区间 <span class="math inline">\([l,r]\)</span>，查询 <span class="math inline">\(l \leq i&lt; j \leq r\)</span>，且 <span class="math inline">\(a_i \oplus a_j\)</span> 的二进制表示下有 <span class="math inline">\(k\)</span> 个 <span class="math inline">\(1\)</span> 的二元组 <span class="math inline">\((i,j)\)</span> 的个数。<span class="math inline">\(\oplus\)</span> 是指按位异或。<span class="math inline">\(1 \leq n, m \leq 10^5\)</span>，<span class="math inline">\(0 \leq a_i, k &lt; 16384\)</span>。1s，40MB。</p>
</blockquote>
<p>注意到值域为 <span class="math inline">\([0,2^{14})\)</span>，直接裸的莫队移动答案复杂度是 <span class="math inline">\(O(\binom{14}k)\)</span> 的，<span class="math inline">\(O(n\sqrt m\binom{14}{k})\)</span> 显然过不去。由于信息满足可减性，故考虑莫二离。</p>
<p>具体写的时候，对于莫队部分，分类讨论可以得到</p>
<ul>
<li>右端点右移，<span class="math inline">\([l,r]\to[l,r']\)</span>，答案增加 <span class="math inline">\(\sum\limits_{i=r+1}^{r'}F(i,i-1) - F(i,l-1)\)</span>。</li>
<li>右端点左移，<span class="math inline">\([l,r]\to[l,r']\)</span>，答案减少 <span class="math inline">\(\sum\limits_{i=r'+1}^rF(i,i-1) - F(i,l-1)\)</span>。</li>
<li>左端点右移，<span class="math inline">\([l,r]\to[l',r]\)</span>，答案减少 <span class="math inline">\(\sum\limits_{i=l}^{l'-1}F(i,r) - F(i,i)\)</span>。</li>
<li>左端点左移，<span class="math inline">\([l,r]\to[l',r]\)</span>，答案增加 <span class="math inline">\(\sum\limits_{i=l'}^{l-1}F(i,r)-F(i,i)\)</span>。</li>
</ul>
<p>注意到 <span class="math inline">\(a_i\oplus a_i = 0\)</span>，<span class="math inline">\(i=i\)</span> 的贡献不算，所以 <span class="math inline">\(F(i,i) = F(i,i-1)\)</span>。跑的时候记得同时把减号前半段的贡献处理好。</p>
<p>然后对每个前缀 <span class="math inline">\([1,i]\)</span> 开一个 <code>vector</code>，里面装二元组（就是上面指针移动的端点，不要忘记记录 ID），设 <span class="math inline">\(t\)</span> 为桶，<span class="math inline">\(t_z\)</span> 表示 <span class="math inline">\([1,i]\)</span> 中异或 <span class="math inline">\(z\)</span> 后得到的数有 <span class="math inline">\(k\)</span> 个 <span class="math inline">\(1\)</span> 的数的个数。那么我们扫描线枚举 <span class="math inline">\([1,i]\)</span> 的时候，插入就 <span class="math inline">\(O(\binom{14}{k})\)</span> 枚举所有有 <span class="math inline">\(k\)</span> 个 <span class="math inline">\(1\)</span> 的 <span class="math inline">\(v\)</span>，然后 <span class="math inline">\(t_{v\oplus a_i}\)</span> 自增 <span class="math inline">\(1\)</span>。二元组 <span class="math inline">\((l,r)\)</span> 产生的贡献也就是 <span class="math inline">\(\sum\limits_{i=l}^rt_i\)</span>。</p>
<p>这样子总的时间复杂度就是 <span class="math inline">\(O(n\sqrt m + n\binom{14}{k})\)</span>，可以通过，代码细节较多：</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a aria-hidden="true" href="#cb11-1"></a><span class="pp">#include </span><span class="im">&lt;bits/stdc++.h&gt;</span></span>
<span id="cb11-2"><a aria-hidden="true" href="#cb11-2"></a><span class="pp">#include </span><span class="im">&lt;fastio.hpp&gt;</span><span class="pp"> </span></span>
<span id="cb11-3"><a aria-hidden="true" href="#cb11-3"></a><span class="pp">#define il </span><span class="kw">inline</span></span>
<span id="cb11-4"><a aria-hidden="true" href="#cb11-4"></a><span class="pp">#define FOR</span>(i,<span class="pp"> </span>a,<span class="pp"> </span>b)<span class="pp"> </span><span class="cf">for</span><span class="pp"> </span>(<span class="dt">int</span><span class="pp"> </span>i<span class="pp"> </span>=<span class="pp"> </span>(a);<span class="pp"> </span>i<span class="pp"> </span>&lt;=<span class="pp"> </span>(b);<span class="pp"> </span>++i)</span>
<span id="cb11-5"><a aria-hidden="true" href="#cb11-5"></a></span>
<span id="cb11-6"><a aria-hidden="true" href="#cb11-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb11-7"><a aria-hidden="true" href="#cb11-7"></a><span class="kw">using</span> YangTY::fastIO::is;</span>
<span id="cb11-8"><a aria-hidden="true" href="#cb11-8"></a><span class="kw">using</span> YangTY::fastIO::os;</span>
<span id="cb11-9"><a aria-hidden="true" href="#cb11-9"></a><span class="kw">using</span> ll = <span class="dt">long</span> <span class="dt">long</span>;</span>
<span id="cb11-10"><a aria-hidden="true" href="#cb11-10"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">1e5</span> + <span class="dv">5</span>;</span>
<span id="cb11-11"><a aria-hidden="true" href="#cb11-11"></a><span class="dt">int</span> n, m, k, a[maxn], bl[maxn], block;</span>
<span id="cb11-12"><a aria-hidden="true" href="#cb11-12"></a>vector&lt;<span class="dt">int</span>&gt; buc;</span>
<span id="cb11-13"><a aria-hidden="true" href="#cb11-13"></a>ll t[maxn], pre[maxn], ans[maxn];</span>
<span id="cb11-14"><a aria-hidden="true" href="#cb11-14"></a></span>
<span id="cb11-15"><a aria-hidden="true" href="#cb11-15"></a><span class="kw">struct</span> Query {</span>
<span id="cb11-16"><a aria-hidden="true" href="#cb11-16"></a>    <span class="dt">int</span> l, r, id;</span>
<span id="cb11-17"><a aria-hidden="true" href="#cb11-17"></a>    Query(<span class="dt">int</span> _l = <span class="dv">0</span>, <span class="dt">int</span> _r = <span class="dv">0</span>, <span class="dt">int</span> _id = <span class="dv">0</span>) :  l(_l), r(_r), id(_id) {}</span>
<span id="cb11-18"><a aria-hidden="true" href="#cb11-18"></a>} q[maxn];</span>
<span id="cb11-19"><a aria-hidden="true" href="#cb11-19"></a>vector&lt;Query&gt; v[maxn];</span>
<span id="cb11-20"><a aria-hidden="true" href="#cb11-20"></a></span>
<span id="cb11-21"><a aria-hidden="true" href="#cb11-21"></a><span class="dt">int</span> main() {</span>
<span id="cb11-22"><a aria-hidden="true" href="#cb11-22"></a>    is &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span>
<span id="cb11-23"><a aria-hidden="true" href="#cb11-23"></a>    block = n / (sqrt(m) + <span class="dv">1</span>) + <span class="dv">1</span>;</span>
<span id="cb11-24"><a aria-hidden="true" href="#cb11-24"></a>    <span class="cf">if</span> (k &gt; <span class="dv">14</span>) {</span>
<span id="cb11-25"><a aria-hidden="true" href="#cb11-25"></a>        FOR(i, <span class="dv">1</span>, m) os &lt;&lt; <span class="st">"0</span><span class="sc">\n</span><span class="st">"</span>;</span>
<span id="cb11-26"><a aria-hidden="true" href="#cb11-26"></a>        <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb11-27"><a aria-hidden="true" href="#cb11-27"></a>    }</span>
<span id="cb11-28"><a aria-hidden="true" href="#cb11-28"></a>    FOR(i, <span class="dv">1</span>, n) is &gt;&gt; a[i], bl[i] = (i - <span class="dv">1</span>) / block + <span class="dv">1</span>;</span>
<span id="cb11-29"><a aria-hidden="true" href="#cb11-29"></a>    FOR(i, <span class="dv">1</span>, m) is &gt;&gt; q[i].l &gt;&gt; q[i].r, q[i].id = i;</span>
<span id="cb11-30"><a aria-hidden="true" href="#cb11-30"></a>    FOR(i, <span class="dv">0</span>, <span class="dv">16384</span> - <span class="dv">1</span>) <span class="cf">if</span> (<span class="fu">__builtin_popcount</span>(i) == k) buc.emplace_back(i);</span>
<span id="cb11-31"><a aria-hidden="true" href="#cb11-31"></a>    sort(q + <span class="dv">1</span>, q + m + <span class="dv">1</span>, [](<span class="at">const</span> Query &amp;a, <span class="at">const</span> Query &amp;b) {<span class="cf">return</span> (bl[a.l] == bl[b.l]) ? a.r &lt; b.r : a.l &lt; b.l;});</span>
<span id="cb11-32"><a aria-hidden="true" href="#cb11-32"></a>    FOR(i, <span class="dv">1</span>, n) {</span>
<span id="cb11-33"><a aria-hidden="true" href="#cb11-33"></a>        <span class="cf">for</span> (<span class="kw">auto</span> &amp;x : buc) ++t[a[i] ^ x];</span>
<span id="cb11-34"><a aria-hidden="true" href="#cb11-34"></a>        pre[i] = t[a[i + <span class="dv">1</span>]]; <span class="co">// 预处理 F(i+1,i)</span></span>
<span id="cb11-35"><a aria-hidden="true" href="#cb11-35"></a>    }</span>
<span id="cb11-36"><a aria-hidden="true" href="#cb11-36"></a>    memset(t, <span class="dv">0</span>, <span class="kw">sizeof</span> t);</span>
<span id="cb11-37"><a aria-hidden="true" href="#cb11-37"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>, l = <span class="dv">1</span>, r = <span class="dv">0</span>; i &lt;= m; ++i) {</span>
<span id="cb11-38"><a aria-hidden="true" href="#cb11-38"></a>        <span class="cf">if</span> (r &lt; q[i].r) v[l - <span class="dv">1</span>].emplace_back(r + <span class="dv">1</span>, q[i].r, -i);</span>
<span id="cb11-39"><a aria-hidden="true" href="#cb11-39"></a>        <span class="cf">while</span> (r &lt; q[i].r) ans[q[i].id] += pre[r++];</span>
<span id="cb11-40"><a aria-hidden="true" href="#cb11-40"></a>        <span class="cf">if</span> (l &gt; q[i].l) v[r].emplace_back(q[i].l, l - <span class="dv">1</span>, i);</span>
<span id="cb11-41"><a aria-hidden="true" href="#cb11-41"></a>        <span class="cf">while</span> (l &gt; q[i].l) ans[q[i].id] -= pre[l-- - <span class="dv">2</span>];</span>
<span id="cb11-42"><a aria-hidden="true" href="#cb11-42"></a>        <span class="cf">if</span> (r &gt; q[i].r) v[l - <span class="dv">1</span>].emplace_back(q[i].r + <span class="dv">1</span>, r, i);</span>
<span id="cb11-43"><a aria-hidden="true" href="#cb11-43"></a>        <span class="cf">while</span> (r &gt; q[i].r) ans[q[i].id] -= pre[r-- - <span class="dv">1</span>];</span>
<span id="cb11-44"><a aria-hidden="true" href="#cb11-44"></a>        <span class="cf">if</span> (l &lt; q[i].l) v[r].emplace_back(l, q[i].l - <span class="dv">1</span>, -i);</span>
<span id="cb11-45"><a aria-hidden="true" href="#cb11-45"></a>        <span class="cf">while</span> (l &lt; q[i].l) ans[q[i].id] += pre[l++ - <span class="dv">1</span>];</span>
<span id="cb11-46"><a aria-hidden="true" href="#cb11-46"></a>    }</span>
<span id="cb11-47"><a aria-hidden="true" href="#cb11-47"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>, l, r, id; i &lt;= n; ++i) {</span>
<span id="cb11-48"><a aria-hidden="true" href="#cb11-48"></a>        <span class="cf">for</span> (<span class="kw">auto</span> &amp;x : buc) ++t[a[i] ^ x];</span>
<span id="cb11-49"><a aria-hidden="true" href="#cb11-49"></a>        <span class="cf">for</span> (<span class="at">const</span> <span class="kw">auto</span> &amp;x : v[i]) {</span>
<span id="cb11-50"><a aria-hidden="true" href="#cb11-50"></a>            l = x.l, r = x.r, id = x.id;</span>
<span id="cb11-51"><a aria-hidden="true" href="#cb11-51"></a>            <span class="cf">for</span> (<span class="dt">int</span> j = l, tmp = <span class="dv">0</span>; j &lt;= r; ++j) {</span>
<span id="cb11-52"><a aria-hidden="true" href="#cb11-52"></a>                tmp = t[a[j]];</span>
<span id="cb11-53"><a aria-hidden="true" href="#cb11-53"></a>                <span class="cf">if</span> (j &lt;= i &amp;&amp; k == <span class="dv">0</span>) --tmp; <span class="co">// 特判 k=0 的时候产生的贡献</span></span>
<span id="cb11-54"><a aria-hidden="true" href="#cb11-54"></a>                <span class="cf">if</span> (id &lt; <span class="dv">0</span>) ans[q[-id].id] -= tmp;</span>
<span id="cb11-55"><a aria-hidden="true" href="#cb11-55"></a>                <span class="cf">else</span> ans[q[id].id] += tmp;</span>
<span id="cb11-56"><a aria-hidden="true" href="#cb11-56"></a>            }</span>
<span id="cb11-57"><a aria-hidden="true" href="#cb11-57"></a>        }</span>
<span id="cb11-58"><a aria-hidden="true" href="#cb11-58"></a>    }</span>
<span id="cb11-59"><a aria-hidden="true" href="#cb11-59"></a>    FOR(i, <span class="dv">1</span>, m) ans[q[i].id] += ans[q[i - <span class="dv">1</span>].id]; <span class="co">// 注意最后要做前缀和</span></span>
<span id="cb11-60"><a aria-hidden="true" href="#cb11-60"></a>    FOR(i, <span class="dv">1</span>, m) os &lt;&lt; ans[i] &lt;&lt; <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span>;</span>
<span id="cb11-61"><a aria-hidden="true" href="#cb11-61"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb11-62"><a aria-hidden="true" href="#cb11-62"></a>}</span></code></pre></div>
<h3 id="综合应用">综合应用</h3>
<blockquote>
<p><a href="https://www.luogu.com.cn/problem/solution/CF940F">CF940F Machine Learning</a></p>
<p>给定序列，单点修改，区间查询每个数字出现次数的 <span class="math inline">\(\mathrm{mex}\)</span>。</p>
</blockquote>
<p>“每个数字出现次数的 <span class="math inline">\(\mathrm{mex}\)</span>”是 <span class="math inline">\(O(\sqrt n)\)</span> 级别的，考虑到如果答案为 <span class="math inline">\(x\)</span>，那么出现次数为 <span class="math inline">\([1,x - 1]\)</span> 的数都要有。所以对于每个询问我们大可以直接暴力查 <span class="math inline">\(\mathrm{mex}\)</span>，带修莫队时间复杂度为 <span class="math inline">\(O(n^{5/3})\)</span>。</p>
<blockquote>
<p><a href="https://www.luogu.com.cn/problem/P3674">P3674 小清新人渣的本愿</a></p>
<p>长度为 <span class="math inline">\(n\)</span> 的序列，<span class="math inline">\(m\)</span> 次查询一个区间是否可以选出两个数（可以在同一位置）使得差/积/和为 <span class="math inline">\(x\)</span>。</p>
</blockquote>
<p>考虑在莫队的过程中维护一个 <code>bitset</code>，然后差为 <span class="math inline">\(x\)</span> 本质上就是需要存在 <span class="math inline">\(a=b+x\)</span>，所以判断 <code>s &amp; (s &lt;&lt; x)</code> 是否有 <span class="math inline">\(1\)</span> 即可。和为 <span class="math inline">\(x\)</span> 即为 <span class="math inline">\(a+b=x\)</span>，维护一下 <span class="math inline">\(N-x\)</span> 是否存在即可。积的话直接 <span class="math inline">\(O(\sqrt x)\)</span> 枚举约数就过得去了。<span class="math inline">\(O(nm/w)\)</span>。</p>
<blockquote>
<p><a href="https://www.luogu.com.cn/problem/P3604">P3604 美好的每一天</a></p>
<p>给定小写字符串，区间询问该区间内有多少子区间，满足其字符能否重排形成回文串。数据范围 <span class="math inline">\(60000\)</span>。</p>
</blockquote>
<p>不难发现等价于该区间内至多有一个出现奇数次的字符时，区间合法。字符集 <span class="math inline">\(26\)</span>，转成 <span class="math inline">\(2^i\)</span>，发现就是区间内的异或起来之后得到 <span class="math inline">\(2^i\)</span> 才合法。</p>
<p>所以我们先做一遍前缀和，然后就是问区间内多少对异或起来能得到 <span class="math inline">\(2^i\)</span>，这个东西可以直接上莫队，时间复杂度 <span class="math inline">\(O(n\sqrt m\Sigma)\)</span>，其中 <span class="math inline">\(\Sigma\)</span> 为字符集。</p>
<blockquote>
<p><a href="https://www.luogu.com.cn/problem/P3709">P3709 大爷的字符串题</a></p>
<p>给你一个字符串 <span class="math inline">\(a\)</span>，每次询问一段区间的贡献。贡献定义：</p>
<p>每次从这个区间中拿出一个字符 <span class="math inline">\(x\)</span> ，然后把 <span class="math inline">\(x\)</span> 从这个区间中删除，直到区间为空。你要维护一个集合 <span class="math inline">\(S\)</span>。</p>
<ul>
<li>如果 <span class="math inline">\(S\)</span> 为空，你 rp 减 <span class="math inline">\(1\)</span>。</li>
<li>如果 <span class="math inline">\(S\)</span> 中有一个元素不小于 <span class="math inline">\(x\)</span>，则你 rp 减 <span class="math inline">\(1\)</span>，清空 <span class="math inline">\(S\)</span>。</li>
<li>之后将 <span class="math inline">\(x\)</span> 插入 <span class="math inline">\(S\)</span>。</li>
</ul>
<p>其贡献定义为你最多还剩多少 rp，初始 rp 为 <span class="math inline">\(0\)</span>，询问间互不影响。</p>
</blockquote>
<p>读题难度比较大。手玩一下发现就是每次取一个严格上升的序列，问最少取几次。那么也就是问的是区间众数的出现次数，发现我们扩展区间的时候可以很方便地维护答案，那么就上回滚莫队就行了。</p>
<blockquote>
<p>P8078 [WC2022] 秃子酋长</p>
<p>给一个长为 <span class="math inline">\(n\)</span> 的排列 <span class="math inline">\(a_1,\dots, a_n\)</span>，有 <span class="math inline">\(m\)</span> 次询问，每次询问区间 <span class="math inline">\([l, r]\)</span> 内，排序后相邻的数在原序列中的位置的差的绝对值之和。满足 <span class="math inline">\(1 \leq n, m \leq 5\times 10^5\)</span>，<span class="math inline">\(1 \leq a_i \leq n\)</span>，<span class="math inline">\(a_i\)</span> 互不相同，<span class="math inline">\(1 \leq l \leq r \leq n\)</span>，所有数值为整数。</p>
</blockquote>
<p>本题的 polylog 做法不在此处说明。用 <code>std::set</code> 维护的莫队可以做到 <span class="math inline">\(O(n\sqrt m\log n)\)</span>，很难跑的过去。</p>
<p>发现加点时维护前驱/后继是没法丢掉那个 <span class="math inline">\(\log\)</span> 的，考虑另辟蹊径。发现我们实际上需要的就是前驱和后继的信息，这个东西我们可以使用链表维护，支持 <span class="math inline">\(O(1)\)</span> 删除。那么就做一下不删除的回滚莫队即可。</p>
<p>具体地，我们可以通过逆排列将最初 <span class="math inline">\([l,r]\)</span> 的状态处理出来，然后每次 <span class="math inline">\(O(1)\)</span> 删除并计算贡献即可，回滚就正常回滚。</p>
<blockquote>
<p><a href="https://www.luogu.com.cn/problem/CF1479D">CF1479D Odd Mineral Resource</a></p>
<p>给定一棵树，每个点有颜色 <span class="math inline">\(c_i\)</span>。多次查询，给定 <span class="math inline">\(u,v,l,r\)</span>，求一个颜色 <span class="math inline">\(x\)</span> 使得 <span class="math inline">\(x\in[l,r]\)</span> 且 <span class="math inline">\(x\)</span> 在路径 <span class="math inline">\((u,v)\)</span> 上出现了奇数次。数据范围 <span class="math inline">\(3\times 10^5\)</span>，5s。</p>
</blockquote>
<p>更神奇的 polylog 做法看<a href="">这里</a>。考虑树上莫队，对颜色进行值域分块，每块维护块内出现次数为奇数的数的个数。修改的时候若其出现次数是奇数了，就直接把它扔进块里面去，查询的时候对整块扫描里面可能成为答案的 <span class="math inline">\(x\)</span>，不合法就删掉，合法就直接输出，时间复杂度均摊下来是对的，<span class="math inline">\(O(n\sqrt m + m\sqrt n)\)</span>，当然存在 <span class="math inline">\(O((n+q)\log n)\)</span> 的高妙随机化做法，此处不表。</p>
<blockquote>
<p><a href="https://www.luogu.com.cn/problem/P5047">P5047 [Ynoi2019 模拟赛] Yuno loves sqrt technology II</a></p>
<p>区间逆序对，允许离线。250ms，31.25MB。</p>
</blockquote>
<p>以下视 <span class="math inline">\(n,m\)</span> 同阶。首先大家都知道可以使用树状数组，但是 <span class="math inline">\(O(n\sqrt n\log n)\)</span> 必然过不去。</p>
<p>此时一个数字的贡献与区间内大于/小于它的数的个数有关，其明显满足可减性，考虑莫二离。</p>
<p>但是这个时候需要注意，右端点改变时，对答案产生变化的是区间内大于它的数的个数，对于左端点移动，是小于它的数的个数。然后使用值域分块进行平衡复杂度（<span class="math inline">\(O(\sqrt n)\)</span> 插入，<span class="math inline">\(O(1)\)</span> 查询），最终复杂度 <span class="math inline">\(O(n\sqrt n)\)</span>。顺便纪念一下 AC 1.3k。</p>
<h2 id="根号分治">根号分治</h2>
<p>同样是根号平衡思想的应用，本质是按大小分类讨论。</p>
<p>对于规模为 <span class="math inline">\(x\)</span> 的问题，若我们能在 <span class="math inline">\(O(x)\)</span> 和 <span class="math inline">\(O(n/x)\)</span> 的时间内解决，可以设定一个阈值 <span class="math inline">\(B\)</span>，当 <span class="math inline">\(x\le B\)</span> 的时候采用 <span class="math inline">\(O(x)\)</span> 的算法，<span class="math inline">\(x&gt;B\)</span> 的时候采用 <span class="math inline">\(O(n/x)\)</span> 的算法，这样在 <span class="math inline">\(B=\sqrt n\)</span> 的时候能达到 <span class="math inline">\(O(q\sqrt n)\)</span> 的最优时间复杂度。</p>
<p>一般地，对于 <span class="math inline">\(x\le \sqrt n\)</span> 的情况我们采用<strong>预处理</strong>的方法，相当于在预处理和查询中间平衡复杂度。</p>
<p>小技巧：根号分治的题目调试时可以考虑令 <span class="math inline">\(B = 1\)</span>。</p>
<h3 id="常见根号模型">常见根号模型</h3>
<h3 id="应用">应用</h3>
<blockquote>
<p>例题：<a href="https://www.luogu.com.cn/problem/P3396">P3396 哈希冲突</a></p>
<p>给定一个序列 <span class="math inline">\(a\)</span>，带修，询问 <span class="math inline">\(\sum\limits_{i=1}^na_i[i\bmod p = x]\)</span>。数据范围 <span class="math inline">\(1.5\times 10^5\)</span>，值域 <span class="math inline">\([1, 1000]\)</span>。</p>
</blockquote>
<p>对于 <span class="math inline">\(p&gt;\sqrt n\)</span> 的情况，显然最多只有 <span class="math inline">\(O(\sqrt n)\)</span> 个下标 <span class="math inline">\(i\)</span> 满足 <span class="math inline">\(i\bmod p = x\)</span>。这部分大可直接暴力。</p>
<p>对于 <span class="math inline">\(p\le \sqrt n\)</span> 的情况，维护个 <span class="math inline">\(f_{i,p}\)</span> 之类的东西就行了，<span class="math inline">\(O(1)\)</span> 回答，<span class="math inline">\(O(\sqrt n)\)</span> 修改。</p>
<p>总时间复杂度 <span class="math inline">\(O(n\sqrt n)\)</span>。</p>
<blockquote>
<p>例题：<a href="https://www.luogu.com.cn/problem/CF797E">CF797E Array Queries</a></p>
<ul>
<li>给定长度为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(a\)</span>。<span class="math inline">\(m\)</span> 次询问。</li>
<li>每次询问给出 <span class="math inline">\(p,k\)</span>。您要不断地执行操作 <span class="math inline">\(p\gets p+a_p+k\)</span>，直到 <span class="math inline">\(p&gt;n\)</span> 为止。询问的答案为操作次数。</li>
<li><span class="math inline">\(1\le n,q\le 10^5\)</span>，<span class="math inline">\(1\le a_i\le n\)</span>，<span class="math inline">\(1\le p,k\le n\)</span>。</li>
</ul>
</blockquote>
<p>当 <span class="math inline">\(k&gt;\sqrt n\)</span> 的时候，答案必然是 <span class="math inline">\(\le \sqrt n\)</span> 的，所以对于 <span class="math inline">\(k&gt;\sqrt n\)</span> 的时候可以直接暴力。而我们可以预处理 <span class="math inline">\(k\le\sqrt n\)</span> 的答案，这样就得到了 <span class="math inline">\(O(q\sqrt n)\)</span> 的复杂度。</p>
<blockquote>
<p>例题：<a href="https://www.luogu.com.cn/problem/CF1039D">CF1039D You Are Given a Tree</a></p>
<p><span class="math inline">\(n\le 10^5\)</span> 节点的树，称一个简单路径的集合为 <span class="math inline">\(k\)</span> 合法的，当且仅当其由若干条长度为 <span class="math inline">\(k\)</span> 的不交路径构成。</p>
<p>对于 <span class="math inline">\(k\in[1,n]\)</span> 求出 <span class="math inline">\(k\)</span> 合法路径集合的最大大小。</p>
</blockquote>
<p>容易发现，当 <span class="math inline">\(k&gt;B\)</span> 的时候答案一定 <span class="math inline">\(&lt;n / B\)</span>，对于这部分我们可以 <span class="math inline">\(O(n/B)\)</span> 枚举答案然后二分 <span class="math inline">\(k\)</span> 的取值区间，而对于 <span class="math inline">\(k\le B\)</span> 的时候直接 <span class="math inline">\(O(n)\)</span> 树形 dp 即可。</p>
<p>总时间复杂度 <span class="math inline">\(O(nB + n^2/B\log n)\)</span>，取 <span class="math inline">\(B = \sqrt{n\log n}\)</span> 得到最优时间复杂度 <span class="math inline">\(O(n\sqrt{n\log n})\)</span>。</p>
<p>dp 的时候，维护一下 <span class="math inline">\(f_u\)</span> 表示往上窜的最长零头，对于两个儿子 <span class="math inline">\(v_1\)</span> 和 <span class="math inline">\(v_2\)</span> 若有 <span class="math inline">\(f_{v_1} + f_{v_2} + 1\ge k\)</span> 那么就把他们两个拼成一条链，<span class="math inline">\(f_u = 0\)</span>，否则 <span class="math inline">\(f_u = \max\{f_{v_1}\} +1\)</span>。</p>
<blockquote>
<p>例题：<a href="https://www.luogu.com.cn/problem/CF506D">CF506D Mr. Kitayuta’s Colorful Graph</a></p>
<p>给出一个 <span class="math inline">\(n\)</span> 个点，<span class="math inline">\(m\)</span> 条边的无向图，每条边上是有颜色的。有 <span class="math inline">\(q\)</span> 组询问。对于第 <span class="math inline">\(i\)</span> 组询问，给出点对 <span class="math inline">\(u_i,v_i\)</span>， 求有多少种颜色 <span class="math inline">\(c\)</span>，满足存在至少一条从 <span class="math inline">\(u_i\)</span> 到 <span class="math inline">\(v_i\)</span> 的路径，使得该路径上的所有边的颜色均为 <span class="math inline">\(c\)</span>。<span class="math inline">\(2 \le n \le 10^5\)</span>，<span class="math inline">\(1 \le m,q \le 10^5\)</span>，<span class="math inline">\(1 \le c_i \le m\)</span>。</p>
</blockquote>
<p>先思考一个比较蠢的能针对单个颜色的做法：对于一种颜色 <span class="math inline">\(c\)</span>，将所有颜色为 <span class="math inline">\(c\)</span> 的边在并查集里面连起来，然后对询问直接累加。</p>
<p>但是此时我们发现，出现次数 <span class="math inline">\(&gt;\sqrt m\)</span> 的颜色只有 <span class="math inline">\(O(\sqrt m)\)</span> 级别。那么对于这些颜色，我们可以直接 <span class="math inline">\(O(m\log n)\)</span> 带走，这部分的时间复杂度是 <span class="math inline">\(O((m\sqrt m + q)\log n)\)</span>。</p>
<p>而对于出现次数 <span class="math inline">\(&lt;\sqrt m\)</span> 的颜色，将这些边连成图后，图的大小不会超过 <span class="math inline">\(O(\sqrt m)\)</span>，相应地总的点对数量也在 <span class="math inline">\(O(m\sqrt m)\)</span> 之间，对于这部分的所有点对直接用 <code>map</code> 统计贡献，最后扫一遍询问进行累加。<del>哈cuocuo的每次 <span class="math inline">\(O(n)\)</span> 清空并查集的复杂度是不对的不对的不对的。</del></p>
<h2 id="树分块">树分块</h2>
<p>随机撒 <span class="math inline">\(n/B\)</span> 个点，保证每个点到其最近的关键点祖先距离不超过 <span class="math inline">\(B\)</span>，预处理关键点对间的信息，以得到答案。</p>
<p>给出一种撒点方法：每次选深度最大的非关键点，若其 <span class="math inline">\(1\sim B\)</span> 级祖先没有关键点，则令其 <span class="math inline">\(B\)</span> 级祖先为关键点。这样保证了每个点到关键点祖先距离的限制，而且没标记一个点，都有 <span class="math inline">\(B\)</span> 个点不会成为关键点，所以 <span class="math inline">\(n/B\)</span> 个点的限制也被满足。</p>
<blockquote>
<p>例题：<a href="https://www.luogu.com.cn/problem/P6177">P6177 Count on a tree II/【模板】树分块</a></p>
<p>链数颜色，<span class="math inline">\(n\le 4\times 10^4\)</span>，<span class="math inline">\(m\le 10^5\)</span>，<strong>强制在线</strong>。</p>
</blockquote>
<p>发现强制在线不能拿莫队混过去了，考虑使用 <code>bitset</code>。</p>
<p>对于一条到根路径上的所有关键点，<span class="math inline">\(x_1,\cdots,x_k\)</span>，考虑维护出其两两之间路径的 <code>bitset</code>，先对于每对相邻点 <span class="math inline">\(O(B)\)</span> 求出其 <code>bitset</code>，然后再递推出两两之间的，这样的时间复杂度是 <span class="math inline">\(O(n^2/B + n^3/wB^2)\)</span>。</p>
<p>求解答案的时候，令 <span class="math inline">\(t = \operatorname{LCA}(u,v)\)</span>，求出 <span class="math inline">\(u,v\)</span> 祖先中离各自最近的关键点 <span class="math inline">\(u_0,v_0\)</span>，以及离 <span class="math inline">\(t\)</span> 最近但在 <span class="math inline">\(t\)</span> 子树内的关键点 <span class="math inline">\(u_1,v_1\)</span>，于是这样的路径就被拆成了 <span class="math inline">\(u\to u_0\to u_1\to t\to v_1\to v_0\to v\)</span>。<span class="math inline">\(u_0\to u_1\)</span> 和 <span class="math inline">\(v_1\to v_0\)</span> 的部分我们已经预处理好了，剩下四部分暴力即可。</p>
<p>总时间复杂度 <span class="math inline">\(O(n^2/B + n^3/wB^2 + nm/w + mB)\)</span>，取 <span class="math inline">\(B =\sqrt n\)</span> 得到总时间复杂度 <span class="math inline">\(O\left((n+m)\sqrt n + \dfrac{n^2+nm}{w}\right)\)</span>。空间复杂度 <span class="math inline">\(O(n^3/B^2) = O(n^2)\)</span>。适当调大 <span class="math inline">\(B\)</span>，空间平方缩小，时间线性增加。</p>
<p><strong>坑点：<code>bitset</code> 的 <code>|</code> 运算生成的新的 <code>bitset</code> 不会立马销毁，不会立马销毁，请使用 <code>|=</code></strong>。</p>
<h2 id="references">References</h2>
<ul>
<li>lxl 的 PPT。</li>
</ul>
</section>
<footer class="article-footer">
<section class="article-tags">
<a href="/tags/OI/">OI</a>
<a href="/tags/note/">笔记</a>
</section>
<section class="article-copyright">
<svg class="icon icon-tabler icon-tabler-copyright" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<circle cx="12" cy="12" r="9"></circle>
<path d="M14.5 9a3.5 4 0 1 0 0 6"></path>
</svg>
<span>Licensed under CC BY-NC-SA 4.0</span>
</section>
</footer>
<link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css" integrity="sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn" rel="stylesheet"/><script crossorigin="anonymous" defer="" integrity="sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8" src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js">
</script><script crossorigin="anonymous" defer="" integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js">
</script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.querySelector(`.article-content`), {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ]
        });})
</script>
</article>
<aside class="related-contents--wrapper">
<h2 class="section-title">相关文章</h2>
<div class="related-contents">
<div class="flex article-list--tile">
<article class="has-image">
<a href="/note-gf/">
<div class="article-image">
<img data-hash="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg28.webp" data-key="" loading="lazy" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg28.webp"/>
</div>
<div class="article-details">
<h2 class="article-title">生成函数胡扯</h2>
</div>
</a>
</article>
<article class="has-image">
<a href="/note-set-power-series/">
<div class="article-image">
<img data-hash="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg39.webp" data-key="" loading="lazy" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg39.webp"/>
</div>
<div class="article-details">
<h2 class="article-title">集合幂级数胡扯</h2>
</div>
</a>
</article>
<article class="has-image">
<a href="/note-linear-basis/">
<div class="article-image">
<img data-hash="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg19.webp" data-key="" loading="lazy" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg19.webp"/>
</div>
<div class="article-details">
<h2 class="article-title">线性基学习笔记</h2>
</div>
</a>
</article>
<article class="has-image">
<a href="/note-wqs/">
<div class="article-image">
<img data-hash="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg28.webp" data-key="" loading="lazy" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg28.webp"/>
</div>
<div class="article-details">
<h2 class="article-title">wqs 二分学习笔记</h2>
</div>
</a>
</article>
<article class="has-image">
<a href="/note-builtin/">
<div class="article-image">
<img data-hash="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg9.webp" data-key="" loading="lazy" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg9.webp"/>
</div>
<div class="article-details">
<h2 class="article-title">__builtin 系列函数总结</h2>
</div>
</a>
</article>
</div>
</div>
</aside>
<footer class="site-footer">
<section class="copyright">
        © 
        
            2019 - 
        
        2024 清烛的博客
    </section>
<section class="powerby">
        Built with <a href="https://gohugo.io/" rel="noopener" target="_blank">Hugo</a> <br/>
        主题 <b><a data-version="3.11.0" href="https://github.com/CaiJimmy/hugo-theme-stack" rel="noopener" target="_blank">Stack</a></b> 由 <a href="https://jimmycai.com" rel="noopener" target="_blank">Jimmy</a> 设计
    </section>
</footer>
<div aria-hidden="true" class="pswp" role="dialog" tabindex="-1">
<div class="pswp__bg"></div>
<div class="pswp__scroll-wrap">
<div class="pswp__container">
<div class="pswp__item"></div>
<div class="pswp__item"></div>
<div class="pswp__item"></div>
</div>
<div class="pswp__ui pswp__ui--hidden">
<div class="pswp__top-bar">
<div class="pswp__counter"></div>
<button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title="Share"></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
<div class="pswp__preloader">
<div class="pswp__preloader__icn">
<div class="pswp__preloader__cut">
<div class="pswp__preloader__donut"></div>
</div>
</div>
</div>
</div>
<div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
<div class="pswp__share-tooltip"></div>
</div>
<button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
</button>
<div class="pswp__caption">
<div class="pswp__caption__center"></div>
</div>
</div>
</div>
</div><script crossorigin="anonymous" defer="" integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js">
</script><script crossorigin="anonymous" defer="" integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js">
</script><link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css" integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" rel="stylesheet"/><link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css" integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" rel="stylesheet"/>
</main>
</div>
<script crossorigin="anonymous" integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js">
</script><script defer="" src="/ts/main.js" type="text/javascript"></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>
</body>
</html>

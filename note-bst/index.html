<!DOCTYPE html>
<html dir="ltr" lang="zh-CN">
<head><meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/><meta content="二叉搜索树(BST) BST 是一种常用的数据结构，每个节点储存着一个可以比较大小的权值，并且其满足如下性质：对于任意节点 \(u\)，其左子树（如果存在）内所有节点的权值均小于 \(u\) 的权值，其右子树（如果存在）内所有节点的权值均大于 \(u\) 的权值。
不难发现这棵树可以做很多事情：这棵树的中序遍历就是排好序的序列，并且可以很方便的进行插入删除和查找操作（只需层层递归即可），同时可以统计一个元素的排名（只需看左边有多少节点）。
然而，如果插入的序列是一个递增的序列，则 BST 的复杂度可以退化到 \(O(n)\)，这样的话查找一个元素的复杂度和在线性表内查找就没有什么区别了，需要进行优化。
不难发现，对于一个集合，如果我们将他建构成一棵 BST，可以有很多情况，而很明显地：左右平衡的结构是相对比较优的，这样子的话操作的期望复杂度为 \(O(\log n)\)，达到了我们的目的。
下面学习一些比较常用的可以使 BST 平衡的手法
Treap 简介 Treap=Tree+Heap，是一种相对好写的平衡 BST（简称平衡树），从其命名可以看出来它是一个堆（Heap) 与 BST（Tree）的结合体。
Treap 有如下性质：
是一棵关于元素值 val 的 BST 是关于权值 priority（一般是随机的）的堆（小根大根没什么区别） val 和 priority 确定时，Treap 唯一 这样随机给元素分配权值可以使得 Treap 不容易退化成链，使查找/插入/删除/第 \(k\) 大/排名的操作都是 \(O(\log n)\) 的。
Initialization 首先是 Treap 的数组形式定义（指针太难写了而且容易出奇奇怪怪的 bug）
struct treap { int ch[2];//存储左/右儿子的编号 int cnt,size;//存储当前元素的数量和子树大小 int val,p;//val为元素值，p为随机权值 }t[maxn]; 下面操作类似于线段树的 pushup，主要是下面信息改变后维护子树大小用
#define L t[u].ch[0] #define R t[u].ch[1] inline void maintain(int u) { t[u]." name="description"/><title>平衡树笔记</title>
<link href="https://oi.imyangty.com/note-bst/" rel="canonical"/>
<link href="/scss/style.min.a5821f3d3ab84ce5a0ac21477e347a2e0ca00292e398d16c5e8e36ded6e35a23.css" rel="stylesheet"/><meta content="平衡树笔记" property="og:title"/>
<meta content="二叉搜索树(BST) BST 是一种常用的数据结构，每个节点储存着一个可以比较大小的权值，并且其满足如下性质：对于任意节点 \(u\)，其左子树（如果存在）内所有节点的权值均小于 \(u\) 的权值，其右子树（如果存在）内所有节点的权值均大于 \(u\) 的权值。
不难发现这棵树可以做很多事情：这棵树的中序遍历就是排好序的序列，并且可以很方便的进行插入删除和查找操作（只需层层递归即可），同时可以统计一个元素的排名（只需看左边有多少节点）。
然而，如果插入的序列是一个递增的序列，则 BST 的复杂度可以退化到 \(O(n)\)，这样的话查找一个元素的复杂度和在线性表内查找就没有什么区别了，需要进行优化。
不难发现，对于一个集合，如果我们将他建构成一棵 BST，可以有很多情况，而很明显地：左右平衡的结构是相对比较优的，这样子的话操作的期望复杂度为 \(O(\log n)\)，达到了我们的目的。
下面学习一些比较常用的可以使 BST 平衡的手法
Treap 简介 Treap=Tree+Heap，是一种相对好写的平衡 BST（简称平衡树），从其命名可以看出来它是一个堆（Heap) 与 BST（Tree）的结合体。
Treap 有如下性质：
是一棵关于元素值 val 的 BST 是关于权值 priority（一般是随机的）的堆（小根大根没什么区别） val 和 priority 确定时，Treap 唯一 这样随机给元素分配权值可以使得 Treap 不容易退化成链，使查找/插入/删除/第 \(k\) 大/排名的操作都是 \(O(\log n)\) 的。
Initialization 首先是 Treap 的数组形式定义（指针太难写了而且容易出奇奇怪怪的 bug）
struct treap { int ch[2];//存储左/右儿子的编号 int cnt,size;//存储当前元素的数量和子树大小 int val,p;//val为元素值，p为随机权值 }t[maxn]; 下面操作类似于线段树的 pushup，主要是下面信息改变后维护子树大小用
#define L t[u].ch[0] #define R t[u].ch[1] inline void maintain(int u) { t[u]." property="og:description"/>
<meta content="https://oi.imyangty.com/note-bst/" property="og:url"/>
<meta content="清烛的博客" property="og:site_name"/>
<meta content="article" property="og:type"/><meta content="Post" property="article:section"/><meta content="OI" property="article:tag"/><meta content="笔记" property="article:tag"/><meta content="平衡树" property="article:tag"/><meta content="2020-12-12T14:20:29+08:00" property="article:published_time"/><meta content="2020-12-12T14:20:29+08:00" property="article:modified_time"/><meta content="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg8.webp" property="og:image"/>
<meta content="平衡树笔记" name="twitter:title"/>
<meta content="二叉搜索树(BST) BST 是一种常用的数据结构，每个节点储存着一个可以比较大小的权值，并且其满足如下性质：对于任意节点 \(u\)，其左子树（如果存在）内所有节点的权值均小于 \(u\) 的权值，其右子树（如果存在）内所有节点的权值均大于 \(u\) 的权值。
不难发现这棵树可以做很多事情：这棵树的中序遍历就是排好序的序列，并且可以很方便的进行插入删除和查找操作（只需层层递归即可），同时可以统计一个元素的排名（只需看左边有多少节点）。
然而，如果插入的序列是一个递增的序列，则 BST 的复杂度可以退化到 \(O(n)\)，这样的话查找一个元素的复杂度和在线性表内查找就没有什么区别了，需要进行优化。
不难发现，对于一个集合，如果我们将他建构成一棵 BST，可以有很多情况，而很明显地：左右平衡的结构是相对比较优的，这样子的话操作的期望复杂度为 \(O(\log n)\)，达到了我们的目的。
下面学习一些比较常用的可以使 BST 平衡的手法
Treap 简介 Treap=Tree+Heap，是一种相对好写的平衡 BST（简称平衡树），从其命名可以看出来它是一个堆（Heap) 与 BST（Tree）的结合体。
Treap 有如下性质：
是一棵关于元素值 val 的 BST 是关于权值 priority（一般是随机的）的堆（小根大根没什么区别） val 和 priority 确定时，Treap 唯一 这样随机给元素分配权值可以使得 Treap 不容易退化成链，使查找/插入/删除/第 \(k\) 大/排名的操作都是 \(O(\log n)\) 的。
Initialization 首先是 Treap 的数组形式定义（指针太难写了而且容易出奇奇怪怪的 bug）
struct treap { int ch[2];//存储左/右儿子的编号 int cnt,size;//存储当前元素的数量和子树大小 int val,p;//val为元素值，p为随机权值 }t[maxn]; 下面操作类似于线段树的 pushup，主要是下面信息改变后维护子树大小用
#define L t[u].ch[0] #define R t[u].ch[1] inline void maintain(int u) { t[u]." name="twitter:description"/><meta content="summary_large_image" name="twitter:card"/>
<meta content="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg8.webp" name="twitter:image"/>
<link href="https://q1.qlogo.cn/g?b=qq&amp;nk=375836877&amp;s=5" rel="shortcut icon"/>
<link href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/styles/github-dark-dimmed.min.css" rel="stylesheet"/>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
</head>
<body class="article-page">
<script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky">
<button aria-label="切换菜单" class="hamburger hamburger--spin" id="toggle-menu" type="button">
<span class="hamburger-box">
<span class="hamburger-inner"></span>
</span>
</button>
<header>
<figure class="site-avatar">
<a href="/">
<img alt="Avatar" class="site-logo" height="300" loading="lazy" src="/img/avatar_huea3ce2119467b51fdd2a81393644a76d_51594_300x0_resize_q75_box.jpg" width="300"/>
</a>
<span class="emoji">😅</span>
</figure>
<div class="site-meta">
<h1 class="site-name"><a href="/">清烛的博客</a></h1>
<h2 class="site-description">烟火已谢，笙歌未停</h2>
</div>
</header><ol class="social-menu">
<li>
<a href="mailto:i@imyangty.com" target="_blank" title="email">
<svg class="icon icon-tabler icon-tabler-mail" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
<rect height="14" rx="2" width="18" x="3" y="5"></rect>
<polyline points="3 7 12 13 21 7"></polyline>
</svg>
</a>
</li>
<li>
<a href="https://github.com/Cgfyufsygsm" target="_blank" title="GitHub">
<svg class="icon icon-tabler icon-tabler-brand-github" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
<path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5"></path>
</svg>
</a>
</li>
<li>
<a href="https://t.me/Cgfyufsygsm" target="_blank" title="Telegram">
<svg class="icon icon-tabler icon-tabler-brand-telegram" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
<path d="M15 10l-4 4l6 6l4 -16l-18 7l4 2l2 6l3 -4"></path>
</svg>
</a>
</li>
<li>
<a href="https://twitter.com/Cgfyufsygsm" target="_blank" title="Twitter">
<svg class="icon icon-tabler icon-tabler-brand-twitter" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
<path d="M22 4.01c-1 .49 -1.98 .689 -3 .99c-1.121 -1.265 -2.783 -1.335 -4.38 -.737s-2.643 2.06 -2.62 3.737v1c-3.245 .083 -6.135 -1.395 -8 -4c0 0 -4.182 7.433 4 11c-1.872 1.247 -3.739 2.088 -6 2c3.308 1.803 6.913 2.423 10.034 1.517c3.58 -1.04 6.522 -3.723 7.651 -7.742a13.84 13.84 0 0 0 .497 -3.753c-.002 -.249 1.51 -2.772 1.818 -4.013z"></path>
</svg>
</a>
</li>
</ol><ol class="menu" id="main-menu">
<li>
<a href="/">
<svg class="icon icon-tabler icon-tabler-home" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<polyline points="5 12 3 12 12 3 21 12 19 12"></polyline>
<path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7"></path>
<path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6"></path>
</svg>
<span>主页</span>
</a>
</li>
<li>
<a href="/about/">
<svg class="icon icon-tabler icon-tabler-user" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<circle cx="12" cy="7" r="4"></circle>
<path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2"></path>
</svg>
<span>关于</span>
</a>
</li>
<li>
<a href="/idx/">
<svg class="icon icon-tabler icon-tabler-hash" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<line x1="5" x2="19" y1="9" y2="9"></line>
<line x1="5" x2="19" y1="15" y2="15"></line>
<line x1="11" x2="7" y1="4" y2="20"></line>
<line x1="17" x2="13" y1="4" y2="20"></line>
</svg>
<span>导航</span>
</a>
</li>
<li>
<a href="/archives/">
<svg class="icon icon-tabler icon-tabler-archive" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<rect height="4" rx="2" width="18" x="3" y="4"></rect>
<path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10"></path>
<line x1="10" x2="14" y1="12" y2="12"></line>
</svg>
<span>归档</span>
</a>
</li>
<li>
<a href="/search/">
<svg class="icon icon-tabler icon-tabler-search" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<circle cx="10" cy="10" r="7"></circle>
<line x1="21" x2="15" y1="21" y2="15"></line>
</svg>
<span>搜索</span>
</a>
</li>
<li>
<a href="/friends/">
<svg class="icon icon-tabler icon-tabler-link" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5"></path>
<path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5"></path>
</svg>
<span>友链</span>
</a>
</li>
<li>
<a href="https://blog.imyangty.com" target="_blank">
<svg class="icon icon-tabler icon-tabler-home" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<polyline points="5 12 3 12 12 3 21 12 19 12"></polyline>
<path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7"></path>
<path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6"></path>
</svg>
<span>主博客</span>
</a>
</li>
<div class="menu-bottom-section">
<li id="dark-mode-toggle">
<svg class="icon icon-tabler icon-tabler-toggle-left" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<circle cx="8" cy="12" r="2"></circle>
<rect height="12" rx="6" width="20" x="2" y="6"></rect>
</svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<circle cx="16" cy="12" r="2"></circle>
<rect height="12" rx="6" width="20" x="2" y="6"></rect>
</svg>
<span>暗色模式</span>
</li>
</div>
</ol>
</aside>
<main class="main full-width">
<article class="has-image main-article">
<header class="article-header">
<div class="article-image">
<a href="/note-bst/">
<img alt="Featured image of post 平衡树笔记" loading="lazy" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg8.webp"/>
</a>
</div>
<div class="article-details">
<header class="article-category">
<a href="/categories/oi/">
                OI
            </a>
<a href="/categories/note/">
                笔记
            </a>
</header>
<div class="article-title-wrapper">
<h2 class="article-title">
<a href="/note-bst/">平衡树笔记</a>
</h2>
</div>
<footer class="article-time">
<div>
<svg class="icon icon-tabler icon-tabler-calendar-time" fill="none" height="56" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="56" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4"></path>
<circle cx="18" cy="18" r="4"></circle>
<path d="M15 3v4"></path>
<path d="M7 3v4"></path>
<path d="M3 11h16"></path>
<path d="M18 16.496v1.504l1 1"></path>
</svg>
<time class="article-time--published">Dec 12, 2020</time>
</div>
<div>
<svg class="icon icon-tabler icon-tabler-clock" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<circle cx="12" cy="12" r="9"></circle>
<polyline points="12 7 12 12 15 15"></polyline>
</svg>
<time class="article-time--reading">
                    阅读时长: 25 分钟
                </time>
</div>
</footer>
</div>
</header>
<section class="article-content">
<h2 id="二叉搜索树bst">二叉搜索树(BST)</h2>
<p>BST 是一种常用的数据结构，每个节点储存着一个可以比较大小的权值，并且其满足如下性质：对于任意节点 <span class="math inline">\(u\)</span>，其左子树（如果存在）内所有节点的权值均小于 <span class="math inline">\(u\)</span> 的权值，其右子树（如果存在）内所有节点的权值均大于 <span class="math inline">\(u\)</span> 的权值。</p>
<p>不难发现这棵树可以做很多事情：这棵树的中序遍历就是排好序的序列，并且可以很方便的进行插入删除和查找操作（只需层层递归即可），同时可以统计一个元素的排名（只需看左边有多少节点）。</p>
<p>然而，如果插入的序列是一个递增的序列，则 BST 的复杂度可以退化到 <span class="math inline">\(O(n)\)</span>，这样的话查找一个元素的复杂度和在线性表内查找就没有什么区别了，需要进行优化。</p>
<p>不难发现，对于一个集合，如果我们将他建构成一棵 BST，可以有很多情况，而很明显地：左右平衡的结构是相对比较优的，这样子的话操作的期望复杂度为 <span class="math inline">\(O(\log n)\)</span>，达到了我们的目的。</p>
<p>下面学习一些比较常用的可以使 BST 平衡的手法</p>
<h2 id="treap">Treap</h2>
<h3 id="简介">简介</h3>
<p>Treap=Tree+Heap，是一种相对好写的平衡 BST（简称平衡树），从其命名可以看出来它是一个堆（Heap) 与 BST（Tree）的结合体。</p>
<p>Treap 有如下性质：</p>
<ul>
<li>是一棵关于元素值 val 的 BST</li>
<li>是关于权值 priority（一般是随机的）的堆（小根大根没什么区别）</li>
<li>val 和 priority 确定时，Treap 唯一</li>
</ul>
<p>这样随机给元素分配权值可以使得 Treap 不容易退化成链，使查找/插入/删除/第 <span class="math inline">\(k\)</span> 大/排名的操作都是 <span class="math inline">\(O(\log n)\)</span> 的。</p>
<h3 id="initialization">Initialization</h3>
<p>首先是 Treap 的数组形式定义（指针太难写了而且容易出奇奇怪怪的 bug）</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a aria-hidden="true" href="#cb1-1"></a><span class="kw">struct</span> treap</span>
<span id="cb1-2"><a aria-hidden="true" href="#cb1-2"></a>{</span>
<span id="cb1-3"><a aria-hidden="true" href="#cb1-3"></a>    <span class="dt">int</span> ch[<span class="dv">2</span>];<span class="co">//存储左/右儿子的编号</span></span>
<span id="cb1-4"><a aria-hidden="true" href="#cb1-4"></a>    <span class="dt">int</span> cnt,size;<span class="co">//存储当前元素的数量和子树大小</span></span>
<span id="cb1-5"><a aria-hidden="true" href="#cb1-5"></a>    <span class="dt">int</span> val,p;<span class="co">//val为元素值，p为随机权值</span></span>
<span id="cb1-6"><a aria-hidden="true" href="#cb1-6"></a>}t[maxn];</span></code></pre></div>
<p>下面操作类似于线段树的 pushup，主要是下面信息改变后维护子树大小用</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a aria-hidden="true" href="#cb2-1"></a><span class="pp">#define L </span>t[u].ch[<span class="dv">0</span>]</span>
<span id="cb2-2"><a aria-hidden="true" href="#cb2-2"></a><span class="pp">#define R </span>t[u].ch[<span class="dv">1</span>]</span>
<span id="cb2-3"><a aria-hidden="true" href="#cb2-3"></a><span class="kw">inline</span> <span class="dt">void</span> maintain(<span class="dt">int</span> u)</span>
<span id="cb2-4"><a aria-hidden="true" href="#cb2-4"></a>{</span>
<span id="cb2-5"><a aria-hidden="true" href="#cb2-5"></a>    t[u].size=t[u].cnt+t[L].size+t[R].size;</span>
<span id="cb2-6"><a aria-hidden="true" href="#cb2-6"></a>    <span class="cf">return</span>;</span>
<span id="cb2-7"><a aria-hidden="true" href="#cb2-7"></a>}</span></code></pre></div>
<h3 id="旋转">旋转</h3>
<p>接下来了解一下 Treap 的核心操作：旋转。</p>
<p>Treap 的旋转操作只需要实行一次，说人话就是为了保持堆的性质，将某节点的儿子旋转上来，同时要使树仍满足 BST 的性质，怎么实现呢？看下图：</p>
<figure>
<img alt="" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/treap_rotate.png" title="Treap 的单旋"/><figcaption>Treap 的单旋</figcaption>
</figure>
<p>画图理解后，代码就比较容易写了：<span class="math inline">\(d\)</span> 是旋转方式，0 为旋转左儿子上来（右旋），1 则反之亦然。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a aria-hidden="true" href="#cb3-1"></a><span class="dt">void</span> rotate(<span class="dt">int</span> &amp;x,<span class="dt">int</span> d)<span class="co">// x 引用是为了方便修改，一般传进来的参就是 t[u].ch[x]</span></span>
<span id="cb3-2"><a aria-hidden="true" href="#cb3-2"></a>{</span>
<span id="cb3-3"><a aria-hidden="true" href="#cb3-3"></a>    <span class="dt">int</span> k=t[x].ch[d];<span class="co">//要旋转上来的节点</span></span>
<span id="cb3-4"><a aria-hidden="true" href="#cb3-4"></a>    t[x].ch[d]=t[k].ch[d^<span class="dv">1</span>];</span>
<span id="cb3-5"><a aria-hidden="true" href="#cb3-5"></a>    t[k].ch[d^<span class="dv">1</span>]=x;</span>
<span id="cb3-6"><a aria-hidden="true" href="#cb3-6"></a>    maintain(x);<span class="co">//这里一定要先维护 x</span></span>
<span id="cb3-7"><a aria-hidden="true" href="#cb3-7"></a>    maintain(x=k);<span class="co">//然后将 x 的值改变，并维护之</span></span>
<span id="cb3-8"><a aria-hidden="true" href="#cb3-8"></a>}</span></code></pre></div>
<p><strong>注意 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(k\)</span> 的维护顺序</strong>，因为 <span class="math inline">\(k\)</span> 的 size 是要从 <span class="math inline">\(x\)</span> 那里更新来的，所以要先处理好儿子的结果。</p>
<h3 id="插入删除">插入/删除</h3>
<p>插入操作。直接从根开始，二分查找到对应位置，如果已经存在则 <code>++cnt</code>，如果不存在就新建节点。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a aria-hidden="true" href="#cb4-1"></a><span class="dt">void</span> insert(<span class="dt">int</span> &amp;u,<span class="dt">int</span> val)</span>
<span id="cb4-2"><a aria-hidden="true" href="#cb4-2"></a>{</span>
<span id="cb4-3"><a aria-hidden="true" href="#cb4-3"></a>    <span class="cf">if</span>(!u)<span class="co">//如果 val 不存在</span></span>
<span id="cb4-4"><a aria-hidden="true" href="#cb4-4"></a>    {</span>
<span id="cb4-5"><a aria-hidden="true" href="#cb4-5"></a>        u=++cnt;<span class="co">//开一个新节点</span></span>
<span id="cb4-6"><a aria-hidden="true" href="#cb4-6"></a>        t[u].size=t[u].cnt=<span class="dv">1</span>;</span>
<span id="cb4-7"><a aria-hidden="true" href="#cb4-7"></a>        t[u].val=val;</span>
<span id="cb4-8"><a aria-hidden="true" href="#cb4-8"></a>        t[u].p=rand();<span class="co">//随机一个权值</span></span>
<span id="cb4-9"><a aria-hidden="true" href="#cb4-9"></a>        <span class="cf">return</span>;</span>
<span id="cb4-10"><a aria-hidden="true" href="#cb4-10"></a>    }</span>
<span id="cb4-11"><a aria-hidden="true" href="#cb4-11"></a>    t[u].size++;<span class="co">//因为加到子树里面了，所以 ++size</span></span>
<span id="cb4-12"><a aria-hidden="true" href="#cb4-12"></a>    <span class="cf">if</span>(t[u].val==val)<span class="co">//找到了就直接增加cnt</span></span>
<span id="cb4-13"><a aria-hidden="true" href="#cb4-13"></a>    {</span>
<span id="cb4-14"><a aria-hidden="true" href="#cb4-14"></a>        t[u].cnt++;</span>
<span id="cb4-15"><a aria-hidden="true" href="#cb4-15"></a>        <span class="cf">return</span>;</span>
<span id="cb4-16"><a aria-hidden="true" href="#cb4-16"></a>    }</span>
<span id="cb4-17"><a aria-hidden="true" href="#cb4-17"></a>    <span class="dt">int</span> d=t[u].val&lt;val;<span class="co">//比较巧妙的写法，待插入值大的话就是1，对应右儿子，反之亦然</span></span>
<span id="cb4-18"><a aria-hidden="true" href="#cb4-18"></a>    insert(t[u].ch[d],val);</span>
<span id="cb4-19"><a aria-hidden="true" href="#cb4-19"></a>    <span class="cf">if</span>(t[u].p&gt;t[t[u].ch[d]].p)<span class="co">//维护小根堆，如果插入后破坏了堆的性质</span></span>
<span id="cb4-20"><a aria-hidden="true" href="#cb4-20"></a>        rotate(u,d);<span class="co">//就把对应儿子旋上来</span></span>
<span id="cb4-21"><a aria-hidden="true" href="#cb4-21"></a>    <span class="cf">return</span>;</span>
<span id="cb4-22"><a aria-hidden="true" href="#cb4-22"></a>}</span></code></pre></div>
<p>删除操作。比较难搞，遇到一个节点的时候分为如下情况：</p>
<ol type="1">
<li>当前节点不是待删除节点，递归儿子查找删除</li>
<li>当前节点是待删除节点但是个数大于 1，个数– 然后返回</li>
<li>当前节点是待删除节点且个数为 1</li>
<li>至少有一个儿子为空：把另外一个儿子翻上来，然后直接丢掉自己</li>
<li>两个儿子都不为空：把随机权值较低的儿子翻上来，然后化为 1 情况继续递归</li>
</ol>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a aria-hidden="true" href="#cb5-1"></a><span class="dt">void</span> delnode(<span class="dt">int</span> &amp;u,<span class="dt">int</span> val)</span>
<span id="cb5-2"><a aria-hidden="true" href="#cb5-2"></a>{</span>
<span id="cb5-3"><a aria-hidden="true" href="#cb5-3"></a>    <span class="cf">if</span>(!u)<span class="cf">return</span>;<span class="co">//访问到空了</span></span>
<span id="cb5-4"><a aria-hidden="true" href="#cb5-4"></a>    <span class="cf">if</span>(t[u].val==val)<span class="co">//找到待删除节点</span></span>
<span id="cb5-5"><a aria-hidden="true" href="#cb5-5"></a>    {</span>
<span id="cb5-6"><a aria-hidden="true" href="#cb5-6"></a>        <span class="cf">if</span>(t[u].cnt&gt;<span class="dv">1</span>)<span class="co">//多于一个就只删除一个</span></span>
<span id="cb5-7"><a aria-hidden="true" href="#cb5-7"></a>        {</span>
<span id="cb5-8"><a aria-hidden="true" href="#cb5-8"></a>            t[u].cnt--;</span>
<span id="cb5-9"><a aria-hidden="true" href="#cb5-9"></a>            t[u].size--;</span>
<span id="cb5-10"><a aria-hidden="true" href="#cb5-10"></a>            <span class="cf">return</span>;</span>
<span id="cb5-11"><a aria-hidden="true" href="#cb5-11"></a>        }</span>
<span id="cb5-12"><a aria-hidden="true" href="#cb5-12"></a>        <span class="dt">int</span> d=t[L].p&gt;t[R].p;</span>
<span id="cb5-13"><a aria-hidden="true" href="#cb5-13"></a>        <span class="cf">if</span>((!L)||(!R))<span class="co">//如果左或右有至少一边为空</span></span>
<span id="cb5-14"><a aria-hidden="true" href="#cb5-14"></a>            u=L+R;<span class="co">//直接把非空的赋给 u</span></span>
<span id="cb5-15"><a aria-hidden="true" href="#cb5-15"></a>        <span class="cf">else</span> rotate(u,d),delnode(u,val);<span class="co">//否则就把随机权值更小的儿子翻上来，然后递归处理</span></span>
<span id="cb5-16"><a aria-hidden="true" href="#cb5-16"></a>    }</span>
<span id="cb5-17"><a aria-hidden="true" href="#cb5-17"></a>    <span class="cf">else</span> t[u].size--,delnode(t[u].ch[t[u].val&lt;val],val);<span class="co">//size--，然后递归到儿子里面删除</span></span>
<span id="cb5-18"><a aria-hidden="true" href="#cb5-18"></a>}</span></code></pre></div>
<h3 id="查询排名第-k-大小">查询排名/第 <span class="math inline">\(k\)</span> 大/小</h3>
<p>查询排名操作。这个就比较简单了，同时也是我们为什么要维护每个节点的 size。看代码即能理解：</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a aria-hidden="true" href="#cb6-1"></a><span class="dt">int</span> rank(<span class="dt">int</span> u,<span class="dt">int</span> val)</span>
<span id="cb6-2"><a aria-hidden="true" href="#cb6-2"></a>{</span>
<span id="cb6-3"><a aria-hidden="true" href="#cb6-3"></a>    <span class="cf">if</span>(!u)<span class="cf">return</span> <span class="dv">1</span>;<span class="co">//如果到了空节点，返回 1，因为排名可以排到 1</span></span>
<span id="cb6-4"><a aria-hidden="true" href="#cb6-4"></a>    <span class="cf">if</span>(t[u].val==val)<span class="co">//如果找到了对应的数</span></span>
<span id="cb6-5"><a aria-hidden="true" href="#cb6-5"></a>        <span class="cf">return</span> t[L].size+<span class="dv">1</span>;<span class="co">//返回左儿子的大小加 1</span></span>
<span id="cb6-6"><a aria-hidden="true" href="#cb6-6"></a>    <span class="cf">if</span>(t[u].val&gt;val)<span class="co">//如果当前节点大于待查找</span></span>
<span id="cb6-7"><a aria-hidden="true" href="#cb6-7"></a>        <span class="cf">return</span> rank(L,val);<span class="co">//递归查找左儿子</span></span>
<span id="cb6-8"><a aria-hidden="true" href="#cb6-8"></a>    <span class="cf">else</span> <span class="cf">return</span> rank(R,val)+t[L].size+t[u].cnt;<span class="co">//这里比较容易错，因为需要加上左儿子和节点本身产生的贡献</span></span>
<span id="cb6-9"><a aria-hidden="true" href="#cb6-9"></a>}</span></code></pre></div>
<p>查询第 <span class="math inline">\(k\)</span> 小/大。这里实现查询第 <span class="math inline">\(k\)</span> 小，理解了排名操作基本就能写出来了。值得注意的是这里既可以递归操作，也可以直接迭代写出来。</p>
<p>递归：</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a aria-hidden="true" href="#cb7-1"></a><span class="dt">int</span> kth(<span class="dt">int</span> u, <span class="dt">int</span> k)</span>
<span id="cb7-2"><a aria-hidden="true" href="#cb7-2"></a>{</span>
<span id="cb7-3"><a aria-hidden="true" href="#cb7-3"></a>    <span class="cf">if</span> (!u)</span>
<span id="cb7-4"><a aria-hidden="true" href="#cb7-4"></a>        <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb7-5"><a aria-hidden="true" href="#cb7-5"></a>    <span class="dt">int</span> lsize = L ? t[L].size : <span class="dv">0</span>;</span>
<span id="cb7-6"><a aria-hidden="true" href="#cb7-6"></a>    <span class="cf">if</span> (k &lt;= lsize)</span>
<span id="cb7-7"><a aria-hidden="true" href="#cb7-7"></a>        <span class="cf">return</span> kth(L, k);</span>
<span id="cb7-8"><a aria-hidden="true" href="#cb7-8"></a>    <span class="cf">else</span> <span class="cf">if</span>(k &lt;= lsize + t[u].cnt)</span>
<span id="cb7-9"><a aria-hidden="true" href="#cb7-9"></a>        <span class="cf">return</span> t[u].val;</span>
<span id="cb7-10"><a aria-hidden="true" href="#cb7-10"></a>    <span class="cf">else</span> <span class="cf">return</span> kth(R, k - t[u].cnt - lsize);<span class="co">//k要减去贡献</span></span>
<span id="cb7-11"><a aria-hidden="true" href="#cb7-11"></a>}</span></code></pre></div>
<p>非递归：</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a aria-hidden="true" href="#cb8-1"></a><span class="dt">int</span> kth(<span class="dt">int</span> k)</span>
<span id="cb8-2"><a aria-hidden="true" href="#cb8-2"></a>{</span>
<span id="cb8-3"><a aria-hidden="true" href="#cb8-3"></a>    <span class="dt">int</span> u=root;<span class="co">//从根节点开始向下查找</span></span>
<span id="cb8-4"><a aria-hidden="true" href="#cb8-4"></a>    <span class="cf">while</span> (<span class="kw">true</span>)</span>
<span id="cb8-5"><a aria-hidden="true" href="#cb8-5"></a>    {</span>
<span id="cb8-6"><a aria-hidden="true" href="#cb8-6"></a>        <span class="cf">if</span>(k&lt;=t[L].size)<span class="co">//如果待查询的 k 小于左子树大小</span></span>
<span id="cb8-7"><a aria-hidden="true" href="#cb8-7"></a>            u=L;<span class="co">//往左走</span></span>
<span id="cb8-8"><a aria-hidden="true" href="#cb8-8"></a>        <span class="cf">else</span> <span class="cf">if</span>(k&gt;t[L].size+t[u].cnt)<span class="co">//如果大于了左边和本身产生的贡献</span></span>
<span id="cb8-9"><a aria-hidden="true" href="#cb8-9"></a>            k-=t[L].size+t[u].cnt,u=R;<span class="co">//首先 k 要减去贡献，然后再往右走</span></span>
<span id="cb8-10"><a aria-hidden="true" href="#cb8-10"></a>        <span class="cf">else</span> <span class="cf">return</span> t[u].val;<span class="co">//否则就是找到了，直接返回即可</span></span>
<span id="cb8-11"><a aria-hidden="true" href="#cb8-11"></a>    }</span>
<span id="cb8-12"><a aria-hidden="true" href="#cb8-12"></a>}</span></code></pre></div>
<h3 id="前驱后继完整代码">前驱后继/完整代码</h3>
<p>前驱和后继。前驱的定义为“小于 <span class="math inline">\(x\)</span> 的最大的数”。为了满足“小于 <span class="math inline">\(x\)</span>”，如果当前节点大于等于 <span class="math inline">\(x\)</span>，则在左儿子里面查找。但如果发现了小于 <span class="math inline">\(x\)</span> 的数，为了满足“最大的数”，要在其右子树里面继续查找，结合代码会更好理解。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a aria-hidden="true" href="#cb9-1"></a><span class="dt">int</span> pre(<span class="dt">int</span> u,<span class="dt">int</span> val)</span>
<span id="cb9-2"><a aria-hidden="true" href="#cb9-2"></a>{</span>
<span id="cb9-3"><a aria-hidden="true" href="#cb9-3"></a>    <span class="cf">if</span>(!u)<span class="co">//查到了空节点</span></span>
<span id="cb9-4"><a aria-hidden="true" href="#cb9-4"></a>        <span class="cf">return</span> -inf;<span class="co">//就返回一个不会对答案产生贡献的 -inf</span></span>
<span id="cb9-5"><a aria-hidden="true" href="#cb9-5"></a>    <span class="cf">if</span>(t[u].val&gt;=val)<span class="co">//如果不满足“小于 val“ 的性质</span></span>
<span id="cb9-6"><a aria-hidden="true" href="#cb9-6"></a>        <span class="cf">return</span> pre(L,val);<span class="co">//就在左儿子里面找</span></span>
<span id="cb9-7"><a aria-hidden="true" href="#cb9-7"></a>    <span class="cf">return</span> max(pre(R,val),t[u].val);<span class="co">//取max是为了处理万一右儿子不存在</span></span>
<span id="cb9-8"><a aria-hidden="true" href="#cb9-8"></a>}</span>
<span id="cb9-9"><a aria-hidden="true" href="#cb9-9"></a></span>
<span id="cb9-10"><a aria-hidden="true" href="#cb9-10"></a><span class="dt">int</span> nxt(<span class="dt">int</span> u,<span class="dt">int</span> val)<span class="co">//与前驱同理</span></span>
<span id="cb9-11"><a aria-hidden="true" href="#cb9-11"></a>{</span>
<span id="cb9-12"><a aria-hidden="true" href="#cb9-12"></a>    <span class="cf">if</span>(!u)</span>
<span id="cb9-13"><a aria-hidden="true" href="#cb9-13"></a>        <span class="cf">return</span> inf;</span>
<span id="cb9-14"><a aria-hidden="true" href="#cb9-14"></a>    <span class="cf">if</span>(t[u].val&lt;=val)</span>
<span id="cb9-15"><a aria-hidden="true" href="#cb9-15"></a>        <span class="cf">return</span> nxt(R,val);</span>
<span id="cb9-16"><a aria-hidden="true" href="#cb9-16"></a>    <span class="cf">return</span> min(nxt(L,val),t[u].val);</span>
<span id="cb9-17"><a aria-hidden="true" href="#cb9-17"></a>}</span></code></pre></div>
<p>所以 <a href="https://www.luogu.com.cn/problem/P6136" title="洛谷 P6136">洛谷 P6136</a> 的代码如下（省略了一些不关键的定义）：<strong>（建议不要提交 P3369，有很多问题没有考虑到的 Treap 是可以通过那道题的，建议交加强版）</strong></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a aria-hidden="true" href="#cb10-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb10-2"><a aria-hidden="true" href="#cb10-2"></a><span class="pp">#include </span><span class="im">&lt;cctype&gt;</span></span>
<span id="cb10-3"><a aria-hidden="true" href="#cb10-3"></a><span class="pp">#include </span><span class="im">&lt;climits&gt;</span></span>
<span id="cb10-4"><a aria-hidden="true" href="#cb10-4"></a><span class="pp">#include </span><span class="im">&lt;cstdlib&gt;</span></span>
<span id="cb10-5"><a aria-hidden="true" href="#cb10-5"></a><span class="pp">#define L </span>t[u].ch[<span class="dv">0</span>]</span>
<span id="cb10-6"><a aria-hidden="true" href="#cb10-6"></a><span class="pp">#define R </span>t[u].ch[<span class="dv">1</span>]</span>
<span id="cb10-7"><a aria-hidden="true" href="#cb10-7"></a></span>
<span id="cb10-8"><a aria-hidden="true" href="#cb10-8"></a><span class="kw">inline</span> <span class="dt">int</span> read()</span>
<span id="cb10-9"><a aria-hidden="true" href="#cb10-9"></a>{</span>
<span id="cb10-10"><a aria-hidden="true" href="#cb10-10"></a>    <span class="dt">char</span> c = getchar();</span>
<span id="cb10-11"><a aria-hidden="true" href="#cb10-11"></a>    <span class="dt">int</span> s = <span class="dv">0</span>;</span>
<span id="cb10-12"><a aria-hidden="true" href="#cb10-12"></a>    <span class="dt">bool</span> x = <span class="dv">0</span>;</span>
<span id="cb10-13"><a aria-hidden="true" href="#cb10-13"></a>    <span class="cf">while</span> (!isdigit(c))</span>
<span id="cb10-14"><a aria-hidden="true" href="#cb10-14"></a>        x = x | (c == <span class="ch">'-'</span>), c = getchar();</span>
<span id="cb10-15"><a aria-hidden="true" href="#cb10-15"></a>    <span class="cf">while</span> (isdigit(c))</span>
<span id="cb10-16"><a aria-hidden="true" href="#cb10-16"></a>        s = <span class="dv">10</span> * s + c - <span class="ch">'0'</span>, c = getchar();</span>
<span id="cb10-17"><a aria-hidden="true" href="#cb10-17"></a>    <span class="cf">return</span> x?-s:s;</span>
<span id="cb10-18"><a aria-hidden="true" href="#cb10-18"></a>}</span>
<span id="cb10-19"><a aria-hidden="true" href="#cb10-19"></a></span>
<span id="cb10-20"><a aria-hidden="true" href="#cb10-20"></a><span class="kw">inline</span> <span class="dt">int</span> max(<span class="dt">int</span> a,<span class="dt">int</span> b){<span class="cf">return</span> a &gt; b? a : b;}</span>
<span id="cb10-21"><a aria-hidden="true" href="#cb10-21"></a><span class="kw">inline</span> <span class="dt">int</span> min(<span class="dt">int</span> a,<span class="dt">int</span> b){<span class="cf">return</span> a &lt; b? a : b;}</span>
<span id="cb10-22"><a aria-hidden="true" href="#cb10-22"></a></span>
<span id="cb10-23"><a aria-hidden="true" href="#cb10-23"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">2e6</span>+<span class="dv">5</span>, inf = INT_MAX-<span class="dv">20</span>;</span>
<span id="cb10-24"><a aria-hidden="true" href="#cb10-24"></a><span class="dt">int</span> cnt, root, lastans = <span class="dv">0</span>, ans = <span class="dv">0</span>;</span>
<span id="cb10-25"><a aria-hidden="true" href="#cb10-25"></a></span>
<span id="cb10-26"><a aria-hidden="true" href="#cb10-26"></a><span class="kw">struct</span> treap</span>
<span id="cb10-27"><a aria-hidden="true" href="#cb10-27"></a>{</span>
<span id="cb10-28"><a aria-hidden="true" href="#cb10-28"></a>    <span class="dt">int</span> ch[<span class="dv">2</span>];</span>
<span id="cb10-29"><a aria-hidden="true" href="#cb10-29"></a>    <span class="dt">int</span> val, p;</span>
<span id="cb10-30"><a aria-hidden="true" href="#cb10-30"></a>    <span class="dt">int</span> size, cnt;</span>
<span id="cb10-31"><a aria-hidden="true" href="#cb10-31"></a>} t[maxn];</span>
<span id="cb10-32"><a aria-hidden="true" href="#cb10-32"></a></span>
<span id="cb10-33"><a aria-hidden="true" href="#cb10-33"></a><span class="kw">inline</span> <span class="dt">void</span> maintain(<span class="dt">int</span> u)</span>
<span id="cb10-34"><a aria-hidden="true" href="#cb10-34"></a>{</span>
<span id="cb10-35"><a aria-hidden="true" href="#cb10-35"></a>    t[u].size = t[u].cnt + t[L].size + t[R].size;</span>
<span id="cb10-36"><a aria-hidden="true" href="#cb10-36"></a>    <span class="cf">return</span>;</span>
<span id="cb10-37"><a aria-hidden="true" href="#cb10-37"></a>}</span>
<span id="cb10-38"><a aria-hidden="true" href="#cb10-38"></a></span>
<span id="cb10-39"><a aria-hidden="true" href="#cb10-39"></a><span class="kw">inline</span> <span class="dt">void</span> rotate(<span class="dt">int</span> &amp;u, <span class="dt">int</span> d)</span>
<span id="cb10-40"><a aria-hidden="true" href="#cb10-40"></a>{</span>
<span id="cb10-41"><a aria-hidden="true" href="#cb10-41"></a>    <span class="dt">int</span> k = t[u].ch[d];</span>
<span id="cb10-42"><a aria-hidden="true" href="#cb10-42"></a>    t[u].ch[d] = t[k].ch[d ^ <span class="dv">1</span>];</span>
<span id="cb10-43"><a aria-hidden="true" href="#cb10-43"></a>    t[k].ch[d^<span class="dv">1</span>] = u;</span>
<span id="cb10-44"><a aria-hidden="true" href="#cb10-44"></a>    maintain(u);</span>
<span id="cb10-45"><a aria-hidden="true" href="#cb10-45"></a>    maintain(u = k);</span>
<span id="cb10-46"><a aria-hidden="true" href="#cb10-46"></a>    <span class="cf">return</span>;</span>
<span id="cb10-47"><a aria-hidden="true" href="#cb10-47"></a>}</span>
<span id="cb10-48"><a aria-hidden="true" href="#cb10-48"></a></span>
<span id="cb10-49"><a aria-hidden="true" href="#cb10-49"></a><span class="dt">void</span> insert(<span class="dt">int</span> &amp;u, <span class="dt">int</span> val)</span>
<span id="cb10-50"><a aria-hidden="true" href="#cb10-50"></a>{</span>
<span id="cb10-51"><a aria-hidden="true" href="#cb10-51"></a>    <span class="cf">if</span> (!u)</span>
<span id="cb10-52"><a aria-hidden="true" href="#cb10-52"></a>    {</span>
<span id="cb10-53"><a aria-hidden="true" href="#cb10-53"></a>        u = ++cnt;</span>
<span id="cb10-54"><a aria-hidden="true" href="#cb10-54"></a>        t[u].size = t[u].cnt = <span class="dv">1</span>;</span>
<span id="cb10-55"><a aria-hidden="true" href="#cb10-55"></a>        t[u].val = val;</span>
<span id="cb10-56"><a aria-hidden="true" href="#cb10-56"></a>        t[u].p = rand();</span>
<span id="cb10-57"><a aria-hidden="true" href="#cb10-57"></a>        <span class="cf">return</span>;</span>
<span id="cb10-58"><a aria-hidden="true" href="#cb10-58"></a>    }</span>
<span id="cb10-59"><a aria-hidden="true" href="#cb10-59"></a>    t[u].size++;</span>
<span id="cb10-60"><a aria-hidden="true" href="#cb10-60"></a>    <span class="cf">if</span> (t[u].val == val)</span>
<span id="cb10-61"><a aria-hidden="true" href="#cb10-61"></a>    {</span>
<span id="cb10-62"><a aria-hidden="true" href="#cb10-62"></a>        t[u].cnt++;</span>
<span id="cb10-63"><a aria-hidden="true" href="#cb10-63"></a>        <span class="cf">return</span>;</span>
<span id="cb10-64"><a aria-hidden="true" href="#cb10-64"></a>    }</span>
<span id="cb10-65"><a aria-hidden="true" href="#cb10-65"></a>    <span class="dt">int</span> d = val &gt; t[u].val;</span>
<span id="cb10-66"><a aria-hidden="true" href="#cb10-66"></a>    insert(t[u].ch[d], val);</span>
<span id="cb10-67"><a aria-hidden="true" href="#cb10-67"></a>    <span class="cf">if</span> (t[t[u].ch[d]].p &lt; t[u].p)</span>
<span id="cb10-68"><a aria-hidden="true" href="#cb10-68"></a>        rotate(u, d);</span>
<span id="cb10-69"><a aria-hidden="true" href="#cb10-69"></a>    <span class="cf">return</span>;</span>
<span id="cb10-70"><a aria-hidden="true" href="#cb10-70"></a>}</span>
<span id="cb10-71"><a aria-hidden="true" href="#cb10-71"></a></span>
<span id="cb10-72"><a aria-hidden="true" href="#cb10-72"></a><span class="dt">void</span> delnode(<span class="dt">int</span> &amp;u,<span class="dt">int</span> val)</span>
<span id="cb10-73"><a aria-hidden="true" href="#cb10-73"></a>{</span>
<span id="cb10-74"><a aria-hidden="true" href="#cb10-74"></a>    <span class="cf">if</span> (!u)</span>
<span id="cb10-75"><a aria-hidden="true" href="#cb10-75"></a>        <span class="cf">return</span>;</span>
<span id="cb10-76"><a aria-hidden="true" href="#cb10-76"></a>    <span class="cf">if</span> (t[u].val == val)</span>
<span id="cb10-77"><a aria-hidden="true" href="#cb10-77"></a>    {</span>
<span id="cb10-78"><a aria-hidden="true" href="#cb10-78"></a>        <span class="cf">if</span> (t[u].cnt &gt; <span class="dv">1</span>)</span>
<span id="cb10-79"><a aria-hidden="true" href="#cb10-79"></a>        {</span>
<span id="cb10-80"><a aria-hidden="true" href="#cb10-80"></a>            t[u].cnt--;</span>
<span id="cb10-81"><a aria-hidden="true" href="#cb10-81"></a>            t[u].size--;</span>
<span id="cb10-82"><a aria-hidden="true" href="#cb10-82"></a>            <span class="cf">return</span>;</span>
<span id="cb10-83"><a aria-hidden="true" href="#cb10-83"></a>        }</span>
<span id="cb10-84"><a aria-hidden="true" href="#cb10-84"></a>        <span class="cf">if</span> ((!L) || (!R))</span>
<span id="cb10-85"><a aria-hidden="true" href="#cb10-85"></a>            u = L + R;</span>
<span id="cb10-86"><a aria-hidden="true" href="#cb10-86"></a>        <span class="cf">else</span></span>
<span id="cb10-87"><a aria-hidden="true" href="#cb10-87"></a>        {</span>
<span id="cb10-88"><a aria-hidden="true" href="#cb10-88"></a>            <span class="dt">int</span> d = t[L].p &gt; t[R].p;</span>
<span id="cb10-89"><a aria-hidden="true" href="#cb10-89"></a>            rotate(u, d);</span>
<span id="cb10-90"><a aria-hidden="true" href="#cb10-90"></a>            delnode(u, val);</span>
<span id="cb10-91"><a aria-hidden="true" href="#cb10-91"></a>        }</span>
<span id="cb10-92"><a aria-hidden="true" href="#cb10-92"></a>    }</span>
<span id="cb10-93"><a aria-hidden="true" href="#cb10-93"></a>    <span class="cf">else</span></span>
<span id="cb10-94"><a aria-hidden="true" href="#cb10-94"></a>        t[u].size--, delnode(t[u].ch[val &gt; t[u].val], val);</span>
<span id="cb10-95"><a aria-hidden="true" href="#cb10-95"></a>    <span class="cf">return</span>;</span>
<span id="cb10-96"><a aria-hidden="true" href="#cb10-96"></a>}</span>
<span id="cb10-97"><a aria-hidden="true" href="#cb10-97"></a></span>
<span id="cb10-98"><a aria-hidden="true" href="#cb10-98"></a><span class="dt">int</span> rank(<span class="dt">int</span> u,<span class="dt">int</span> val)</span>
<span id="cb10-99"><a aria-hidden="true" href="#cb10-99"></a>{</span>
<span id="cb10-100"><a aria-hidden="true" href="#cb10-100"></a>    <span class="cf">if</span> (!u)</span>
<span id="cb10-101"><a aria-hidden="true" href="#cb10-101"></a>        <span class="cf">return</span> <span class="dv">1</span>;</span>
<span id="cb10-102"><a aria-hidden="true" href="#cb10-102"></a>    <span class="cf">if</span> (val == t[u].val)</span>
<span id="cb10-103"><a aria-hidden="true" href="#cb10-103"></a>        <span class="cf">return</span> t[L].size + <span class="dv">1</span>;</span>
<span id="cb10-104"><a aria-hidden="true" href="#cb10-104"></a>    <span class="cf">if</span> (val &lt; t[u].val)</span>
<span id="cb10-105"><a aria-hidden="true" href="#cb10-105"></a>        <span class="cf">return</span> rank(L, val);</span>
<span id="cb10-106"><a aria-hidden="true" href="#cb10-106"></a>    <span class="cf">else</span> <span class="cf">return</span> rank(R, val) + t[L].size + t[u].cnt;</span>
<span id="cb10-107"><a aria-hidden="true" href="#cb10-107"></a>}</span>
<span id="cb10-108"><a aria-hidden="true" href="#cb10-108"></a></span>
<span id="cb10-109"><a aria-hidden="true" href="#cb10-109"></a><span class="dt">int</span> kth(<span class="dt">int</span> u, <span class="dt">int</span> k)</span>
<span id="cb10-110"><a aria-hidden="true" href="#cb10-110"></a>{</span>
<span id="cb10-111"><a aria-hidden="true" href="#cb10-111"></a>    <span class="cf">if</span> (!u)</span>
<span id="cb10-112"><a aria-hidden="true" href="#cb10-112"></a>        <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb10-113"><a aria-hidden="true" href="#cb10-113"></a>    <span class="dt">int</span> lsize = L ? t[L].size : <span class="dv">0</span>;</span>
<span id="cb10-114"><a aria-hidden="true" href="#cb10-114"></a>    <span class="cf">if</span> (k &lt;= lsize)</span>
<span id="cb10-115"><a aria-hidden="true" href="#cb10-115"></a>        <span class="cf">return</span> kth(L, k);</span>
<span id="cb10-116"><a aria-hidden="true" href="#cb10-116"></a>    <span class="cf">else</span> <span class="cf">if</span>(k &lt;= lsize + t[u].cnt)</span>
<span id="cb10-117"><a aria-hidden="true" href="#cb10-117"></a>        <span class="cf">return</span> t[u].val;</span>
<span id="cb10-118"><a aria-hidden="true" href="#cb10-118"></a>    <span class="cf">else</span> <span class="cf">return</span> kth(R, k - t[u].cnt - lsize);</span>
<span id="cb10-119"><a aria-hidden="true" href="#cb10-119"></a>}</span>
<span id="cb10-120"><a aria-hidden="true" href="#cb10-120"></a></span>
<span id="cb10-121"><a aria-hidden="true" href="#cb10-121"></a><span class="dt">int</span> pre(<span class="dt">int</span> u, <span class="dt">int</span> val)</span>
<span id="cb10-122"><a aria-hidden="true" href="#cb10-122"></a>{</span>
<span id="cb10-123"><a aria-hidden="true" href="#cb10-123"></a>    <span class="cf">if</span> (!u)</span>
<span id="cb10-124"><a aria-hidden="true" href="#cb10-124"></a>        <span class="cf">return</span> -inf;</span>
<span id="cb10-125"><a aria-hidden="true" href="#cb10-125"></a>    <span class="cf">if</span> (t[u].val &gt;= val)</span>
<span id="cb10-126"><a aria-hidden="true" href="#cb10-126"></a>        <span class="cf">return</span> pre(L, val);</span>
<span id="cb10-127"><a aria-hidden="true" href="#cb10-127"></a>    <span class="cf">else</span> <span class="cf">return</span> max(t[u].val, pre(R, val));</span>
<span id="cb10-128"><a aria-hidden="true" href="#cb10-128"></a>}</span>
<span id="cb10-129"><a aria-hidden="true" href="#cb10-129"></a></span>
<span id="cb10-130"><a aria-hidden="true" href="#cb10-130"></a><span class="dt">int</span> suc(<span class="dt">int</span> u, <span class="dt">int</span> val)</span>
<span id="cb10-131"><a aria-hidden="true" href="#cb10-131"></a>{</span>
<span id="cb10-132"><a aria-hidden="true" href="#cb10-132"></a>    <span class="cf">if</span> (!u)</span>
<span id="cb10-133"><a aria-hidden="true" href="#cb10-133"></a>        <span class="cf">return</span> inf;</span>
<span id="cb10-134"><a aria-hidden="true" href="#cb10-134"></a>    <span class="cf">if</span> (t[u].val &lt;= val)</span>
<span id="cb10-135"><a aria-hidden="true" href="#cb10-135"></a>        <span class="cf">return</span> suc(R, val);</span>
<span id="cb10-136"><a aria-hidden="true" href="#cb10-136"></a>    <span class="cf">else</span> <span class="cf">return</span> min(t[u].val, suc(L, val));</span>
<span id="cb10-137"><a aria-hidden="true" href="#cb10-137"></a>}</span>
<span id="cb10-138"><a aria-hidden="true" href="#cb10-138"></a></span>
<span id="cb10-139"><a aria-hidden="true" href="#cb10-139"></a><span class="dt">int</span> main()</span>
<span id="cb10-140"><a aria-hidden="true" href="#cb10-140"></a>{</span>
<span id="cb10-141"><a aria-hidden="true" href="#cb10-141"></a>    <span class="dt">int</span> n = read(), m = read();</span>
<span id="cb10-142"><a aria-hidden="true" href="#cb10-142"></a>    srand(<span class="dv">20041031</span>);</span>
<span id="cb10-143"><a aria-hidden="true" href="#cb10-143"></a>    <span class="cf">while</span> (n--)</span>
<span id="cb10-144"><a aria-hidden="true" href="#cb10-144"></a>        insert(root, read());</span>
<span id="cb10-145"><a aria-hidden="true" href="#cb10-145"></a>    <span class="cf">while</span> (m--)</span>
<span id="cb10-146"><a aria-hidden="true" href="#cb10-146"></a>    {</span>
<span id="cb10-147"><a aria-hidden="true" href="#cb10-147"></a>        <span class="dt">int</span> opt = read(), x = read() ^ lastans;</span>
<span id="cb10-148"><a aria-hidden="true" href="#cb10-148"></a>        <span class="cf">switch</span> (opt)</span>
<span id="cb10-149"><a aria-hidden="true" href="#cb10-149"></a>        {</span>
<span id="cb10-150"><a aria-hidden="true" href="#cb10-150"></a>        <span class="cf">case</span> <span class="dv">1</span>:</span>
<span id="cb10-151"><a aria-hidden="true" href="#cb10-151"></a>            insert(root, x);</span>
<span id="cb10-152"><a aria-hidden="true" href="#cb10-152"></a>            <span class="cf">break</span>;</span>
<span id="cb10-153"><a aria-hidden="true" href="#cb10-153"></a>        <span class="cf">case</span> <span class="dv">2</span>:</span>
<span id="cb10-154"><a aria-hidden="true" href="#cb10-154"></a>            delnode(root, x);</span>
<span id="cb10-155"><a aria-hidden="true" href="#cb10-155"></a>            <span class="cf">break</span>;</span>
<span id="cb10-156"><a aria-hidden="true" href="#cb10-156"></a>        <span class="cf">case</span> <span class="dv">3</span>:</span>
<span id="cb10-157"><a aria-hidden="true" href="#cb10-157"></a>            ans ^= (lastans = rank(root, x));</span>
<span id="cb10-158"><a aria-hidden="true" href="#cb10-158"></a>            <span class="cf">break</span>;</span>
<span id="cb10-159"><a aria-hidden="true" href="#cb10-159"></a>        <span class="cf">case</span> <span class="dv">4</span>:</span>
<span id="cb10-160"><a aria-hidden="true" href="#cb10-160"></a>            ans ^= (lastans = kth(root, x));</span>
<span id="cb10-161"><a aria-hidden="true" href="#cb10-161"></a>            <span class="cf">break</span>;</span>
<span id="cb10-162"><a aria-hidden="true" href="#cb10-162"></a>        <span class="cf">case</span> <span class="dv">5</span>:</span>
<span id="cb10-163"><a aria-hidden="true" href="#cb10-163"></a>            ans ^= (lastans = pre(root, x));</span>
<span id="cb10-164"><a aria-hidden="true" href="#cb10-164"></a>            <span class="cf">break</span>;</span>
<span id="cb10-165"><a aria-hidden="true" href="#cb10-165"></a>        <span class="cf">case</span> <span class="dv">6</span>:</span>
<span id="cb10-166"><a aria-hidden="true" href="#cb10-166"></a>            ans ^= (lastans = suc(root, x));</span>
<span id="cb10-167"><a aria-hidden="true" href="#cb10-167"></a>            <span class="cf">break</span>;</span>
<span id="cb10-168"><a aria-hidden="true" href="#cb10-168"></a>        }</span>
<span id="cb10-169"><a aria-hidden="true" href="#cb10-169"></a>    }</span>
<span id="cb10-170"><a aria-hidden="true" href="#cb10-170"></a>    printf(<span class="st">"</span><span class="sc">%d\n</span><span class="st">"</span>, ans);</span>
<span id="cb10-171"><a aria-hidden="true" href="#cb10-171"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb10-172"><a aria-hidden="true" href="#cb10-172"></a>}</span></code></pre></div>
<h2 id="fhq-treap无旋-treap">FHQ-Treap（无旋 Treap）</h2>
<p>由范浩强大佬发明的神级数据结构，相比于 Treap 不用旋转，且增添了两个核心操作：分裂（split）与合并（merge），这两个操作是无旋 Treap 的核心操作，其余的所有操作都是基于 split 和 merge 的。</p>
<p><strong>两个值相同的元素是分别储存在两个不同的节点里面的，不像 Treap 的 <code>cnt</code> 域</strong>。</p>
<h3 id="分裂">分裂</h3>
<p>该操作把一棵 Treap 分裂成两棵，有两种分裂方法：按值分裂以及按大小分裂。这里先考虑按值分裂。</p>
<p>该种分裂方式按照一个阈值 <span class="math inline">\(k\)</span> 把一棵 Treap 分裂成两棵，满足左树的所有元素值均<strong>小于等于</strong> <span class="math inline">\(k\)</span>，右树的所有元素值均<strong>大于</strong> <span class="math inline">\(k\)</span>。由于 Treap 满足堆的性质，所以直接分裂即可，不需要特殊维护。</p>
<p>一般来说 <code>split()</code> 函数使用递归实现：<code>void split(int u, int k, int &amp;x, int &amp;y)</code>，其中 <span class="math inline">\(u\)</span> 表示当前节点，<span class="math inline">\(k\)</span> 不再赘述，两个引用 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 是放返回值（即分裂出来的左树的根和右树的根）的。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a aria-hidden="true" href="#cb11-1"></a><span class="dt">void</span> split(<span class="dt">int</span> u, <span class="dt">int</span> k, <span class="dt">int</span>&amp; x, <span class="dt">int</span>&amp; y) {</span>
<span id="cb11-2"><a aria-hidden="true" href="#cb11-2"></a>    <span class="cf">if</span> (!u)</span>
<span id="cb11-3"><a aria-hidden="true" href="#cb11-3"></a>        x = y = <span class="dv">0</span>;</span>
<span id="cb11-4"><a aria-hidden="true" href="#cb11-4"></a>    <span class="cf">else</span> {</span>
<span id="cb11-5"><a aria-hidden="true" href="#cb11-5"></a>        <span class="cf">if</span> (t[u].val &lt;= k) {</span>
<span id="cb11-6"><a aria-hidden="true" href="#cb11-6"></a>            x = u;</span>
<span id="cb11-7"><a aria-hidden="true" href="#cb11-7"></a>            split(R, k, R, y);</span>
<span id="cb11-8"><a aria-hidden="true" href="#cb11-8"></a>        }</span>
<span id="cb11-9"><a aria-hidden="true" href="#cb11-9"></a>        <span class="cf">else</span> {</span>
<span id="cb11-10"><a aria-hidden="true" href="#cb11-10"></a>            y = u;</span>
<span id="cb11-11"><a aria-hidden="true" href="#cb11-11"></a>            split(L, k, x, L);</span>
<span id="cb11-12"><a aria-hidden="true" href="#cb11-12"></a>        }</span>
<span id="cb11-13"><a aria-hidden="true" href="#cb11-13"></a>        maintain(u);</span>
<span id="cb11-14"><a aria-hidden="true" href="#cb11-14"></a>    }</span>
<span id="cb11-15"><a aria-hidden="true" href="#cb11-15"></a>    <span class="cf">return</span>;</span>
<span id="cb11-16"><a aria-hidden="true" href="#cb11-16"></a>}</span></code></pre></div>
<p>接下来解释一下上面的代码：</p>
<p>首先如果这个节点不存在，就不能再继续了，直接 <code>x = y = 0;</code> 即可。</p>
<p>然后如果这个节点的值小于等于 <span class="math inline">\(k\)</span>，则这个节点肯定是划到左树里面去了，所以有 <code>x = u;</code>，然后对于这个节点的左子树，肯定是被划到左子树里面去的，所以继续分裂右子树，即 <code>split(R, k, R, y);</code>。如果无法理解，下面来看看具体步骤：</p>
<figure>
<img alt="" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/fhq_split1.png"/><figcaption>初始的树</figcaption>
</figure>
<p>这是一棵分裂前的 FHQ-Treap（省略了节点编号和随机权值，只保留了值），让我们以阈值 <span class="math inline">\(7\)</span> 将其分裂。一开始 <code>split(root, 7, x, y)</code></p>
<p>首先我们找到树根 <span class="math inline">\(6\)</span>，<span class="math inline">\(6 \le 7\)</span>，所以划到左树里面，同时它的左子树也都属于左树。（属于左树的节点标红）</p>
<figure>
<img alt="" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/fhq_split2.png"/><figcaption>step 1</figcaption>
</figure>
<p>接下来 <code>split(R, k, R, y)</code> 即 <code>split(10的编号, 7, t[6].ch[1], y)</code> 现在来到节点 <span class="math inline">\(10\)</span>，注意到 <span class="math inline">\(10 &gt; 6\)</span>，所以 <span class="math inline">\(10\)</span> 划给右树，<span class="math inline">\(10\)</span> 的所有右节点也都划给右树：此时 <span class="math inline">\(y\)</span> 就被赋为 <span class="math inline">\(10\)</span> 的编号。</p>
<figure>
<img alt="" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/fhq_split3.png"/><figcaption>step 2</figcaption>
</figure>
<p>然后 <code>split(L, k，x, L)</code> 即 <code>split(8的编号, 7, t[6].ch[1], t[10].ch[0])</code>，<span class="math inline">\(8 &gt; 7\)</span></p>
<figure>
<img alt="" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/fhq_split4.png"/><figcaption>step 3</figcaption>
</figure>
<p>接下来 <code>split(L, k, x, L)</code> 即 <code>split(7的编号, 7, t[6].ch[1], t[8].ch[0])</code>，发现 <span class="math inline">\(7 \le 7\)</span>，所以划到左子树，并且 <span class="math inline">\(x=u\)</span>，即把 <code>t[6].ch[1]</code> 赋为 7，</p>
<figure>
<img alt="" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/fhq_split5.png"/><figcaption>step 4</figcaption>
</figure>
<p>然后 <code>split(R, k, R, y)</code> 即 <code>split(0, 7, t[7].ch[1], t[8].ch[0])</code>，发现节点不存在，将 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 都赋为 <span class="math inline">\(0\)</span>，返回即可。这样就完成了分裂。</p>
<p>总结一下：</p>
<ul>
<li>遇到比小于等于阈值的节点，由于其左子树一定划为左树，所以要继续分裂右子树，传下去左树的根是当前节点的右儿子，在更深的递归层会更新。</li>
<li>遇到大于阈值的节点，同理，分裂左子树，传下去右树的根是当前节点的左儿子，在更深的递归层会更新</li>
</ul>
<p>这个递归可能一开始不太好理解，但是理解了会发现其实挺简单的。</p>
<h3 id="合并">合并</h3>
<p>合并的时候是把两棵 FHQ-Treap <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 合并成一棵，必须满足：<span class="math inline">\(x\)</span> 中所有节点的值小于等于 <span class="math inline">\(y\)</span> 中所有节点的值，然后合并的结果也要满足 Treap 的性质（即堆的性质）。</p>
<p>合并函数 <code>int merge(int x, int y)</code> 返回合并后的树根，<span class="math inline">\(x,y\)</span> 分别为两棵待合并树的根。由于要维护堆的性质，实现如下：</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a aria-hidden="true" href="#cb12-1"></a><span class="dt">int</span> merge(<span class="dt">int</span> x, <span class="dt">int</span> y) {</span>
<span id="cb12-2"><a aria-hidden="true" href="#cb12-2"></a>    <span class="cf">if</span> (!x || !y)</span>
<span id="cb12-3"><a aria-hidden="true" href="#cb12-3"></a>        <span class="cf">return</span> x + y;</span>
<span id="cb12-4"><a aria-hidden="true" href="#cb12-4"></a>    <span class="cf">if</span> (t[x].key &lt; t[y].key) {</span>
<span id="cb12-5"><a aria-hidden="true" href="#cb12-5"></a>        t[x].ch[<span class="dv">1</span>] = merge(t[x].ch[<span class="dv">1</span>], y);</span>
<span id="cb12-6"><a aria-hidden="true" href="#cb12-6"></a>        maintain(x);</span>
<span id="cb12-7"><a aria-hidden="true" href="#cb12-7"></a>        <span class="cf">return</span> x;</span>
<span id="cb12-8"><a aria-hidden="true" href="#cb12-8"></a>    }</span>
<span id="cb12-9"><a aria-hidden="true" href="#cb12-9"></a>    <span class="cf">else</span> {</span>
<span id="cb12-10"><a aria-hidden="true" href="#cb12-10"></a>        t[y].ch[<span class="dv">0</span>] = merge(x, t[y].ch[<span class="dv">0</span>]);</span>
<span id="cb12-11"><a aria-hidden="true" href="#cb12-11"></a>        maintain(y);</span>
<span id="cb12-12"><a aria-hidden="true" href="#cb12-12"></a>        <span class="cf">return</span> y;</span>
<span id="cb12-13"><a aria-hidden="true" href="#cb12-13"></a>    }</span>
<span id="cb12-14"><a aria-hidden="true" href="#cb12-14"></a>}</span></code></pre></div>
<p>首先如果两棵树的其中一棵为空，则直接返回另一棵的根即可。</p>
<p>然后维护一个小根堆（小根大根其实无所谓），如果发现左边子树根（<span class="math inline">\(x\)</span>）的权小一些，说明是 <span class="math inline">\(x\)</span> 做父亲，将其右子树与 <span class="math inline">\(y\)</span> 合并的结果作为其右子树即可，合并完记得 pushup 一下就行了。</p>
<p>反之亦然，将 <span class="math inline">\(y\)</span> 的左子树与 <span class="math inline">\(x\)</span> 合并的结果作为 <span class="math inline">\(y\)</span> 的左子树即可，<strong>注意传参的顺序：先传左树后传右树</strong></p>
<p>还是比较好理解的。学习完了两个基本操作，就可以很轻松的实现插入删除排名 <span class="math inline">\(k\text{th}\)</span> 前驱后继等操作了。</p>
<h3 id="插入">插入</h3>
<p>值得注意的是，FHQ-Treap 在处理相同值的时候是单独开新节点的，不像一般的 Treap 维护 <code>cnt</code> 域。</p>
<p>核心思想就是以待插入值为阈值分裂成树 <span class="math inline">\(x\)</span>，<span class="math inline">\(y\)</span>，然后将 <span class="math inline">\(x\)</span>，新节点和 <span class="math inline">\(y\)</span> 合并即可。</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a aria-hidden="true" href="#cb13-1"></a><span class="dt">void</span> insert(<span class="dt">int</span> val) {</span>
<span id="cb13-2"><a aria-hidden="true" href="#cb13-2"></a>    t[++cnt].val = val;<span class="co">//开新节点</span></span>
<span id="cb13-3"><a aria-hidden="true" href="#cb13-3"></a>    t[cnt].key = rnd();<span class="co">//随机分配权</span></span>
<span id="cb13-4"><a aria-hidden="true" href="#cb13-4"></a>    t[cnt].size = <span class="dv">1</span>;</span>
<span id="cb13-5"><a aria-hidden="true" href="#cb13-5"></a>    <span class="dt">int</span> x, y;<span class="co">//临时变量</span></span>
<span id="cb13-6"><a aria-hidden="true" href="#cb13-6"></a>    split(root, val, x, y);<span class="co">//按照 val 分裂</span></span>
<span id="cb13-7"><a aria-hidden="true" href="#cb13-7"></a>    root = merge(merge(x, cnt), y);<span class="co">//先合并 x 和新节点，再将结果与 y 合并</span></span>
<span id="cb13-8"><a aria-hidden="true" href="#cb13-8"></a>    <span class="cf">return</span>;</span>
<span id="cb13-9"><a aria-hidden="true" href="#cb13-9"></a>}</span></code></pre></div>
<h3 id="删除">删除</h3>
<p>这个操作比较精妙：考虑删除 <span class="math inline">\(val\)</span>，先将整棵树分裂成 <span class="math inline">\(x\)</span>，<span class="math inline">\(y\)</span>，<span class="math inline">\(z\)</span> 三棵树，满足：<span class="math inline">\(x\)</span> 中所有节点值均小于 <span class="math inline">\(val\)</span>，<span class="math inline">\(y\)</span> 中均等于 <span class="math inline">\(val\)</span>，<span class="math inline">\(z\)</span> 中均大于 <span class="math inline">\(val\)</span>。这时候我们发现要删除一个 <span class="math inline">\(val\)</span> 就只需要拿掉 <span class="math inline">\(y\)</span> 的根节点就可以了，其等价于直接合并 <span class="math inline">\(y\)</span> 的左右子树。</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a aria-hidden="true" href="#cb14-1"></a><span class="dt">void</span> delnode(<span class="dt">int</span> val) {</span>
<span id="cb14-2"><a aria-hidden="true" href="#cb14-2"></a>    <span class="dt">int</span> x, y, z;</span>
<span id="cb14-3"><a aria-hidden="true" href="#cb14-3"></a>    split(root, val - <span class="dv">1</span>, x, y);<span class="co">//按照 val-1 分裂出 x 树</span></span>
<span id="cb14-4"><a aria-hidden="true" href="#cb14-4"></a>    split(y, val, y, z);<span class="co">//再按照 val 分裂出 y 和 z</span></span>
<span id="cb14-5"><a aria-hidden="true" href="#cb14-5"></a>    y = merge(t[y].ch[<span class="dv">0</span>], t[y].ch[<span class="dv">1</span>]);<span class="co">//直接拿掉 y 的根</span></span>
<span id="cb14-6"><a aria-hidden="true" href="#cb14-6"></a>    root = merge(merge(x, y), z);<span class="co">//再复原就可以了</span></span>
<span id="cb14-7"><a aria-hidden="true" href="#cb14-7"></a>    <span class="cf">return</span>;</span>
<span id="cb14-8"><a aria-hidden="true" href="#cb14-8"></a>}</span></code></pre></div>
<h3 id="排名第-k-大小">排名/第 <span class="math inline">\(k\)</span> 大/小</h3>
<p>查询排名很类似于删除操作，但只需要分裂出小于 <span class="math inline">\(val\)</span> 的树然后返回其大小加一的值即可。</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a aria-hidden="true" href="#cb15-1"></a><span class="dt">int</span> rank(<span class="dt">int</span> val) {</span>
<span id="cb15-2"><a aria-hidden="true" href="#cb15-2"></a>    <span class="dt">int</span> x, y;</span>
<span id="cb15-3"><a aria-hidden="true" href="#cb15-3"></a>    split(root, val - <span class="dv">1</span>, x, y);</span>
<span id="cb15-4"><a aria-hidden="true" href="#cb15-4"></a>    <span class="dt">int</span> ans = t[x].size + <span class="dv">1</span>;</span>
<span id="cb15-5"><a aria-hidden="true" href="#cb15-5"></a>    root = merge(x, y);</span>
<span id="cb15-6"><a aria-hidden="true" href="#cb15-6"></a>    <span class="cf">return</span> ans;</span>
<span id="cb15-7"><a aria-hidden="true" href="#cb15-7"></a>}</span></code></pre></div>
<p>然而查询 <span class="math inline">\(k\text{th}\)</span> 时就不能分裂/合并了，老老实实按照大多数平衡树的写法就可以了，建议非递归，常数小一些。</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a aria-hidden="true" href="#cb16-1"></a><span class="dt">int</span> kth(<span class="dt">int</span> k) {</span>
<span id="cb16-2"><a aria-hidden="true" href="#cb16-2"></a>    <span class="dt">int</span> u = root;</span>
<span id="cb16-3"><a aria-hidden="true" href="#cb16-3"></a>    <span class="cf">while</span> (<span class="kw">true</span>) {</span>
<span id="cb16-4"><a aria-hidden="true" href="#cb16-4"></a>        <span class="dt">int</span> lsize = <span class="dv">0</span>;</span>
<span id="cb16-5"><a aria-hidden="true" href="#cb16-5"></a>        <span class="cf">if</span> (L)</span>
<span id="cb16-6"><a aria-hidden="true" href="#cb16-6"></a>            lsize = t[L].size;</span>
<span id="cb16-7"><a aria-hidden="true" href="#cb16-7"></a>        <span class="cf">if</span> (k &lt;= lsize)</span>
<span id="cb16-8"><a aria-hidden="true" href="#cb16-8"></a>            u = L;</span>
<span id="cb16-9"><a aria-hidden="true" href="#cb16-9"></a>        <span class="cf">else</span> <span class="cf">if</span> (k &gt; lsize + <span class="dv">1</span>)</span>
<span id="cb16-10"><a aria-hidden="true" href="#cb16-10"></a>            k -= lsize + <span class="dv">1</span>, u = R;</span>
<span id="cb16-11"><a aria-hidden="true" href="#cb16-11"></a>        <span class="cf">else</span> <span class="cf">return</span> t[u].val;</span>
<span id="cb16-12"><a aria-hidden="true" href="#cb16-12"></a>    }</span>
<span id="cb16-13"><a aria-hidden="true" href="#cb16-13"></a>}</span></code></pre></div>
<h3 id="前驱后继">前驱/后继</h3>
<p>前驱：小于 <span class="math inline">\(x\)</span> 且最大的数，所以利用排名和 <span class="math inline">\(k\text{th}\)</span> 即可。查找 <span class="math inline">\(x\)</span> 的排名然后输出对应该排名减一的数即可。</p>
<p>后继：查找 <span class="math inline">\(x+1\)</span> 的排名然后输出该排名对应的数即可</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a aria-hidden="true" href="#cb17-1"></a><span class="dt">int</span> pre(<span class="dt">int</span> val) {</span>
<span id="cb17-2"><a aria-hidden="true" href="#cb17-2"></a>    <span class="cf">return</span> kth(rank(val) - <span class="dv">1</span>);</span>
<span id="cb17-3"><a aria-hidden="true" href="#cb17-3"></a>}</span>
<span id="cb17-4"><a aria-hidden="true" href="#cb17-4"></a></span>
<span id="cb17-5"><a aria-hidden="true" href="#cb17-5"></a><span class="dt">int</span> suc(<span class="dt">int</span> val) {</span>
<span id="cb17-6"><a aria-hidden="true" href="#cb17-6"></a>    <span class="cf">return</span> kth(rank(val + <span class="dv">1</span>));</span>
<span id="cb17-7"><a aria-hidden="true" href="#cb17-7"></a>}</span></code></pre></div>
<h3 id="普通平衡树的实现">普通平衡树的实现</h3>
<p>可以发现代码明显短于一般 Treap 和 Splay，但常数大于 Treap 小于 Splay。<strong>关键是特别好写好背</strong></p>
<p><a href="https://www.luogu.com.cn/problem/P6136" title="洛谷 P6136">洛谷 P6136</a> 的代码如下：</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a aria-hidden="true" href="#cb18-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb18-2"><a aria-hidden="true" href="#cb18-2"></a><span class="pp">#include </span><span class="im">&lt;cctype&gt;</span></span>
<span id="cb18-3"><a aria-hidden="true" href="#cb18-3"></a><span class="pp">#include </span><span class="im">&lt;cstdlib&gt;</span></span>
<span id="cb18-4"><a aria-hidden="true" href="#cb18-4"></a></span>
<span id="cb18-5"><a aria-hidden="true" href="#cb18-5"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">1e6</span> + <span class="fl">2e5</span>;</span>
<span id="cb18-6"><a aria-hidden="true" href="#cb18-6"></a></span>
<span id="cb18-7"><a aria-hidden="true" href="#cb18-7"></a><span class="kw">inline</span> <span class="dt">int</span> read() {</span>
<span id="cb18-8"><a aria-hidden="true" href="#cb18-8"></a>    <span class="dt">char</span> c = getchar();</span>
<span id="cb18-9"><a aria-hidden="true" href="#cb18-9"></a>    <span class="dt">int</span> s = <span class="dv">0</span>;</span>
<span id="cb18-10"><a aria-hidden="true" href="#cb18-10"></a>    <span class="dt">bool</span> x = <span class="dv">0</span>;</span>
<span id="cb18-11"><a aria-hidden="true" href="#cb18-11"></a>    <span class="cf">while</span> (!isdigit(c))</span>
<span id="cb18-12"><a aria-hidden="true" href="#cb18-12"></a>        x = x | (c == <span class="ch">'-'</span>), c = getchar();</span>
<span id="cb18-13"><a aria-hidden="true" href="#cb18-13"></a>    <span class="cf">while</span> (isdigit(c))</span>
<span id="cb18-14"><a aria-hidden="true" href="#cb18-14"></a>        s = <span class="dv">10</span> * s + c - <span class="ch">'0'</span>, c = getchar();</span>
<span id="cb18-15"><a aria-hidden="true" href="#cb18-15"></a>    <span class="cf">return</span> x ? -s : s;</span>
<span id="cb18-16"><a aria-hidden="true" href="#cb18-16"></a>}</span>
<span id="cb18-17"><a aria-hidden="true" href="#cb18-17"></a></span>
<span id="cb18-18"><a aria-hidden="true" href="#cb18-18"></a><span class="kw">struct</span> node {</span>
<span id="cb18-19"><a aria-hidden="true" href="#cb18-19"></a>    <span class="dt">int</span> size;</span>
<span id="cb18-20"><a aria-hidden="true" href="#cb18-20"></a>    <span class="dt">int</span> ch[<span class="dv">2</span>];</span>
<span id="cb18-21"><a aria-hidden="true" href="#cb18-21"></a>    <span class="dt">int</span> val, key;</span>
<span id="cb18-22"><a aria-hidden="true" href="#cb18-22"></a><span class="pp">#define L </span>(t[u].ch[<span class="dv">0</span>])</span>
<span id="cb18-23"><a aria-hidden="true" href="#cb18-23"></a><span class="pp">#define R </span>(t[u].ch[<span class="dv">1</span>])</span>
<span id="cb18-24"><a aria-hidden="true" href="#cb18-24"></a>} t[maxn];</span>
<span id="cb18-25"><a aria-hidden="true" href="#cb18-25"></a></span>
<span id="cb18-26"><a aria-hidden="true" href="#cb18-26"></a><span class="dt">int</span> cnt, root;</span>
<span id="cb18-27"><a aria-hidden="true" href="#cb18-27"></a></span>
<span id="cb18-28"><a aria-hidden="true" href="#cb18-28"></a><span class="kw">inline</span> <span class="dt">void</span> pushup(<span class="dt">int</span> u) {</span>
<span id="cb18-29"><a aria-hidden="true" href="#cb18-29"></a>    t[u].size = t[L].size + t[R].size + <span class="dv">1</span>;</span>
<span id="cb18-30"><a aria-hidden="true" href="#cb18-30"></a>    <span class="cf">return</span>;</span>
<span id="cb18-31"><a aria-hidden="true" href="#cb18-31"></a>}</span>
<span id="cb18-32"><a aria-hidden="true" href="#cb18-32"></a></span>
<span id="cb18-33"><a aria-hidden="true" href="#cb18-33"></a><span class="dt">void</span> split(<span class="dt">int</span> u, <span class="dt">int</span> k, <span class="dt">int</span>&amp; x, <span class="dt">int</span>&amp; y) {</span>
<span id="cb18-34"><a aria-hidden="true" href="#cb18-34"></a>    <span class="cf">if</span> (!u) {</span>
<span id="cb18-35"><a aria-hidden="true" href="#cb18-35"></a>        x = y = <span class="dv">0</span>;</span>
<span id="cb18-36"><a aria-hidden="true" href="#cb18-36"></a>        <span class="cf">return</span>;</span>
<span id="cb18-37"><a aria-hidden="true" href="#cb18-37"></a>    }</span>
<span id="cb18-38"><a aria-hidden="true" href="#cb18-38"></a>    <span class="cf">if</span> (t[u].val &lt;= k) {</span>
<span id="cb18-39"><a aria-hidden="true" href="#cb18-39"></a>        x = u;</span>
<span id="cb18-40"><a aria-hidden="true" href="#cb18-40"></a>        split(R, k, R, y);</span>
<span id="cb18-41"><a aria-hidden="true" href="#cb18-41"></a>    }</span>
<span id="cb18-42"><a aria-hidden="true" href="#cb18-42"></a>    <span class="cf">else</span> {</span>
<span id="cb18-43"><a aria-hidden="true" href="#cb18-43"></a>        y = u;</span>
<span id="cb18-44"><a aria-hidden="true" href="#cb18-44"></a>        split(L, k, x, L);</span>
<span id="cb18-45"><a aria-hidden="true" href="#cb18-45"></a>    }</span>
<span id="cb18-46"><a aria-hidden="true" href="#cb18-46"></a>    pushup(u);</span>
<span id="cb18-47"><a aria-hidden="true" href="#cb18-47"></a>    <span class="cf">return</span>;</span>
<span id="cb18-48"><a aria-hidden="true" href="#cb18-48"></a>}</span>
<span id="cb18-49"><a aria-hidden="true" href="#cb18-49"></a></span>
<span id="cb18-50"><a aria-hidden="true" href="#cb18-50"></a><span class="dt">int</span> merge(<span class="dt">int</span> x, <span class="dt">int</span> y) {</span>
<span id="cb18-51"><a aria-hidden="true" href="#cb18-51"></a>    <span class="cf">if</span> (!x || !y)</span>
<span id="cb18-52"><a aria-hidden="true" href="#cb18-52"></a>        <span class="cf">return</span> x + y;</span>
<span id="cb18-53"><a aria-hidden="true" href="#cb18-53"></a>    <span class="cf">if</span> (t[x].key &lt; t[y].key) {</span>
<span id="cb18-54"><a aria-hidden="true" href="#cb18-54"></a>        t[x].ch[<span class="dv">1</span>] = merge(t[x].ch[<span class="dv">1</span>], y);</span>
<span id="cb18-55"><a aria-hidden="true" href="#cb18-55"></a>        pushup(x);</span>
<span id="cb18-56"><a aria-hidden="true" href="#cb18-56"></a>        <span class="cf">return</span> x;</span>
<span id="cb18-57"><a aria-hidden="true" href="#cb18-57"></a>    }</span>
<span id="cb18-58"><a aria-hidden="true" href="#cb18-58"></a>    <span class="cf">else</span> {</span>
<span id="cb18-59"><a aria-hidden="true" href="#cb18-59"></a>        t[y].ch[<span class="dv">0</span>] = merge(x, t[y].ch[<span class="dv">0</span>]);</span>
<span id="cb18-60"><a aria-hidden="true" href="#cb18-60"></a>        pushup(y);</span>
<span id="cb18-61"><a aria-hidden="true" href="#cb18-61"></a>        <span class="cf">return</span> y;</span>
<span id="cb18-62"><a aria-hidden="true" href="#cb18-62"></a>    }</span>
<span id="cb18-63"><a aria-hidden="true" href="#cb18-63"></a>}</span>
<span id="cb18-64"><a aria-hidden="true" href="#cb18-64"></a></span>
<span id="cb18-65"><a aria-hidden="true" href="#cb18-65"></a><span class="dt">void</span> insert(<span class="dt">int</span> val) {</span>
<span id="cb18-66"><a aria-hidden="true" href="#cb18-66"></a>    t[++cnt].val = val;</span>
<span id="cb18-67"><a aria-hidden="true" href="#cb18-67"></a>    t[cnt].key = rand();</span>
<span id="cb18-68"><a aria-hidden="true" href="#cb18-68"></a>    t[cnt].size = <span class="dv">1</span>;</span>
<span id="cb18-69"><a aria-hidden="true" href="#cb18-69"></a>    <span class="dt">int</span> x, y;</span>
<span id="cb18-70"><a aria-hidden="true" href="#cb18-70"></a>    split(root, val, x, y);</span>
<span id="cb18-71"><a aria-hidden="true" href="#cb18-71"></a>    root = merge(merge(x, cnt), y);</span>
<span id="cb18-72"><a aria-hidden="true" href="#cb18-72"></a>    <span class="cf">return</span>;</span>
<span id="cb18-73"><a aria-hidden="true" href="#cb18-73"></a>}</span>
<span id="cb18-74"><a aria-hidden="true" href="#cb18-74"></a></span>
<span id="cb18-75"><a aria-hidden="true" href="#cb18-75"></a><span class="dt">void</span> delnode(<span class="dt">int</span> val) {</span>
<span id="cb18-76"><a aria-hidden="true" href="#cb18-76"></a>    <span class="dt">int</span> x, y, z;</span>
<span id="cb18-77"><a aria-hidden="true" href="#cb18-77"></a>    split(root, val - <span class="dv">1</span>, x, y);</span>
<span id="cb18-78"><a aria-hidden="true" href="#cb18-78"></a>    split(y, val, y, z);</span>
<span id="cb18-79"><a aria-hidden="true" href="#cb18-79"></a>    y = merge(t[y].ch[<span class="dv">0</span>], t[y].ch[<span class="dv">1</span>]);</span>
<span id="cb18-80"><a aria-hidden="true" href="#cb18-80"></a>    root = merge(merge(x, y), z);</span>
<span id="cb18-81"><a aria-hidden="true" href="#cb18-81"></a>    <span class="cf">return</span>;</span>
<span id="cb18-82"><a aria-hidden="true" href="#cb18-82"></a>}</span>
<span id="cb18-83"><a aria-hidden="true" href="#cb18-83"></a></span>
<span id="cb18-84"><a aria-hidden="true" href="#cb18-84"></a><span class="dt">int</span> rank(<span class="dt">int</span> val) {</span>
<span id="cb18-85"><a aria-hidden="true" href="#cb18-85"></a>    <span class="dt">int</span> x, y;</span>
<span id="cb18-86"><a aria-hidden="true" href="#cb18-86"></a>    split(root, val - <span class="dv">1</span>, x, y);</span>
<span id="cb18-87"><a aria-hidden="true" href="#cb18-87"></a>    <span class="dt">int</span> ans = t[x].size + <span class="dv">1</span>;</span>
<span id="cb18-88"><a aria-hidden="true" href="#cb18-88"></a>    root = merge(x, y);</span>
<span id="cb18-89"><a aria-hidden="true" href="#cb18-89"></a>    <span class="cf">return</span> ans;</span>
<span id="cb18-90"><a aria-hidden="true" href="#cb18-90"></a>}</span>
<span id="cb18-91"><a aria-hidden="true" href="#cb18-91"></a></span>
<span id="cb18-92"><a aria-hidden="true" href="#cb18-92"></a><span class="dt">int</span> kth(<span class="dt">int</span> k) {</span>
<span id="cb18-93"><a aria-hidden="true" href="#cb18-93"></a>    <span class="dt">int</span> u = root;</span>
<span id="cb18-94"><a aria-hidden="true" href="#cb18-94"></a>    <span class="cf">while</span> (<span class="kw">true</span>) {</span>
<span id="cb18-95"><a aria-hidden="true" href="#cb18-95"></a>        <span class="dt">int</span> lsize = <span class="dv">0</span>;</span>
<span id="cb18-96"><a aria-hidden="true" href="#cb18-96"></a>        <span class="cf">if</span> (L) lsize = t[L].size;</span>
<span id="cb18-97"><a aria-hidden="true" href="#cb18-97"></a>        <span class="cf">if</span> (k &lt;= lsize)</span>
<span id="cb18-98"><a aria-hidden="true" href="#cb18-98"></a>            u = L;</span>
<span id="cb18-99"><a aria-hidden="true" href="#cb18-99"></a>        <span class="cf">else</span> <span class="cf">if</span> (k &gt; lsize + <span class="dv">1</span>)</span>
<span id="cb18-100"><a aria-hidden="true" href="#cb18-100"></a>            k -= lsize + <span class="dv">1</span>, u = R;</span>
<span id="cb18-101"><a aria-hidden="true" href="#cb18-101"></a>        <span class="cf">else</span> <span class="cf">return</span> t[u].val;</span>
<span id="cb18-102"><a aria-hidden="true" href="#cb18-102"></a>    }</span>
<span id="cb18-103"><a aria-hidden="true" href="#cb18-103"></a>}</span>
<span id="cb18-104"><a aria-hidden="true" href="#cb18-104"></a></span>
<span id="cb18-105"><a aria-hidden="true" href="#cb18-105"></a><span class="dt">int</span> pre(<span class="dt">int</span> val) {</span>
<span id="cb18-106"><a aria-hidden="true" href="#cb18-106"></a>    <span class="cf">return</span> kth(rank(val) - <span class="dv">1</span>);</span>
<span id="cb18-107"><a aria-hidden="true" href="#cb18-107"></a>}</span>
<span id="cb18-108"><a aria-hidden="true" href="#cb18-108"></a></span>
<span id="cb18-109"><a aria-hidden="true" href="#cb18-109"></a><span class="dt">int</span> suc(<span class="dt">int</span> val) {</span>
<span id="cb18-110"><a aria-hidden="true" href="#cb18-110"></a>    <span class="cf">return</span> kth(rank(val + <span class="dv">1</span>));</span>
<span id="cb18-111"><a aria-hidden="true" href="#cb18-111"></a>}</span>
<span id="cb18-112"><a aria-hidden="true" href="#cb18-112"></a></span>
<span id="cb18-113"><a aria-hidden="true" href="#cb18-113"></a><span class="dt">int</span> main() {</span>
<span id="cb18-114"><a aria-hidden="true" href="#cb18-114"></a>    <span class="dt">int</span> n = read(), m = read(), ans = <span class="dv">0</span>, lastans = <span class="dv">0</span>;</span>
<span id="cb18-115"><a aria-hidden="true" href="#cb18-115"></a>    srand(<span class="dv">20041031</span>);</span>
<span id="cb18-116"><a aria-hidden="true" href="#cb18-116"></a>    <span class="cf">while</span> (n--)</span>
<span id="cb18-117"><a aria-hidden="true" href="#cb18-117"></a>        insert(read());</span>
<span id="cb18-118"><a aria-hidden="true" href="#cb18-118"></a>    <span class="cf">while</span> (m--) {</span>
<span id="cb18-119"><a aria-hidden="true" href="#cb18-119"></a>        <span class="dt">int</span> opt = read(), x = read() ^ lastans;</span>
<span id="cb18-120"><a aria-hidden="true" href="#cb18-120"></a>        <span class="cf">switch</span> (opt) {</span>
<span id="cb18-121"><a aria-hidden="true" href="#cb18-121"></a>        <span class="cf">case</span> <span class="dv">1</span>:</span>
<span id="cb18-122"><a aria-hidden="true" href="#cb18-122"></a>            insert(x);</span>
<span id="cb18-123"><a aria-hidden="true" href="#cb18-123"></a>            <span class="cf">break</span>;</span>
<span id="cb18-124"><a aria-hidden="true" href="#cb18-124"></a>        <span class="cf">case</span> <span class="dv">2</span>:</span>
<span id="cb18-125"><a aria-hidden="true" href="#cb18-125"></a>            delnode(x);</span>
<span id="cb18-126"><a aria-hidden="true" href="#cb18-126"></a>            <span class="cf">break</span>;</span>
<span id="cb18-127"><a aria-hidden="true" href="#cb18-127"></a>        <span class="cf">case</span> <span class="dv">3</span>:</span>
<span id="cb18-128"><a aria-hidden="true" href="#cb18-128"></a>            ans ^= (lastans = rank(x));</span>
<span id="cb18-129"><a aria-hidden="true" href="#cb18-129"></a>            <span class="cf">break</span>;</span>
<span id="cb18-130"><a aria-hidden="true" href="#cb18-130"></a>        <span class="cf">case</span> <span class="dv">4</span>:</span>
<span id="cb18-131"><a aria-hidden="true" href="#cb18-131"></a>            ans ^= (lastans = kth(x));</span>
<span id="cb18-132"><a aria-hidden="true" href="#cb18-132"></a>            <span class="cf">break</span>;</span>
<span id="cb18-133"><a aria-hidden="true" href="#cb18-133"></a>        <span class="cf">case</span> <span class="dv">5</span>:</span>
<span id="cb18-134"><a aria-hidden="true" href="#cb18-134"></a>            ans ^= (lastans = pre(x));</span>
<span id="cb18-135"><a aria-hidden="true" href="#cb18-135"></a>            <span class="cf">break</span>;</span>
<span id="cb18-136"><a aria-hidden="true" href="#cb18-136"></a>        <span class="cf">case</span> <span class="dv">6</span>:</span>
<span id="cb18-137"><a aria-hidden="true" href="#cb18-137"></a>            ans ^= (lastans = suc(x));</span>
<span id="cb18-138"><a aria-hidden="true" href="#cb18-138"></a>            <span class="cf">break</span>;</span>
<span id="cb18-139"><a aria-hidden="true" href="#cb18-139"></a>        }</span>
<span id="cb18-140"><a aria-hidden="true" href="#cb18-140"></a>    }</span>
<span id="cb18-141"><a aria-hidden="true" href="#cb18-141"></a>    printf(<span class="st">"</span><span class="sc">%d\n</span><span class="st">"</span>, ans);</span>
<span id="cb18-142"><a aria-hidden="true" href="#cb18-142"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb18-143"><a aria-hidden="true" href="#cb18-143"></a>}</span></code></pre></div>
<h3 id="按大小分裂文艺平衡树的实现">按大小分裂/文艺平衡树的实现</h3>
<p>FHQ-Treap 还有另外一种分裂方式：按大小分裂，将一棵 FHQ-Treap 分裂成 <span class="math inline">\(x\)</span>，<span class="math inline">\(y\)</span>，满足 <span class="math inline">\(x\)</span> 的大小为给定值。这样子分裂能够让我们更好更方便地处理区间问题，下面以文艺平衡树为例：</p>
<p>首先是分裂函数：</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a aria-hidden="true" href="#cb19-1"></a><span class="dt">void</span> split(<span class="dt">int</span> u, <span class="dt">int</span> size, <span class="dt">int</span> &amp;x, <span class="dt">int</span> &amp;y) {</span>
<span id="cb19-2"><a aria-hidden="true" href="#cb19-2"></a>    <span class="cf">if</span> (!u) {</span>
<span id="cb19-3"><a aria-hidden="true" href="#cb19-3"></a>        x = y = <span class="dv">0</span>;</span>
<span id="cb19-4"><a aria-hidden="true" href="#cb19-4"></a>        <span class="cf">return</span>;</span>
<span id="cb19-5"><a aria-hidden="true" href="#cb19-5"></a>    }</span>
<span id="cb19-6"><a aria-hidden="true" href="#cb19-6"></a>    pushdown(u);</span>
<span id="cb19-7"><a aria-hidden="true" href="#cb19-7"></a>    <span class="cf">if</span> (t[L].size &lt; size)</span>
<span id="cb19-8"><a aria-hidden="true" href="#cb19-8"></a>        x = u, split(R, size - t[L].size - <span class="dv">1</span>, R, y);</span>
<span id="cb19-9"><a aria-hidden="true" href="#cb19-9"></a>    <span class="cf">else</span></span>
<span id="cb19-10"><a aria-hidden="true" href="#cb19-10"></a>        y = u, split(L, size, x, L);</span>
<span id="cb19-11"><a aria-hidden="true" href="#cb19-11"></a>    pushup(u);</span>
<span id="cb19-12"><a aria-hidden="true" href="#cb19-12"></a>    <span class="cf">return</span>;</span>
<span id="cb19-13"><a aria-hidden="true" href="#cb19-13"></a>}</span></code></pre></div>
<p>基本和一般的按值分裂是差不多的，只不过要注意的就是如果要继续分裂右子树，传下去的 <code>size</code> 值是需要改变的。</p>
<p>剩下的也没什么了，对于要翻转区间 <span class="math inline">\([l,r]\)</span>，直接分裂成三棵树。具体地，按照 <span class="math inline">\(l-1\)</span> 分裂成 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span>，再将 <span class="math inline">\(y\)</span> 按照 <span class="math inline">\(r-l+1\)</span> 分裂成 <span class="math inline">\(y\)</span> 和 <span class="math inline">\(z\)</span>，此时 <span class="math inline">\(y\)</span> 树就是提取出来的区间 <span class="math inline">\([l,r]\)</span>，打上标记即可。</p>
<p><strong>实现文艺平衡树的时候需要特别注意标记的下传</strong>，实现如下，比 Splay 简洁且不容易写错。</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a aria-hidden="true" href="#cb20-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb20-2"><a aria-hidden="true" href="#cb20-2"></a><span class="pp">#include </span><span class="im">&lt;cctype&gt;</span></span>
<span id="cb20-3"><a aria-hidden="true" href="#cb20-3"></a><span class="pp">#include </span><span class="im">&lt;cstdlib&gt;</span></span>
<span id="cb20-4"><a aria-hidden="true" href="#cb20-4"></a></span>
<span id="cb20-5"><a aria-hidden="true" href="#cb20-5"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="dv">100000</span> + <span class="dv">5</span>;</span>
<span id="cb20-6"><a aria-hidden="true" href="#cb20-6"></a></span>
<span id="cb20-7"><a aria-hidden="true" href="#cb20-7"></a><span class="kw">inline</span> <span class="dt">int</span> read() {</span>
<span id="cb20-8"><a aria-hidden="true" href="#cb20-8"></a>    <span class="dt">char</span> c = getchar();</span>
<span id="cb20-9"><a aria-hidden="true" href="#cb20-9"></a>    <span class="dt">int</span> s = <span class="dv">0</span>;</span>
<span id="cb20-10"><a aria-hidden="true" href="#cb20-10"></a>    <span class="dt">bool</span> x = <span class="dv">0</span>;</span>
<span id="cb20-11"><a aria-hidden="true" href="#cb20-11"></a>    <span class="cf">while</span> (!isdigit(c))</span>
<span id="cb20-12"><a aria-hidden="true" href="#cb20-12"></a>        x = x | (c == <span class="ch">'-'</span>), c = getchar();</span>
<span id="cb20-13"><a aria-hidden="true" href="#cb20-13"></a>    <span class="cf">while</span> (isdigit(c))</span>
<span id="cb20-14"><a aria-hidden="true" href="#cb20-14"></a>        s = <span class="dv">10</span> * s + c - <span class="ch">'0'</span>, c = getchar();</span>
<span id="cb20-15"><a aria-hidden="true" href="#cb20-15"></a>    <span class="cf">return</span> x ? -s : s;</span>
<span id="cb20-16"><a aria-hidden="true" href="#cb20-16"></a>}</span>
<span id="cb20-17"><a aria-hidden="true" href="#cb20-17"></a></span>
<span id="cb20-18"><a aria-hidden="true" href="#cb20-18"></a><span class="kw">struct</span> node {</span>
<span id="cb20-19"><a aria-hidden="true" href="#cb20-19"></a>    <span class="dt">int</span> ch[<span class="dv">2</span>];</span>
<span id="cb20-20"><a aria-hidden="true" href="#cb20-20"></a>    <span class="dt">int</span> size;</span>
<span id="cb20-21"><a aria-hidden="true" href="#cb20-21"></a>    <span class="dt">int</span> val, key;</span>
<span id="cb20-22"><a aria-hidden="true" href="#cb20-22"></a>    <span class="dt">bool</span> tag;</span>
<span id="cb20-23"><a aria-hidden="true" href="#cb20-23"></a><span class="pp">#define L </span>(t[u].ch[<span class="dv">0</span>])</span>
<span id="cb20-24"><a aria-hidden="true" href="#cb20-24"></a><span class="pp">#define R </span>(t[u].ch[<span class="dv">1</span>])</span>
<span id="cb20-25"><a aria-hidden="true" href="#cb20-25"></a>} t[maxn];</span>
<span id="cb20-26"><a aria-hidden="true" href="#cb20-26"></a></span>
<span id="cb20-27"><a aria-hidden="true" href="#cb20-27"></a><span class="dt">int</span> cnt, root;</span>
<span id="cb20-28"><a aria-hidden="true" href="#cb20-28"></a></span>
<span id="cb20-29"><a aria-hidden="true" href="#cb20-29"></a><span class="kw">inline</span> <span class="dt">void</span> pushup(<span class="dt">int</span> u) {</span>
<span id="cb20-30"><a aria-hidden="true" href="#cb20-30"></a>    t[u].size = t[L].size + t[R].size + <span class="dv">1</span>;</span>
<span id="cb20-31"><a aria-hidden="true" href="#cb20-31"></a>    <span class="cf">return</span>;</span>
<span id="cb20-32"><a aria-hidden="true" href="#cb20-32"></a>}</span>
<span id="cb20-33"><a aria-hidden="true" href="#cb20-33"></a></span>
<span id="cb20-34"><a aria-hidden="true" href="#cb20-34"></a><span class="kw">inline</span> <span class="dt">void</span> pushdown(<span class="dt">int</span> u) {</span>
<span id="cb20-35"><a aria-hidden="true" href="#cb20-35"></a>    <span class="cf">if</span> (t[u].tag) {</span>
<span id="cb20-36"><a aria-hidden="true" href="#cb20-36"></a>        <span class="dt">int</span> tmp = L; L = R; R = tmp;</span>
<span id="cb20-37"><a aria-hidden="true" href="#cb20-37"></a>        t[L].tag ^= <span class="dv">1</span>, t[R].tag ^= <span class="dv">1</span>;</span>
<span id="cb20-38"><a aria-hidden="true" href="#cb20-38"></a>        t[u].tag = <span class="dv">0</span>;</span>
<span id="cb20-39"><a aria-hidden="true" href="#cb20-39"></a>    }</span>
<span id="cb20-40"><a aria-hidden="true" href="#cb20-40"></a>    <span class="cf">return</span>;</span>
<span id="cb20-41"><a aria-hidden="true" href="#cb20-41"></a>}</span>
<span id="cb20-42"><a aria-hidden="true" href="#cb20-42"></a></span>
<span id="cb20-43"><a aria-hidden="true" href="#cb20-43"></a><span class="dt">void</span> split(<span class="dt">int</span> u, <span class="dt">int</span> size, <span class="dt">int</span>&amp; x, <span class="dt">int</span>&amp; y) {</span>
<span id="cb20-44"><a aria-hidden="true" href="#cb20-44"></a>    <span class="cf">if</span> (!u) {</span>
<span id="cb20-45"><a aria-hidden="true" href="#cb20-45"></a>        x = y = <span class="dv">0</span>;</span>
<span id="cb20-46"><a aria-hidden="true" href="#cb20-46"></a>        <span class="cf">return</span>;</span>
<span id="cb20-47"><a aria-hidden="true" href="#cb20-47"></a>    }</span>
<span id="cb20-48"><a aria-hidden="true" href="#cb20-48"></a>    pushdown(u);</span>
<span id="cb20-49"><a aria-hidden="true" href="#cb20-49"></a>    <span class="cf">if</span> (t[L].size &lt; size)</span>
<span id="cb20-50"><a aria-hidden="true" href="#cb20-50"></a>        x = u, split(R, size - t[L].size - <span class="dv">1</span>, R, y);</span>
<span id="cb20-51"><a aria-hidden="true" href="#cb20-51"></a>    <span class="cf">else</span></span>
<span id="cb20-52"><a aria-hidden="true" href="#cb20-52"></a>        y = u, split(L, size, x, L);</span>
<span id="cb20-53"><a aria-hidden="true" href="#cb20-53"></a>    pushup(u);</span>
<span id="cb20-54"><a aria-hidden="true" href="#cb20-54"></a>    <span class="cf">return</span>;</span>
<span id="cb20-55"><a aria-hidden="true" href="#cb20-55"></a>}</span>
<span id="cb20-56"><a aria-hidden="true" href="#cb20-56"></a></span>
<span id="cb20-57"><a aria-hidden="true" href="#cb20-57"></a><span class="dt">int</span> merge(<span class="dt">int</span> x, <span class="dt">int</span> y) {</span>
<span id="cb20-58"><a aria-hidden="true" href="#cb20-58"></a>    <span class="cf">if</span> (!x || !y)</span>
<span id="cb20-59"><a aria-hidden="true" href="#cb20-59"></a>        <span class="cf">return</span> x + y;</span>
<span id="cb20-60"><a aria-hidden="true" href="#cb20-60"></a>    <span class="cf">if</span> (t[x].key &lt; t[y].key)</span>
<span id="cb20-61"><a aria-hidden="true" href="#cb20-61"></a>        <span class="cf">return</span> pushdown(x), t[x].ch[<span class="dv">1</span>] = merge(t[x].ch[<span class="dv">1</span>], y), pushup(x), x;</span>
<span id="cb20-62"><a aria-hidden="true" href="#cb20-62"></a>    <span class="cf">else</span></span>
<span id="cb20-63"><a aria-hidden="true" href="#cb20-63"></a>        <span class="cf">return</span> pushdown(y), t[y].ch[<span class="dv">0</span>] = merge(x, t[y].ch[<span class="dv">0</span>]), pushup(y), y;</span>
<span id="cb20-64"><a aria-hidden="true" href="#cb20-64"></a>}</span>
<span id="cb20-65"><a aria-hidden="true" href="#cb20-65"></a></span>
<span id="cb20-66"><a aria-hidden="true" href="#cb20-66"></a><span class="dt">int</span> newnode(<span class="dt">int</span> val) {</span>
<span id="cb20-67"><a aria-hidden="true" href="#cb20-67"></a>    t[++cnt].val = val;</span>
<span id="cb20-68"><a aria-hidden="true" href="#cb20-68"></a>    t[cnt].key = rand();</span>
<span id="cb20-69"><a aria-hidden="true" href="#cb20-69"></a>    t[cnt].size = <span class="dv">1</span>;</span>
<span id="cb20-70"><a aria-hidden="true" href="#cb20-70"></a>    <span class="cf">return</span> cnt;</span>
<span id="cb20-71"><a aria-hidden="true" href="#cb20-71"></a>}</span>
<span id="cb20-72"><a aria-hidden="true" href="#cb20-72"></a></span>
<span id="cb20-73"><a aria-hidden="true" href="#cb20-73"></a><span class="dt">void</span> reverse(<span class="dt">int</span> l, <span class="dt">int</span> r) {</span>
<span id="cb20-74"><a aria-hidden="true" href="#cb20-74"></a>    <span class="dt">int</span> x, y, z;</span>
<span id="cb20-75"><a aria-hidden="true" href="#cb20-75"></a>    split(root, l - <span class="dv">1</span>, x, y);</span>
<span id="cb20-76"><a aria-hidden="true" href="#cb20-76"></a>    split(y, r - l + <span class="dv">1</span>, y, z);</span>
<span id="cb20-77"><a aria-hidden="true" href="#cb20-77"></a>    t[y].tag ^= <span class="dv">1</span>;</span>
<span id="cb20-78"><a aria-hidden="true" href="#cb20-78"></a>    root = merge(merge(x, y), z);</span>
<span id="cb20-79"><a aria-hidden="true" href="#cb20-79"></a>    <span class="cf">return</span>;</span>
<span id="cb20-80"><a aria-hidden="true" href="#cb20-80"></a>}</span>
<span id="cb20-81"><a aria-hidden="true" href="#cb20-81"></a></span>
<span id="cb20-82"><a aria-hidden="true" href="#cb20-82"></a><span class="dt">void</span> dfs(<span class="dt">int</span> u) {</span>
<span id="cb20-83"><a aria-hidden="true" href="#cb20-83"></a>    <span class="cf">if</span> (!u)</span>
<span id="cb20-84"><a aria-hidden="true" href="#cb20-84"></a>        <span class="cf">return</span>;</span>
<span id="cb20-85"><a aria-hidden="true" href="#cb20-85"></a>    pushdown(u);</span>
<span id="cb20-86"><a aria-hidden="true" href="#cb20-86"></a>    dfs(L);</span>
<span id="cb20-87"><a aria-hidden="true" href="#cb20-87"></a>    printf(<span class="st">"</span><span class="sc">%d</span><span class="st"> "</span>, t[u].val);</span>
<span id="cb20-88"><a aria-hidden="true" href="#cb20-88"></a>    dfs(R);</span>
<span id="cb20-89"><a aria-hidden="true" href="#cb20-89"></a>    <span class="cf">return</span>;</span>
<span id="cb20-90"><a aria-hidden="true" href="#cb20-90"></a>}</span>
<span id="cb20-91"><a aria-hidden="true" href="#cb20-91"></a></span>
<span id="cb20-92"><a aria-hidden="true" href="#cb20-92"></a><span class="dt">int</span> main() {</span>
<span id="cb20-93"><a aria-hidden="true" href="#cb20-93"></a>    <span class="dt">int</span> n = read(), m = read();</span>
<span id="cb20-94"><a aria-hidden="true" href="#cb20-94"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; ++i)</span>
<span id="cb20-95"><a aria-hidden="true" href="#cb20-95"></a>        root = merge(root, newnode(i));</span>
<span id="cb20-96"><a aria-hidden="true" href="#cb20-96"></a>    <span class="cf">while</span> (m--) {</span>
<span id="cb20-97"><a aria-hidden="true" href="#cb20-97"></a>        <span class="dt">int</span> l = read(), r = read();</span>
<span id="cb20-98"><a aria-hidden="true" href="#cb20-98"></a>        reverse(l, r);</span>
<span id="cb20-99"><a aria-hidden="true" href="#cb20-99"></a>    }</span>
<span id="cb20-100"><a aria-hidden="true" href="#cb20-100"></a>    dfs(root);</span>
<span id="cb20-101"><a aria-hidden="true" href="#cb20-101"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb20-102"><a aria-hidden="true" href="#cb20-102"></a>}</span></code></pre></div>
<p>可见 <span class="math inline">\(100\)</span> 行出头就写完了，比 Splay 好写太多了。</p>
<h3 id="维护区间时的一个-trick">维护区间时的一个 trick</h3>
<p>当我们在使用 FHQ-Treap 维护一段序列时，有时需要快速找出某元素在序列中的位置，怎么办呢？</p>
<p>此时可以在建树时记录下这个元素在树中的节点编号，然后在找寻其排名时自底而上记录在它左边的节点个数。具体可以这样：</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a aria-hidden="true" href="#cb21-1"></a><span class="dt">int</span> getrank(<span class="dt">int</span> u)</span>
<span id="cb21-2"><a aria-hidden="true" href="#cb21-2"></a>{</span>
<span id="cb21-3"><a aria-hidden="true" href="#cb21-3"></a>    <span class="dt">int</span> ret = t[L].size + <span class="dv">1</span>;</span>
<span id="cb21-4"><a aria-hidden="true" href="#cb21-4"></a>    <span class="cf">while</span> (t[u].fa)</span>
<span id="cb21-5"><a aria-hidden="true" href="#cb21-5"></a>    {</span>
<span id="cb21-6"><a aria-hidden="true" href="#cb21-6"></a>        <span class="cf">if</span> (t[t[u].fa].ch[<span class="dv">1</span>] == u)</span>
<span id="cb21-7"><a aria-hidden="true" href="#cb21-7"></a>            ret += t[t[t[u].fa].ch[<span class="dv">0</span>]].size + <span class="dv">1</span>;</span>
<span id="cb21-8"><a aria-hidden="true" href="#cb21-8"></a>        u = t[u].fa;</span>
<span id="cb21-9"><a aria-hidden="true" href="#cb21-9"></a>    }</span>
<span id="cb21-10"><a aria-hidden="true" href="#cb21-10"></a>    <span class="cf">return</span> ret;</span>
<span id="cb21-11"><a aria-hidden="true" href="#cb21-11"></a>}</span></code></pre></div>
<p>对于一个节点 <span class="math inline">\(u\)</span>，首先它的排名就是其左子树大小加一，然后往上跳，在跳的过程中判断一下它是父亲节点的左儿子还是右儿子，如果是右儿子的话，<strong>父亲本身和其兄弟节点都会产生贡献</strong>，一路搜到根即可。</p>
<p><strong>同时 pushup 的时候要更新父亲</strong>，pushup 一个节点的时候顺带更新其两个儿子的父亲（需要判断是否存在）</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a aria-hidden="true" href="#cb22-1"></a><span class="kw">inline</span> <span class="dt">void</span> pushup(<span class="dt">int</span> u)</span>
<span id="cb22-2"><a aria-hidden="true" href="#cb22-2"></a>{</span>
<span id="cb22-3"><a aria-hidden="true" href="#cb22-3"></a>    t[u].size = <span class="dv">1</span>;</span>
<span id="cb22-4"><a aria-hidden="true" href="#cb22-4"></a>    <span class="cf">if</span> (L)</span>
<span id="cb22-5"><a aria-hidden="true" href="#cb22-5"></a>        t[u].size += t[L].size, t[L].fa = u;</span>
<span id="cb22-6"><a aria-hidden="true" href="#cb22-6"></a>    <span class="cf">if</span> (R)</span>
<span id="cb22-7"><a aria-hidden="true" href="#cb22-7"></a>        t[u].size += t[R].size, t[R].fa = u;</span>
<span id="cb22-8"><a aria-hidden="true" href="#cb22-8"></a>    <span class="cf">return</span>;</span>
<span id="cb22-9"><a aria-hidden="true" href="#cb22-9"></a>}</span></code></pre></div>
<p>相关题目 <a href="https://www.luogu.com.cn/problem/P2596">[ZJOI2006]书架</a>、<a href="https://www.luogu.com.cn/problem/P3165">[CQOI2014]排序机械臂</a>，当然这些题都可以用 Splay 解决。</p>
<h3 id="启发式合并">启发式合并</h3>
<p>此处的合并与之前的 merge 操作不同，此处合并的两棵树就是两棵一般的树，不能简单地直接 <span class="math inline">\(O(\log n)\)</span> 合并。此时我们能做的就是将小树暴力递归加入到大树中，复杂度 <span class="math inline">\(O(\log^2 n)\)</span>。具体实现如下：</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a aria-hidden="true" href="#cb23-1"></a><span class="dt">void</span> insert(<span class="dt">int</span>&amp; root, <span class="dt">int</span> u) { <span class="co">//表示将 u 节点加入 root 为根的新树中</span></span>
<span id="cb23-2"><a aria-hidden="true" href="#cb23-2"></a>    <span class="dt">int</span> x, y;</span>
<span id="cb23-3"><a aria-hidden="true" href="#cb23-3"></a>    <span class="dt">int</span> val = t[u].val;</span>
<span id="cb23-4"><a aria-hidden="true" href="#cb23-4"></a>    split(root, val, x, y);</span>
<span id="cb23-5"><a aria-hidden="true" href="#cb23-5"></a>    root = merge(merge(x, u), y);</span>
<span id="cb23-6"><a aria-hidden="true" href="#cb23-6"></a>    <span class="cf">return</span>;</span>
<span id="cb23-7"><a aria-hidden="true" href="#cb23-7"></a>}</span>
<span id="cb23-8"><a aria-hidden="true" href="#cb23-8"></a></span>
<span id="cb23-9"><a aria-hidden="true" href="#cb23-9"></a><span class="dt">void</span> dfs(<span class="dt">int</span> u, <span class="dt">int</span>&amp; root) { <span class="co">//这个 root 的引用是新树的树根</span></span>
<span id="cb23-10"><a aria-hidden="true" href="#cb23-10"></a>    <span class="cf">if</span> (!u)</span>
<span id="cb23-11"><a aria-hidden="true" href="#cb23-11"></a>        <span class="cf">return</span>;</span>
<span id="cb23-12"><a aria-hidden="true" href="#cb23-12"></a>    dfs(L, root);<span class="co">//先把左子树加入</span></span>
<span id="cb23-13"><a aria-hidden="true" href="#cb23-13"></a>    dfs(R, root);<span class="co">//加入右子树</span></span>
<span id="cb23-14"><a aria-hidden="true" href="#cb23-14"></a>    L = R = <span class="dv">0</span>;<span class="co">//清空儿子，这一步不写会出问题</span></span>
<span id="cb23-15"><a aria-hidden="true" href="#cb23-15"></a>    insert(root, u);<span class="co">//再加入自己</span></span>
<span id="cb23-16"><a aria-hidden="true" href="#cb23-16"></a>    <span class="cf">return</span>;</span>
<span id="cb23-17"><a aria-hidden="true" href="#cb23-17"></a>}</span>
<span id="cb23-18"><a aria-hidden="true" href="#cb23-18"></a></span>
<span id="cb23-19"><a aria-hidden="true" href="#cb23-19"></a><span class="dt">int</span> join(<span class="dt">int</span> x, <span class="dt">int</span> y) {</span>
<span id="cb23-20"><a aria-hidden="true" href="#cb23-20"></a>    <span class="cf">if</span> (t[x].size &gt; t[y].size)</span>
<span id="cb23-21"><a aria-hidden="true" href="#cb23-21"></a>        swap(x, y);</span>
<span id="cb23-22"><a aria-hidden="true" href="#cb23-22"></a>    dfs(x, y);<span class="co">//使 x 成为小树然后递归加入 y 中</span></span>
<span id="cb23-23"><a aria-hidden="true" href="#cb23-23"></a>    <span class="cf">return</span> y;<span class="co">//返回新的根 y</span></span>
<span id="cb23-24"><a aria-hidden="true" href="#cb23-24"></a>}</span></code></pre></div>
<p>相关试题 <a href="https://www.luogu.com.cn/problem/P3224">[HNOI2012]永无乡</a></p>
<h3 id="易错点">易错点</h3>
<ul>
<li><strong>分裂代码不背错就行</strong></li>
<li>涉及到分裂完合并的时候<strong>一定记得更新根！！</strong>即 <code>root = merge(...)</code></li>
<li>类似第二点，删除节点过程中合并 <span class="math inline">\(y\)</span> 的左右子树的时候<strong>千万记得更新 <span class="math inline">\(y\)</span> 的值</strong></li>
<li>涉及到子树的操作千万<strong>提前 pushdown</strong></li>
</ul>
<h2 id="splay">Splay</h2>
<h3 id="简介initialization">简介/Initialization</h3>
<p>相较于两种 Treap，Splay（伸展树）则稍微难写一点，Splay 的核心操作就是 splay：即把一个节点旋转到根的位置，以此维护树的平衡。它相较于 Treap 的优点就是可以处理区间信息以及快速合并/分裂（虽然 fhqTreap 也能做到）。</p>
<p>Splay 具有一切 BST 具有的性质，其相较于 Treap 的区别就是它是双旋的，这样可以保证均摊复杂度 <span class="math inline">\(O(\log n)\)</span>（证明要用势能分析，我太菜暂时不会）。首先看下结构体如何定义：</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb24-1"><a aria-hidden="true" href="#cb24-1"></a><span class="kw">struct</span> Splay</span>
<span id="cb24-2"><a aria-hidden="true" href="#cb24-2"></a>{</span>
<span id="cb24-3"><a aria-hidden="true" href="#cb24-3"></a>    <span class="dt">int</span> ch[<span class="dv">2</span>], fa;<span class="co">//与 treap 不同之处在于 splay 需要记录父亲节点的编号</span></span>
<span id="cb24-4"><a aria-hidden="true" href="#cb24-4"></a>    <span class="dt">int</span> cnt, size;</span>
<span id="cb24-5"><a aria-hidden="true" href="#cb24-5"></a>    <span class="dt">int</span> val;</span>
<span id="cb24-6"><a aria-hidden="true" href="#cb24-6"></a>} t[maxn];</span></code></pre></div>
<p>处理旋转的时候是需要知道这个节点是父亲的左儿子还是右儿子的，如下：</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a aria-hidden="true" href="#cb25-1"></a><span class="kw">inline</span> <span class="dt">bool</span> get(<span class="dt">int</span> u)</span>
<span id="cb25-2"><a aria-hidden="true" href="#cb25-2"></a>{</span>
<span id="cb25-3"><a aria-hidden="true" href="#cb25-3"></a>    <span class="cf">return</span> t[t[u].fa].ch[<span class="dv">1</span>] == u;</span>
<span id="cb25-4"><a aria-hidden="true" href="#cb25-4"></a>}</span></code></pre></div>
<p>旋转后与 Treap 一样需要维护 size</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb26-1"><a aria-hidden="true" href="#cb26-1"></a><span class="kw">inline</span> <span class="dt">void</span> maintain(<span class="dt">int</span> u)</span>
<span id="cb26-2"><a aria-hidden="true" href="#cb26-2"></a>{</span>
<span id="cb26-3"><a aria-hidden="true" href="#cb26-3"></a>    t[u].size = t[u].cnt + t[L].size + t[R].size;</span>
<span id="cb26-4"><a aria-hidden="true" href="#cb26-4"></a>    <span class="cf">return</span>;</span>
<span id="cb26-5"><a aria-hidden="true" href="#cb26-5"></a>}</span></code></pre></div>
<h3 id="旋转伸展splay">旋转/伸展（Splay）</h3>
<p>接下来就是该死的旋转操作了：考虑将 <span class="math inline">\(x\)</span> 节点旋转到 <span class="math inline">\(fa\)</span> 的位置，（令 <span class="math inline">\(fa\)</span> 的父节点为 <span class="math inline">\(gfa\)</span>）图示如下：</p>
<figure>
<img alt="" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/splay_r1.png" title="step 1"/><figcaption>step 1</figcaption>
</figure>
<p>这是一开始的情况，首先判断 <span class="math inline">\(x\)</span> 是其父亲的哪个儿子，定义 <span class="math inline">\(d_1\)</span> 为 <span class="math inline">\(0\)</span> 表示是左儿子，<span class="math inline">\(1\)</span> 为右儿子，然后把其父亲的 <span class="math inline">\(d_1\)</span> 儿子变成 <code>t[x].ch[d1^1]</code>，如下，此时由于 <span class="math inline">\(d_1=0\)</span>，所以 <code>d1^1</code> 为右儿子：</p>
<figure>
<img alt="" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/splay_r2.png" title="step 2"/><figcaption>step 2</figcaption>
</figure>
<p>接下来用 <span class="math inline">\(x\)</span> 连接 <span class="math inline">\(gfa\)</span>，代替 <span class="math inline">\(fa\)</span> 的位置</p>
<figure>
<img alt="" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/splay_r3.png" title="step 3"/><figcaption>step 3</figcaption>
</figure>
<p>最后把 <span class="math inline">\(x\)</span> 与 <span class="math inline">\(fa\)</span> 接起来就可以了（即 <code>t[x].ch[d1^1]=fa</code>）</p>
<figure>
<img alt="" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/splay_r4.png" title="step 4"/><figcaption>step 4</figcaption>
</figure>
<p>这样，一次旋转操作就完成了，它完成的就是将一个节点往上旋转到其父亲的位置。代码如下：</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb27-1"><a aria-hidden="true" href="#cb27-1"></a><span class="dt">void</span> rotate(<span class="dt">int</span> u)</span>
<span id="cb27-2"><a aria-hidden="true" href="#cb27-2"></a>{</span>
<span id="cb27-3"><a aria-hidden="true" href="#cb27-3"></a>    <span class="dt">int</span> fa = t[u].fa, gfa = t[fa].fa;</span>
<span id="cb27-4"><a aria-hidden="true" href="#cb27-4"></a>    <span class="dt">int</span> d1 = get(u), d2 = get(fa);</span>
<span id="cb27-5"><a aria-hidden="true" href="#cb27-5"></a>    t[fa].ch[d1] = t[u].ch[d1 ^ <span class="dv">1</span>], t[t[u].ch[d1 ^ <span class="dv">1</span>]].fa = fa;</span>
<span id="cb27-6"><a aria-hidden="true" href="#cb27-6"></a>    <span class="cf">if</span> (gfa)</span>
<span id="cb27-7"><a aria-hidden="true" href="#cb27-7"></a>        t[gfa].ch[d2] = u;</span>
<span id="cb27-8"><a aria-hidden="true" href="#cb27-8"></a>    t[u].fa = gfa;</span>
<span id="cb27-9"><a aria-hidden="true" href="#cb27-9"></a>    t[fa].fa = u, t[u].ch[d1 ^ <span class="dv">1</span>] = fa;</span>
<span id="cb27-10"><a aria-hidden="true" href="#cb27-10"></a>    maintain(fa);<span class="co">//最后不忘维护，注意先维护 fa，理由同 treap</span></span>
<span id="cb27-11"><a aria-hidden="true" href="#cb27-11"></a>    maintain(u);</span>
<span id="cb27-12"><a aria-hidden="true" href="#cb27-12"></a>}</span></code></pre></div>
<p>接下来就是 splay 过程了，<strong>splay 操作的目的就是将指定节点旋转到根节点</strong>，一次操作分为六种情况：</p>
<ul>
<li>如果 <span class="math inline">\(x\)</span> 的父亲为根，则旋转一次</li>
<li>如果 <span class="math inline">\(x\)</span> 的父亲不为根，且 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(fa\)</span> 的儿子类型相同（即“三点共线”，代码中就是 <code>get()</code> 函数返回值相同），那么首先左/右旋 <span class="math inline">\(fa\)</span>，再左/右旋 <span class="math inline">\(x\)</span>（两次单旋的方向相同）</li>
<li>如果在第二种情况种，<span class="math inline">\(x\)</span> 和 <span class="math inline">\(fa\)</span> 的儿子类型不同，则将 <span class="math inline">\(x\)</span> 旋转两次，先左/右再右/左旋（两次单旋的方向不同）</li>
</ul>
<p>”三点共线“的情况见下图：<span class="math inline">\(6\)</span> 为 <span class="math inline">\(x\)</span>，<span class="math inline">\(3\)</span> 为 <span class="math inline">\(fa\)</span>，<span class="math inline">\(2\)</span> 为 <span class="math inline">\(gfa\)</span>。</p>
<figure>
<img alt="" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/splay_s1.png"/><figcaption>step 1</figcaption>
</figure>
<p>可见我们先右旋 <span class="math inline">\(fa\)</span>，得到如下结果：</p>
<figure>
<img alt="" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/splay_s2.png"/><figcaption>step 2</figcaption>
</figure>
<p>接下来再右旋 <span class="math inline">\(x\)</span>，得到：</p>
<figure>
<img alt="" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/splay_s3.png"/><figcaption>step 3</figcaption>
</figure>
<p>三点不共线的情况如下图：</p>
<figure>
<img alt="" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/splay_s4.png"/><figcaption>step 1</figcaption>
</figure>
<p>此时 <span class="math inline">\(x=6\)</span>，<span class="math inline">\(fa=4\)</span>，<span class="math inline">\(gfa=2\)</span>，现在对 <span class="math inline">\(x\)</span> 先进行一次右旋：</p>
<figure>
<img alt="" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/splay_s5.png"/><figcaption>step 2</figcaption>
</figure>
<p>再对 <span class="math inline">\(x\)</span> 进行一次左旋：</p>
<figure>
<img alt="" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/splay_s6.png"/><figcaption>step 3</figcaption>
</figure>
<p>反复执行如上操作，直到 <span class="math inline">\(x\)</span> 成为根后，整个 splay 过程就结束了。</p>
<p>下面的 <code>splay(u,goal)</code> 意为把 <span class="math inline">\(u\)</span> 节点伸展到 <span class="math inline">\(goal\)</span> 节点的儿子处（<span class="math inline">\(goal=0\)</span> 就是使 <span class="math inline">\(u\)</span> 变成根节点）</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb28-1"><a aria-hidden="true" href="#cb28-1"></a><span class="dt">void</span> splay(<span class="dt">int</span> u, <span class="dt">int</span> goal) {</span>
<span id="cb28-2"><a aria-hidden="true" href="#cb28-2"></a>    <span class="cf">while</span> (t[u].fa != goal) {<span class="co">//一直伸展</span></span>
<span id="cb28-3"><a aria-hidden="true" href="#cb28-3"></a>        <span class="dt">int</span> fa = t[u].fa, gfa = t[fa].fa;<span class="co">//找到父亲和爷爷</span></span>
<span id="cb28-4"><a aria-hidden="true" href="#cb28-4"></a>        <span class="dt">int</span> d1 = get(u), d2 = get(fa);<span class="co">//找到 u 是什么儿子，fa 是什么儿子。左0右1</span></span>
<span id="cb28-5"><a aria-hidden="true" href="#cb28-5"></a>        <span class="cf">if</span> (gfa != goal) {<span class="co">//如果爷爷不是根，则需要旋转两次，下面是旋转第一次</span></span>
<span id="cb28-6"><a aria-hidden="true" href="#cb28-6"></a>            <span class="cf">if</span> (d1 == d2)<span class="co">//如果三点共线</span></span>
<span id="cb28-7"><a aria-hidden="true" href="#cb28-7"></a>                rotate(fa);<span class="co">//先旋转 fa</span></span>
<span id="cb28-8"><a aria-hidden="true" href="#cb28-8"></a>            <span class="cf">else</span></span>
<span id="cb28-9"><a aria-hidden="true" href="#cb28-9"></a>                rotate(u);<span class="co">//否则先旋转 u</span></span>
<span id="cb28-10"><a aria-hidden="true" href="#cb28-10"></a>        }</span>
<span id="cb28-11"><a aria-hidden="true" href="#cb28-11"></a>        rotate(u);<span class="co">//第二次旋转</span></span>
<span id="cb28-12"><a aria-hidden="true" href="#cb28-12"></a>    }</span>
<span id="cb28-13"><a aria-hidden="true" href="#cb28-13"></a>    <span class="cf">if</span> (goal == <span class="dv">0</span>)<span class="co">//如果 u 成为根了</span></span>
<span id="cb28-14"><a aria-hidden="true" href="#cb28-14"></a>        root = u;<span class="co">//更新根的值</span></span>
<span id="cb28-15"><a aria-hidden="true" href="#cb28-15"></a>}</span></code></pre></div>
<h3 id="插入-1">插入</h3>
<p>插入操作就比较简单了，由于 Splay 的形态是可以改变的，所以不需要递归。<strong>每插入一个元素都进行一次 Splay 操作让其变为根</strong></p>
<div class="sourceCode" id="cb29"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb29-1"><a aria-hidden="true" href="#cb29-1"></a><span class="dt">void</span> insert(<span class="dt">int</span> val) {</span>
<span id="cb29-2"><a aria-hidden="true" href="#cb29-2"></a>    <span class="dt">int</span> u = root, fa = <span class="dv">0</span>;</span>
<span id="cb29-3"><a aria-hidden="true" href="#cb29-3"></a>    <span class="cf">while</span> (u &amp;&amp; t[u].val != val)</span>
<span id="cb29-4"><a aria-hidden="true" href="#cb29-4"></a>        fa = u, u = t[u].ch[t[u].val &lt; val];<span class="co">//往下走</span></span>
<span id="cb29-5"><a aria-hidden="true" href="#cb29-5"></a>    <span class="cf">if</span> (u)<span class="co">//如果节点已经存在</span></span>
<span id="cb29-6"><a aria-hidden="true" href="#cb29-6"></a>        t[u].cnt++;</span>
<span id="cb29-7"><a aria-hidden="true" href="#cb29-7"></a>    <span class="cf">else</span> {</span>
<span id="cb29-8"><a aria-hidden="true" href="#cb29-8"></a>        u = ++cnt;<span class="co">//否则新开节点</span></span>
<span id="cb29-9"><a aria-hidden="true" href="#cb29-9"></a>        <span class="cf">if</span> (fa)<span class="co">//如果自己不是根</span></span>
<span id="cb29-10"><a aria-hidden="true" href="#cb29-10"></a>            t[fa].ch[t[fa].val &lt; val] = u;</span>
<span id="cb29-11"><a aria-hidden="true" href="#cb29-11"></a>        t[u].fa = fa;</span>
<span id="cb29-12"><a aria-hidden="true" href="#cb29-12"></a>        t[u].size = t[u].cnt = <span class="dv">1</span>;</span>
<span id="cb29-13"><a aria-hidden="true" href="#cb29-13"></a>        t[u].val = val;</span>
<span id="cb29-14"><a aria-hidden="true" href="#cb29-14"></a>    }</span>
<span id="cb29-15"><a aria-hidden="true" href="#cb29-15"></a>    splay(u, <span class="dv">0</span>);<span class="co">//为了降低均摊复杂度，需要将新插入的节点 splay 到根</span></span>
<span id="cb29-16"><a aria-hidden="true" href="#cb29-16"></a>}</span></code></pre></div>
<h3 id="排名第-k-小大">排名/第 <span class="math inline">\(k\)</span> 小/大</h3>
<p>由于 Splay 的形态可以改变，因此在查询排名的时候可以直接将其 splay 到树根，然后统计左子树大小再 +1 就可以了。当然首先需要找到对应的数在哪里，下面先实现 <code>find(int val)</code> 函数，它返回刚好等于 <span class="math inline">\(val\)</span> 的节点的编号（如果存在的话），不存在则返回一个叶子节点（<strong>手玩一下便知它返回的要么是前驱要么是后继，但不一定是与 <span class="math inline">\(val\)</span> 的值最接近的节点，但是一定可以保证返回的排名是正确的</strong>）。然后 <code>rank()</code> 函数的实现就相当简单了：</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb30-1"><a aria-hidden="true" href="#cb30-1"></a><span class="dt">int</span> find(<span class="dt">int</span> val) {</span>
<span id="cb30-2"><a aria-hidden="true" href="#cb30-2"></a>    <span class="dt">int</span> u = root;</span>
<span id="cb30-3"><a aria-hidden="true" href="#cb30-3"></a>    <span class="cf">while</span> (t[u].val != val &amp;&amp; t[u].ch[t[u].val &lt; val])</span>
<span id="cb30-4"><a aria-hidden="true" href="#cb30-4"></a>        u = t[u].ch[t[u].val &lt; val];</span>
<span id="cb30-5"><a aria-hidden="true" href="#cb30-5"></a>    <span class="cf">return</span> u;</span>
<span id="cb30-6"><a aria-hidden="true" href="#cb30-6"></a>}</span>
<span id="cb30-7"><a aria-hidden="true" href="#cb30-7"></a><span class="dt">int</span> rank(<span class="dt">int</span> val) {</span>
<span id="cb30-8"><a aria-hidden="true" href="#cb30-8"></a>    splay(find(val), <span class="dv">0</span>);<span class="co">//先把对应节点旋转到根</span></span>
<span id="cb30-9"><a aria-hidden="true" href="#cb30-9"></a>    <span class="cf">return</span> t[t[root].ch[<span class="dv">0</span>]].size + <span class="dv">1</span>;<span class="co">//直接根的左子树大小加 1</span></span>
<span id="cb30-10"><a aria-hidden="true" href="#cb30-10"></a>}</span></code></pre></div>
<p><strong>需要注意的是如果查询排名的数不存在的话会出一些奇奇怪怪的问题，所以在写加强版模板的时候推荐使用下面的写法：</strong></p>
<div class="sourceCode" id="cb31"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb31-1"><a aria-hidden="true" href="#cb31-1"></a><span class="dt">int</span> rank(<span class="dt">int</span> val) {</span>
<span id="cb31-2"><a aria-hidden="true" href="#cb31-2"></a>    insert(val);</span>
<span id="cb31-3"><a aria-hidden="true" href="#cb31-3"></a>    <span class="dt">int</span> ans = t[t[root].ch[<span class="dv">0</span>]].size + <span class="dv">1</span>;</span>
<span id="cb31-4"><a aria-hidden="true" href="#cb31-4"></a>    delnode(val);</span>
<span id="cb31-5"><a aria-hidden="true" href="#cb31-5"></a>    <span class="cf">return</span> ans;</span>
<span id="cb31-6"><a aria-hidden="true" href="#cb31-6"></a>}</span></code></pre></div>
<p>第 <span class="math inline">\(k\)</span> 小。类似递归的查找即可，注意查询右子树的时候要减去本身和左子树的贡献：</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb32-1"><a aria-hidden="true" href="#cb32-1"></a><span class="dt">int</span> kth(<span class="dt">int</span> k) {</span>
<span id="cb32-2"><a aria-hidden="true" href="#cb32-2"></a>    <span class="dt">int</span> u = root;</span>
<span id="cb32-3"><a aria-hidden="true" href="#cb32-3"></a>    <span class="cf">while</span> (<span class="kw">true</span>) {</span>
<span id="cb32-4"><a aria-hidden="true" href="#cb32-4"></a>        <span class="cf">if</span> (k &lt;= t[L].size)<span class="co">//如果第 k 小在左子树中</span></span>
<span id="cb32-5"><a aria-hidden="true" href="#cb32-5"></a>            u = L;</span>
<span id="cb32-6"><a aria-hidden="true" href="#cb32-6"></a>        <span class="cf">else</span> <span class="cf">if</span> (k &gt; t[L].size + t[u].cnt) { <span class="co">//如果第 k 小在右子树中</span></span>
<span id="cb32-7"><a aria-hidden="true" href="#cb32-7"></a>            k -= t[L].size + t[u].cnt;<span class="co">//减去 L 和 u 产生的贡献</span></span>
<span id="cb32-8"><a aria-hidden="true" href="#cb32-8"></a>            u = R;</span>
<span id="cb32-9"><a aria-hidden="true" href="#cb32-9"></a>        } <span class="cf">else</span> <span class="cf">return</span> t[u].val;<span class="co">//否则就是自己了，返回即可</span></span>
<span id="cb32-10"><a aria-hidden="true" href="#cb32-10"></a>    }</span>
<span id="cb32-11"><a aria-hidden="true" href="#cb32-11"></a>}</span></code></pre></div>
<h3 id="前驱后继删除">前驱后继/删除</h3>
<p>同排名操作，考虑直接把 <span class="math inline">\(val\)</span> 节点翻到根。此时<strong>前驱要么就是根节点，要么就是左子树中最靠右的节点</strong>。由 <code>find()</code> 函数的性质，如果 <span class="math inline">\(val\)</span> 存在，则前驱一定在左子树里面的最右边，如果 <span class="math inline">\(val\)</span> 不存在，则翻上来的点要么是前驱要么是后继，如果小于 <span class="math inline">\(val\)</span> 就直接返回，大于 <span class="math inline">\(val\)</span> 则和第一种情况一样，在左子树里面的最右边。</p>
<p>而后继几乎同理。不难写出如下代码：</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb33-1"><a aria-hidden="true" href="#cb33-1"></a><span class="dt">int</span> getnxt(<span class="dt">int</span> val, <span class="dt">int</span> opt) {<span class="co">//opt=0 是前驱，1 是后继</span></span>
<span id="cb33-2"><a aria-hidden="true" href="#cb33-2"></a>    splay(find(val), <span class="dv">0</span>);<span class="co">//先把对应节点翻到根</span></span>
<span id="cb33-3"><a aria-hidden="true" href="#cb33-3"></a>    <span class="dt">int</span> u = root;</span>
<span id="cb33-4"><a aria-hidden="true" href="#cb33-4"></a>    <span class="cf">if</span> (t[u].val &lt; val &amp;&amp; (!opt))<span class="co">//如果要找前驱并且根就是前驱，直接返回即可</span></span>
<span id="cb33-5"><a aria-hidden="true" href="#cb33-5"></a>        <span class="cf">return</span> u;</span>
<span id="cb33-6"><a aria-hidden="true" href="#cb33-6"></a>    <span class="cf">if</span> (t[u].val &gt; val &amp;&amp; opt)<span class="co">//同理，要查找后继并且根就是后继</span></span>
<span id="cb33-7"><a aria-hidden="true" href="#cb33-7"></a>        <span class="cf">return</span> u;</span>
<span id="cb33-8"><a aria-hidden="true" href="#cb33-8"></a>    u = t[u].ch[opt];<span class="co">//否则到左/右子树查找</span></span>
<span id="cb33-9"><a aria-hidden="true" href="#cb33-9"></a>    <span class="cf">while</span> (t[u].ch[opt ^ <span class="dv">1</span>])<span class="co">//查找最右/左边的节点</span></span>
<span id="cb33-10"><a aria-hidden="true" href="#cb33-10"></a>        u = t[u].ch[opt ^ <span class="dv">1</span>];</span>
<span id="cb33-11"><a aria-hidden="true" href="#cb33-11"></a>    <span class="cf">return</span> u;</span>
<span id="cb33-12"><a aria-hidden="true" href="#cb33-12"></a>}</span></code></pre></div>
<p>注意这个函数返回的是前驱/后继在树中的编号，为什么要这样呢，为了下面的删除操作。</p>
<p>删除一个数时，注意我们如果将其 splay 到根的话，会发现左右子树不好处理。怎么办呢，<strong>把前驱旋转到根，然后把后继翻到前驱的下面</strong>，此时 <code>splay()</code> 函数的 <span class="math inline">\(goal\)</span> 参数就体现出它的作用了。</p>
<p>不难发现，此时 <strong><span class="math inline">\(val\)</span> 一定是后继节点的左儿子</strong>，如图（回想一下前驱和后继的定义，你会发现确实是这样的）：</p>
<figure>
<img alt="" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/splay_del.png"/><figcaption>证明很简单，可以自己思考思考</figcaption>
</figure>
<p>问题现在就很简单了，只需要删除掉 <span class="math inline">\(suc\)</span> 的左儿子就可以了，如果有多个那就 <code>cnt--</code> 并把对应节点 splay 到根，只有一个就把 <span class="math inline">\(suc\)</span> 的左儿子设为空即可。<strong>现在知道为什么上面前驱和后继的函数返回的是节点编号了吧</strong></p>
<div class="sourceCode" id="cb34"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb34-1"><a aria-hidden="true" href="#cb34-1"></a><span class="dt">void</span> delnode(<span class="dt">int</span> val) {</span>
<span id="cb34-2"><a aria-hidden="true" href="#cb34-2"></a>    <span class="dt">int</span> pre = getnxt(val, <span class="dv">0</span>);</span>
<span id="cb34-3"><a aria-hidden="true" href="#cb34-3"></a>    <span class="dt">int</span> suc = getnxt(val, <span class="dv">1</span>);</span>
<span id="cb34-4"><a aria-hidden="true" href="#cb34-4"></a>    splay(pre, <span class="dv">0</span>);</span>
<span id="cb34-5"><a aria-hidden="true" href="#cb34-5"></a>    splay(suc, pre);<span class="co">//把后继旋转到前驱的儿子</span></span>
<span id="cb34-6"><a aria-hidden="true" href="#cb34-6"></a>    <span class="cf">if</span>(t[t[suc].ch[<span class="dv">0</span>]].cnt &gt; <span class="dv">1</span>) {</span>
<span id="cb34-7"><a aria-hidden="true" href="#cb34-7"></a>        t[t[suc].ch[<span class="dv">0</span>]].cnt--;</span>
<span id="cb34-8"><a aria-hidden="true" href="#cb34-8"></a>        splay(t[suc].ch[<span class="dv">0</span>], <span class="dv">0</span>);<span class="co">//不忘再splay一次</span></span>
<span id="cb34-9"><a aria-hidden="true" href="#cb34-9"></a>    } <span class="cf">else</span> t[suc].ch[<span class="dv">0</span>] = <span class="dv">0</span>;</span>
<span id="cb34-10"><a aria-hidden="true" href="#cb34-10"></a>    <span class="cf">return</span>;</span>
<span id="cb34-11"><a aria-hidden="true" href="#cb34-11"></a>}</span></code></pre></div>
<h3 id="普通平衡树的实现-1">普通平衡树的实现</h3>
<p>唯一要注意的就是一开始需要先插入正负无穷，然后算出来的排名要减一，查询的 <span class="math inline">\(k\)</span> 要加一</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb35-1"><a aria-hidden="true" href="#cb35-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb35-2"><a aria-hidden="true" href="#cb35-2"></a><span class="pp">#include </span><span class="im">&lt;cctype&gt;</span></span>
<span id="cb35-3"><a aria-hidden="true" href="#cb35-3"></a><span class="pp">#define L </span>t[u].ch[<span class="dv">0</span>]</span>
<span id="cb35-4"><a aria-hidden="true" href="#cb35-4"></a><span class="pp">#define R </span>t[u].ch[<span class="dv">1</span>]</span>
<span id="cb35-5"><a aria-hidden="true" href="#cb35-5"></a></span>
<span id="cb35-6"><a aria-hidden="true" href="#cb35-6"></a><span class="kw">inline</span> <span class="dt">int</span> read() {</span>
<span id="cb35-7"><a aria-hidden="true" href="#cb35-7"></a>    <span class="dt">char</span> c = getchar();</span>
<span id="cb35-8"><a aria-hidden="true" href="#cb35-8"></a>    <span class="dt">int</span> s = <span class="dv">0</span>;</span>
<span id="cb35-9"><a aria-hidden="true" href="#cb35-9"></a>    <span class="dt">bool</span> x = <span class="dv">0</span>;</span>
<span id="cb35-10"><a aria-hidden="true" href="#cb35-10"></a>    <span class="cf">while</span> (!isdigit(c))</span>
<span id="cb35-11"><a aria-hidden="true" href="#cb35-11"></a>        x = x | (c == <span class="ch">'-'</span>), c = getchar();</span>
<span id="cb35-12"><a aria-hidden="true" href="#cb35-12"></a>    <span class="cf">while</span> (isdigit(c))</span>
<span id="cb35-13"><a aria-hidden="true" href="#cb35-13"></a>        s = <span class="dv">10</span> * s + c - <span class="ch">'0'</span>, c = getchar();</span>
<span id="cb35-14"><a aria-hidden="true" href="#cb35-14"></a>    <span class="cf">return</span> x ? -s : s;</span>
<span id="cb35-15"><a aria-hidden="true" href="#cb35-15"></a>}</span>
<span id="cb35-16"><a aria-hidden="true" href="#cb35-16"></a></span>
<span id="cb35-17"><a aria-hidden="true" href="#cb35-17"></a><span class="kw">inline</span> <span class="dt">int</span> max(<span class="dt">int</span> a, <span class="dt">int</span> b) { <span class="cf">return</span> a &gt; b ? a : b; }</span>
<span id="cb35-18"><a aria-hidden="true" href="#cb35-18"></a><span class="kw">inline</span> <span class="dt">int</span> min(<span class="dt">int</span> a, <span class="dt">int</span> b) { <span class="cf">return</span> a &lt; b ? a : b; }</span>
<span id="cb35-19"><a aria-hidden="true" href="#cb35-19"></a></span>
<span id="cb35-20"><a aria-hidden="true" href="#cb35-20"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">1e5</span> + <span class="dv">5</span>, inf = <span class="bn">0x3f3f3f3f</span>;</span>
<span id="cb35-21"><a aria-hidden="true" href="#cb35-21"></a><span class="dt">int</span> cnt, root;</span>
<span id="cb35-22"><a aria-hidden="true" href="#cb35-22"></a></span>
<span id="cb35-23"><a aria-hidden="true" href="#cb35-23"></a><span class="kw">struct</span> Splay {</span>
<span id="cb35-24"><a aria-hidden="true" href="#cb35-24"></a>    <span class="dt">int</span> ch[<span class="dv">2</span>], fa;</span>
<span id="cb35-25"><a aria-hidden="true" href="#cb35-25"></a>    <span class="dt">int</span> cnt, size;</span>
<span id="cb35-26"><a aria-hidden="true" href="#cb35-26"></a>    <span class="dt">int</span> val;</span>
<span id="cb35-27"><a aria-hidden="true" href="#cb35-27"></a>} t[maxn];</span>
<span id="cb35-28"><a aria-hidden="true" href="#cb35-28"></a></span>
<span id="cb35-29"><a aria-hidden="true" href="#cb35-29"></a><span class="kw">inline</span> <span class="dt">bool</span> get(<span class="dt">int</span> u) {</span>
<span id="cb35-30"><a aria-hidden="true" href="#cb35-30"></a>    <span class="cf">return</span> t[t[u].fa].ch[<span class="dv">1</span>] == u;</span>
<span id="cb35-31"><a aria-hidden="true" href="#cb35-31"></a>}</span>
<span id="cb35-32"><a aria-hidden="true" href="#cb35-32"></a></span>
<span id="cb35-33"><a aria-hidden="true" href="#cb35-33"></a><span class="kw">inline</span> <span class="dt">void</span> maintain(<span class="dt">int</span> u) {</span>
<span id="cb35-34"><a aria-hidden="true" href="#cb35-34"></a>    t[u].size = t[u].cnt + t[L].size + t[R].size;</span>
<span id="cb35-35"><a aria-hidden="true" href="#cb35-35"></a>    <span class="cf">return</span>;</span>
<span id="cb35-36"><a aria-hidden="true" href="#cb35-36"></a>}</span>
<span id="cb35-37"><a aria-hidden="true" href="#cb35-37"></a></span>
<span id="cb35-38"><a aria-hidden="true" href="#cb35-38"></a><span class="dt">void</span> rotate(<span class="dt">int</span> u) {</span>
<span id="cb35-39"><a aria-hidden="true" href="#cb35-39"></a>    <span class="dt">int</span> fa = t[u].fa, gfa = t[fa].fa;</span>
<span id="cb35-40"><a aria-hidden="true" href="#cb35-40"></a>    <span class="dt">int</span> d1 = get(u), d2 = get(fa);</span>
<span id="cb35-41"><a aria-hidden="true" href="#cb35-41"></a>    t[fa].ch[d1] = t[u].ch[d1 ^ <span class="dv">1</span>], t[t[u].ch[d1 ^ <span class="dv">1</span>]].fa = fa;</span>
<span id="cb35-42"><a aria-hidden="true" href="#cb35-42"></a>    t[gfa].ch[d2] = u, t[u].fa = gfa;</span>
<span id="cb35-43"><a aria-hidden="true" href="#cb35-43"></a>    t[fa].fa = u, t[u].ch[d1 ^ <span class="dv">1</span>] = fa;</span>
<span id="cb35-44"><a aria-hidden="true" href="#cb35-44"></a>    maintain(fa);</span>
<span id="cb35-45"><a aria-hidden="true" href="#cb35-45"></a>    maintain(u);</span>
<span id="cb35-46"><a aria-hidden="true" href="#cb35-46"></a>}</span>
<span id="cb35-47"><a aria-hidden="true" href="#cb35-47"></a></span>
<span id="cb35-48"><a aria-hidden="true" href="#cb35-48"></a><span class="dt">void</span> splay(<span class="dt">int</span> u, <span class="dt">int</span> goal) {</span>
<span id="cb35-49"><a aria-hidden="true" href="#cb35-49"></a>    <span class="cf">while</span> (t[u].fa != goal) {</span>
<span id="cb35-50"><a aria-hidden="true" href="#cb35-50"></a>        <span class="dt">int</span> fa = t[u].fa, gfa = t[fa].fa;</span>
<span id="cb35-51"><a aria-hidden="true" href="#cb35-51"></a>        <span class="dt">int</span> d1 = get(u), d2 = get(fa);</span>
<span id="cb35-52"><a aria-hidden="true" href="#cb35-52"></a>        <span class="cf">if</span> (gfa != goal) {</span>
<span id="cb35-53"><a aria-hidden="true" href="#cb35-53"></a>            <span class="cf">if</span> (d1 == d2)</span>
<span id="cb35-54"><a aria-hidden="true" href="#cb35-54"></a>                rotate(fa);</span>
<span id="cb35-55"><a aria-hidden="true" href="#cb35-55"></a>            <span class="cf">else</span></span>
<span id="cb35-56"><a aria-hidden="true" href="#cb35-56"></a>                rotate(u);</span>
<span id="cb35-57"><a aria-hidden="true" href="#cb35-57"></a>        }</span>
<span id="cb35-58"><a aria-hidden="true" href="#cb35-58"></a>        rotate(u);</span>
<span id="cb35-59"><a aria-hidden="true" href="#cb35-59"></a>    }</span>
<span id="cb35-60"><a aria-hidden="true" href="#cb35-60"></a>    <span class="cf">if</span> (goal == <span class="dv">0</span>)</span>
<span id="cb35-61"><a aria-hidden="true" href="#cb35-61"></a>        root = u;</span>
<span id="cb35-62"><a aria-hidden="true" href="#cb35-62"></a>}</span>
<span id="cb35-63"><a aria-hidden="true" href="#cb35-63"></a></span>
<span id="cb35-64"><a aria-hidden="true" href="#cb35-64"></a><span class="dt">void</span> insert(<span class="dt">int</span> val) {</span>
<span id="cb35-65"><a aria-hidden="true" href="#cb35-65"></a>    <span class="dt">int</span> u = root, fa = <span class="dv">0</span>;</span>
<span id="cb35-66"><a aria-hidden="true" href="#cb35-66"></a>    <span class="cf">while</span> (u &amp;&amp; t[u].val != val)</span>
<span id="cb35-67"><a aria-hidden="true" href="#cb35-67"></a>        fa = u, u = t[u].ch[t[u].val &lt; val];</span>
<span id="cb35-68"><a aria-hidden="true" href="#cb35-68"></a>    <span class="cf">if</span> (u)</span>
<span id="cb35-69"><a aria-hidden="true" href="#cb35-69"></a>        t[u].cnt++;</span>
<span id="cb35-70"><a aria-hidden="true" href="#cb35-70"></a>    <span class="cf">else</span> {</span>
<span id="cb35-71"><a aria-hidden="true" href="#cb35-71"></a>        u = ++cnt;</span>
<span id="cb35-72"><a aria-hidden="true" href="#cb35-72"></a>        <span class="cf">if</span> (fa)</span>
<span id="cb35-73"><a aria-hidden="true" href="#cb35-73"></a>            t[fa].ch[t[fa].val &lt; val] = u;</span>
<span id="cb35-74"><a aria-hidden="true" href="#cb35-74"></a>        t[u].fa = fa;</span>
<span id="cb35-75"><a aria-hidden="true" href="#cb35-75"></a>        t[u].size = t[u].cnt = <span class="dv">1</span>;</span>
<span id="cb35-76"><a aria-hidden="true" href="#cb35-76"></a>        t[u].val = val;</span>
<span id="cb35-77"><a aria-hidden="true" href="#cb35-77"></a>    }</span>
<span id="cb35-78"><a aria-hidden="true" href="#cb35-78"></a>    splay(u, <span class="dv">0</span>);</span>
<span id="cb35-79"><a aria-hidden="true" href="#cb35-79"></a>}</span>
<span id="cb35-80"><a aria-hidden="true" href="#cb35-80"></a></span>
<span id="cb35-81"><a aria-hidden="true" href="#cb35-81"></a><span class="dt">int</span> find(<span class="dt">int</span> val) {</span>
<span id="cb35-82"><a aria-hidden="true" href="#cb35-82"></a>    <span class="dt">int</span> u = root;</span>
<span id="cb35-83"><a aria-hidden="true" href="#cb35-83"></a>    <span class="cf">while</span> (t[u].val != val &amp;&amp; t[u].ch[t[u].val &lt; val])</span>
<span id="cb35-84"><a aria-hidden="true" href="#cb35-84"></a>        u = t[u].ch[t[u].val &lt; val];</span>
<span id="cb35-85"><a aria-hidden="true" href="#cb35-85"></a>    <span class="cf">return</span> u;</span>
<span id="cb35-86"><a aria-hidden="true" href="#cb35-86"></a>}</span>
<span id="cb35-87"><a aria-hidden="true" href="#cb35-87"></a></span>
<span id="cb35-88"><a aria-hidden="true" href="#cb35-88"></a><span class="dt">int</span> rank(<span class="dt">int</span> val) {</span>
<span id="cb35-89"><a aria-hidden="true" href="#cb35-89"></a>    splay(find(val), <span class="dv">0</span>);</span>
<span id="cb35-90"><a aria-hidden="true" href="#cb35-90"></a>    <span class="cf">return</span> t[t[root].ch[<span class="dv">0</span>]].size + <span class="dv">1</span>;</span>
<span id="cb35-91"><a aria-hidden="true" href="#cb35-91"></a>}</span>
<span id="cb35-92"><a aria-hidden="true" href="#cb35-92"></a></span>
<span id="cb35-93"><a aria-hidden="true" href="#cb35-93"></a><span class="dt">int</span> kth(<span class="dt">int</span> k) {</span>
<span id="cb35-94"><a aria-hidden="true" href="#cb35-94"></a>    <span class="dt">int</span> u = root;</span>
<span id="cb35-95"><a aria-hidden="true" href="#cb35-95"></a>    <span class="cf">while</span> (<span class="kw">true</span>) {</span>
<span id="cb35-96"><a aria-hidden="true" href="#cb35-96"></a>        <span class="cf">if</span> (k &lt;= t[L].size)</span>
<span id="cb35-97"><a aria-hidden="true" href="#cb35-97"></a>            u = L;</span>
<span id="cb35-98"><a aria-hidden="true" href="#cb35-98"></a>        <span class="cf">else</span> <span class="cf">if</span> (k &gt; t[L].size + t[u].cnt) {</span>
<span id="cb35-99"><a aria-hidden="true" href="#cb35-99"></a>            k -= t[L].size + t[u].cnt;</span>
<span id="cb35-100"><a aria-hidden="true" href="#cb35-100"></a>            u = R;</span>
<span id="cb35-101"><a aria-hidden="true" href="#cb35-101"></a>        }</span>
<span id="cb35-102"><a aria-hidden="true" href="#cb35-102"></a>        <span class="cf">else</span></span>
<span id="cb35-103"><a aria-hidden="true" href="#cb35-103"></a>            <span class="cf">return</span> t[u].val;</span>
<span id="cb35-104"><a aria-hidden="true" href="#cb35-104"></a>    }</span>
<span id="cb35-105"><a aria-hidden="true" href="#cb35-105"></a>}</span>
<span id="cb35-106"><a aria-hidden="true" href="#cb35-106"></a></span>
<span id="cb35-107"><a aria-hidden="true" href="#cb35-107"></a><span class="dt">int</span> getnxt(<span class="dt">int</span> val, <span class="dt">int</span> opt) {</span>
<span id="cb35-108"><a aria-hidden="true" href="#cb35-108"></a>    splay(find(val), <span class="dv">0</span>);</span>
<span id="cb35-109"><a aria-hidden="true" href="#cb35-109"></a>    <span class="dt">int</span> u = root;</span>
<span id="cb35-110"><a aria-hidden="true" href="#cb35-110"></a>    <span class="cf">if</span> (t[u].val &lt; val &amp;&amp; (!opt))</span>
<span id="cb35-111"><a aria-hidden="true" href="#cb35-111"></a>        <span class="cf">return</span> u;</span>
<span id="cb35-112"><a aria-hidden="true" href="#cb35-112"></a>    <span class="cf">if</span> (t[u].val &gt; val &amp;&amp; opt)</span>
<span id="cb35-113"><a aria-hidden="true" href="#cb35-113"></a>        <span class="cf">return</span> u;</span>
<span id="cb35-114"><a aria-hidden="true" href="#cb35-114"></a>    u = t[u].ch[opt];</span>
<span id="cb35-115"><a aria-hidden="true" href="#cb35-115"></a>    <span class="cf">while</span> (t[u].ch[opt ^ <span class="dv">1</span>])</span>
<span id="cb35-116"><a aria-hidden="true" href="#cb35-116"></a>        u = t[u].ch[opt ^ <span class="dv">1</span>];</span>
<span id="cb35-117"><a aria-hidden="true" href="#cb35-117"></a>    <span class="cf">return</span> u;</span>
<span id="cb35-118"><a aria-hidden="true" href="#cb35-118"></a>}</span>
<span id="cb35-119"><a aria-hidden="true" href="#cb35-119"></a></span>
<span id="cb35-120"><a aria-hidden="true" href="#cb35-120"></a><span class="dt">void</span> delnode(<span class="dt">int</span> val) {</span>
<span id="cb35-121"><a aria-hidden="true" href="#cb35-121"></a>    <span class="dt">int</span> pre = getnxt(val, <span class="dv">0</span>);</span>
<span id="cb35-122"><a aria-hidden="true" href="#cb35-122"></a>    <span class="dt">int</span> suc = getnxt(val, <span class="dv">1</span>);</span>
<span id="cb35-123"><a aria-hidden="true" href="#cb35-123"></a>    splay(pre, <span class="dv">0</span>);</span>
<span id="cb35-124"><a aria-hidden="true" href="#cb35-124"></a>    splay(suc, pre);</span>
<span id="cb35-125"><a aria-hidden="true" href="#cb35-125"></a>    <span class="cf">if</span> (t[t[suc].ch[<span class="dv">0</span>]].cnt &gt; <span class="dv">1</span>) {</span>
<span id="cb35-126"><a aria-hidden="true" href="#cb35-126"></a>        t[t[suc].ch[<span class="dv">0</span>]].cnt--;</span>
<span id="cb35-127"><a aria-hidden="true" href="#cb35-127"></a>        splay(t[suc].ch[<span class="dv">0</span>], <span class="dv">0</span>);</span>
<span id="cb35-128"><a aria-hidden="true" href="#cb35-128"></a>    }</span>
<span id="cb35-129"><a aria-hidden="true" href="#cb35-129"></a>    <span class="cf">else</span> t[suc].ch[<span class="dv">0</span>] = <span class="dv">0</span>;</span>
<span id="cb35-130"><a aria-hidden="true" href="#cb35-130"></a>    <span class="cf">return</span>;</span>
<span id="cb35-131"><a aria-hidden="true" href="#cb35-131"></a>}</span>
<span id="cb35-132"><a aria-hidden="true" href="#cb35-132"></a></span>
<span id="cb35-133"><a aria-hidden="true" href="#cb35-133"></a><span class="dt">int</span> main() {</span>
<span id="cb35-134"><a aria-hidden="true" href="#cb35-134"></a>    insert(inf), insert(-inf);</span>
<span id="cb35-135"><a aria-hidden="true" href="#cb35-135"></a>    <span class="dt">int</span> n = read();</span>
<span id="cb35-136"><a aria-hidden="true" href="#cb35-136"></a>    <span class="cf">while</span> (n--) {</span>
<span id="cb35-137"><a aria-hidden="true" href="#cb35-137"></a>        <span class="dt">int</span> opt = read(), x = read();</span>
<span id="cb35-138"><a aria-hidden="true" href="#cb35-138"></a>        <span class="cf">switch</span> (opt) {</span>
<span id="cb35-139"><a aria-hidden="true" href="#cb35-139"></a>        <span class="cf">case</span> <span class="dv">1</span>:</span>
<span id="cb35-140"><a aria-hidden="true" href="#cb35-140"></a>            insert(x);</span>
<span id="cb35-141"><a aria-hidden="true" href="#cb35-141"></a>            <span class="cf">break</span>;</span>
<span id="cb35-142"><a aria-hidden="true" href="#cb35-142"></a>        <span class="cf">case</span> <span class="dv">2</span>:</span>
<span id="cb35-143"><a aria-hidden="true" href="#cb35-143"></a>            delnode(x);</span>
<span id="cb35-144"><a aria-hidden="true" href="#cb35-144"></a>            <span class="cf">break</span>;</span>
<span id="cb35-145"><a aria-hidden="true" href="#cb35-145"></a>        <span class="cf">case</span> <span class="dv">3</span>:</span>
<span id="cb35-146"><a aria-hidden="true" href="#cb35-146"></a>            printf(<span class="st">"</span><span class="sc">%d\n</span><span class="st">"</span>, rank(x) - <span class="dv">1</span>);</span>
<span id="cb35-147"><a aria-hidden="true" href="#cb35-147"></a>            <span class="cf">break</span>;</span>
<span id="cb35-148"><a aria-hidden="true" href="#cb35-148"></a>        <span class="cf">case</span> <span class="dv">4</span>:</span>
<span id="cb35-149"><a aria-hidden="true" href="#cb35-149"></a>            printf(<span class="st">"</span><span class="sc">%d\n</span><span class="st">"</span>, kth(x+<span class="dv">1</span>));</span>
<span id="cb35-150"><a aria-hidden="true" href="#cb35-150"></a>            <span class="cf">break</span>;</span>
<span id="cb35-151"><a aria-hidden="true" href="#cb35-151"></a>        <span class="cf">case</span> <span class="dv">5</span>:</span>
<span id="cb35-152"><a aria-hidden="true" href="#cb35-152"></a>            printf(<span class="st">"</span><span class="sc">%d\n</span><span class="st">"</span>, t[getnxt(x, <span class="dv">0</span>)].val);</span>
<span id="cb35-153"><a aria-hidden="true" href="#cb35-153"></a>            <span class="cf">break</span>;</span>
<span id="cb35-154"><a aria-hidden="true" href="#cb35-154"></a>        <span class="cf">case</span> <span class="dv">6</span>:</span>
<span id="cb35-155"><a aria-hidden="true" href="#cb35-155"></a>            printf(<span class="st">"</span><span class="sc">%d\n</span><span class="st">"</span>, t[getnxt(x, <span class="dv">1</span>)].val);</span>
<span id="cb35-156"><a aria-hidden="true" href="#cb35-156"></a>            <span class="cf">break</span>;</span>
<span id="cb35-157"><a aria-hidden="true" href="#cb35-157"></a>        }</span>
<span id="cb35-158"><a aria-hidden="true" href="#cb35-158"></a>    }</span>
<span id="cb35-159"><a aria-hidden="true" href="#cb35-159"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb35-160"><a aria-hidden="true" href="#cb35-160"></a>}</span></code></pre></div>
<h3 id="前驱后继删除操作的另一种实现">前驱后继/删除操作的另一种实现</h3>
<p>其实对于查询前驱/后继，我们也可以先插入 <span class="math inline">\(val\)</span>（插入后它就会被 splay 成根），然后在其左/右子树中查询前驱/后继，最后完事了删除 <span class="math inline">\(val\)</span> 就行了（<span class="math inline">\(val\)</span> 工具人表示很淦）。</p>
<p>但问题是，删除怎么办，此时要完成前驱后继操作就需要先学会删除。</p>
<p>此处不妨把 <span class="math inline">\(val\)</span> splay 到根，然后分两种情况讨论：</p>
<ul>
<li>如果左/右子树至少有一个是空的话，直接让不空的那个节点当根就可以了（如果删干净了就删干净了吧）</li>
<li>如果左右子树都不为空，则相当于要合并两棵 Splay，怎么办呢，考虑怎么维护 Splay 的性质：</li>
</ul>
<p>我们可以将左子树最大的节点 Splay 到最上方，然后注意到<strong>此时根的左儿子肯定没有右儿子了</strong>。所以直接把根的右子树接到根的左儿子的右儿子上，然后让左儿子当根，根就直接滚蛋了。觉得抽象的可以看一下下面的图：</p>
<figure>
<img alt="" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/splay_del1.png"/><figcaption>将待删除节点 splay 到根后</figcaption>
</figure>
<p>这是将待删除节点 splay 到根后，然后我们把左子树的最大值 splay 到左子树的根，这样左子树就不存在右子树了，将原来根的右子树接上去即可。</p>
<figure>
<img alt="" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/splay_del2.png"/><figcaption>完成之后</figcaption>
</figure>
<p>原来的根节点就可以丢掉不要了，同时不要忘记再更新根的值。</p>
<p>代码如下：（此时 <code>getnxt()</code> 返回的是答案了）</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb36-1"><a aria-hidden="true" href="#cb36-1"></a><span class="dt">void</span> delnode(<span class="dt">int</span> val) {</span>
<span id="cb36-2"><a aria-hidden="true" href="#cb36-2"></a>    splay(find(val), <span class="dv">0</span>);<span class="co">//把待删除节点旋转到根</span></span>
<span id="cb36-3"><a aria-hidden="true" href="#cb36-3"></a>    <span class="cf">if</span> (t[root].val != val)</span>
<span id="cb36-4"><a aria-hidden="true" href="#cb36-4"></a>        <span class="cf">return</span>;</span>
<span id="cb36-5"><a aria-hidden="true" href="#cb36-5"></a>    <span class="cf">if</span> (t[root].cnt &gt; <span class="dv">1</span>)</span>
<span id="cb36-6"><a aria-hidden="true" href="#cb36-6"></a>    {</span>
<span id="cb36-7"><a aria-hidden="true" href="#cb36-7"></a>        t[root].cnt--;</span>
<span id="cb36-8"><a aria-hidden="true" href="#cb36-8"></a>        t[root].size--;</span>
<span id="cb36-9"><a aria-hidden="true" href="#cb36-9"></a>        <span class="cf">return</span>;</span>
<span id="cb36-10"><a aria-hidden="true" href="#cb36-10"></a>    }</span>
<span id="cb36-11"><a aria-hidden="true" href="#cb36-11"></a>    <span class="cf">if</span> ((!t[root].ch[<span class="dv">0</span>]) || (!t[root].ch[<span class="dv">1</span>]))</span>
<span id="cb36-12"><a aria-hidden="true" href="#cb36-12"></a>        root = t[root].ch[<span class="dv">0</span>] + t[root].ch[<span class="dv">1</span>];</span>
<span id="cb36-13"><a aria-hidden="true" href="#cb36-13"></a>    <span class="cf">else</span> {</span>
<span id="cb36-14"><a aria-hidden="true" href="#cb36-14"></a>        <span class="dt">int</span> lmax = t[root].ch[<span class="dv">0</span>];</span>
<span id="cb36-15"><a aria-hidden="true" href="#cb36-15"></a>        <span class="cf">while</span> (t[lmax].ch[<span class="dv">1</span>])</span>
<span id="cb36-16"><a aria-hidden="true" href="#cb36-16"></a>            lmax = t[lmax].ch[<span class="dv">1</span>];</span>
<span id="cb36-17"><a aria-hidden="true" href="#cb36-17"></a>        splay(lmax, root);</span>
<span id="cb36-18"><a aria-hidden="true" href="#cb36-18"></a>        t[t[root].ch[<span class="dv">1</span>]].fa = lmax;</span>
<span id="cb36-19"><a aria-hidden="true" href="#cb36-19"></a>        t[lmax].ch[<span class="dv">1</span>] = t[root].ch[<span class="dv">1</span>];</span>
<span id="cb36-20"><a aria-hidden="true" href="#cb36-20"></a>        maintain(root = lmax);</span>
<span id="cb36-21"><a aria-hidden="true" href="#cb36-21"></a>    }</span>
<span id="cb36-22"><a aria-hidden="true" href="#cb36-22"></a>    t[root].fa = <span class="dv">0</span>;<span class="co">//千万不要忘记把根的 fa 设为 0</span></span>
<span id="cb36-23"><a aria-hidden="true" href="#cb36-23"></a>    <span class="cf">return</span>;</span>
<span id="cb36-24"><a aria-hidden="true" href="#cb36-24"></a>}</span>
<span id="cb36-25"><a aria-hidden="true" href="#cb36-25"></a></span>
<span id="cb36-26"><a aria-hidden="true" href="#cb36-26"></a><span class="dt">int</span> getnxt(<span class="dt">int</span> val,<span class="dt">int</span> opt) {</span>
<span id="cb36-27"><a aria-hidden="true" href="#cb36-27"></a>    insert(val);</span>
<span id="cb36-28"><a aria-hidden="true" href="#cb36-28"></a>    <span class="dt">int</span> u = t[root].ch[opt], ans = t[u].val;</span>
<span id="cb36-29"><a aria-hidden="true" href="#cb36-29"></a>    <span class="cf">while</span> (t[u].ch[opt ^ <span class="dv">1</span>])</span>
<span id="cb36-30"><a aria-hidden="true" href="#cb36-30"></a>        u = t[u].ch[opt ^ <span class="dv">1</span>], ans = t[u].val;</span>
<span id="cb36-31"><a aria-hidden="true" href="#cb36-31"></a>    delnode(val);</span>
<span id="cb36-32"><a aria-hidden="true" href="#cb36-32"></a>    <span class="cf">return</span> ans;</span>
<span id="cb36-33"><a aria-hidden="true" href="#cb36-33"></a>}</span></code></pre></div>
<h3 id="普通平衡树的另外一种实现">普通平衡树的另外一种实现</h3>
<p><a href="https://www.luogu.com.cn/problem/P6136">洛谷P6136</a> 的实现：<strong>这个版本可以较好的处理查询前驱/后继/排名时待查询数不存在的情况</strong></p>
<div class="sourceCode" id="cb37"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb37-1"><a aria-hidden="true" href="#cb37-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb37-2"><a aria-hidden="true" href="#cb37-2"></a><span class="pp">#include </span><span class="im">&lt;cctype&gt;</span></span>
<span id="cb37-3"><a aria-hidden="true" href="#cb37-3"></a><span class="pp">#define L </span>t[u].ch[<span class="dv">0</span>]</span>
<span id="cb37-4"><a aria-hidden="true" href="#cb37-4"></a><span class="pp">#define R </span>t[u].ch[<span class="dv">1</span>]</span>
<span id="cb37-5"><a aria-hidden="true" href="#cb37-5"></a></span>
<span id="cb37-6"><a aria-hidden="true" href="#cb37-6"></a><span class="kw">inline</span> <span class="dt">int</span> read() {</span>
<span id="cb37-7"><a aria-hidden="true" href="#cb37-7"></a>    <span class="dt">char</span> c = getchar();</span>
<span id="cb37-8"><a aria-hidden="true" href="#cb37-8"></a>    <span class="dt">int</span> s = <span class="dv">0</span>;</span>
<span id="cb37-9"><a aria-hidden="true" href="#cb37-9"></a>    <span class="dt">bool</span> x = <span class="dv">0</span>;</span>
<span id="cb37-10"><a aria-hidden="true" href="#cb37-10"></a>    <span class="cf">while</span> (!isdigit(c))</span>
<span id="cb37-11"><a aria-hidden="true" href="#cb37-11"></a>        x = x | (c == <span class="ch">'-'</span>), c = getchar();</span>
<span id="cb37-12"><a aria-hidden="true" href="#cb37-12"></a>    <span class="cf">while</span> (isdigit(c))</span>
<span id="cb37-13"><a aria-hidden="true" href="#cb37-13"></a>        s = <span class="dv">10</span> * s + c - <span class="ch">'0'</span>, c = getchar();</span>
<span id="cb37-14"><a aria-hidden="true" href="#cb37-14"></a>    <span class="cf">return</span> x ? -s : s;</span>
<span id="cb37-15"><a aria-hidden="true" href="#cb37-15"></a>}</span>
<span id="cb37-16"><a aria-hidden="true" href="#cb37-16"></a></span>
<span id="cb37-17"><a aria-hidden="true" href="#cb37-17"></a><span class="kw">inline</span> <span class="dt">int</span> max(<span class="dt">int</span> a, <span class="dt">int</span> b) { <span class="cf">return</span> a &gt; b ? a : b; }</span>
<span id="cb37-18"><a aria-hidden="true" href="#cb37-18"></a><span class="kw">inline</span> <span class="dt">int</span> min(<span class="dt">int</span> a, <span class="dt">int</span> b) { <span class="cf">return</span> a &lt; b ? a : b; }</span>
<span id="cb37-19"><a aria-hidden="true" href="#cb37-19"></a></span>
<span id="cb37-20"><a aria-hidden="true" href="#cb37-20"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">2e6</span> + <span class="dv">5</span>, inf = <span class="dv">2147483647</span> - <span class="dv">20</span>;</span>
<span id="cb37-21"><a aria-hidden="true" href="#cb37-21"></a><span class="dt">int</span> cnt, root;</span>
<span id="cb37-22"><a aria-hidden="true" href="#cb37-22"></a></span>
<span id="cb37-23"><a aria-hidden="true" href="#cb37-23"></a><span class="kw">struct</span> Splay {</span>
<span id="cb37-24"><a aria-hidden="true" href="#cb37-24"></a>    <span class="dt">int</span> ch[<span class="dv">2</span>], fa;</span>
<span id="cb37-25"><a aria-hidden="true" href="#cb37-25"></a>    <span class="dt">int</span> cnt, size;</span>
<span id="cb37-26"><a aria-hidden="true" href="#cb37-26"></a>    <span class="dt">int</span> val;</span>
<span id="cb37-27"><a aria-hidden="true" href="#cb37-27"></a>} t[maxn];</span>
<span id="cb37-28"><a aria-hidden="true" href="#cb37-28"></a></span>
<span id="cb37-29"><a aria-hidden="true" href="#cb37-29"></a><span class="kw">inline</span> <span class="dt">bool</span> get(<span class="dt">int</span> u) {</span>
<span id="cb37-30"><a aria-hidden="true" href="#cb37-30"></a>    <span class="cf">return</span> t[t[u].fa].ch[<span class="dv">1</span>] == u;</span>
<span id="cb37-31"><a aria-hidden="true" href="#cb37-31"></a>}</span>
<span id="cb37-32"><a aria-hidden="true" href="#cb37-32"></a></span>
<span id="cb37-33"><a aria-hidden="true" href="#cb37-33"></a><span class="kw">inline</span> <span class="dt">void</span> maintain(<span class="dt">int</span> u) {</span>
<span id="cb37-34"><a aria-hidden="true" href="#cb37-34"></a>    t[u].size = t[u].cnt + t[L].size + t[R].size;</span>
<span id="cb37-35"><a aria-hidden="true" href="#cb37-35"></a>    <span class="cf">return</span>;</span>
<span id="cb37-36"><a aria-hidden="true" href="#cb37-36"></a>}</span>
<span id="cb37-37"><a aria-hidden="true" href="#cb37-37"></a></span>
<span id="cb37-38"><a aria-hidden="true" href="#cb37-38"></a><span class="dt">void</span> rotate(<span class="dt">int</span> u) {</span>
<span id="cb37-39"><a aria-hidden="true" href="#cb37-39"></a>    <span class="dt">int</span> fa = t[u].fa, gfa = t[fa].fa;</span>
<span id="cb37-40"><a aria-hidden="true" href="#cb37-40"></a>    <span class="dt">int</span> d1 = get(u), d2 = get(fa);</span>
<span id="cb37-41"><a aria-hidden="true" href="#cb37-41"></a>    t[fa].ch[d1] = t[u].ch[d1 ^ <span class="dv">1</span>], t[t[u].ch[d1 ^ <span class="dv">1</span>]].fa = fa;</span>
<span id="cb37-42"><a aria-hidden="true" href="#cb37-42"></a>    <span class="cf">if</span> (gfa)</span>
<span id="cb37-43"><a aria-hidden="true" href="#cb37-43"></a>        t[gfa].ch[d2] = u;</span>
<span id="cb37-44"><a aria-hidden="true" href="#cb37-44"></a>    t[u].fa = gfa;</span>
<span id="cb37-45"><a aria-hidden="true" href="#cb37-45"></a>    t[fa].fa = u, t[u].ch[d1 ^ <span class="dv">1</span>] = fa;</span>
<span id="cb37-46"><a aria-hidden="true" href="#cb37-46"></a>    maintain(fa);</span>
<span id="cb37-47"><a aria-hidden="true" href="#cb37-47"></a>    maintain(u);</span>
<span id="cb37-48"><a aria-hidden="true" href="#cb37-48"></a>}</span>
<span id="cb37-49"><a aria-hidden="true" href="#cb37-49"></a></span>
<span id="cb37-50"><a aria-hidden="true" href="#cb37-50"></a><span class="dt">void</span> splay(<span class="dt">int</span> u, <span class="dt">int</span> goal) {</span>
<span id="cb37-51"><a aria-hidden="true" href="#cb37-51"></a>    <span class="cf">while</span> (t[u].fa != goal) {</span>
<span id="cb37-52"><a aria-hidden="true" href="#cb37-52"></a>        <span class="dt">int</span> fa = t[u].fa, gfa = t[fa].fa;</span>
<span id="cb37-53"><a aria-hidden="true" href="#cb37-53"></a>        <span class="dt">int</span> d1 = get(u), d2 = get(fa);</span>
<span id="cb37-54"><a aria-hidden="true" href="#cb37-54"></a>        <span class="cf">if</span> (gfa != goal) {</span>
<span id="cb37-55"><a aria-hidden="true" href="#cb37-55"></a>            <span class="cf">if</span> (d1 == d2)</span>
<span id="cb37-56"><a aria-hidden="true" href="#cb37-56"></a>                rotate(fa);</span>
<span id="cb37-57"><a aria-hidden="true" href="#cb37-57"></a>            <span class="cf">else</span></span>
<span id="cb37-58"><a aria-hidden="true" href="#cb37-58"></a>                rotate(u);</span>
<span id="cb37-59"><a aria-hidden="true" href="#cb37-59"></a>        }</span>
<span id="cb37-60"><a aria-hidden="true" href="#cb37-60"></a>        rotate(u);</span>
<span id="cb37-61"><a aria-hidden="true" href="#cb37-61"></a>    }</span>
<span id="cb37-62"><a aria-hidden="true" href="#cb37-62"></a>    <span class="cf">if</span> (goal == <span class="dv">0</span>)</span>
<span id="cb37-63"><a aria-hidden="true" href="#cb37-63"></a>        root = u;</span>
<span id="cb37-64"><a aria-hidden="true" href="#cb37-64"></a>}</span>
<span id="cb37-65"><a aria-hidden="true" href="#cb37-65"></a></span>
<span id="cb37-66"><a aria-hidden="true" href="#cb37-66"></a><span class="dt">void</span> insert(<span class="dt">int</span> val) {</span>
<span id="cb37-67"><a aria-hidden="true" href="#cb37-67"></a>    <span class="dt">int</span> u = root, fa = <span class="dv">0</span>;</span>
<span id="cb37-68"><a aria-hidden="true" href="#cb37-68"></a>    <span class="cf">while</span> (u &amp;&amp; t[u].val != val)</span>
<span id="cb37-69"><a aria-hidden="true" href="#cb37-69"></a>        fa = u, u = t[u].ch[t[u].val &lt; val];</span>
<span id="cb37-70"><a aria-hidden="true" href="#cb37-70"></a>    <span class="cf">if</span> (u)</span>
<span id="cb37-71"><a aria-hidden="true" href="#cb37-71"></a>        t[u].cnt++;</span>
<span id="cb37-72"><a aria-hidden="true" href="#cb37-72"></a>    <span class="cf">else</span> {</span>
<span id="cb37-73"><a aria-hidden="true" href="#cb37-73"></a>        u = ++cnt;</span>
<span id="cb37-74"><a aria-hidden="true" href="#cb37-74"></a>        <span class="cf">if</span> (fa)</span>
<span id="cb37-75"><a aria-hidden="true" href="#cb37-75"></a>            t[fa].ch[t[fa].val &lt; val] = u;</span>
<span id="cb37-76"><a aria-hidden="true" href="#cb37-76"></a>        t[u].fa = fa;</span>
<span id="cb37-77"><a aria-hidden="true" href="#cb37-77"></a>        t[u].size = t[u].cnt = <span class="dv">1</span>;</span>
<span id="cb37-78"><a aria-hidden="true" href="#cb37-78"></a>        t[u].val = val;</span>
<span id="cb37-79"><a aria-hidden="true" href="#cb37-79"></a>    }</span>
<span id="cb37-80"><a aria-hidden="true" href="#cb37-80"></a>    splay(u, <span class="dv">0</span>);</span>
<span id="cb37-81"><a aria-hidden="true" href="#cb37-81"></a>}</span>
<span id="cb37-82"><a aria-hidden="true" href="#cb37-82"></a></span>
<span id="cb37-83"><a aria-hidden="true" href="#cb37-83"></a><span class="dt">int</span> find(<span class="dt">int</span> val) {</span>
<span id="cb37-84"><a aria-hidden="true" href="#cb37-84"></a>    <span class="dt">int</span> u = root;</span>
<span id="cb37-85"><a aria-hidden="true" href="#cb37-85"></a>    <span class="cf">while</span> (t[u].val != val &amp;&amp; t[u].ch[t[u].val &lt; val])</span>
<span id="cb37-86"><a aria-hidden="true" href="#cb37-86"></a>        u = t[u].ch[t[u].val &lt; val];</span>
<span id="cb37-87"><a aria-hidden="true" href="#cb37-87"></a>    <span class="cf">return</span> u;</span>
<span id="cb37-88"><a aria-hidden="true" href="#cb37-88"></a>}</span>
<span id="cb37-89"><a aria-hidden="true" href="#cb37-89"></a></span>
<span id="cb37-90"><a aria-hidden="true" href="#cb37-90"></a><span class="dt">int</span> kth(<span class="dt">int</span> k) {</span>
<span id="cb37-91"><a aria-hidden="true" href="#cb37-91"></a>    <span class="dt">int</span> u = root;</span>
<span id="cb37-92"><a aria-hidden="true" href="#cb37-92"></a>    <span class="cf">while</span> (<span class="kw">true</span>) {</span>
<span id="cb37-93"><a aria-hidden="true" href="#cb37-93"></a>        <span class="cf">if</span> (k &lt;= t[L].size)</span>
<span id="cb37-94"><a aria-hidden="true" href="#cb37-94"></a>            u = L;</span>
<span id="cb37-95"><a aria-hidden="true" href="#cb37-95"></a>        <span class="cf">else</span> <span class="cf">if</span> (k &gt; t[L].size + t[u].cnt) {</span>
<span id="cb37-96"><a aria-hidden="true" href="#cb37-96"></a>            k -= t[L].size + t[u].cnt;</span>
<span id="cb37-97"><a aria-hidden="true" href="#cb37-97"></a>            u = R;</span>
<span id="cb37-98"><a aria-hidden="true" href="#cb37-98"></a>        }</span>
<span id="cb37-99"><a aria-hidden="true" href="#cb37-99"></a>        <span class="cf">else</span></span>
<span id="cb37-100"><a aria-hidden="true" href="#cb37-100"></a>            <span class="cf">return</span> t[u].val;</span>
<span id="cb37-101"><a aria-hidden="true" href="#cb37-101"></a>    }</span>
<span id="cb37-102"><a aria-hidden="true" href="#cb37-102"></a>}</span>
<span id="cb37-103"><a aria-hidden="true" href="#cb37-103"></a></span>
<span id="cb37-104"><a aria-hidden="true" href="#cb37-104"></a><span class="dt">void</span> delnode(<span class="dt">int</span> val) {</span>
<span id="cb37-105"><a aria-hidden="true" href="#cb37-105"></a>    splay(find(val), <span class="dv">0</span>);</span>
<span id="cb37-106"><a aria-hidden="true" href="#cb37-106"></a>    <span class="cf">if</span> (t[root].val != val)</span>
<span id="cb37-107"><a aria-hidden="true" href="#cb37-107"></a>        <span class="cf">return</span>;</span>
<span id="cb37-108"><a aria-hidden="true" href="#cb37-108"></a>    <span class="cf">if</span> (t[root].cnt &gt; <span class="dv">1</span>) {</span>
<span id="cb37-109"><a aria-hidden="true" href="#cb37-109"></a>        t[root].cnt--;</span>
<span id="cb37-110"><a aria-hidden="true" href="#cb37-110"></a>        t[root].size--;</span>
<span id="cb37-111"><a aria-hidden="true" href="#cb37-111"></a>        <span class="cf">return</span>;</span>
<span id="cb37-112"><a aria-hidden="true" href="#cb37-112"></a>    }</span>
<span id="cb37-113"><a aria-hidden="true" href="#cb37-113"></a>    <span class="cf">if</span> ((!t[root].ch[<span class="dv">0</span>]) || (!t[root].ch[<span class="dv">1</span>]))</span>
<span id="cb37-114"><a aria-hidden="true" href="#cb37-114"></a>        root = t[root].ch[<span class="dv">0</span>] + t[root].ch[<span class="dv">1</span>];</span>
<span id="cb37-115"><a aria-hidden="true" href="#cb37-115"></a>    <span class="cf">else</span> {</span>
<span id="cb37-116"><a aria-hidden="true" href="#cb37-116"></a>        <span class="dt">int</span> lmax = t[root].ch[<span class="dv">0</span>];</span>
<span id="cb37-117"><a aria-hidden="true" href="#cb37-117"></a>        <span class="cf">while</span> (t[lmax].ch[<span class="dv">1</span>])</span>
<span id="cb37-118"><a aria-hidden="true" href="#cb37-118"></a>            lmax = t[lmax].ch[<span class="dv">1</span>];</span>
<span id="cb37-119"><a aria-hidden="true" href="#cb37-119"></a>        splay(lmax, root);</span>
<span id="cb37-120"><a aria-hidden="true" href="#cb37-120"></a>        t[t[root].ch[<span class="dv">1</span>]].fa = lmax;</span>
<span id="cb37-121"><a aria-hidden="true" href="#cb37-121"></a>        t[lmax].ch[<span class="dv">1</span>] = t[root].ch[<span class="dv">1</span>];</span>
<span id="cb37-122"><a aria-hidden="true" href="#cb37-122"></a>        maintain(root = lmax);</span>
<span id="cb37-123"><a aria-hidden="true" href="#cb37-123"></a>    }</span>
<span id="cb37-124"><a aria-hidden="true" href="#cb37-124"></a>    t[root].fa = <span class="dv">0</span>;</span>
<span id="cb37-125"><a aria-hidden="true" href="#cb37-125"></a>    <span class="cf">return</span>;</span>
<span id="cb37-126"><a aria-hidden="true" href="#cb37-126"></a>}</span>
<span id="cb37-127"><a aria-hidden="true" href="#cb37-127"></a></span>
<span id="cb37-128"><a aria-hidden="true" href="#cb37-128"></a><span class="dt">int</span> rank(<span class="dt">int</span> val) {</span>
<span id="cb37-129"><a aria-hidden="true" href="#cb37-129"></a>    insert(val);</span>
<span id="cb37-130"><a aria-hidden="true" href="#cb37-130"></a>    <span class="dt">int</span> ans = t[t[root].ch[<span class="dv">0</span>]].size + <span class="dv">1</span>;</span>
<span id="cb37-131"><a aria-hidden="true" href="#cb37-131"></a>    delnode(val);</span>
<span id="cb37-132"><a aria-hidden="true" href="#cb37-132"></a>    <span class="cf">return</span> ans;</span>
<span id="cb37-133"><a aria-hidden="true" href="#cb37-133"></a>}</span>
<span id="cb37-134"><a aria-hidden="true" href="#cb37-134"></a></span>
<span id="cb37-135"><a aria-hidden="true" href="#cb37-135"></a><span class="dt">int</span> getnxt(<span class="dt">int</span> val, <span class="dt">int</span> opt) {</span>
<span id="cb37-136"><a aria-hidden="true" href="#cb37-136"></a>    insert(val);</span>
<span id="cb37-137"><a aria-hidden="true" href="#cb37-137"></a>    <span class="dt">int</span> u = t[root].ch[opt], ans = t[u].val;</span>
<span id="cb37-138"><a aria-hidden="true" href="#cb37-138"></a>    <span class="cf">while</span> (t[u].ch[opt ^ <span class="dv">1</span>])</span>
<span id="cb37-139"><a aria-hidden="true" href="#cb37-139"></a>        u = t[u].ch[opt ^ <span class="dv">1</span>], ans = t[u].val;</span>
<span id="cb37-140"><a aria-hidden="true" href="#cb37-140"></a>    delnode(val);</span>
<span id="cb37-141"><a aria-hidden="true" href="#cb37-141"></a>    <span class="cf">return</span> ans;</span>
<span id="cb37-142"><a aria-hidden="true" href="#cb37-142"></a>}</span>
<span id="cb37-143"><a aria-hidden="true" href="#cb37-143"></a></span>
<span id="cb37-144"><a aria-hidden="true" href="#cb37-144"></a><span class="dt">int</span> main() {</span>
<span id="cb37-145"><a aria-hidden="true" href="#cb37-145"></a>    insert(inf), insert(-inf);</span>
<span id="cb37-146"><a aria-hidden="true" href="#cb37-146"></a>    <span class="dt">int</span> n = read(), m = read();</span>
<span id="cb37-147"><a aria-hidden="true" href="#cb37-147"></a>    <span class="cf">while</span> (n--)</span>
<span id="cb37-148"><a aria-hidden="true" href="#cb37-148"></a>        insert(read());</span>
<span id="cb37-149"><a aria-hidden="true" href="#cb37-149"></a>    <span class="dt">int</span> ans = <span class="dv">0</span>, last = <span class="dv">0</span>;</span>
<span id="cb37-150"><a aria-hidden="true" href="#cb37-150"></a>    <span class="cf">while</span> (m--) {</span>
<span id="cb37-151"><a aria-hidden="true" href="#cb37-151"></a>        <span class="dt">int</span> opt = read(), x = read() ^ last;</span>
<span id="cb37-152"><a aria-hidden="true" href="#cb37-152"></a>        <span class="cf">switch</span> (opt) {</span>
<span id="cb37-153"><a aria-hidden="true" href="#cb37-153"></a>        <span class="cf">case</span> <span class="dv">1</span>:</span>
<span id="cb37-154"><a aria-hidden="true" href="#cb37-154"></a>            insert(x);</span>
<span id="cb37-155"><a aria-hidden="true" href="#cb37-155"></a>            <span class="cf">break</span>;</span>
<span id="cb37-156"><a aria-hidden="true" href="#cb37-156"></a>        <span class="cf">case</span> <span class="dv">2</span>:</span>
<span id="cb37-157"><a aria-hidden="true" href="#cb37-157"></a>            delnode(x);</span>
<span id="cb37-158"><a aria-hidden="true" href="#cb37-158"></a>            <span class="cf">break</span>;</span>
<span id="cb37-159"><a aria-hidden="true" href="#cb37-159"></a>        <span class="cf">case</span> <span class="dv">3</span>:</span>
<span id="cb37-160"><a aria-hidden="true" href="#cb37-160"></a>            ans ^= (last = rank(x) - <span class="dv">1</span>);</span>
<span id="cb37-161"><a aria-hidden="true" href="#cb37-161"></a>            <span class="cf">break</span>;</span>
<span id="cb37-162"><a aria-hidden="true" href="#cb37-162"></a>        <span class="cf">case</span> <span class="dv">4</span>:</span>
<span id="cb37-163"><a aria-hidden="true" href="#cb37-163"></a>            ans ^= (last = kth(x + <span class="dv">1</span>));</span>
<span id="cb37-164"><a aria-hidden="true" href="#cb37-164"></a>            <span class="cf">break</span>;</span>
<span id="cb37-165"><a aria-hidden="true" href="#cb37-165"></a>        <span class="cf">case</span> <span class="dv">5</span>:</span>
<span id="cb37-166"><a aria-hidden="true" href="#cb37-166"></a>            ans ^= (last = getnxt(x, <span class="dv">0</span>));</span>
<span id="cb37-167"><a aria-hidden="true" href="#cb37-167"></a>            <span class="cf">break</span>;</span>
<span id="cb37-168"><a aria-hidden="true" href="#cb37-168"></a>        <span class="cf">case</span> <span class="dv">6</span>:</span>
<span id="cb37-169"><a aria-hidden="true" href="#cb37-169"></a>            ans ^= (last = getnxt(x, <span class="dv">1</span>));</span>
<span id="cb37-170"><a aria-hidden="true" href="#cb37-170"></a>        <span class="cf">default</span>:</span>
<span id="cb37-171"><a aria-hidden="true" href="#cb37-171"></a>            <span class="cf">break</span>;</span>
<span id="cb37-172"><a aria-hidden="true" href="#cb37-172"></a>        }</span>
<span id="cb37-173"><a aria-hidden="true" href="#cb37-173"></a>    }</span>
<span id="cb37-174"><a aria-hidden="true" href="#cb37-174"></a>    printf(<span class="st">"</span><span class="sc">%d\n</span><span class="st">"</span>, ans);</span>
<span id="cb37-175"><a aria-hidden="true" href="#cb37-175"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb37-176"><a aria-hidden="true" href="#cb37-176"></a>}</span></code></pre></div>
<h3 id="文艺平衡树的实现">文艺平衡树的实现</h3>
<p>文艺平衡树，可实现快速区间翻转，主要得益于 Splay 的区间操作功能。具体地，我们对序列 <span class="math inline">\(1 - n\)</span> 建一棵 Splay，这棵 Splay 的中序遍历即为我们的序列。然后如果要对 <span class="math inline">\([l,r]\)</span> 翻转，就需要先把 <span class="math inline">\([l,r]\)</span> 区间独立出来成单独一个子树然后打标记。我们可以考虑先把在 Splay 中排名为 <span class="math inline">\(l-1\)</span> 的点 splay 到根，然后将排名为 <span class="math inline">\(r+1\)</span> 的点 splay 到根下方，由 BST 的性质我们可以知道此时 <span class="math inline">\(r+1\)</span> 的左子树就是我们的 <span class="math inline">\([l,r]\)</span>。</p>
<p>找到之后打标记即可，注意旋转和 Splay 以及找节点的时候千万记得<strong>下放标记</strong>。</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb38-1"><a aria-hidden="true" href="#cb38-1"></a><span class="kw">inline</span> <span class="dt">void</span> pushdown(<span class="dt">int</span> u) {</span>
<span id="cb38-2"><a aria-hidden="true" href="#cb38-2"></a>    <span class="cf">if</span> (t[u].mark &amp;&amp; u) {</span>
<span id="cb38-3"><a aria-hidden="true" href="#cb38-3"></a>        swap(L, R);</span>
<span id="cb38-4"><a aria-hidden="true" href="#cb38-4"></a>        t[L].mark ^= <span class="dv">1</span>;</span>
<span id="cb38-5"><a aria-hidden="true" href="#cb38-5"></a>        t[R].mark ^= <span class="dv">1</span>;</span>
<span id="cb38-6"><a aria-hidden="true" href="#cb38-6"></a>        t[u].mark = <span class="dv">0</span>;</span>
<span id="cb38-7"><a aria-hidden="true" href="#cb38-7"></a>    }</span>
<span id="cb38-8"><a aria-hidden="true" href="#cb38-8"></a>    <span class="cf">return</span>;</span>
<span id="cb38-9"><a aria-hidden="true" href="#cb38-9"></a>}</span></code></pre></div>
<p>然后是翻转函数的实现。<strong>注意由于 <span class="math inline">\(l-1\)</span> 可能等于 <span class="math inline">\(0\)</span></strong>，所以需要提前插入正无穷和负无穷节点，同时读入的 <span class="math inline">\([l,r]\)</span> 要各自自增 <span class="math inline">\(1\)</span>。<strong>同时注意此处 <code>find()</code> 函数与之前的区别</strong></p>
<div class="sourceCode" id="cb39"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb39-1"><a aria-hidden="true" href="#cb39-1"></a><span class="dt">int</span> find(<span class="dt">int</span> val) {</span>
<span id="cb39-2"><a aria-hidden="true" href="#cb39-2"></a>    <span class="dt">int</span> u = root;</span>
<span id="cb39-3"><a aria-hidden="true" href="#cb39-3"></a>    <span class="cf">while</span> (<span class="dv">1</span>) {</span>
<span id="cb39-4"><a aria-hidden="true" href="#cb39-4"></a>        pushdown(u);</span>
<span id="cb39-5"><a aria-hidden="true" href="#cb39-5"></a>        <span class="cf">if</span> (val &lt;= t[L].size)</span>
<span id="cb39-6"><a aria-hidden="true" href="#cb39-6"></a>            u = L;</span>
<span id="cb39-7"><a aria-hidden="true" href="#cb39-7"></a>        <span class="cf">else</span> {</span>
<span id="cb39-8"><a aria-hidden="true" href="#cb39-8"></a>            val -= t[L].size + <span class="dv">1</span>;</span>
<span id="cb39-9"><a aria-hidden="true" href="#cb39-9"></a>            <span class="cf">if</span> (!val)</span>
<span id="cb39-10"><a aria-hidden="true" href="#cb39-10"></a>                <span class="cf">return</span> u;</span>
<span id="cb39-11"><a aria-hidden="true" href="#cb39-11"></a>            u = R;</span>
<span id="cb39-12"><a aria-hidden="true" href="#cb39-12"></a>        }</span>
<span id="cb39-13"><a aria-hidden="true" href="#cb39-13"></a>    }</span>
<span id="cb39-14"><a aria-hidden="true" href="#cb39-14"></a>}</span>
<span id="cb39-15"><a aria-hidden="true" href="#cb39-15"></a></span>
<span id="cb39-16"><a aria-hidden="true" href="#cb39-16"></a><span class="dt">void</span> reverse(<span class="dt">int</span> l, <span class="dt">int</span> r) {</span>
<span id="cb39-17"><a aria-hidden="true" href="#cb39-17"></a>    splay(find(l - <span class="dv">1</span>), <span class="dv">0</span>);</span>
<span id="cb39-18"><a aria-hidden="true" href="#cb39-18"></a>    splay(find(r + <span class="dv">1</span>), root);</span>
<span id="cb39-19"><a aria-hidden="true" href="#cb39-19"></a>    <span class="dt">int</span> u = t[root].ch[<span class="dv">1</span>];</span>
<span id="cb39-20"><a aria-hidden="true" href="#cb39-20"></a>    u = t[u].ch[<span class="dv">0</span>];</span>
<span id="cb39-21"><a aria-hidden="true" href="#cb39-21"></a>    t[u].mark ^= <span class="dv">1</span>;</span>
<span id="cb39-22"><a aria-hidden="true" href="#cb39-22"></a>    <span class="cf">return</span>;</span>
<span id="cb39-23"><a aria-hidden="true" href="#cb39-23"></a>}</span></code></pre></div>
<p>全部具体实现如下：<a href="https://www.luogu.com.cn/problem/P3391">洛谷P3391</a></p>
<div class="sourceCode" id="cb40"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb40-1"><a aria-hidden="true" href="#cb40-1"></a><span class="pp">#define L </span>(t[u].ch[<span class="dv">0</span>])</span>
<span id="cb40-2"><a aria-hidden="true" href="#cb40-2"></a><span class="pp">#define R </span>(t[u].ch[<span class="dv">1</span>])</span>
<span id="cb40-3"><a aria-hidden="true" href="#cb40-3"></a>...</span>
<span id="cb40-4"><a aria-hidden="true" href="#cb40-4"></a><span class="kw">struct</span> Splay {</span>
<span id="cb40-5"><a aria-hidden="true" href="#cb40-5"></a>    <span class="dt">int</span> ch[<span class="dv">2</span>], fa;</span>
<span id="cb40-6"><a aria-hidden="true" href="#cb40-6"></a>    <span class="dt">int</span> size, val;</span>
<span id="cb40-7"><a aria-hidden="true" href="#cb40-7"></a>    <span class="dt">int</span> mark;</span>
<span id="cb40-8"><a aria-hidden="true" href="#cb40-8"></a>} t[maxn];</span>
<span id="cb40-9"><a aria-hidden="true" href="#cb40-9"></a></span>
<span id="cb40-10"><a aria-hidden="true" href="#cb40-10"></a><span class="dt">int</span> root, cnt, n, m;</span>
<span id="cb40-11"><a aria-hidden="true" href="#cb40-11"></a></span>
<span id="cb40-12"><a aria-hidden="true" href="#cb40-12"></a><span class="dt">void</span> maintain(<span class="dt">int</span> u) {</span>
<span id="cb40-13"><a aria-hidden="true" href="#cb40-13"></a>    t[u].size = t[L].size + t[R].size + <span class="dv">1</span>;</span>
<span id="cb40-14"><a aria-hidden="true" href="#cb40-14"></a>    <span class="cf">return</span>;</span>
<span id="cb40-15"><a aria-hidden="true" href="#cb40-15"></a>}</span>
<span id="cb40-16"><a aria-hidden="true" href="#cb40-16"></a></span>
<span id="cb40-17"><a aria-hidden="true" href="#cb40-17"></a><span class="dt">int</span> get(<span class="dt">int</span> u) {</span>
<span id="cb40-18"><a aria-hidden="true" href="#cb40-18"></a>    <span class="cf">return</span> t[t[u].fa].ch[<span class="dv">1</span>] == u;</span>
<span id="cb40-19"><a aria-hidden="true" href="#cb40-19"></a>}</span>
<span id="cb40-20"><a aria-hidden="true" href="#cb40-20"></a></span>
<span id="cb40-21"><a aria-hidden="true" href="#cb40-21"></a><span class="kw">inline</span> <span class="dt">void</span> pushdown(<span class="dt">int</span> u) {</span>
<span id="cb40-22"><a aria-hidden="true" href="#cb40-22"></a>    <span class="cf">if</span> (t[u].mark &amp;&amp; u) {</span>
<span id="cb40-23"><a aria-hidden="true" href="#cb40-23"></a>        swap(L, R);</span>
<span id="cb40-24"><a aria-hidden="true" href="#cb40-24"></a>        t[L].mark ^= <span class="dv">1</span>;</span>
<span id="cb40-25"><a aria-hidden="true" href="#cb40-25"></a>        t[R].mark ^= <span class="dv">1</span>;</span>
<span id="cb40-26"><a aria-hidden="true" href="#cb40-26"></a>        t[u].mark = <span class="dv">0</span>;</span>
<span id="cb40-27"><a aria-hidden="true" href="#cb40-27"></a>    }</span>
<span id="cb40-28"><a aria-hidden="true" href="#cb40-28"></a>    <span class="cf">return</span>;</span>
<span id="cb40-29"><a aria-hidden="true" href="#cb40-29"></a>}</span>
<span id="cb40-30"><a aria-hidden="true" href="#cb40-30"></a></span>
<span id="cb40-31"><a aria-hidden="true" href="#cb40-31"></a><span class="dt">void</span> rotate(<span class="dt">int</span> u) {</span>
<span id="cb40-32"><a aria-hidden="true" href="#cb40-32"></a>    <span class="dt">int</span> fa = t[u].fa, gfa = t[fa].fa;</span>
<span id="cb40-33"><a aria-hidden="true" href="#cb40-33"></a>    pushdown(fa); pushdown(u);</span>
<span id="cb40-34"><a aria-hidden="true" href="#cb40-34"></a>    <span class="dt">int</span> d1 = get(u), d2 = get(fa);</span>
<span id="cb40-35"><a aria-hidden="true" href="#cb40-35"></a>    t[fa].ch[d1] = t[u].ch[d1 ^ <span class="dv">1</span>];</span>
<span id="cb40-36"><a aria-hidden="true" href="#cb40-36"></a>    t[t[u].ch[d1 ^ <span class="dv">1</span>]].fa = fa;</span>
<span id="cb40-37"><a aria-hidden="true" href="#cb40-37"></a>    t[u].ch[d1 ^ <span class="dv">1</span>] = fa;</span>
<span id="cb40-38"><a aria-hidden="true" href="#cb40-38"></a>    t[fa].fa = u;</span>
<span id="cb40-39"><a aria-hidden="true" href="#cb40-39"></a>    <span class="cf">if</span> (gfa)</span>
<span id="cb40-40"><a aria-hidden="true" href="#cb40-40"></a>        t[gfa].ch[d2] = u;</span>
<span id="cb40-41"><a aria-hidden="true" href="#cb40-41"></a>    t[u].fa = gfa;</span>
<span id="cb40-42"><a aria-hidden="true" href="#cb40-42"></a>    maintain(fa);</span>
<span id="cb40-43"><a aria-hidden="true" href="#cb40-43"></a>    maintain(u);</span>
<span id="cb40-44"><a aria-hidden="true" href="#cb40-44"></a>    <span class="cf">return</span>;</span>
<span id="cb40-45"><a aria-hidden="true" href="#cb40-45"></a>}</span>
<span id="cb40-46"><a aria-hidden="true" href="#cb40-46"></a></span>
<span id="cb40-47"><a aria-hidden="true" href="#cb40-47"></a><span class="dt">void</span> splay(<span class="dt">int</span> u, <span class="dt">int</span> goal) {</span>
<span id="cb40-48"><a aria-hidden="true" href="#cb40-48"></a>    pushdown(u);</span>
<span id="cb40-49"><a aria-hidden="true" href="#cb40-49"></a>    <span class="cf">while</span> (t[u].fa != goal) {</span>
<span id="cb40-50"><a aria-hidden="true" href="#cb40-50"></a>        <span class="dt">int</span> fa = t[u].fa, gfa = t[fa].fa;</span>
<span id="cb40-51"><a aria-hidden="true" href="#cb40-51"></a>        <span class="dt">int</span> d1 = get(u), d2 = get(fa);</span>
<span id="cb40-52"><a aria-hidden="true" href="#cb40-52"></a>        <span class="cf">if</span> (gfa != goal) {</span>
<span id="cb40-53"><a aria-hidden="true" href="#cb40-53"></a>            <span class="cf">if</span> (d1 == d2)</span>
<span id="cb40-54"><a aria-hidden="true" href="#cb40-54"></a>                rotate(fa);</span>
<span id="cb40-55"><a aria-hidden="true" href="#cb40-55"></a>            <span class="cf">else</span> rotate(u);</span>
<span id="cb40-56"><a aria-hidden="true" href="#cb40-56"></a>        }</span>
<span id="cb40-57"><a aria-hidden="true" href="#cb40-57"></a>        rotate(u);</span>
<span id="cb40-58"><a aria-hidden="true" href="#cb40-58"></a>    }</span>
<span id="cb40-59"><a aria-hidden="true" href="#cb40-59"></a>    <span class="cf">if</span> (!goal)</span>
<span id="cb40-60"><a aria-hidden="true" href="#cb40-60"></a>        root = u;</span>
<span id="cb40-61"><a aria-hidden="true" href="#cb40-61"></a>    <span class="cf">return</span>;</span>
<span id="cb40-62"><a aria-hidden="true" href="#cb40-62"></a>}</span>
<span id="cb40-63"><a aria-hidden="true" href="#cb40-63"></a></span>
<span id="cb40-64"><a aria-hidden="true" href="#cb40-64"></a><span class="dt">void</span> build(<span class="dt">int</span> i, <span class="dt">int</span> j, <span class="dt">int</span>&amp; u, <span class="dt">int</span> fa) {</span>
<span id="cb40-65"><a aria-hidden="true" href="#cb40-65"></a>    <span class="dt">int</span> cur = (i + j) &gt;&gt; <span class="dv">1</span>;</span>
<span id="cb40-66"><a aria-hidden="true" href="#cb40-66"></a>    u = ++cnt;</span>
<span id="cb40-67"><a aria-hidden="true" href="#cb40-67"></a>    t[u].fa = fa;</span>
<span id="cb40-68"><a aria-hidden="true" href="#cb40-68"></a>    t[u].size = <span class="dv">1</span>;</span>
<span id="cb40-69"><a aria-hidden="true" href="#cb40-69"></a>    <span class="cf">if</span> (cur == <span class="dv">1</span>)</span>
<span id="cb40-70"><a aria-hidden="true" href="#cb40-70"></a>        t[u].val = -(maxn &lt;&lt; <span class="dv">1</span>);</span>
<span id="cb40-71"><a aria-hidden="true" href="#cb40-71"></a>    <span class="cf">else</span> <span class="cf">if</span> (cur == n + <span class="dv">2</span>)</span>
<span id="cb40-72"><a aria-hidden="true" href="#cb40-72"></a>        t[u].val = maxn &lt;&lt; <span class="dv">1</span>;</span>
<span id="cb40-73"><a aria-hidden="true" href="#cb40-73"></a>    <span class="cf">else</span></span>
<span id="cb40-74"><a aria-hidden="true" href="#cb40-74"></a>        t[u].val = cur - <span class="dv">1</span>;</span>
<span id="cb40-75"><a aria-hidden="true" href="#cb40-75"></a>    <span class="cf">if</span> (cur &gt; i)</span>
<span id="cb40-76"><a aria-hidden="true" href="#cb40-76"></a>        build(i, cur - <span class="dv">1</span>, t[u].ch[<span class="dv">0</span>], u);</span>
<span id="cb40-77"><a aria-hidden="true" href="#cb40-77"></a>    <span class="cf">if</span> (cur &lt; j)</span>
<span id="cb40-78"><a aria-hidden="true" href="#cb40-78"></a>        build(cur + <span class="dv">1</span>, j, t[u].ch[<span class="dv">1</span>], u);</span>
<span id="cb40-79"><a aria-hidden="true" href="#cb40-79"></a>    maintain(u);</span>
<span id="cb40-80"><a aria-hidden="true" href="#cb40-80"></a>    <span class="cf">return</span>;</span>
<span id="cb40-81"><a aria-hidden="true" href="#cb40-81"></a>}</span>
<span id="cb40-82"><a aria-hidden="true" href="#cb40-82"></a></span>
<span id="cb40-83"><a aria-hidden="true" href="#cb40-83"></a><span class="dt">int</span> find(<span class="dt">int</span> val) {</span>
<span id="cb40-84"><a aria-hidden="true" href="#cb40-84"></a>    <span class="dt">int</span> u = root;</span>
<span id="cb40-85"><a aria-hidden="true" href="#cb40-85"></a>    <span class="cf">while</span> (<span class="dv">1</span>) {</span>
<span id="cb40-86"><a aria-hidden="true" href="#cb40-86"></a>        pushdown(u);</span>
<span id="cb40-87"><a aria-hidden="true" href="#cb40-87"></a>        <span class="cf">if</span> (val &lt;= t[L].size)</span>
<span id="cb40-88"><a aria-hidden="true" href="#cb40-88"></a>            u = L;</span>
<span id="cb40-89"><a aria-hidden="true" href="#cb40-89"></a>        <span class="cf">else</span> {</span>
<span id="cb40-90"><a aria-hidden="true" href="#cb40-90"></a>            val -= t[L].size + <span class="dv">1</span>;</span>
<span id="cb40-91"><a aria-hidden="true" href="#cb40-91"></a>            <span class="cf">if</span> (!val)</span>
<span id="cb40-92"><a aria-hidden="true" href="#cb40-92"></a>                <span class="cf">return</span> u;</span>
<span id="cb40-93"><a aria-hidden="true" href="#cb40-93"></a>            u = R;</span>
<span id="cb40-94"><a aria-hidden="true" href="#cb40-94"></a>        }</span>
<span id="cb40-95"><a aria-hidden="true" href="#cb40-95"></a>    }</span>
<span id="cb40-96"><a aria-hidden="true" href="#cb40-96"></a>}</span>
<span id="cb40-97"><a aria-hidden="true" href="#cb40-97"></a></span>
<span id="cb40-98"><a aria-hidden="true" href="#cb40-98"></a><span class="dt">void</span> reverse(<span class="dt">int</span> l, <span class="dt">int</span> r) {</span>
<span id="cb40-99"><a aria-hidden="true" href="#cb40-99"></a>    splay(find(l - <span class="dv">1</span>), <span class="dv">0</span>);</span>
<span id="cb40-100"><a aria-hidden="true" href="#cb40-100"></a>    splay(find(r + <span class="dv">1</span>), root);</span>
<span id="cb40-101"><a aria-hidden="true" href="#cb40-101"></a>    <span class="dt">int</span> u = t[root].ch[<span class="dv">1</span>];</span>
<span id="cb40-102"><a aria-hidden="true" href="#cb40-102"></a>    u = t[u].ch[<span class="dv">0</span>];</span>
<span id="cb40-103"><a aria-hidden="true" href="#cb40-103"></a>    t[u].mark ^= <span class="dv">1</span>;</span>
<span id="cb40-104"><a aria-hidden="true" href="#cb40-104"></a>    <span class="cf">return</span>;</span>
<span id="cb40-105"><a aria-hidden="true" href="#cb40-105"></a>}</span>
<span id="cb40-106"><a aria-hidden="true" href="#cb40-106"></a></span>
<span id="cb40-107"><a aria-hidden="true" href="#cb40-107"></a><span class="dt">void</span> dfs(<span class="dt">int</span> u) {</span>
<span id="cb40-108"><a aria-hidden="true" href="#cb40-108"></a>    <span class="cf">if</span> (!u)</span>
<span id="cb40-109"><a aria-hidden="true" href="#cb40-109"></a>        <span class="cf">return</span>;</span>
<span id="cb40-110"><a aria-hidden="true" href="#cb40-110"></a>    pushdown(u);</span>
<span id="cb40-111"><a aria-hidden="true" href="#cb40-111"></a>    dfs(L);</span>
<span id="cb40-112"><a aria-hidden="true" href="#cb40-112"></a>    <span class="cf">if</span> (t[u].val &lt;= <span class="dv">0</span> || t[u].val &gt; n + <span class="dv">1</span>);</span>
<span id="cb40-113"><a aria-hidden="true" href="#cb40-113"></a>    <span class="cf">else</span></span>
<span id="cb40-114"><a aria-hidden="true" href="#cb40-114"></a>        printf(<span class="st">"</span><span class="sc">%d</span><span class="st"> "</span>, t[u].val);</span>
<span id="cb40-115"><a aria-hidden="true" href="#cb40-115"></a>    dfs(R);</span>
<span id="cb40-116"><a aria-hidden="true" href="#cb40-116"></a>    <span class="cf">return</span>;</span>
<span id="cb40-117"><a aria-hidden="true" href="#cb40-117"></a>}</span>
<span id="cb40-118"><a aria-hidden="true" href="#cb40-118"></a></span>
<span id="cb40-119"><a aria-hidden="true" href="#cb40-119"></a><span class="dt">int</span> main() {</span>
<span id="cb40-120"><a aria-hidden="true" href="#cb40-120"></a>    n = read(), m = read();</span>
<span id="cb40-121"><a aria-hidden="true" href="#cb40-121"></a>    build(<span class="dv">1</span>, n + <span class="dv">2</span>, root, <span class="dv">0</span>);</span>
<span id="cb40-122"><a aria-hidden="true" href="#cb40-122"></a>    <span class="cf">while</span> (m--) {</span>
<span id="cb40-123"><a aria-hidden="true" href="#cb40-123"></a>        <span class="dt">int</span> l = read() + <span class="dv">1</span>, r = read() + <span class="dv">1</span>;</span>
<span id="cb40-124"><a aria-hidden="true" href="#cb40-124"></a>        reverse(l, r);</span>
<span id="cb40-125"><a aria-hidden="true" href="#cb40-125"></a>    }</span>
<span id="cb40-126"><a aria-hidden="true" href="#cb40-126"></a>    dfs(root);</span>
<span id="cb40-127"><a aria-hidden="true" href="#cb40-127"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb40-128"><a aria-hidden="true" href="#cb40-128"></a>}</span></code></pre></div>
<h3 id="易错点-1">易错点</h3>
<ul>
<li>一开始记得<strong>插入正负无穷</strong>，然后在<strong>计算排名和第 <span class="math inline">\(k\)</span> 大的时候要考虑其影响</strong></li>
<li><strong>旋转操作完成后务必 pushup</strong></li>
<li>如果涉及到标记下传，<strong>需要在可能改变树形的时候或者向下遍历节点的时候先 pushdown</strong></li>
<li><strong>插入完成一个节点之后要将其 splay 到根</strong>，否则可能 <strong>TLE</strong> 或者<strong>导致其父亲的 <code>size</code> 计算错误</strong>（因为 splay 时会一路更新 <code>size</code>）</li>
<li>splay 一个节点到根之后<strong>务必更新 <code>root</code> 变量</strong></li>
<li><strong>对于任何操作，如果该改变了节点的父子关系，一定记得既要更改儿子的，也要更改父亲的</strong></li>
</ul>
<p>这样，最基础的平衡树就学习完了，当然平衡树还有很多其他品种，如红黑树、AVL、替罪羊树、SBT 等等，但事实上 FHQ-Treap 和 Splay 已经基本能解决大多数问题了，所以就不再继续深入了。祝大家 debug 快乐。</p>
<h2 id="可持久化平衡树">可持久化平衡树</h2>
<h3 id="简介-1">简介</h3>
<p>与可持久化线段树类似，可持久化平衡树支持普通平衡树的基本操作，同时支持在某个历史版本的基础上进行查询和修改。</p>
<p>鉴于 splay 是均摊数据结构，形态多变，不好进行可持久化；而 fhq-treap 只涉及分裂/合并，且不旋转，容易实现，所以一般的“可持久化平衡树”均指“可持久化 fhq-treap”</p>
<p>前置知识：主席树，fhq-treap</p>
<h3 id="做法">做法</h3>
<p>对于 merge 和 split 操作，我们可以通过对这些过程经过的节点进行复制以达到可持久化的效果。</p>
<p>其相比普通的平衡树，是没有什么改变的：</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb41-1"><a aria-hidden="true" href="#cb41-1"></a><span class="dt">void</span> split(<span class="dt">int</span> u, <span class="dt">int</span> k, <span class="dt">int</span>&amp; x, <span class="dt">int</span>&amp; y) {</span>
<span id="cb41-2"><a aria-hidden="true" href="#cb41-2"></a>    <span class="cf">if</span> (!u) {</span>
<span id="cb41-3"><a aria-hidden="true" href="#cb41-3"></a>        x = y = <span class="dv">0</span>;</span>
<span id="cb41-4"><a aria-hidden="true" href="#cb41-4"></a>        <span class="cf">return</span>;</span>
<span id="cb41-5"><a aria-hidden="true" href="#cb41-5"></a>    }</span>
<span id="cb41-6"><a aria-hidden="true" href="#cb41-6"></a>    <span class="cf">if</span> (t[u].val &lt;= k) {</span>
<span id="cb41-7"><a aria-hidden="true" href="#cb41-7"></a>        x = clone(u);<span class="co">//*****************</span></span>
<span id="cb41-8"><a aria-hidden="true" href="#cb41-8"></a>        split(t[x].ch[<span class="dv">1</span>], k, t[x].ch[<span class="dv">1</span>], y);</span>
<span id="cb41-9"><a aria-hidden="true" href="#cb41-9"></a>        pushup(x);</span>
<span id="cb41-10"><a aria-hidden="true" href="#cb41-10"></a>    } <span class="cf">else</span> {</span>
<span id="cb41-11"><a aria-hidden="true" href="#cb41-11"></a>        y = clone(u);<span class="co">//*****************</span></span>
<span id="cb41-12"><a aria-hidden="true" href="#cb41-12"></a>        split(t[y].ch[<span class="dv">0</span>], k, x, t[y].ch[<span class="dv">0</span>]);</span>
<span id="cb41-13"><a aria-hidden="true" href="#cb41-13"></a>        pushup(y);</span>
<span id="cb41-14"><a aria-hidden="true" href="#cb41-14"></a>    }</span>
<span id="cb41-15"><a aria-hidden="true" href="#cb41-15"></a>    <span class="cf">return</span>;</span>
<span id="cb41-16"><a aria-hidden="true" href="#cb41-16"></a>}</span></code></pre></div>
<p>对比一下普通版的：</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb42-1"><a aria-hidden="true" href="#cb42-1"></a><span class="dt">void</span> split(<span class="dt">int</span> u, <span class="dt">int</span> k, <span class="dt">int</span> &amp;x, <span class="dt">int</span> &amp;y) {</span>
<span id="cb42-2"><a aria-hidden="true" href="#cb42-2"></a>    <span class="cf">if</span> (!u) {</span>
<span id="cb42-3"><a aria-hidden="true" href="#cb42-3"></a>        x = y = <span class="dv">0</span>;</span>
<span id="cb42-4"><a aria-hidden="true" href="#cb42-4"></a>        <span class="cf">return</span>;</span>
<span id="cb42-5"><a aria-hidden="true" href="#cb42-5"></a>    }</span>
<span id="cb42-6"><a aria-hidden="true" href="#cb42-6"></a>    <span class="cf">if</span> (t[u].val &lt;= k)</span>
<span id="cb42-7"><a aria-hidden="true" href="#cb42-7"></a>        x = u, split(R, k, R, y);</span>
<span id="cb42-8"><a aria-hidden="true" href="#cb42-8"></a>    <span class="cf">else</span></span>
<span id="cb42-9"><a aria-hidden="true" href="#cb42-9"></a>        y = u, split(L, k, x, L);</span>
<span id="cb42-10"><a aria-hidden="true" href="#cb42-10"></a>    pushup(u);</span>
<span id="cb42-11"><a aria-hidden="true" href="#cb42-11"></a>    <span class="cf">return</span>;</span>
<span id="cb42-12"><a aria-hidden="true" href="#cb42-12"></a>}</span></code></pre></div>
<p>注意一下星号的几行。其本质也就是对进行了修改的节点进行增加并且复制。</p>
<p>由于我们进行修改的时候，split 和 merge 是成对存在的，所以在 merge 的时候就不需要再复制一遍节点了。</p>
<p>容易出错的地方：</p>
<ul>
<li>如果存在 pushdown 操作，那么 pushdown 的时候也要复制一遍节点</li>
<li>注意哪里要 pushdown 以及哪里不要 pushdown</li>
<li>思考清楚各个数据间被调用的先后顺序及关系</li>
</ul>
<h3 id="普通平衡树的实现-2">普通平衡树的实现</h3>
<div class="sourceCode" id="cb43"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb43-1"><a aria-hidden="true" href="#cb43-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb43-2"><a aria-hidden="true" href="#cb43-2"></a><span class="pp">#include </span><span class="im">&lt;cctype&gt;</span></span>
<span id="cb43-3"><a aria-hidden="true" href="#cb43-3"></a><span class="pp">#include </span><span class="im">&lt;cstdlib&gt;</span></span>
<span id="cb43-4"><a aria-hidden="true" href="#cb43-4"></a><span class="pp">#define il </span><span class="kw">inline</span></span>
<span id="cb43-5"><a aria-hidden="true" href="#cb43-5"></a><span class="pp">#define FOR</span>(i,<span class="pp"> </span>a,<span class="pp"> </span>b)<span class="pp"> </span><span class="cf">for</span><span class="pp"> </span>(<span class="dt">int</span><span class="pp"> </span>i<span class="pp"> </span>=<span class="pp"> </span>a;<span class="pp"> </span>i<span class="pp"> </span>&lt;=<span class="pp"> </span>b;<span class="pp"> </span>++i)</span>
<span id="cb43-6"><a aria-hidden="true" href="#cb43-6"></a><span class="pp">#define DEC</span>(i,<span class="pp"> </span>a,<span class="pp"> </span>b)<span class="pp"> </span><span class="cf">for</span><span class="pp"> </span>(<span class="dt">int</span><span class="pp"> </span>i<span class="pp"> </span>=<span class="pp"> </span>a;<span class="pp"> </span>i<span class="pp"> </span>&gt;=<span class="pp"> </span>b;<span class="pp"> </span>--i)</span>
<span id="cb43-7"><a aria-hidden="true" href="#cb43-7"></a></span>
<span id="cb43-8"><a aria-hidden="true" href="#cb43-8"></a><span class="kw">namespace</span> fastIO {</span>
<span id="cb43-9"><a aria-hidden="true" href="#cb43-9"></a>    <span class="at">const</span> <span class="dt">int</span> maxc = <span class="dv">1</span> &lt;&lt; <span class="dv">21</span>;</span>
<span id="cb43-10"><a aria-hidden="true" href="#cb43-10"></a>    <span class="dt">char</span> ibuf[maxc], * __p1 = ibuf, * __p2 = ibuf;</span>
<span id="cb43-11"><a aria-hidden="true" href="#cb43-11"></a>    il <span class="dt">char</span> getchar() { <span class="cf">return</span> __p1 == __p2 &amp;&amp; (__p2 = (__p1 = ibuf) + fread(ibuf, <span class="dv">1</span>, maxc, stdin), __p1 == __p2) ? EOF : *__p1++; }</span>
<span id="cb43-12"><a aria-hidden="true" href="#cb43-12"></a>    <span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt; <span class="dt">void</span> read(T&amp; n) {</span>
<span id="cb43-13"><a aria-hidden="true" href="#cb43-13"></a>        <span class="dt">int</span> x = <span class="dv">0</span>; n = <span class="dv">0</span>;</span>
<span id="cb43-14"><a aria-hidden="true" href="#cb43-14"></a>        <span class="dt">char</span> c = getchar();</span>
<span id="cb43-15"><a aria-hidden="true" href="#cb43-15"></a>        <span class="cf">while</span> (!isdigit(c))</span>
<span id="cb43-16"><a aria-hidden="true" href="#cb43-16"></a>            x |= (c == <span class="ch">'-'</span>), c = getchar();</span>
<span id="cb43-17"><a aria-hidden="true" href="#cb43-17"></a>        <span class="cf">while</span> (isdigit(c))</span>
<span id="cb43-18"><a aria-hidden="true" href="#cb43-18"></a>            n = n * <span class="dv">10</span> + c - <span class="ch">'0'</span>, c = getchar();</span>
<span id="cb43-19"><a aria-hidden="true" href="#cb43-19"></a>        n = x ? -n : n;</span>
<span id="cb43-20"><a aria-hidden="true" href="#cb43-20"></a>    }</span>
<span id="cb43-21"><a aria-hidden="true" href="#cb43-21"></a>    <span class="dt">char</span> obuf[maxc], * __pO = obuf;</span>
<span id="cb43-22"><a aria-hidden="true" href="#cb43-22"></a>    il <span class="dt">void</span> putchar(<span class="dt">char</span> c) { *__pO++ = c; }</span>
<span id="cb43-23"><a aria-hidden="true" href="#cb43-23"></a>    <span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt; <span class="dt">void</span> print(T x) {</span>
<span id="cb43-24"><a aria-hidden="true" href="#cb43-24"></a>        <span class="cf">if</span> (x &lt; <span class="dv">0</span>) putchar(<span class="ch">'-'</span>), print(-x);</span>
<span id="cb43-25"><a aria-hidden="true" href="#cb43-25"></a>        <span class="cf">else</span> {</span>
<span id="cb43-26"><a aria-hidden="true" href="#cb43-26"></a>            <span class="cf">if</span> (x &gt; <span class="dv">9</span>) print(x / <span class="dv">10</span>);</span>
<span id="cb43-27"><a aria-hidden="true" href="#cb43-27"></a>            putchar(x % <span class="dv">10</span> + <span class="ch">'0'</span>);</span>
<span id="cb43-28"><a aria-hidden="true" href="#cb43-28"></a>        }</span>
<span id="cb43-29"><a aria-hidden="true" href="#cb43-29"></a>        <span class="cf">return</span>;</span>
<span id="cb43-30"><a aria-hidden="true" href="#cb43-30"></a>    }</span>
<span id="cb43-31"><a aria-hidden="true" href="#cb43-31"></a>    <span class="dt">void</span> output() { fwrite(obuf, __pO - obuf, <span class="dv">1</span>, stdout); }</span>
<span id="cb43-32"><a aria-hidden="true" href="#cb43-32"></a>}</span>
<span id="cb43-33"><a aria-hidden="true" href="#cb43-33"></a></span>
<span id="cb43-34"><a aria-hidden="true" href="#cb43-34"></a><span class="kw">using</span> <span class="kw">namespace</span> fastIO;</span>
<span id="cb43-35"><a aria-hidden="true" href="#cb43-35"></a></span>
<span id="cb43-36"><a aria-hidden="true" href="#cb43-36"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">5e5</span> + <span class="dv">5</span>;</span>
<span id="cb43-37"><a aria-hidden="true" href="#cb43-37"></a></span>
<span id="cb43-38"><a aria-hidden="true" href="#cb43-38"></a><span class="dt">int</span> root[maxn], cnt;</span>
<span id="cb43-39"><a aria-hidden="true" href="#cb43-39"></a></span>
<span id="cb43-40"><a aria-hidden="true" href="#cb43-40"></a><span class="kw">struct</span> node {</span>
<span id="cb43-41"><a aria-hidden="true" href="#cb43-41"></a>    <span class="dt">int</span> ch[<span class="dv">2</span>], size, val, key;</span>
<span id="cb43-42"><a aria-hidden="true" href="#cb43-42"></a>    <span class="dt">void</span> clear() {ch[<span class="dv">0</span>] = ch[<span class="dv">1</span>] = size = val = key = <span class="dv">0</span>;}</span>
<span id="cb43-43"><a aria-hidden="true" href="#cb43-43"></a>} t[maxn * <span class="dv">50</span>];</span>
<span id="cb43-44"><a aria-hidden="true" href="#cb43-44"></a></span>
<span id="cb43-45"><a aria-hidden="true" href="#cb43-45"></a><span class="pp">#define L </span>t[u].ch[<span class="dv">0</span>]</span>
<span id="cb43-46"><a aria-hidden="true" href="#cb43-46"></a><span class="pp">#define R </span>t[u].ch[<span class="dv">1</span>]</span>
<span id="cb43-47"><a aria-hidden="true" href="#cb43-47"></a></span>
<span id="cb43-48"><a aria-hidden="true" href="#cb43-48"></a>il <span class="dt">void</span> pushup(<span class="dt">int</span> u) { t[u].size = t[L].size + t[R].size + <span class="dv">1</span>; }</span>
<span id="cb43-49"><a aria-hidden="true" href="#cb43-49"></a></span>
<span id="cb43-50"><a aria-hidden="true" href="#cb43-50"></a>il <span class="dt">int</span> newnode() { <span class="cf">return</span> ++cnt; }</span>
<span id="cb43-51"><a aria-hidden="true" href="#cb43-51"></a></span>
<span id="cb43-52"><a aria-hidden="true" href="#cb43-52"></a>il <span class="dt">int</span> newnode(<span class="dt">int</span> val) {</span>
<span id="cb43-53"><a aria-hidden="true" href="#cb43-53"></a>    <span class="dt">int</span> u = newnode();</span>
<span id="cb43-54"><a aria-hidden="true" href="#cb43-54"></a>    t[u].ch[<span class="dv">0</span>] = t[u].ch[<span class="dv">1</span>] = <span class="dv">0</span>, t[u].size = <span class="dv">1</span>, t[u].val = val, t[u].key = rand();</span>
<span id="cb43-55"><a aria-hidden="true" href="#cb43-55"></a>    <span class="cf">return</span> u;</span>
<span id="cb43-56"><a aria-hidden="true" href="#cb43-56"></a>}</span>
<span id="cb43-57"><a aria-hidden="true" href="#cb43-57"></a></span>
<span id="cb43-58"><a aria-hidden="true" href="#cb43-58"></a><span class="dt">int</span> merge(<span class="dt">int</span> x, <span class="dt">int</span> y) {</span>
<span id="cb43-59"><a aria-hidden="true" href="#cb43-59"></a>    <span class="cf">if</span> (!x || !y) <span class="cf">return</span> x ^ y;</span>
<span id="cb43-60"><a aria-hidden="true" href="#cb43-60"></a>    <span class="cf">if</span> (t[x].key &lt; t[y].key)</span>
<span id="cb43-61"><a aria-hidden="true" href="#cb43-61"></a>        <span class="cf">return</span> t[x].ch[<span class="dv">1</span>] = merge(t[x].ch[<span class="dv">1</span>], y), pushup(x), x;</span>
<span id="cb43-62"><a aria-hidden="true" href="#cb43-62"></a>    <span class="cf">else</span> <span class="cf">return</span> t[y].ch[<span class="dv">0</span>] = merge(x, t[y].ch[<span class="dv">0</span>]), pushup(y), y;</span>
<span id="cb43-63"><a aria-hidden="true" href="#cb43-63"></a>}</span>
<span id="cb43-64"><a aria-hidden="true" href="#cb43-64"></a></span>
<span id="cb43-65"><a aria-hidden="true" href="#cb43-65"></a><span class="dt">void</span> split(<span class="dt">int</span> u, <span class="dt">int</span> k, <span class="dt">int</span>&amp; x, <span class="dt">int</span>&amp; y) {</span>
<span id="cb43-66"><a aria-hidden="true" href="#cb43-66"></a>    <span class="cf">if</span> (!u) {</span>
<span id="cb43-67"><a aria-hidden="true" href="#cb43-67"></a>        x = y = <span class="dv">0</span>;</span>
<span id="cb43-68"><a aria-hidden="true" href="#cb43-68"></a>        <span class="cf">return</span>;</span>
<span id="cb43-69"><a aria-hidden="true" href="#cb43-69"></a>    }</span>
<span id="cb43-70"><a aria-hidden="true" href="#cb43-70"></a>    <span class="cf">if</span> (t[u].val &lt;= k) {</span>
<span id="cb43-71"><a aria-hidden="true" href="#cb43-71"></a>        x = newnode(), t[x] = t[u];</span>
<span id="cb43-72"><a aria-hidden="true" href="#cb43-72"></a>        split(t[x].ch[<span class="dv">1</span>], k, t[x].ch[<span class="dv">1</span>], y);</span>
<span id="cb43-73"><a aria-hidden="true" href="#cb43-73"></a>        pushup(x);</span>
<span id="cb43-74"><a aria-hidden="true" href="#cb43-74"></a>    } <span class="cf">else</span> {</span>
<span id="cb43-75"><a aria-hidden="true" href="#cb43-75"></a>        y = newnode(), t[y] = t[u];</span>
<span id="cb43-76"><a aria-hidden="true" href="#cb43-76"></a>        split(t[y].ch[<span class="dv">0</span>], k, x, t[y].ch[<span class="dv">0</span>]);</span>
<span id="cb43-77"><a aria-hidden="true" href="#cb43-77"></a>        pushup(y);</span>
<span id="cb43-78"><a aria-hidden="true" href="#cb43-78"></a>    }</span>
<span id="cb43-79"><a aria-hidden="true" href="#cb43-79"></a>    <span class="cf">return</span>;</span>
<span id="cb43-80"><a aria-hidden="true" href="#cb43-80"></a>}</span>
<span id="cb43-81"><a aria-hidden="true" href="#cb43-81"></a></span>
<span id="cb43-82"><a aria-hidden="true" href="#cb43-82"></a><span class="dt">void</span> insert(<span class="dt">int</span>&amp; u, <span class="dt">int</span> val) {</span>
<span id="cb43-83"><a aria-hidden="true" href="#cb43-83"></a>    <span class="dt">int</span> x, y, z;</span>
<span id="cb43-84"><a aria-hidden="true" href="#cb43-84"></a>    split(u, val, x, z);</span>
<span id="cb43-85"><a aria-hidden="true" href="#cb43-85"></a>    y = newnode(val);</span>
<span id="cb43-86"><a aria-hidden="true" href="#cb43-86"></a>    u = merge(merge(x, y), z);</span>
<span id="cb43-87"><a aria-hidden="true" href="#cb43-87"></a>    <span class="cf">return</span>;</span>
<span id="cb43-88"><a aria-hidden="true" href="#cb43-88"></a>}</span>
<span id="cb43-89"><a aria-hidden="true" href="#cb43-89"></a></span>
<span id="cb43-90"><a aria-hidden="true" href="#cb43-90"></a><span class="dt">void</span> delNode(<span class="dt">int</span>&amp; u, <span class="dt">int</span> val) {</span>
<span id="cb43-91"><a aria-hidden="true" href="#cb43-91"></a>    <span class="dt">int</span> x, y, z;</span>
<span id="cb43-92"><a aria-hidden="true" href="#cb43-92"></a>    split(u, val, x, z);</span>
<span id="cb43-93"><a aria-hidden="true" href="#cb43-93"></a>    split(x, val - <span class="dv">1</span>, x, y);</span>
<span id="cb43-94"><a aria-hidden="true" href="#cb43-94"></a>    y = merge(t[y].ch[<span class="dv">0</span>], t[y].ch[<span class="dv">1</span>]);</span>
<span id="cb43-95"><a aria-hidden="true" href="#cb43-95"></a>    u = merge(merge(x, y), z);</span>
<span id="cb43-96"><a aria-hidden="true" href="#cb43-96"></a>    <span class="cf">return</span>;</span>
<span id="cb43-97"><a aria-hidden="true" href="#cb43-97"></a>}</span>
<span id="cb43-98"><a aria-hidden="true" href="#cb43-98"></a></span>
<span id="cb43-99"><a aria-hidden="true" href="#cb43-99"></a><span class="dt">int</span> getRank(<span class="dt">int</span>&amp; u, <span class="dt">int</span> val) {</span>
<span id="cb43-100"><a aria-hidden="true" href="#cb43-100"></a>    <span class="dt">int</span> x, y;</span>
<span id="cb43-101"><a aria-hidden="true" href="#cb43-101"></a>    split(u, val - <span class="dv">1</span>, x, y);</span>
<span id="cb43-102"><a aria-hidden="true" href="#cb43-102"></a>    <span class="dt">int</span> ans = t[x].size + <span class="dv">1</span>;</span>
<span id="cb43-103"><a aria-hidden="true" href="#cb43-103"></a>    u = merge(x, y);</span>
<span id="cb43-104"><a aria-hidden="true" href="#cb43-104"></a>    <span class="cf">return</span> ans;</span>
<span id="cb43-105"><a aria-hidden="true" href="#cb43-105"></a>}</span>
<span id="cb43-106"><a aria-hidden="true" href="#cb43-106"></a></span>
<span id="cb43-107"><a aria-hidden="true" href="#cb43-107"></a><span class="dt">int</span> getKth(<span class="dt">int</span> u, <span class="dt">int</span> k) {</span>
<span id="cb43-108"><a aria-hidden="true" href="#cb43-108"></a>    <span class="cf">if</span> (k == t[L].size + <span class="dv">1</span>) <span class="cf">return</span> t[u].val;</span>
<span id="cb43-109"><a aria-hidden="true" href="#cb43-109"></a>    <span class="cf">else</span> <span class="cf">if</span> (k &lt;= t[L].size) <span class="cf">return</span> getKth(L, k);</span>
<span id="cb43-110"><a aria-hidden="true" href="#cb43-110"></a>    <span class="cf">else</span> <span class="cf">return</span> getKth(R, k - t[L].size - <span class="dv">1</span>);</span>
<span id="cb43-111"><a aria-hidden="true" href="#cb43-111"></a>}</span>
<span id="cb43-112"><a aria-hidden="true" href="#cb43-112"></a></span>
<span id="cb43-113"><a aria-hidden="true" href="#cb43-113"></a><span class="dt">int</span> getPre(<span class="dt">int</span>&amp; root, <span class="dt">int</span> val) {</span>
<span id="cb43-114"><a aria-hidden="true" href="#cb43-114"></a>    <span class="dt">int</span> x, y, ans;</span>
<span id="cb43-115"><a aria-hidden="true" href="#cb43-115"></a>    split(root, val - <span class="dv">1</span>, x, y);</span>
<span id="cb43-116"><a aria-hidden="true" href="#cb43-116"></a>    <span class="cf">if</span> (!x) <span class="cf">return</span> -<span class="dv">2147483647</span>;</span>
<span id="cb43-117"><a aria-hidden="true" href="#cb43-117"></a>    ans = getKth(x, t[x].size);</span>
<span id="cb43-118"><a aria-hidden="true" href="#cb43-118"></a>    root = merge(x, y);</span>
<span id="cb43-119"><a aria-hidden="true" href="#cb43-119"></a>    <span class="cf">return</span> ans;</span>
<span id="cb43-120"><a aria-hidden="true" href="#cb43-120"></a>}</span>
<span id="cb43-121"><a aria-hidden="true" href="#cb43-121"></a></span>
<span id="cb43-122"><a aria-hidden="true" href="#cb43-122"></a><span class="dt">int</span> getSuc(<span class="dt">int</span>&amp; root, <span class="dt">int</span> val) {</span>
<span id="cb43-123"><a aria-hidden="true" href="#cb43-123"></a>    <span class="dt">int</span> x, y, ans;</span>
<span id="cb43-124"><a aria-hidden="true" href="#cb43-124"></a>    split(root, val, x, y);</span>
<span id="cb43-125"><a aria-hidden="true" href="#cb43-125"></a>    <span class="cf">if</span> (!y) <span class="cf">return</span> <span class="dv">2147483647</span>;</span>
<span id="cb43-126"><a aria-hidden="true" href="#cb43-126"></a>    ans = getKth(y, <span class="dv">1</span>);</span>
<span id="cb43-127"><a aria-hidden="true" href="#cb43-127"></a>    root = merge(x, y);</span>
<span id="cb43-128"><a aria-hidden="true" href="#cb43-128"></a>    <span class="cf">return</span> ans;</span>
<span id="cb43-129"><a aria-hidden="true" href="#cb43-129"></a>}</span>
<span id="cb43-130"><a aria-hidden="true" href="#cb43-130"></a></span>
<span id="cb43-131"><a aria-hidden="true" href="#cb43-131"></a><span class="dt">int</span> main() {</span>
<span id="cb43-132"><a aria-hidden="true" href="#cb43-132"></a>    srand(<span class="dv">20041031</span>);</span>
<span id="cb43-133"><a aria-hidden="true" href="#cb43-133"></a>    <span class="dt">int</span> n; read(n);</span>
<span id="cb43-134"><a aria-hidden="true" href="#cb43-134"></a>    FOR(i, <span class="dv">1</span>, n) {</span>
<span id="cb43-135"><a aria-hidden="true" href="#cb43-135"></a>        <span class="dt">int</span> v, op, val; read(v), read(op), read(val);</span>
<span id="cb43-136"><a aria-hidden="true" href="#cb43-136"></a>        root[i] = root[v];</span>
<span id="cb43-137"><a aria-hidden="true" href="#cb43-137"></a>        <span class="cf">if</span> (op == <span class="dv">1</span>) insert(root[i], val);</span>
<span id="cb43-138"><a aria-hidden="true" href="#cb43-138"></a>        <span class="cf">else</span> <span class="cf">if</span> (op == <span class="dv">2</span>) delNode(root[i], val);</span>
<span id="cb43-139"><a aria-hidden="true" href="#cb43-139"></a>        <span class="cf">else</span> <span class="cf">if</span> (op == <span class="dv">3</span>) print(getRank(root[i], val)), putchar(<span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span>);</span>
<span id="cb43-140"><a aria-hidden="true" href="#cb43-140"></a>        <span class="cf">else</span> <span class="cf">if</span> (op == <span class="dv">4</span>) print(getKth(root[i], val)), putchar(<span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span>);</span>
<span id="cb43-141"><a aria-hidden="true" href="#cb43-141"></a>        <span class="cf">else</span> <span class="cf">if</span> (op == <span class="dv">5</span>) print(getPre(root[i], val)), putchar(<span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span>);</span>
<span id="cb43-142"><a aria-hidden="true" href="#cb43-142"></a>        <span class="cf">else</span> <span class="cf">if</span> (op == <span class="dv">6</span>) print(getSuc(root[i], val)), putchar(<span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span>);</span>
<span id="cb43-143"><a aria-hidden="true" href="#cb43-143"></a>    }</span>
<span id="cb43-144"><a aria-hidden="true" href="#cb43-144"></a>    <span class="cf">return</span> output(), <span class="dv">0</span>;</span>
<span id="cb43-145"><a aria-hidden="true" href="#cb43-145"></a>}</span></code></pre></div>
</section>
<footer class="article-footer">
<section class="article-tags">
<a href="/tags/OI/">OI</a>
<a href="/tags/note/">笔记</a>
<a href="/tags/balanced-bst/">平衡树</a>
</section>
<section class="article-copyright">
<svg class="icon icon-tabler icon-tabler-copyright" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<circle cx="12" cy="12" r="9"></circle>
<path d="M14.5 9a3.5 4 0 1 0 0 6"></path>
</svg>
<span>Licensed under CC BY-NC-SA 4.0</span>
</section>
</footer>
<link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css" integrity="sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn" rel="stylesheet"/><script crossorigin="anonymous" defer="" integrity="sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8" src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js">
</script><script crossorigin="anonymous" defer="" integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js">
</script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.querySelector(`.article-content`), {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ]
        });})
</script>
</article>
<aside class="related-contents--wrapper">
<h2 class="section-title">相关文章</h2>
<div class="related-contents">
<div class="flex article-list--tile">
<article class="has-image">
<a href="/note-gf/">
<div class="article-image">
<img data-hash="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg28.webp" data-key="" loading="lazy" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg28.webp"/>
</div>
<div class="article-details">
<h2 class="article-title">生成函数胡扯</h2>
</div>
</a>
</article>
<article class="has-image">
<a href="/note-set-power-series/">
<div class="article-image">
<img data-hash="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg39.webp" data-key="" loading="lazy" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg39.webp"/>
</div>
<div class="article-details">
<h2 class="article-title">集合幂级数胡扯</h2>
</div>
</a>
</article>
<article class="has-image">
<a href="/note-linear-basis/">
<div class="article-image">
<img data-hash="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg19.webp" data-key="" loading="lazy" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg19.webp"/>
</div>
<div class="article-details">
<h2 class="article-title">线性基学习笔记</h2>
</div>
</a>
</article>
<article class="has-image">
<a href="/note-wqs/">
<div class="article-image">
<img data-hash="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg28.webp" data-key="" loading="lazy" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg28.webp"/>
</div>
<div class="article-details">
<h2 class="article-title">wqs 二分学习笔记</h2>
</div>
</a>
</article>
<article class="has-image">
<a href="/sol-sp-gss/">
<div class="article-image">
<img data-hash="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg41.webp" data-key="" loading="lazy" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg41.webp"/>
</div>
<div class="article-details">
<h2 class="article-title">SPOJ GSS 系列题解</h2>
</div>
</a>
</article>
</div>
</div>
</aside>
<footer class="site-footer">
<section class="copyright">
        © 
        
            2019 - 
        
        2024 清烛的博客
    </section>
<section class="powerby">
        Built with <a href="https://gohugo.io/" rel="noopener" target="_blank">Hugo</a> <br/>
        主题 <b><a data-version="3.11.0" href="https://github.com/CaiJimmy/hugo-theme-stack" rel="noopener" target="_blank">Stack</a></b> 由 <a href="https://jimmycai.com" rel="noopener" target="_blank">Jimmy</a> 设计
    </section>
</footer>
<div aria-hidden="true" class="pswp" role="dialog" tabindex="-1">
<div class="pswp__bg"></div>
<div class="pswp__scroll-wrap">
<div class="pswp__container">
<div class="pswp__item"></div>
<div class="pswp__item"></div>
<div class="pswp__item"></div>
</div>
<div class="pswp__ui pswp__ui--hidden">
<div class="pswp__top-bar">
<div class="pswp__counter"></div>
<button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title="Share"></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
<div class="pswp__preloader">
<div class="pswp__preloader__icn">
<div class="pswp__preloader__cut">
<div class="pswp__preloader__donut"></div>
</div>
</div>
</div>
</div>
<div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
<div class="pswp__share-tooltip"></div>
</div>
<button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
</button>
<div class="pswp__caption">
<div class="pswp__caption__center"></div>
</div>
</div>
</div>
</div><script crossorigin="anonymous" defer="" integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js">
</script><script crossorigin="anonymous" defer="" integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js">
</script><link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css" integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" rel="stylesheet"/><link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css" integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" rel="stylesheet"/>
</main>
</div>
<script crossorigin="anonymous" integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js">
</script><script defer="" src="/ts/main.js" type="text/javascript"></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>
</body>
</html>

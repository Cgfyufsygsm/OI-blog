<!DOCTYPE html>
<html dir="ltr" lang="zh-CN">
<head><meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/><meta content="ABC 补题表 近期目标：ABC 稳定 30min 过 4 题，争取赛时过 G，尽量补全套 ABC。
Round Rank Perf Sol A B C D E F G H ABC202 1095 1437 4 🉑 🉑 🉑 🉑 🉑 🉑 ABC207 956 1484 3 🉑 🉑 🉑 👀 🉑 👀 ABC210 485 1823 5 🉑 🉑 🉑 🉑 🉑 👀 ABC212 856 1536 5 🉑 🉑 🉑 🉑 🉑 🉑 🉑 🉑 ABC213 1031 1485 5 🉑 🉑 🉑 🉑 🉑 🉑 🉑 🉑 ABC214 742 1647 4 🉑 🉑 🉑 🉑 👀 👀 👀 👀 ABC217 1320 1383 5 🉑 🉑 🉑 🉑 🉑 🉑 🉑 👀 ABC219 1153 1375 4 🉑 🉑 🉑 🉑 🉑 👀 👀 👀 ABC222 425 1880 5 🉑 🉑 🉑 🉑 🉑 🉑 🉑 😅 ABC223 1573 1074 3 🉑 🉑 👀 🉑 👀 👀 👀 👀 ABC224 426 1828 5 🉑 🉑 🉑 🉑 🉑 👀 👀 👀 ABC231 571 1665 5 🉑 🉑 🉑 🉑 🉑 🉑 🉑 😅 ABC232 762 1518 5 🉑 🉑 🉑 🉑 🉑 🉑 🉑 🉑 ABC233 659 1660 5 🉑 🉑 🉑 🉑 🉑 🉑 🉑 🉑 ABC234 1553 1224 5 🉑 🉑 🉑 🉑 🉑 🉑 🉑 🉑 ABC235 913 1525 5 🉑 🉑 🉑 🉑 🉑 🉑 🉑 😅 ABC237 534 1790 5 🉑 🉑 🉑 🉑 🉑 🉑 🉑 🉑 ABC244 333 1788 6 🉑 🉑 🉑 🉑 🉑 🉑 🉑 👅 ABC246 703 1656 5 🉑 🉑 🉑 🉑 🉑 🉑 🉑 🉑 ABC247 640 1703 6 🉑 🉑 🉑 🉑 🉑 🉑 🉑 🉑 一些新见到的 trick ABC212E：补集思想优化 dp。 ABC212H：FWT 的线性性。 ABC219E：网格很小所以直接将护城河的状态和格子双射。 ABC231G：期望线性性推大式子。 ABC232G：对于模 \(M\) 类问题建环。 ABC233Ex：曼哈顿转切比雪夫然后主席树二维数点。 ABC235G：逆向考虑问题→二项式反演→棋盘路径计数的递推。 ABC237E：点高度直接满足势能性质→直接 Dijkstra。 ABC237Ex：串的包含关系转为偏序关系👉求最大反链。 ABC212 A + B + C + D + E。A - D 略。" name="description"/><title>AtCoder 比赛日记</title>
<link href="https://oi.imyangty.com/summary-atcoder/" rel="canonical"/>
<link href="/scss/style.min.a5821f3d3ab84ce5a0ac21477e347a2e0ca00292e398d16c5e8e36ded6e35a23.css" rel="stylesheet"/><meta content="AtCoder 比赛日记" property="og:title"/>
<meta content="ABC 补题表 近期目标：ABC 稳定 30min 过 4 题，争取赛时过 G，尽量补全套 ABC。
Round Rank Perf Sol A B C D E F G H ABC202 1095 1437 4 🉑 🉑 🉑 🉑 🉑 🉑 ABC207 956 1484 3 🉑 🉑 🉑 👀 🉑 👀 ABC210 485 1823 5 🉑 🉑 🉑 🉑 🉑 👀 ABC212 856 1536 5 🉑 🉑 🉑 🉑 🉑 🉑 🉑 🉑 ABC213 1031 1485 5 🉑 🉑 🉑 🉑 🉑 🉑 🉑 🉑 ABC214 742 1647 4 🉑 🉑 🉑 🉑 👀 👀 👀 👀 ABC217 1320 1383 5 🉑 🉑 🉑 🉑 🉑 🉑 🉑 👀 ABC219 1153 1375 4 🉑 🉑 🉑 🉑 🉑 👀 👀 👀 ABC222 425 1880 5 🉑 🉑 🉑 🉑 🉑 🉑 🉑 😅 ABC223 1573 1074 3 🉑 🉑 👀 🉑 👀 👀 👀 👀 ABC224 426 1828 5 🉑 🉑 🉑 🉑 🉑 👀 👀 👀 ABC231 571 1665 5 🉑 🉑 🉑 🉑 🉑 🉑 🉑 😅 ABC232 762 1518 5 🉑 🉑 🉑 🉑 🉑 🉑 🉑 🉑 ABC233 659 1660 5 🉑 🉑 🉑 🉑 🉑 🉑 🉑 🉑 ABC234 1553 1224 5 🉑 🉑 🉑 🉑 🉑 🉑 🉑 🉑 ABC235 913 1525 5 🉑 🉑 🉑 🉑 🉑 🉑 🉑 😅 ABC237 534 1790 5 🉑 🉑 🉑 🉑 🉑 🉑 🉑 🉑 ABC244 333 1788 6 🉑 🉑 🉑 🉑 🉑 🉑 🉑 👅 ABC246 703 1656 5 🉑 🉑 🉑 🉑 🉑 🉑 🉑 🉑 ABC247 640 1703 6 🉑 🉑 🉑 🉑 🉑 🉑 🉑 🉑 一些新见到的 trick ABC212E：补集思想优化 dp。 ABC212H：FWT 的线性性。 ABC219E：网格很小所以直接将护城河的状态和格子双射。 ABC231G：期望线性性推大式子。 ABC232G：对于模 \(M\) 类问题建环。 ABC233Ex：曼哈顿转切比雪夫然后主席树二维数点。 ABC235G：逆向考虑问题→二项式反演→棋盘路径计数的递推。 ABC237E：点高度直接满足势能性质→直接 Dijkstra。 ABC237Ex：串的包含关系转为偏序关系👉求最大反链。 ABC212 A + B + C + D + E。A - D 略。" property="og:description"/>
<meta content="https://oi.imyangty.com/summary-atcoder/" property="og:url"/>
<meta content="清烛的博客" property="og:site_name"/>
<meta content="article" property="og:type"/><meta content="Post" property="article:section"/><meta content="OI" property="article:tag"/><meta content="解题报告" property="article:tag"/><meta content="AtCoder" property="article:tag"/><meta content="素数与筛法" property="article:tag"/><meta content="模拟" property="article:tag"/><meta content="构造" property="article:tag"/><meta content="树的直径" property="article:tag"/><meta content="组合数学" property="article:tag"/><meta content="Lucas定理" property="article:tag"/><meta content="二分答案" property="article:tag"/><meta content="贪心" property="article:tag"/><meta content="最大公约数" property="article:tag"/><meta content="前缀和" property="article:tag"/><meta content="二分图" property="article:tag"/><meta content="线段树" property="article:tag"/><meta content="原根" property="article:tag"/><meta content="后缀数组" property="article:tag"/><meta content="FWT" property="article:tag"/><meta content="生成函数" property="article:tag"/><meta content="FFT" property="article:tag"/><meta content="NTT" property="article:tag"/><meta content="动态规划" property="article:tag"/><meta content="区间dp" property="article:tag"/><meta content="换根dp" property="article:tag"/><meta content="动态dp" property="article:tag"/><meta content="cdq分治" property="article:tag"/><meta content="期望" property="article:tag"/><meta content="单调栈" property="article:tag"/><meta content="高维前缀和" property="article:tag"/><meta content="博弈论" property="article:tag"/><meta content="线性基" property="article:tag"/><meta content="费用流" property="article:tag"/><meta content="2021-04-23T12:38:59+08:00" property="article:published_time"/><meta content="2021-04-23T12:38:59+08:00" property="article:modified_time"/><meta content="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg70.webp" property="og:image"/>
<meta content="AtCoder 比赛日记" name="twitter:title"/>
<meta content="ABC 补题表 近期目标：ABC 稳定 30min 过 4 题，争取赛时过 G，尽量补全套 ABC。
Round Rank Perf Sol A B C D E F G H ABC202 1095 1437 4 🉑 🉑 🉑 🉑 🉑 🉑 ABC207 956 1484 3 🉑 🉑 🉑 👀 🉑 👀 ABC210 485 1823 5 🉑 🉑 🉑 🉑 🉑 👀 ABC212 856 1536 5 🉑 🉑 🉑 🉑 🉑 🉑 🉑 🉑 ABC213 1031 1485 5 🉑 🉑 🉑 🉑 🉑 🉑 🉑 🉑 ABC214 742 1647 4 🉑 🉑 🉑 🉑 👀 👀 👀 👀 ABC217 1320 1383 5 🉑 🉑 🉑 🉑 🉑 🉑 🉑 👀 ABC219 1153 1375 4 🉑 🉑 🉑 🉑 🉑 👀 👀 👀 ABC222 425 1880 5 🉑 🉑 🉑 🉑 🉑 🉑 🉑 😅 ABC223 1573 1074 3 🉑 🉑 👀 🉑 👀 👀 👀 👀 ABC224 426 1828 5 🉑 🉑 🉑 🉑 🉑 👀 👀 👀 ABC231 571 1665 5 🉑 🉑 🉑 🉑 🉑 🉑 🉑 😅 ABC232 762 1518 5 🉑 🉑 🉑 🉑 🉑 🉑 🉑 🉑 ABC233 659 1660 5 🉑 🉑 🉑 🉑 🉑 🉑 🉑 🉑 ABC234 1553 1224 5 🉑 🉑 🉑 🉑 🉑 🉑 🉑 🉑 ABC235 913 1525 5 🉑 🉑 🉑 🉑 🉑 🉑 🉑 😅 ABC237 534 1790 5 🉑 🉑 🉑 🉑 🉑 🉑 🉑 🉑 ABC244 333 1788 6 🉑 🉑 🉑 🉑 🉑 🉑 🉑 👅 ABC246 703 1656 5 🉑 🉑 🉑 🉑 🉑 🉑 🉑 🉑 ABC247 640 1703 6 🉑 🉑 🉑 🉑 🉑 🉑 🉑 🉑 一些新见到的 trick ABC212E：补集思想优化 dp。 ABC212H：FWT 的线性性。 ABC219E：网格很小所以直接将护城河的状态和格子双射。 ABC231G：期望线性性推大式子。 ABC232G：对于模 \(M\) 类问题建环。 ABC233Ex：曼哈顿转切比雪夫然后主席树二维数点。 ABC235G：逆向考虑问题→二项式反演→棋盘路径计数的递推。 ABC237E：点高度直接满足势能性质→直接 Dijkstra。 ABC237Ex：串的包含关系转为偏序关系👉求最大反链。 ABC212 A + B + C + D + E。A - D 略。" name="twitter:description"/><meta content="summary_large_image" name="twitter:card"/>
<meta content="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg70.webp" name="twitter:image"/>
<link href="https://q1.qlogo.cn/g?b=qq&amp;nk=375836877&amp;s=5" rel="shortcut icon"/>
<link href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/styles/github-dark-dimmed.min.css" rel="stylesheet"/>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
</head>
<body class="article-page">
<script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky">
<button aria-label="切换菜单" class="hamburger hamburger--spin" id="toggle-menu" type="button">
<span class="hamburger-box">
<span class="hamburger-inner"></span>
</span>
</button>
<header>
<figure class="site-avatar">
<a href="/">
<img alt="Avatar" class="site-logo" height="300" loading="lazy" src="/img/avatar_huea3ce2119467b51fdd2a81393644a76d_51594_300x0_resize_q75_box.jpg" width="300"/>
</a>
<span class="emoji">😅</span>
</figure>
<div class="site-meta">
<h1 class="site-name"><a href="/">清烛的博客</a></h1>
<h2 class="site-description">烟火已谢，笙歌未停</h2>
</div>
</header><ol class="social-menu">
<li>
<a href="mailto:i@imyangty.com" target="_blank" title="email">
<svg class="icon icon-tabler icon-tabler-mail" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
<rect height="14" rx="2" width="18" x="3" y="5"></rect>
<polyline points="3 7 12 13 21 7"></polyline>
</svg>
</a>
</li>
<li>
<a href="https://github.com/Cgfyufsygsm" target="_blank" title="GitHub">
<svg class="icon icon-tabler icon-tabler-brand-github" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
<path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5"></path>
</svg>
</a>
</li>
<li>
<a href="https://t.me/Cgfyufsygsm" target="_blank" title="Telegram">
<svg class="icon icon-tabler icon-tabler-brand-telegram" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
<path d="M15 10l-4 4l6 6l4 -16l-18 7l4 2l2 6l3 -4"></path>
</svg>
</a>
</li>
<li>
<a href="https://twitter.com/Cgfyufsygsm" target="_blank" title="Twitter">
<svg class="icon icon-tabler icon-tabler-brand-twitter" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
<path d="M22 4.01c-1 .49 -1.98 .689 -3 .99c-1.121 -1.265 -2.783 -1.335 -4.38 -.737s-2.643 2.06 -2.62 3.737v1c-3.245 .083 -6.135 -1.395 -8 -4c0 0 -4.182 7.433 4 11c-1.872 1.247 -3.739 2.088 -6 2c3.308 1.803 6.913 2.423 10.034 1.517c3.58 -1.04 6.522 -3.723 7.651 -7.742a13.84 13.84 0 0 0 .497 -3.753c-.002 -.249 1.51 -2.772 1.818 -4.013z"></path>
</svg>
</a>
</li>
</ol><ol class="menu" id="main-menu">
<li>
<a href="/">
<svg class="icon icon-tabler icon-tabler-home" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<polyline points="5 12 3 12 12 3 21 12 19 12"></polyline>
<path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7"></path>
<path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6"></path>
</svg>
<span>主页</span>
</a>
</li>
<li>
<a href="/about/">
<svg class="icon icon-tabler icon-tabler-user" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<circle cx="12" cy="7" r="4"></circle>
<path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2"></path>
</svg>
<span>关于</span>
</a>
</li>
<li>
<a href="/idx/">
<svg class="icon icon-tabler icon-tabler-hash" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<line x1="5" x2="19" y1="9" y2="9"></line>
<line x1="5" x2="19" y1="15" y2="15"></line>
<line x1="11" x2="7" y1="4" y2="20"></line>
<line x1="17" x2="13" y1="4" y2="20"></line>
</svg>
<span>导航</span>
</a>
</li>
<li>
<a href="/archives/">
<svg class="icon icon-tabler icon-tabler-archive" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<rect height="4" rx="2" width="18" x="3" y="4"></rect>
<path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10"></path>
<line x1="10" x2="14" y1="12" y2="12"></line>
</svg>
<span>归档</span>
</a>
</li>
<li>
<a href="/search/">
<svg class="icon icon-tabler icon-tabler-search" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<circle cx="10" cy="10" r="7"></circle>
<line x1="21" x2="15" y1="21" y2="15"></line>
</svg>
<span>搜索</span>
</a>
</li>
<li>
<a href="/friends/">
<svg class="icon icon-tabler icon-tabler-link" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5"></path>
<path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5"></path>
</svg>
<span>友链</span>
</a>
</li>
<li>
<a href="https://blog.imyangty.com" target="_blank">
<svg class="icon icon-tabler icon-tabler-home" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<polyline points="5 12 3 12 12 3 21 12 19 12"></polyline>
<path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7"></path>
<path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6"></path>
</svg>
<span>主博客</span>
</a>
</li>
<div class="menu-bottom-section">
<li id="dark-mode-toggle">
<svg class="icon icon-tabler icon-tabler-toggle-left" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<circle cx="8" cy="12" r="2"></circle>
<rect height="12" rx="6" width="20" x="2" y="6"></rect>
</svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<circle cx="16" cy="12" r="2"></circle>
<rect height="12" rx="6" width="20" x="2" y="6"></rect>
</svg>
<span>暗色模式</span>
</li>
</div>
</ol>
</aside>
<main class="main full-width">
<article class="has-image main-article">
<header class="article-header">
<div class="article-image">
<a href="/summary-atcoder/">
<img alt="Featured image of post AtCoder 比赛日记" loading="lazy" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg70.webp"/>
</a>
</div>
<div class="article-details">
<header class="article-category">
<a href="/categories/oi/">
                OI
            </a>
<a href="/categories/tutorial/">
                题解
            </a>
</header>
<div class="article-title-wrapper">
<h2 class="article-title">
<a href="/summary-atcoder/">AtCoder 比赛日记</a>
</h2>
</div>
<footer class="article-time">
<div>
<svg class="icon icon-tabler icon-tabler-calendar-time" fill="none" height="56" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="56" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4"></path>
<circle cx="18" cy="18" r="4"></circle>
<path d="M15 3v4"></path>
<path d="M7 3v4"></path>
<path d="M3 11h16"></path>
<path d="M18 16.496v1.504l1 1"></path>
</svg>
<time class="article-time--published">Apr 23, 2021</time>
</div>
<div>
<svg class="icon icon-tabler icon-tabler-clock" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<circle cx="12" cy="12" r="9"></circle>
<polyline points="12 7 12 12 15 15"></polyline>
</svg>
<time class="article-time--reading">
                    阅读时长: 42 分钟
                </time>
</div>
</footer>
</div>
</header>
<section class="article-content">
<h2 id="abc">ABC</h2>
<h3 id="补题表">补题表</h3>
<p>近期目标：ABC 稳定 30min 过 4 题，争取赛时过 G，尽量补全套 ABC。</p>
<div class="table-wrapper"><table>
<thead>
<tr class="header">
<th>Round</th>
<th style="text-align: center;">Rank</th>
<th style="text-align: center;">Perf</th>
<th style="text-align: center;">Sol</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
<th>H</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ABC202</td>
<td style="text-align: center;"><a href="https://atcoder.jp/contests/abc202/standings?watching=YangTY">1095</a></td>
<td style="text-align: center;">1437</td>
<td style="text-align: center;">4</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>ABC207</td>
<td style="text-align: center;"><a href="https://atcoder.jp/contests/abc207/standings?watching=YangTY">956</a></td>
<td style="text-align: center;">1484</td>
<td style="text-align: center;">3</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>👀</td>
<td>🉑</td>
<td>👀</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>ABC210</td>
<td style="text-align: center;"><a href="https://atcoder.jp/contests/abc210/standings?watching=YangTY">485</a></td>
<td style="text-align: center;">1823</td>
<td style="text-align: center;">5</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>👀</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>ABC212</td>
<td style="text-align: center;"><a href="https://atcoder.jp/contests/abc212/standings?watching=YangTY">856</a></td>
<td style="text-align: center;">1536</td>
<td style="text-align: center;">5</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
</tr>
<tr class="odd">
<td>ABC213</td>
<td style="text-align: center;"><a href="https://atcoder.jp/contests/abc213/standings?watching=YangTY">1031</a></td>
<td style="text-align: center;">1485</td>
<td style="text-align: center;">5</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
</tr>
<tr class="even">
<td>ABC214</td>
<td style="text-align: center;"><a href="https://atcoder.jp/contests/abc214/standings?watching=YangTY">742</a></td>
<td style="text-align: center;">1647</td>
<td style="text-align: center;">4</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>👀</td>
<td>👀</td>
<td>👀</td>
<td>👀</td>
</tr>
<tr class="odd">
<td>ABC217</td>
<td style="text-align: center;"><a href="https://atcoder.jp/contests/abc217/standings?watching=Cgfyufsygsm">1320</a></td>
<td style="text-align: center;">1383</td>
<td style="text-align: center;">5</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>👀</td>
</tr>
<tr class="even">
<td>ABC219</td>
<td style="text-align: center;"><a href="https://atcoder.jp/contests/abc219/standings?watching=YangTY">1153</a></td>
<td style="text-align: center;">1375</td>
<td style="text-align: center;">4</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>👀</td>
<td>👀</td>
<td>👀</td>
</tr>
<tr class="odd">
<td>ABC222</td>
<td style="text-align: center;"><a href="https://atcoder.jp/contests/abc222/standings?watching=YangTY">425</a></td>
<td style="text-align: center;">1880</td>
<td style="text-align: center;">5</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>😅</td>
</tr>
<tr class="even">
<td>ABC223</td>
<td style="text-align: center;"><a href="https://atcoder.jp/contests/abc223/standings?watching=Cgfyufsygsm">1573</a></td>
<td style="text-align: center;">1074</td>
<td style="text-align: center;">3</td>
<td>🉑</td>
<td>🉑</td>
<td>👀</td>
<td>🉑</td>
<td>👀</td>
<td>👀</td>
<td>👀</td>
<td>👀</td>
</tr>
<tr class="odd">
<td>ABC224</td>
<td style="text-align: center;"><a href="https://atcoder.jp/contests/abc224/standings?watching=YangTY">426</a></td>
<td style="text-align: center;">1828</td>
<td style="text-align: center;">5</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>👀</td>
<td>👀</td>
<td>👀</td>
</tr>
<tr class="even">
<td>ABC231</td>
<td style="text-align: center;"><a href="https://atcoder.jp/contests/abc231/standings?watching=Cgfyufsygsm">571</a></td>
<td style="text-align: center;">1665</td>
<td style="text-align: center;">5</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>😅</td>
</tr>
<tr class="odd">
<td>ABC232</td>
<td style="text-align: center;"><a href="https://atcoder.jp/contests/abc232/standings?watching=YangTY">762</a></td>
<td style="text-align: center;">1518</td>
<td style="text-align: center;">5</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
</tr>
<tr class="even">
<td>ABC233</td>
<td style="text-align: center;"><a href="https://atcoder.jp/contests/abc233/standings?watching=YangTY">659</a></td>
<td style="text-align: center;">1660</td>
<td style="text-align: center;">5</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
</tr>
<tr class="odd">
<td>ABC234</td>
<td style="text-align: center;"><a href="https://atcoder.jp/contests/abc234/standings?watching=YangTY">1553</a></td>
<td style="text-align: center;">1224</td>
<td style="text-align: center;">5</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
</tr>
<tr class="even">
<td>ABC235</td>
<td style="text-align: center;"><a href="https://atcoder.jp/contests/abc235/standings?watching=YangTY">913</a></td>
<td style="text-align: center;">1525</td>
<td style="text-align: center;">5</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>😅</td>
</tr>
<tr class="odd">
<td>ABC237</td>
<td style="text-align: center;"><a href="https://atcoder.jp/contests/abc237/standings?watching=YangTY">534</a></td>
<td style="text-align: center;">1790</td>
<td style="text-align: center;">5</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
</tr>
<tr class="even">
<td>ABC244</td>
<td style="text-align: center;"><a href="https://atcoder.jp/contests/abc244/standings?watching=YangTY">333</a></td>
<td style="text-align: center;">1788</td>
<td style="text-align: center;">6</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>👅</td>
</tr>
<tr class="odd">
<td>ABC246</td>
<td style="text-align: center;"><a href="https://atcoder.jp/contests/abc246/standings?watching=YangTY">703</a></td>
<td style="text-align: center;">1656</td>
<td style="text-align: center;">5</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
</tr>
<tr class="even">
<td>ABC247</td>
<td style="text-align: center;"><a href="https://atcoder.jp/contests/abc247/standings?watching=YangTY">640</a></td>
<td style="text-align: center;">1703</td>
<td style="text-align: center;">6</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
</tr>
</tbody>
</table></div>
<h3 id="一些新见到的-trick">一些新见到的 trick</h3>
<ul>
<li>ABC212E：补集思想优化 dp。</li>
<li>ABC212H：FWT 的线性性。</li>
<li>ABC219E：网格很小所以直接将护城河的状态和格子双射。</li>
<li>ABC231G：期望线性性推大式子。</li>
<li>ABC232G：对于模 <span class="math inline">\(M\)</span> 类问题建环。</li>
<li>ABC233Ex：曼哈顿转切比雪夫然后主席树二维数点。</li>
<li>ABC235G：逆向考虑问题→二项式反演→<strong>棋盘路径计数的递推</strong>。</li>
<li>ABC237E：点高度直接满足势能性质→直接 Dijkstra。</li>
<li>ABC237Ex：串的包含关系转为偏序关系👉求最大反链。</li>
</ul>
<h3 id="abc212">ABC212</h3>
<p>A + B + C + D + E。A - D 略。</p>
<h4 id="abc212e---safety-journey">ABC212E - Safety Journey</h4>
<p>补集思想优化 DP ： <span class="math display">\[
f_{i, j} = \sum_{j'\text{ is connected with j}}f_{i - 1, j'}
\]</span> 可以转化为 <span class="math display">\[
f_{i, j} = \sum_{j' = 1}^n f_{i - 1, j'} - \sum_{j'\text{ isn't connected with j}}f_{i - 1, j'}
\]</span> 没连边的数量是总共 <span class="math inline">\(O(m)\)</span> 的，总复杂度 <span class="math inline">\(O((n + m)k)\)</span></p>
<h4 id="abc212f---greedy-takahashi">ABC212F - Greedy Takahashi</h4>
<p>建模成森林然后直接树上倍增求解。码力要求较高。</p>
<h4 id="abc212g---power-pair">ABC212G - Power Pair</h4>
<p>给定质数 <span class="math inline">\(p\)</span>，问数对 <span class="math inline">\((x, y)\)</span> 的个数模 <span class="math inline">\(998244353\)</span>：</p>
<ul>
<li><span class="math inline">\(0\le x, y\le p - 1\)</span></li>
<li><span class="math inline">\(\exists n, x^n\equiv y\pmod p\)</span></li>
</ul>
<p><span class="math inline">\(2\le p\le 10^{12}\)</span>。</p>
<p>回顾原根的概念。<span class="math inline">\(r\)</span> 为模 <span class="math inline">\(p\)</span> 的原根当且仅当最小的使得 <span class="math inline">\(r^e\equiv 1\pmod p\)</span> 的正整数为 <span class="math inline">\(e = p - 1\)</span>。本题需要用到的性质：<span class="math inline">\(r^i\bmod p, i\in[0, p - 1]\)</span> 的值两两不同，且对于一个质数，一定有原根存在。</p>
<p>设 <span class="math inline">\(x\equiv r^a\pmod p\)</span>，<span class="math inline">\(y\equiv r^b\pmod p\)</span>，不难发现 <span class="math inline">\((x, y)\)</span> 总能有一个 <span class="math inline">\((a, b)\)</span> 与之对应。于是就有 <span class="math inline">\(an\equiv b\pmod{p - 1}\)</span>。现在就是需要找满足上式的 <span class="math inline">\((a, b)\)</span> 的数量。</p>
<p>枚举 <span class="math inline">\(a\)</span>，则上式有解的条件是 <span class="math inline">\(\gcd(a, p - 1)\mid b\)</span>（裴蜀定理）。那对于所有的 <span class="math inline">\(a\)</span> 就可以写成： <span class="math display">\[
\sum_{a = 1}^{p - 1}\frac{p - 1}{\gcd(a, p - 1)}
\]</span> 然后 <span class="math inline">\(O(p)\)</span> 是过不去的，要考虑优化。优化它的方法明显是寻找 <span class="math inline">\(\gcd(a, p - 1)\)</span> 相同的 <span class="math inline">\(a\)</span> 的个数。根据 <span class="math inline">\(p - 1\)</span> 的因数个数 为 <span class="math inline">\(O(\sqrt p)\)</span> 的，故这些 <span class="math inline">\(\gcd\)</span> 也只有 <span class="math inline">\(O(\sqrt p)\)</span> 个。我们枚举 <span class="math inline">\(\gcd(a, p - 1) = g\)</span>，有 <span class="math display">\[
\sum_{g\mid p - 1}\frac{p - 1}{g}\times\phi\left(\frac{p - 1}{g}\right)
\]</span> <span class="math inline">\(\phi(n)\)</span> 可以暴力计算。<span class="math inline">\(O(\sqrt p\log p)\)</span>，因为 $$ 的上界很松，轻松通过。</p>
<h4 id="abc212h---nim-counting">ABC212H - Nim Counting</h4>
<p>给定 <span class="math inline">\(n\)</span>，<span class="math inline">\(k\)</span> 和 <span class="math inline">\((A_1, \cdots, A_k)\)</span>。可以如下安排石子：每堆石子数量必须是 <span class="math inline">\(A_i\)</span> 之一，且石子堆数量小等于 <span class="math inline">\(n\)</span>。问安排石子使得先手 Nim 必胜的方案数。</p>
<p><span class="math inline">\(1\le n\le 2\times 10^5\)</span>，<span class="math inline">\(1\le k, A_i\le 2^{17}\)</span>，<span class="math inline">\(A_i\)</span> 两两不同。</p>
<p>不难发现问题转化为求 <span class="math inline">\(\bigoplus_{i = 1}^m B_i\not=0\)</span> 的 <span class="math inline">\(B_i\)</span> 的方案数，其中 <span class="math inline">\(m\)</span> 为石子个数。</p>
<p>先考虑固定 <span class="math inline">\(m\)</span>。则构造序列 <span class="math inline">\(C\)</span> 使得 <span class="math inline">\(C_i = [\exist j, A_j = i]\)</span>，定义卷积 <span class="math inline">\(*\)</span> 为异或卷积，则 <span class="math inline">\(C * C * \cdots * C\)</span>（<span class="math inline">\(m\)</span> 个 <span class="math inline">\(C\)</span>）的第 <span class="math inline">\(i\)</span> 项系数即为异或和为 <span class="math inline">\(i\)</span> 的方案数。这个过程是可以 FWT 做的，具体地，给 <span class="math inline">\(\operatorname{FWT}(C)_i\)</span> 的每一项做一下快速幂再 IFWT 回去，把除了第 <span class="math inline">\(0\)</span> 项之外的求个和，就得到了石子堆数为 <span class="math inline">\(m\)</span> 的答案。</p>
<p>然后，不固定 <span class="math inline">\(m\)</span> 怎么做呢？因为 FWT 是线性变换，而我们需要求的是 <span class="math inline">\(\operatorname{IFWT}(\operatorname{FWT}(C)_i + \operatorname{FWT}(C)_i^2 + \operatorname{FWT}(C)_i^3 + \cdots \operatorname{FWT}(C)_i^n)\)</span>，所以定义 <span class="math inline">\(C'_i = \operatorname{FWT}(C)_i\)</span>，然后求出 <span class="math inline">\(D_i = C_i' + C_i'^2 + \cdots + C_i'^n\)</span> 再求 <span class="math inline">\(\operatorname{IFWT}(D)\)</span> 把除了第 <span class="math inline">\(0\)</span> 项外的系数累加即可。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a aria-hidden="true" href="#cb1-1"></a>modint calc(modint x, modint n) {</span>
<span id="cb1-2"><a aria-hidden="true" href="#cb1-2"></a>    <span class="cf">if</span> (x == <span class="dv">1</span>) <span class="cf">return</span> n;</span>
<span id="cb1-3"><a aria-hidden="true" href="#cb1-3"></a>    <span class="cf">if</span> (x == <span class="dv">0</span>) <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb1-4"><a aria-hidden="true" href="#cb1-4"></a>    <span class="cf">return</span> x * (qPow(x, n) - <span class="dv">1</span>) * qPow(x - <span class="dv">1</span>, mod - <span class="dv">2</span>);</span>
<span id="cb1-5"><a aria-hidden="true" href="#cb1-5"></a>}</span>
<span id="cb1-6"><a aria-hidden="true" href="#cb1-6"></a></span>
<span id="cb1-7"><a aria-hidden="true" href="#cb1-7"></a><span class="dt">int</span> main() {</span>
<span id="cb1-8"><a aria-hidden="true" href="#cb1-8"></a>    read(n), read(k);</span>
<span id="cb1-9"><a aria-hidden="true" href="#cb1-9"></a>    <span class="dt">int</span> tmp;</span>
<span id="cb1-10"><a aria-hidden="true" href="#cb1-10"></a>    FOR(i, <span class="dv">1</span>, k) read(tmp), maxa = tmp &gt; maxa ? tmp : maxa, f[tmp] = <span class="dv">1</span>;</span>
<span id="cb1-11"><a aria-hidden="true" href="#cb1-11"></a>    ++maxa;</span>
<span id="cb1-12"><a aria-hidden="true" href="#cb1-12"></a>    <span class="dt">int</span> lim;</span>
<span id="cb1-13"><a aria-hidden="true" href="#cb1-13"></a>    <span class="cf">for</span> (lim = <span class="dv">1</span>; lim &lt;= maxa; lim &lt;&lt;= <span class="dv">1</span>);</span>
<span id="cb1-14"><a aria-hidden="true" href="#cb1-14"></a>    XOR(f, lim, <span class="dv">1</span>);</span>
<span id="cb1-15"><a aria-hidden="true" href="#cb1-15"></a>    FOR(i, <span class="dv">0</span>, lim - <span class="dv">1</span>) f[i] = calc(f[i], n);</span>
<span id="cb1-16"><a aria-hidden="true" href="#cb1-16"></a>    XOR(f, lim, inv2);</span>
<span id="cb1-17"><a aria-hidden="true" href="#cb1-17"></a>    modint ans = <span class="dv">0</span>;</span>
<span id="cb1-18"><a aria-hidden="true" href="#cb1-18"></a>    FOR(i, <span class="dv">1</span>, lim - <span class="dv">1</span>) ans += f[i];</span>
<span id="cb1-19"><a aria-hidden="true" href="#cb1-19"></a>    print(ans);</span>
<span id="cb1-20"><a aria-hidden="true" href="#cb1-20"></a>    <span class="cf">return</span> output(), <span class="dv">0</span>;</span>
<span id="cb1-21"><a aria-hidden="true" href="#cb1-21"></a>}</span></code></pre></div>
<h3 id="abc213">ABC213</h3>
<p>A + B + C + D + F</p>
<h4 id="abc213e---stronger-takahashi">ABC213E - Stronger Takahashi</h4>
<p>0-1 bfs，因为边权只为 <span class="math inline">\(0\)</span> 或 <span class="math inline">\(1\)</span>。</p>
<h4 id="abc213f---common-prefixes">ABC213F - Common Prefixes</h4>
<p>令 <span class="math inline">\(\operatorname{LCP}(S_i, S_j)\)</span> 为 <span class="math inline">\(i\)</span> 开头子串和 <span class="math inline">\(j\)</span> 开头子串的最长公共前缀。对每个 <span class="math inline">\(k\in[1, n]\)</span> 求 <span class="math display">\[
\sum_{i = 1}^n\operatorname{LCP}(S_k, S_i)
\]</span></p>
<p>SA 板子。</p>
<h4 id="abc213g---connectivity-2">ABC213G - Connectivity 2</h4>
<p>对于每个 <span class="math inline">\(k\)</span>，求 <span class="math inline">\(1\)</span> 和 <span class="math inline">\(k\)</span> 联通的子图个数。<span class="math inline">\(2\le n\le 17\)</span>，<span class="math inline">\(m\)</span> 很小。</p>
<p>状压 dp。</p>
<p>令 <span class="math inline">\(g(S)\)</span> 表示点集 <span class="math inline">\(S\)</span> 中有连边的数量。这可以 <span class="math inline">\(O(2^nm)\)</span> 的时间内完成。</p>
<p>设 <span class="math inline">\(f(S)\)</span> 为保证 <span class="math inline">\(S\)</span> 内点联通的连边方案数，则我们可以考虑容斥，随便选一个点 <span class="math inline">\(x\)</span>，然后考虑这个点所在的连通分量 <span class="math inline">\(T\)</span>，其中 <span class="math inline">\(T\subset S\)</span>。则有如下转移 <span class="math display">\[
f(S) = g(S) - \sum_{x\in T, T\subset S} f(T)
\]</span> 然后对于答案，<span class="math inline">\(k\)</span> 号点的答案即为： <span class="math display">\[
\sum_{1\in S, k\in S} f(S)
\]</span> 这题就做完了。</p>
<h4 id="abc213h---stroll">ABC213H - Stroll</h4>
<p><span class="math inline">\(n\)</span> 个点，<span class="math inline">\(m\)</span> 对点 <span class="math inline">\((a_i, b_i)\)</span> 间有连边，长度为 <span class="math inline">\(d\)</span> 的有 <span class="math inline">\(p_{i, d}\)</span> 条。问从 <span class="math inline">\(1\)</span> 点出发，在 <span class="math inline">\(1\)</span> 点结束的长度为 <span class="math inline">\(T\)</span> 的路径方案数。</p>
<p>先把最朴素的 DP 方程写出来：设 <span class="math inline">\(f_{u, s}\)</span> 为结束点为 <span class="math inline">\(u\)</span>，长度为 <span class="math inline">\(s\)</span> 的路径条数。</p>
<p>则最朴素的方程：对于每条边进行转移 <span class="math display">\[
f_{u_i, s} := f_{u_i, s} + \sum_{t = 0}^sf_{v_i, t}p_{i, t}
\]</span> 写成生成函数的形式就是 <span class="math display">\[
F_{u_i}(x) := F_{u_i}(x) + F_{v_i}(x)P_i(x)
\]</span> 这个东西看似可以 NTT 优化，但是你会发现存在反复横跳的情况。所以直接去做肯定是不行的。</p>
<p>考虑在长度的维度分治。考虑当前分治区间为 <span class="math inline">\([l, r]\)</span>，然后首先处理一下 <span class="math inline">\([l, mid]\)</span> 内部，把这些算完，然后处理 <span class="math inline">\([l, mid]\)</span> 到 <span class="math inline">\([mid + 1, r]\)</span> 的贡献。即 <span class="math display">\[
f_{u_i, s} := f_{u_i, s} + \sum_{t = l}^{mid}f_{v_i, t}p_{i, s - t}\quad s\in[mid + 1, r]
\]</span> 类似分治 NTT 处理即可。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a aria-hidden="true" href="#cb2-1"></a>Poly f[<span class="dv">11</span>], p[<span class="dv">11</span>], t1, t2;</span>
<span id="cb2-2"><a aria-hidden="true" href="#cb2-2"></a><span class="dt">int</span> n, m, T, u[<span class="dv">11</span>], v[<span class="dv">11</span>];</span>
<span id="cb2-3"><a aria-hidden="true" href="#cb2-3"></a></span>
<span id="cb2-4"><a aria-hidden="true" href="#cb2-4"></a><span class="dt">void</span> solve(Poly &amp;f, Poly &amp;g, Poly &amp;ret, <span class="dt">int</span> l, <span class="dt">int</span> r) {</span>
<span id="cb2-5"><a aria-hidden="true" href="#cb2-5"></a>    <span class="dt">int</span> mid = (l + r) &gt;&gt; <span class="dv">1</span>;</span>
<span id="cb2-6"><a aria-hidden="true" href="#cb2-6"></a>    t1 = {f.begin() + l, f.begin() + mid + <span class="dv">1</span>};</span>
<span id="cb2-7"><a aria-hidden="true" href="#cb2-7"></a>    t2 = {g.begin() + <span class="dv">1</span>, g.begin() + r - l + <span class="dv">1</span>};</span>
<span id="cb2-8"><a aria-hidden="true" href="#cb2-8"></a>    t1 = t1 * t2;</span>
<span id="cb2-9"><a aria-hidden="true" href="#cb2-9"></a>    FOR(i, mid + <span class="dv">1</span>, r) ret[i] = (ret[i] + t1[i - l - <span class="dv">1</span>]) % mod;</span>
<span id="cb2-10"><a aria-hidden="true" href="#cb2-10"></a>    <span class="cf">return</span>;</span>
<span id="cb2-11"><a aria-hidden="true" href="#cb2-11"></a>}</span>
<span id="cb2-12"><a aria-hidden="true" href="#cb2-12"></a></span>
<span id="cb2-13"><a aria-hidden="true" href="#cb2-13"></a><span class="dt">void</span> solve(<span class="dt">int</span> l, <span class="dt">int</span> r) {</span>
<span id="cb2-14"><a aria-hidden="true" href="#cb2-14"></a>    <span class="dt">int</span> mid = (l + r) &gt;&gt; <span class="dv">1</span>;</span>
<span id="cb2-15"><a aria-hidden="true" href="#cb2-15"></a>    <span class="cf">if</span> (l == r) <span class="cf">return</span>;</span>
<span id="cb2-16"><a aria-hidden="true" href="#cb2-16"></a>    solve(l, mid);</span>
<span id="cb2-17"><a aria-hidden="true" href="#cb2-17"></a>    FOR(i, <span class="dv">1</span>, m) {</span>
<span id="cb2-18"><a aria-hidden="true" href="#cb2-18"></a>        solve(f[u[i]], p[i], f[v[i]], l, r);</span>
<span id="cb2-19"><a aria-hidden="true" href="#cb2-19"></a>        solve(f[v[i]], p[i], f[u[i]], l, r);</span>
<span id="cb2-20"><a aria-hidden="true" href="#cb2-20"></a>    }</span>
<span id="cb2-21"><a aria-hidden="true" href="#cb2-21"></a>    solve(mid + <span class="dv">1</span>, r);</span>
<span id="cb2-22"><a aria-hidden="true" href="#cb2-22"></a>    <span class="cf">return</span>;</span>
<span id="cb2-23"><a aria-hidden="true" href="#cb2-23"></a>}</span>
<span id="cb2-24"><a aria-hidden="true" href="#cb2-24"></a></span>
<span id="cb2-25"><a aria-hidden="true" href="#cb2-25"></a><span class="dt">int</span> main() {</span>
<span id="cb2-26"><a aria-hidden="true" href="#cb2-26"></a>    read(n), read(m), read(T);</span>
<span id="cb2-27"><a aria-hidden="true" href="#cb2-27"></a>    lim = T + <span class="dv">1</span>;</span>
<span id="cb2-28"><a aria-hidden="true" href="#cb2-28"></a>    FOR(i, <span class="dv">1</span>, m) {</span>
<span id="cb2-29"><a aria-hidden="true" href="#cb2-29"></a>        read(u[i]), read(v[i]);</span>
<span id="cb2-30"><a aria-hidden="true" href="#cb2-30"></a>        p[i].resize(T + <span class="dv">1</span>);</span>
<span id="cb2-31"><a aria-hidden="true" href="#cb2-31"></a>        FOR(j, <span class="dv">1</span>, T) read(p[i][j]);</span>
<span id="cb2-32"><a aria-hidden="true" href="#cb2-32"></a>    }</span>
<span id="cb2-33"><a aria-hidden="true" href="#cb2-33"></a>    FOR(i, <span class="dv">1</span>, n) f[i].resize(T + <span class="dv">1</span>);</span>
<span id="cb2-34"><a aria-hidden="true" href="#cb2-34"></a>    f[<span class="dv">1</span>][<span class="dv">0</span>] = <span class="dv">1</span>;</span>
<span id="cb2-35"><a aria-hidden="true" href="#cb2-35"></a>    solve(<span class="dv">0</span>, T);</span>
<span id="cb2-36"><a aria-hidden="true" href="#cb2-36"></a>    print(f[<span class="dv">1</span>][T]);</span>
<span id="cb2-37"><a aria-hidden="true" href="#cb2-37"></a>    <span class="cf">return</span> output(), <span class="dv">0</span>;</span>
<span id="cb2-38"><a aria-hidden="true" href="#cb2-38"></a>}</span></code></pre></div>
<h3 id="abc217">ABC217</h3>
<p>A + B + C + D + E</p>
<h4 id="abc217f---make-pair">ABC217F - Make Pair</h4>
<p>给定 <span class="math inline">\(2n\)</span> 个学生，其中只有 <span class="math inline">\(m\)</span> 对关系好。每次选择相邻两个关系好的进行配对并从序列中删除，问把所有学生配对的方案。</p>
<p>一眼就是区间 dp。设 <span class="math inline">\(f_{l, r}\)</span> 为将 <span class="math inline">\([l, r]\)</span> 里面的人配对的方案数。</p>
<p>然后至于转移，考虑 <span class="math inline">\(l\)</span> 与谁配对，设其为 <span class="math inline">\(x\)</span>。则首先， <span class="math inline">\([l, x]\)</span> 的长度一定是偶数，并且 <span class="math inline">\(l\)</span> 和 <span class="math inline">\(x\)</span> 的关系好。然后我们需要的就是 <span class="math inline">\(f_{l + 1, x - 1}\)</span> 和 <span class="math inline">\(f_{x + 1, r}\)</span>。注意到移除 <span class="math inline">\([l + 1, x - 1]\)</span> 和 <span class="math inline">\([x + 1, r]\)</span> 是两个独立的过程，并且 <span class="math inline">\([l + 1, x - 1]\)</span> 必须在配对 <span class="math inline">\(l\)</span> 和 <span class="math inline">\(x\)</span> 之前完成。</p>
<p>现在的问题就是，合并 <span class="math inline">\([l, x]\)</span> 和 <span class="math inline">\([x + 1, r]\)</span> 是两个独立的过程，所以考虑一共进行了 <span class="math inline">\((r - l + 1) / 2\)</span> 次合并，而我们需要确定有哪几次是 <span class="math inline">\([x + 1, r]\)</span> 里面的在做，不难发现就是 <span class="math display">\[
\binom{(r - l + 1) / 2}{(r - x) / 2}
\]</span> 转移的时候乘上这个系数即可。</p>
<p><a href="https://atcoder.jp/contests/abc217/submissions/25628059">代码</a>。</p>
<h4 id="abc217g---groups">ABC217G - Groups</h4>
<p>给定 <span class="math inline">\(n\)</span> 个数，要求划分成 <span class="math inline">\(k\)</span> 个非空组，若 <span class="math inline">\(i\equiv j\pmod m\)</span>，则 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(j\)</span> 不能在一组。对于 <span class="math inline">\(k = 1,\cdots, n\)</span> 输出方案数模 <span class="math inline">\(998244353\)</span> 的结果。</p>
<p>原来的组是非空且无标号的，方案数设为 <span class="math inline">\(f(k)\)</span>，先考虑可以为空并且有标号的情况，设为 <span class="math inline">\(g(k)\)</span></p>
<p>设 <span class="math inline">\(S_r\)</span> 为 <span class="math inline">\([1, n]\)</span> 中模 <span class="math inline">\(m\)</span> 的余数为 <span class="math inline">\(r\)</span> 的数字构成的集合，则对于每个 <span class="math inline">\(S_r\)</span>，我们都要将其划分在 <span class="math inline">\(k\)</span> 个不同的组里面去，每个组里面最多 <span class="math inline">\(1\)</span> 个数。</p>
<p>设 <span class="math inline">\(P(n, m) = \displaystyle\frac{n!}{(n - m)!}\)</span> 为 <span class="math inline">\(n\)</span> 选 <span class="math inline">\(m\)</span> 的排列数： <span class="math display">\[
g(k) = \prod_{i = 0}^{m - 1 }P(k, |S_i|)
\]</span> 这是不要求放满的。而如果知道恰好放满的，除以 <span class="math inline">\(k!\)</span> 就是不带标号的了。</p>
<p>恰好放满可以用容斥。去掉的是 <span class="math display">\[
\sum_{p = 0}^{k - 1}\binom kpf(p)p!
\]</span> 即为有序非空组数不到 <span class="math inline">\(k\)</span> 的，所以 <span class="math display">\[
f(k) = \frac{\prod_{i = 0}^{m - 1}P(k, |S_i|) - \sum_{p = 0}^{k - 1}\binom k p f(p)p!}{k!}
\]</span> 递推可做，前面那一段可以快速预处理然后用快速幂 <span class="math inline">\(O(\log n)\)</span> 来算。</p>
<p><a href="https://atcoder.jp/contests/abc217/submissions/25641347/">代码</a>。</p>
<h3 id="abc219">ABC219</h3>
<p>状态差。A + B + C + D。</p>
<h4 id="abc219e---moat">ABC219E - Moat</h4>
<p>一个 <span class="math inline">\(4\times 4\)</span> 的网格，要求在网格边上修一个护城河，使得护城河是一个合法多边形并且包含了所有的村庄。</p>
<p>比较神奇的思路，鉴于网格只有 <span class="math inline">\(16\)</span> 个，而且一个护城河必定和一种状态（一个格子有没有被包含）一一对应，所以可以直接枚举这 <span class="math inline">\(O(2^{16})\)</span> 个状态然后判断网格是否合法。</p>
<p>判断网格是否合法这个，首先需要判断每个村庄是不是被包含，其次需要避免中间被挖空的情况，然后要避免 <span class="math inline">\(1\)</span> 的格子被割裂开的情况，综上即整张图（把边界外的考虑进去）只能有两个连通块，dfs 染色即可。</p>
<h3 id="abc222">ABC222</h3>
<p>A + B + C + D + G，rk 425。</p>
<h4 id="abc222e---red-and-blue-tree">ABC222E - Red and Blue Tree</h4>
<p>给定 <span class="math inline">\(m\)</span> 条树上路径，每次会覆盖若干边。</p>
<p>如果我设第 <span class="math inline">\(i\)</span> 条边的被覆盖次数为 <span class="math inline">\(c_i\)</span> 的话，那么我们每次都会给途径的 <span class="math inline">\(c_i\)</span> 增加 <span class="math inline">\(1\)</span>。</p>
<p>要求覆盖完之后访问红边的次数-访问蓝边的次数=<span class="math inline">\(k\)</span>，问染色方案数。</p>
<p><span class="math inline">\(n\)</span> 很小，所以可以暴力给边染色。</p>
<p>染完之后不难发现 <span class="math inline">\(R\)</span> 和 <span class="math inline">\(B\)</span> 是确定的。所以直接背包一下就可以了。</p>
<h4 id="abc222f---expensive-expense">ABC222F - Expensive Expense</h4>
<p>树，定义 <span class="math inline">\(E_{i, j}\)</span> 为 <span class="math inline">\(i\)</span> 到 <span class="math inline">\(j\)</span> 路径上边权和加上 <span class="math inline">\(j\)</span> 的点权，对于每个 <span class="math inline">\(i\)</span> 找到最大的 <span class="math inline">\(E_{i, j}\)</span>，点数在 <span class="math inline">\(2\times 10^5\)</span> 级别。</p>
<p>简单换根 dp。</p>
<h3 id="abc231">ABC231</h3>
<p>A + B + C + D + F，rk571</p>
<h4 id="abc231e---minimal-payments">ABC231E - Minimal payments</h4>
<p>由于 <span class="math inline">\(A_{i - 1}\mid A_i\)</span>，所以对于一个 <span class="math inline">\(A_i\)</span> 可以只考虑两种方案：用这个 <span class="math inline">\(A_i\)</span> 尽可能凑，或者用更大的面值付然后要找零。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a aria-hidden="true" href="#cb3-1"></a><span class="kw">using</span> ll = <span class="dt">long</span> <span class="dt">long</span>;</span>
<span id="cb3-2"><a aria-hidden="true" href="#cb3-2"></a><span class="dt">int</span> n;</span>
<span id="cb3-3"><a aria-hidden="true" href="#cb3-3"></a>ll a[<span class="dv">65</span>], x, ans;</span>
<span id="cb3-4"><a aria-hidden="true" href="#cb3-4"></a>unordered_map&lt;ll, unordered_map&lt;ll, ll&gt; &gt; f;</span>
<span id="cb3-5"><a aria-hidden="true" href="#cb3-5"></a></span>
<span id="cb3-6"><a aria-hidden="true" href="#cb3-6"></a>ll dfs(ll x, <span class="dt">int</span> now) {</span>
<span id="cb3-7"><a aria-hidden="true" href="#cb3-7"></a>    <span class="cf">if</span> (now == <span class="dv">1</span>) <span class="cf">return</span> x;</span>
<span id="cb3-8"><a aria-hidden="true" href="#cb3-8"></a>    <span class="cf">if</span> (f[x][now] &gt; <span class="dv">0</span>) <span class="cf">return</span> f[x][now];</span>
<span id="cb3-9"><a aria-hidden="true" href="#cb3-9"></a>    ll r = x % a[now], q = x / a[now], p = a[now] - r;</span>
<span id="cb3-10"><a aria-hidden="true" href="#cb3-10"></a>    <span class="cf">if</span> (r == <span class="dv">0</span>) <span class="cf">return</span> q;</span>
<span id="cb3-11"><a aria-hidden="true" href="#cb3-11"></a>    ll w1 = q + <span class="dv">1</span><span class="bu">ll</span> + dfs(p, now - <span class="dv">1</span>);</span>
<span id="cb3-12"><a aria-hidden="true" href="#cb3-12"></a>    ll w2 = q + dfs(r, now - <span class="dv">1</span>);</span>
<span id="cb3-13"><a aria-hidden="true" href="#cb3-13"></a>    <span class="cf">return</span> f[x][now] = min(w1, w2);</span>
<span id="cb3-14"><a aria-hidden="true" href="#cb3-14"></a>}</span>
<span id="cb3-15"><a aria-hidden="true" href="#cb3-15"></a></span>
<span id="cb3-16"><a aria-hidden="true" href="#cb3-16"></a><span class="dt">int</span> main() {</span>
<span id="cb3-17"><a aria-hidden="true" href="#cb3-17"></a>    read(n, x);</span>
<span id="cb3-18"><a aria-hidden="true" href="#cb3-18"></a>    FOR(i, <span class="dv">1</span>, n) read(a[i]);</span>
<span id="cb3-19"><a aria-hidden="true" href="#cb3-19"></a>    ans = x;</span>
<span id="cb3-20"><a aria-hidden="true" href="#cb3-20"></a>    print(dfs(x, n));</span>
<span id="cb3-21"><a aria-hidden="true" href="#cb3-21"></a>    <span class="cf">return</span> output(), <span class="dv">0</span>;</span>
<span id="cb3-22"><a aria-hidden="true" href="#cb3-22"></a>}</span></code></pre></div>
<h4 id="abc231g---balls-in-boxes">ABC231G - Balls in Boxes</h4>
<p>期望牛逼题。大体思路就是拆开期望的式子，利用线性性进行化简。</p>
<p><span class="math inline">\(N\)</span> 个盒子，第 <span class="math inline">\(i\)</span> 个盒子一开始有 <span class="math inline">\(A_i\)</span> 个球，<span class="math inline">\(K\)</span> 次操作，每次操作随机选一个盒子加一个球，最后每个盒子有 <span class="math inline">\(B_i\)</span> 个球，问 <span class="math inline">\(S = \prod B_i\)</span> 的期望，对 <span class="math inline">\(998244353\)</span> 取模。</p>
<p>答案为 <span class="math inline">\(E[S]\)</span>，令 <span class="math inline">\(X_i\)</span> 为表示第 <span class="math inline">\(i\)</span> 个盒子被选中次数的随机变量，则我们要的最终答案就是 <span class="math inline">\(E[\prod_i(A_i + X_i)]\)</span>。考虑 <span class="math inline">\(N = 2\)</span> 的情况，即为 <span class="math inline">\(E[(A_1 + X_1)(A_2 + X_2)] = E[A_1A_2] + E[A_1X_2] + E[A_2X_1] + E[X_1X_2]\)</span>。</p>
<p>推而广之，对于 <span class="math inline">\(n\)</span> 个不一样的下标 <span class="math inline">\(i_1,\cdots, i_n\)</span>，容易知道 <span class="math inline">\(E[\prod_{j = 1}^n X_{i_j}] = E[\prod_{i = 1}^nX_i]\)</span>。所以提出这个公因式，有 <span class="math display">\[
E\left[\prod_{i =1}^N(A_i + X_i)\right] = \sum_{n = 0}^NS_{N, n}(A_1,\cdots, A_N)E\left[\prod_{i =1}^{N - n}X_i\right]
\]</span> 其中 <span class="math inline">\(S_{N, n}\)</span> 表示 <span class="math inline">\(N\)</span> 个变量的 <span class="math inline">\(n\)</span> 次对称多项式。</p>
<p>现在只需要对于每个 <span class="math inline">\(n\)</span> 算出 <span class="math inline">\(S_{N, n}(A_1,\cdots, A_N)\)</span> 和 <span class="math inline">\(E[\prod_{i = 1}^nX_i]\)</span> 即可。</p>
<p>前者，<span class="math inline">\(S_{N, n}(A_1,\cdots, A_N) = [x^n]\prod_{i =1}^N(A_ix + 1)\)</span>。这个东西一个分治 NTT 碾过去应该是 <span class="math inline">\(O(n\log^2n)\)</span> 的。</p>
<p>然后是后者。我们考虑随机变量 <span class="math inline">\(X_{i, j}\)</span> 表示第 <span class="math inline">\(i\)</span> 个盒子在第 <span class="math inline">\(j\)</span> 次操作是否会被选中（0/1）。则 <span class="math inline">\(X_i = \sum_{j = 1}^KX_{i, j}\)</span>。枚举一下下标，发现 <span class="math display">\[
E\left[\prod_{i = 1}^n X_i \right] = \sum_{j_1, j_2,\cdots, j_n}E\left[\prod_{i = 1}^nX_{i, j_i}\right]
\]</span> 然后当 <span class="math inline">\(i_1\not= i_2\)</span> 的时候，显然 <span class="math inline">\(X_{i_1, j}X_{i_2, j} = 0\)</span>。故 <span class="math display">\[
E\left[\prod_{i = 1}^nX_{i, j_i}\right] =
\begin{cases}
\left(\frac 1N\right)^n \quad&amp; \text{if }j_i\text{ are pairwise different}\\
0\quad&amp; \text{otherwise}
\end{cases}
\]</span> 于是 <span class="math display">\[
E\left[\prod_{i = 1}^n X_i \right] = \left(\prod_{i = 1}^n(K + 1 - i)\right)\left(\frac1N\right)^n
\]</span> 这个可以 <span class="math inline">\(O(n)\)</span> 算，于是 <span class="math inline">\(O(n\log^2n)\)</span> 解决了。</p>
<h3 id="abc232">ABC232</h3>
<p>A，B 略。</p>
<p>C 建出一张图的邻接矩阵然后用 <code>next_permutation</code> 枚举排列判断是否能建立映射即可。</p>
<p>D 简单网格 dp，注意边界条件。</p>
<h4 id="abc232e---rook-path">ABC232E - Rook Path</h4>
<p><span class="math inline">\(H \times W\)</span> 的网格，你初始在 <span class="math inline">\((x_1, y_1)\)</span>，要求做 <span class="math inline">\(K\)</span> 次操作后位置变为 <span class="math inline">\((x_2, y_2)\)</span>。每次操作形如：</p>
<ul>
<li>移动横坐标，从 <span class="math inline">\((x, y)\)</span> 移动到 <span class="math inline">\((x', y)\)</span>，其中 <span class="math inline">\(1\le x'\le H\land x'\neq x\)</span>。</li>
<li>移动纵坐标，从 <span class="math inline">\((x, y)\)</span> 移动到 <span class="math inline">\((x, y')\)</span>，其中 <span class="math inline">\(1\le y'\le W\land y'\neq y\)</span>。</li>
</ul>
<p>（就是车的移动方式）问有多少种可能的操作方案，两种操作方案不同当且仅当中间某一步经过的点不同。答案对 <span class="math inline">\(998244353\)</span> 取模。</p>
<p>根据套路，这个东西的横向移动和纵向移动是可以分开来考虑的。即，我们可以考虑横向上走 <span class="math inline">\(m\)</span> 步的方案，再乘上纵向上走 <span class="math inline">\(K - m\)</span> 步的方案，再乘上组合系数 <span class="math inline">\(\dbinom K m\)</span>。考虑计算在一个方向上走 <span class="math inline">\(m\)</span> 步的方案数。</p>
<p>可以 DP，设 <span class="math inline">\(f_{0/1, i}\)</span> 表示横向移动（纵向的类似）回到出发点与否，走 <span class="math inline">\(i\)</span> 步的方案数，其中初始边界是 <span class="math inline">\(f_{1,0} = 1\)</span>，即走 <span class="math inline">\(0\)</span> 步，终点在原点的方案数为 <span class="math inline">\(1\)</span>。转移如下： <span class="math display">\[
\begin{cases}
f_{1, i} = (H - 1)f_{1, i - 1}\\
f_{0, i} = f_{1, i - 1} + (H - 2)f_{0, i - 1}
\end{cases}
\]</span> 转移的意义还是很显然的。于是我们 <span class="math inline">\(O(n)\)</span> 求出 dp 数组，这题就做完了，<a href="https://atcoder.jp/contests/abc232/submissions/28029224">评测记录</a>。</p>
<h4 id="abc232f---simple-operations-on-sequence">ABC232F - Simple Operations on Sequence</h4>
<p>给定两个长度为 <span class="math inline">\(N\)</span>（<span class="math inline">\(2\le N\le 18\)</span>）：<span class="math inline">\(A_i\)</span> 和 <span class="math inline">\(B_i\)</span>（<span class="math inline">\(1\le A_i, B_i\le 10^8\)</span>）。可以进行如下两种操作，问最小的使得 <span class="math inline">\(A\)</span> 变成 <span class="math inline">\(B\)</span> 的操作代价：</p>
<ul>
<li>对 <span class="math inline">\(A_i\)</span> 加一/减一，代价为 <span class="math inline">\(X\)</span>（<span class="math inline">\(1\le X\le 10^8\)</span>）</li>
<li>交换 <span class="math inline">\(A\)</span> 中的相邻元素，代价为 <span class="math inline">\(Y\)</span>（<span class="math inline">\(1\le Y\le 10^{16}\)</span>）</li>
</ul>
<p>毫无疑问，两个操作是相互独立的，可以分开考虑。如果我们先交换，出一个 <span class="math inline">\(P_1, P_2,\cdots,P_N\)</span> 的排列，然后再统计第一个的答案。令 <span class="math inline">\(\operatorname{inv}(P)\)</span> 为 <span class="math inline">\(P\)</span> 的逆序对数，则总代价为： <span class="math display">\[
\sum_{i = 1}^N|A_{P_i} - B_i|\cdot X + \operatorname{inv}(P)\cdot Y
\]</span> 把逆序对的这个关于 <span class="math inline">\(i\)</span> 的贡献拆开，则我们可以得到 <span class="math display">\[
\sum_{i = 1}^N(|A_{P_i} - B_i|\cdot X + |\{p:p\in\{1,2,\cdots, N\} \backslash \{P_1, \cdots, P_{i - 1}\}, p &lt; P_i\}|\cdot Y)
\]</span> 然后会发现一个很关键的地方：后面那个东西只和 <span class="math inline">\(\{P_1, \cdots, P_i\}\)</span> 这个集合有关，而这个集合很小，所以不妨考虑将其状压起来，令 <span class="math inline">\(f(x, S)\)</span> 表示 <span class="math inline">\(|p:p\in\{1, \cdots, N\}\backslash S, p &lt; x|\)</span>。然后式子改写为： <span class="math display">\[
\sum_{i = 1}^N(|A_{P_i} - B_i|\cdot X + f(P_i, \{P_1, \cdots, P_{i - 1}\})\cdot Y)
\]</span> 于是发现，这个东西可以状压 dp，具体地，设 <span class="math inline">\(dp_S\)</span> 表示排列的前 <span class="math inline">\(|S|\)</span> 项是 <span class="math inline">\(S\)</span> 内的元素，则转移应该是很好转移的。这题就做完了，<a href="https://atcoder.jp/contests/abc232/submissions/28032712">评测记录</a>。</p>
<h4 id="abc232g---modulo-shortest-path">ABC232G - Modulo Shortest Path</h4>
<p>给定一张 <span class="math inline">\(N\)</span> 个点的有向完全图，其中，<span class="math inline">\(i\)</span> 到 <span class="math inline">\(j\)</span> 的有向边边权为 <span class="math inline">\((A_i + B_j)\bmod M\)</span>。问 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(N\)</span> 的最短路。</p>
<p><span class="math inline">\(2\le N\le 2\times 10^5\)</span>，<span class="math inline">\(2\le M\le 10^9\)</span>。</p>
<p>首先如果我们直接连边跑 Dij，那么必然会寄，边数是 <span class="math inline">\(O(n^2)\)</span> 级别的，要想办法少下来。</p>
<p>考虑一个技巧，建一张新图：</p>
<ul>
<li>构建 <span class="math inline">\([0, M)\)</span> 的虚点 <span class="math inline">\(\overline{0},\overline 1,\cdots,\overline{M - 1}\)</span>。</li>
<li>然后 <span class="math inline">\(\forall k\in[0, M - 1)\)</span>，连边 <span class="math inline">\(\overline k\to \overline{k + 1}\)</span>，边权为 <span class="math inline">\(1\)</span>。</li>
<li><span class="math inline">\(\forall i\in [1, N]\)</span>，连边 <span class="math inline">\(i\to \overline{-A_i\bmod M}\)</span>，边权为 <span class="math inline">\(0\)</span>。</li>
<li><span class="math inline">\(\forall i\in [1, N]\)</span>，连边 <span class="math inline">\(\overline{B_i}\)</span>，边权为 <span class="math inline">\(0\)</span>。</li>
</ul>
<p>这样一来，从 <span class="math inline">\(i\)</span> 走到 <span class="math inline">\(j\)</span> 就相当于，从 <span class="math inline">\(i\)</span> 走到 <span class="math inline">\(\overline{-A_i\bmod M}\)</span>，然后一步步走到 <span class="math inline">\(\overline{B_j}\)</span>，再走到 <span class="math inline">\(j\)</span>。发现中间的路程刚好就是 <span class="math inline">\((A_i + B_j)\bmod M\)</span>，于是问题就得到了转化，我们求新图上 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(N\)</span> 的最短路即可。</p>
<p>可是，<span class="math inline">\(O(n + m)\)</span> 似乎也必死无疑。</p>
<p>然而我们可以发现，环上的很多点是没有用的，我们可以将其缩起来，会和原来的点连接的虚点只有 <span class="math inline">\(2n\)</span> 个，这样子点数和边数就都控制在了 <span class="math inline">\(O(n)\)</span> 级别，直接跑 Dij 便可通过，时间复杂度 <span class="math inline">\(O(n\log n)\)</span>，<a href="https://atcoder.jp/contests/abc232/submissions/28035096">评测记录</a>。</p>
<h4 id="abc232h---kings-tour">ABC232H - King’s Tour</h4>
<p>不知道组题人怎么想的。。。这个题居然放在 H。</p>
<p>给定 <span class="math inline">\(H\times W\)</span> 棋盘，一个国王初始在 <span class="math inline">\((1, 1)\)</span>。国王每步可以走到与其八连通的格子，请构造一个方案使得国王不重复地走完了每个格子，且终点为 <span class="math inline">\((a, b)\)</span>。<span class="math inline">\(2\le H, W\le 100\)</span>，<span class="math inline">\((a, b)\neq (1, 1)\)</span>。</p>
<p>我们考虑减治构造。考虑如下几种情况：</p>
<hr/>
<p><span class="math inline">\(H = 2\)</span> 或 <span class="math inline">\(W = 2\)</span>：</p>
<p>如果 <span class="math inline">\(H = 2\)</span>，那么就可以像下面这样构造方案（图源 AtCoder 官方题解）：</p>
<p><img src="https://img.atcoder.jp/ghi/45d400563f38eb01ffea2e66239b9664.png"/></p>
<p>即，轨迹为：<span class="math inline">\((1, 1)\to (2, 1)\to\cdots\to(1, b)\to (1, b + 1)\to \cdots \to(1, W)\to (2, W)\to \cdots\to (2, b)\)</span>。如果 <span class="math inline">\(W= 2\)</span>，那么将行列调换之后是一样的。</p>
<hr/>
<p><span class="math inline">\(H &gt; 2\)</span> 且 <span class="math inline">\(W &gt; 2\)</span>：</p>
<p>考虑下面这个方案：</p>
<p><img src="https://img.atcoder.jp/ghi/6a11b9fe7eebca4ddd44a12826580c99.png"/></p>
<p>绿色圈出来的点集为 <span class="math inline">\(S\)</span>，分类讨论：</p>
<ul>
<li><span class="math inline">\((a, b)\notin S\)</span>，则我们可以走完 <span class="math inline">\(S\)</span> 内的点，然后垂直翻转一下坐标系，就变成了一个一模一样的子问题，递归处理即可。</li>
<li><span class="math inline">\((a, b)\in S\)</span>，则我们交换行列之后，就变成了 <span class="math inline">\((a,b)\notin S\)</span> 的情况。</li>
</ul>
<p>然后就可以递归地去解决这道题了。这种代码写的很巧妙：</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a aria-hidden="true" href="#cb4-1"></a><span class="kw">using</span> pii = pair&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt;;</span>
<span id="cb4-2"><a aria-hidden="true" href="#cb4-2"></a> </span>
<span id="cb4-3"><a aria-hidden="true" href="#cb4-3"></a>vector&lt;pii&gt; solve(<span class="dt">int</span> h, <span class="dt">int</span> w, <span class="dt">int</span> a, <span class="dt">int</span> b) {</span>
<span id="cb4-4"><a aria-hidden="true" href="#cb4-4"></a>    vector&lt;pii&gt; ret;</span>
<span id="cb4-5"><a aria-hidden="true" href="#cb4-5"></a>    <span class="cf">if</span> (h == <span class="dv">2</span>) {</span>
<span id="cb4-6"><a aria-hidden="true" href="#cb4-6"></a>        FOR(i, <span class="dv">1</span>, b - <span class="dv">1</span>) ret.push_back(pii(<span class="dv">1</span>, i)), ret.push_back(pii(<span class="dv">2</span>, i));</span>
<span id="cb4-7"><a aria-hidden="true" href="#cb4-7"></a>        ret.push_back(pii(<span class="dv">3</span> - a, b));</span>
<span id="cb4-8"><a aria-hidden="true" href="#cb4-8"></a>        FOR(i, b + <span class="dv">1</span>, w) ret.push_back(pii(<span class="dv">1</span>, i));</span>
<span id="cb4-9"><a aria-hidden="true" href="#cb4-9"></a>        DEC(i, w, b + <span class="dv">1</span>) ret.push_back(pii(<span class="dv">2</span>, i));</span>
<span id="cb4-10"><a aria-hidden="true" href="#cb4-10"></a>        ret.push_back(pii(a, b));</span>
<span id="cb4-11"><a aria-hidden="true" href="#cb4-11"></a>    } <span class="cf">else</span> <span class="cf">if</span> ((h &gt; <span class="dv">2</span> &amp;&amp; w == <span class="dv">2</span>) || b == <span class="dv">1</span> || (a == h &amp;&amp; b == <span class="dv">2</span>)) {</span>
<span id="cb4-12"><a aria-hidden="true" href="#cb4-12"></a>        ret = solve(w, h, b, a);</span>
<span id="cb4-13"><a aria-hidden="true" href="#cb4-13"></a>        <span class="cf">for</span> (<span class="kw">auto</span> &amp;p : ret) myswap(p.first, p.second);</span>
<span id="cb4-14"><a aria-hidden="true" href="#cb4-14"></a>    } <span class="cf">else</span> {</span>
<span id="cb4-15"><a aria-hidden="true" href="#cb4-15"></a>        FOR(i, <span class="dv">1</span>, h) ret.push_back(pii(i, <span class="dv">1</span>));</span>
<span id="cb4-16"><a aria-hidden="true" href="#cb4-16"></a>        <span class="kw">auto</span> res = solve(h, w - <span class="dv">1</span>, h + <span class="dv">1</span> - a, b - <span class="dv">1</span>);</span>
<span id="cb4-17"><a aria-hidden="true" href="#cb4-17"></a>        <span class="cf">for</span> (<span class="kw">auto</span> &amp;p : res) p.first = h + <span class="dv">1</span> - p.first, ++p.second;</span>
<span id="cb4-18"><a aria-hidden="true" href="#cb4-18"></a>        ret.insert(ret.end(), res.begin(), res.end());</span>
<span id="cb4-19"><a aria-hidden="true" href="#cb4-19"></a>    }</span>
<span id="cb4-20"><a aria-hidden="true" href="#cb4-20"></a>    <span class="cf">return</span> ret;</span>
<span id="cb4-21"><a aria-hidden="true" href="#cb4-21"></a>}</span>
<span id="cb4-22"><a aria-hidden="true" href="#cb4-22"></a> </span>
<span id="cb4-23"><a aria-hidden="true" href="#cb4-23"></a><span class="dt">int</span> main() {</span>
<span id="cb4-24"><a aria-hidden="true" href="#cb4-24"></a>    <span class="dt">int</span> h, w, a, b; read(h, w, a, b);</span>
<span id="cb4-25"><a aria-hidden="true" href="#cb4-25"></a>    <span class="kw">auto</span> ans = solve(h, w, a, b);</span>
<span id="cb4-26"><a aria-hidden="true" href="#cb4-26"></a>    <span class="cf">for</span> (<span class="kw">auto</span> p : ans) print(p.first, p.second);</span>
<span id="cb4-27"><a aria-hidden="true" href="#cb4-27"></a>    <span class="cf">return</span> output(), <span class="dv">0</span>;</span>
<span id="cb4-28"><a aria-hidden="true" href="#cb4-28"></a>}</span></code></pre></div>
<h3 id="abc233">ABC233</h3>
<h4 id="abc233f---swap-and-sort">ABC233F - Swap and Sort</h4>
<p>简要题意：给定排列 <span class="math inline">\(P\)</span>，<span class="math inline">\(n\le 1000\)</span>。同时给定 <span class="math inline">\(m\)</span> 组关系 <span class="math inline">\((a_i, b_i)\)</span>，每次可以交换 <span class="math inline">\(P_{a_i}\)</span> 和 <span class="math inline">\(P_{b_i}\)</span>。构造一个最多 <span class="math inline">\(5\times 10^5\)</span> 步的方案使得 <span class="math inline">\(P\)</span> 为升序。</p>
<p>整个问题可以抽象成一张图。然后可以发现，当且仅当数字 <span class="math inline">\(p_i\)</span> 和点 <span class="math inline">\(i\)</span> 在一个连通分量内时整个问题有解，这个问题可以写一个并查集之类的东西判断一下。</p>
<p>然后构造方案。由于不要求最优性，所以我们可以直接考虑建出一个生成树，然后从点度为 <span class="math inline">\(1\)</span> 的点开始逐个复位并删点。操作次数最多为 <span class="math inline">\(999 + 998 + \cdots + 1 = 499500\)</span>。<a href="https://atcoder.jp/contests/abc233/submissions/28192989">评测记录</a>。</p>
<h4 id="abc233g---strongest-takahashi">ABC233G - Strongest Takahashi</h4>
<p>简要题意：给定一张 <span class="math inline">\(N\times N\)</span>（<span class="math inline">\(1\le N\le 50\)</span>）网格，里面若干个格子有障碍。每次可以选择一个 <span class="math inline">\(D\times D\)</span> 的区域然后消耗 <span class="math inline">\(D\)</span> 点体力将其中的障碍消去。问将所有障碍消去的最小体力消耗。</p>
<p>这种高维度的 dp 一直是我的弱点。。。考虑一个 <span class="math inline">\(A\times B\)</span> 的矩形区域（子问题），我们显然需要 <span class="math inline">\(C = \max(A,B)\)</span> 的体力来覆盖整个矩形。然而可能存在更少的体力消耗就能覆盖。具体地，当存在一个空行/空列时，我们就可以考虑将子矩形划开，变成两个独立子问题，看一下有没有更优解。</p>
<p>所以设一个 <span class="math inline">\(f_{l,u,r,d}\)</span> 来进行 dp（使用记搜转移）即可，转移复杂度似乎是 <span class="math inline">\(O(n^5)\)</span> 的，<a href="https://atcoder.jp/contests/abc233/submissions/28194586">评测记录</a>。</p>
<h4 id="abc233ex---manhattan-christmas-tree">ABC233Ex - Manhattan Christmas Tree</h4>
<p>简要题意：给定平面内 <span class="math inline">\(n\)</span> 个点，<span class="math inline">\(q\)</span> 次询问到 <span class="math inline">\((a, b)\)</span> 第 <span class="math inline">\(k\)</span> 近的点到 <span class="math inline">\((a, b)\)</span> 的距离，这里的距离指曼哈顿距离。<span class="math inline">\(5\times 10^5\)</span>，7s。</p>
<p>首先我们发现曼哈顿距离很不好处理第 <span class="math inline">\(k\)</span> 近之类的问题，因为既要考虑两个维度又有绝对值。所以考虑将每个点 <span class="math inline">\((x, y)\)</span> 变成 <span class="math inline">\((x + y, x - y)\)</span>，这样原图的曼哈顿距离就可以被转化为切比雪夫距离。</p>
<p>于是我们对于每个询问就可以二分一下第 <span class="math inline">\(k\)</span> 近的距离，查询有多少个点到 <span class="math inline">\((a,b)\)</span> 的切比雪夫距离 <span class="math inline">\(\le d\)</span>，这个查询其实就是一个二维数点（查询矩形和），可以通过写一个主席树来实现。复杂度为 <span class="math inline">\(O((n + Q)\log^2X)\)</span>，<span class="math inline">\(X\)</span> 为点的值域。主席树写着有点心烦，要注意细节，<a href="https://atcoder.jp/contests/abc233/submissions/28193992">评测记录</a>。</p>
<h3 id="abc234">ABC234</h3>
<p>A，B 略。</p>
<p>C 考虑将 <span class="math inline">\(K\)</span> 二进制表示下的每个 <span class="math inline">\(1\)</span> 换成 <span class="math inline">\(2\)</span> 即可。</p>
<p>D 维护一个小根堆在线维护前 <span class="math inline">\(K\)</span> 大元素即可。</p>
<p>E 发现首项只可能是 <span class="math inline">\(a_1\)</span> 或 <span class="math inline">\(a_1 + 1\)</span>，随后枚举公差判断是否可行即可，细节略多。</p>
<h4 id="abc234f---reordering">ABC234F - Reordering</h4>
<p>题意：给定一个字符串 <span class="math inline">\(S\)</span>，问选出里面的部分字母并重排后能得到多少种不同字符串。<span class="math inline">\(|S|\le 5000\)</span>，模 <span class="math inline">\(998244353\)</span>。</p>
<p>考虑能构成的字符串只与字符集合有关。我们不妨从 <span class="math inline">\(\texttt a\)</span> 开始，一个个的加字符。设 <span class="math inline">\(f_{i, j}\)</span> 表示前 <span class="math inline">\(i\)</span> 种字符中，填满了 <span class="math inline">\(j\)</span> 个格子的方案数。转移的时候考虑第 <span class="math inline">\(i\)</span> 个字符我们填 <span class="math inline">\(k\)</span> 个进去，就相当于是 <span class="math inline">\(j - k + 1\)</span> 个不同的桶里面放 <span class="math inline">\(k\)</span> 个相同球，可以有空桶，所以转移如下： <span class="math display">\[
f_{i,j} = \sum_{k = 0}^{\min(j, g(i))}\binom k jf_{i- 1, j - k}
\]</span> <span class="math inline">\(g(i)\)</span> 为第 <span class="math inline">\(i\)</span> 种字符在原串中的出现次数。</p>
<p>那么 <span class="math inline">\(\sum f_{26, i}\)</span> 就是答案。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a aria-hidden="true" href="#cb5-1"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="dv">5005</span>;</span>
<span id="cb5-2"><a aria-hidden="true" href="#cb5-2"></a><span class="dt">char</span> s[maxn];</span>
<span id="cb5-3"><a aria-hidden="true" href="#cb5-3"></a>modint f[<span class="dv">26</span>][maxn], fac[maxn], ifac[maxn];</span>
<span id="cb5-4"><a aria-hidden="true" href="#cb5-4"></a><span class="dt">int</span> buc[<span class="dv">27</span>];</span>
<span id="cb5-5"><a aria-hidden="true" href="#cb5-5"></a></span>
<span id="cb5-6"><a aria-hidden="true" href="#cb5-6"></a>modint binom(<span class="dt">int</span> n, <span class="dt">int</span> m) {<span class="cf">return</span> fac[n] * ifac[m] * ifac[n - m];}</span>
<span id="cb5-7"><a aria-hidden="true" href="#cb5-7"></a></span>
<span id="cb5-8"><a aria-hidden="true" href="#cb5-8"></a><span class="dt">int</span> main() {</span>
<span id="cb5-9"><a aria-hidden="true" href="#cb5-9"></a>    read(s + <span class="dv">1</span>);</span>
<span id="cb5-10"><a aria-hidden="true" href="#cb5-10"></a>    <span class="dt">int</span> n = strlen(s + <span class="dv">1</span>);</span>
<span id="cb5-11"><a aria-hidden="true" href="#cb5-11"></a>    FOR(i, <span class="dv">1</span>, n) ++buc[s[i] - <span class="ch">'a'</span>];</span>
<span id="cb5-12"><a aria-hidden="true" href="#cb5-12"></a>    fac[<span class="dv">0</span>] = <span class="dv">1</span>;</span>
<span id="cb5-13"><a aria-hidden="true" href="#cb5-13"></a>    FOR(i, <span class="dv">1</span>, n) fac[i] = i * fac[i - <span class="dv">1</span>];</span>
<span id="cb5-14"><a aria-hidden="true" href="#cb5-14"></a>    ifac[n] = qPow(fac[n], mod - <span class="dv">2</span>);</span>
<span id="cb5-15"><a aria-hidden="true" href="#cb5-15"></a>    DEC(i, n - <span class="dv">1</span>, <span class="dv">0</span>) ifac[i] = (i + <span class="dv">1</span>) * ifac[i + <span class="dv">1</span>];</span>
<span id="cb5-16"><a aria-hidden="true" href="#cb5-16"></a>    FOR(j, <span class="dv">0</span>, buc[<span class="dv">0</span>]) f[<span class="dv">0</span>][j] = <span class="dv">1</span>;</span>
<span id="cb5-17"><a aria-hidden="true" href="#cb5-17"></a>    FOR(i, <span class="dv">1</span>, <span class="dv">25</span>) {</span>
<span id="cb5-18"><a aria-hidden="true" href="#cb5-18"></a>        FOR(j, <span class="dv">0</span>, n) {</span>
<span id="cb5-19"><a aria-hidden="true" href="#cb5-19"></a>            FOR(k, <span class="dv">0</span>, min(buc[i], j)) {</span>
<span id="cb5-20"><a aria-hidden="true" href="#cb5-20"></a>                f[i][j] += binom(j, k) * f[i - <span class="dv">1</span>][j - k];</span>
<span id="cb5-21"><a aria-hidden="true" href="#cb5-21"></a>            }</span>
<span id="cb5-22"><a aria-hidden="true" href="#cb5-22"></a>        }</span>
<span id="cb5-23"><a aria-hidden="true" href="#cb5-23"></a>    }</span>
<span id="cb5-24"><a aria-hidden="true" href="#cb5-24"></a>    modint ans = <span class="dv">0</span>;</span>
<span id="cb5-25"><a aria-hidden="true" href="#cb5-25"></a>    FOR(j, <span class="dv">1</span>, n) ans += f[<span class="dv">25</span>][j];</span>
<span id="cb5-26"><a aria-hidden="true" href="#cb5-26"></a>    print(ans);</span>
<span id="cb5-27"><a aria-hidden="true" href="#cb5-27"></a>    <span class="cf">return</span> output(), <span class="dv">0</span>;</span>
<span id="cb5-28"><a aria-hidden="true" href="#cb5-28"></a>}</span></code></pre></div>
<h4 id="abc234g---divide-a-sequence">ABC234G - Divide a Sequence</h4>
<p>给定长为 <span class="math inline">\(N\)</span> 的数列 <span class="math inline">\(A\)</span>，有 <span class="math inline">\(2^{N - 1}\)</span> 种方法将其划分为若干个非空序列 <span class="math inline">\(B_1,\cdots, B_k\)</span>，求出对于每种划分方式，下面这个式子的和，对 <span class="math inline">\(998244353\)</span> 取模，<span class="math inline">\(N\le 3\times 10^5\)</span>。 <span class="math display">\[
\prod_{i = 1}^k(\max\{B_i\} - \min\{B_i\})
\]</span> 考虑一个 dp：<span class="math inline">\(f_i\)</span> 为 <span class="math inline">\(A_1, \cdots, A_i\)</span> 的答案，边界为 <span class="math inline">\(f_0 = 1\)</span>。则我们可以知道： <span class="math display">\[
f_i = \sum_{j = 0}^{i - 1}f_j(\max_{k = j + 1}^i\{A_i\} - \min_{k = j + 1}^i\{A_i\})
\]</span> 这个式子看似是 <span class="math inline">\(O(n^2)\)</span> 的，拆开来： <span class="math display">\[
f_i = \sum_{j = 0}^{i - 1}f_j\max_{k = j + 1}^i\{A_i\} - \sum_{j = 0}^{i - 1}f_j\min_{k = j + 1}^i\{A_i\}
\]</span> 然后我们维护一下 <span class="math inline">\(\max_{k = j + 1}^i\{A_k\}\)</span>，以及对应的 dp 值之和，使用单调栈就可以完成这题了。答案即为 <span class="math inline">\(f_n\)</span>，实现细节见代码。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a aria-hidden="true" href="#cb6-1"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">3e5</span> + <span class="dv">5</span>;</span>
<span id="cb6-2"><a aria-hidden="true" href="#cb6-2"></a>modint f[maxn];</span>
<span id="cb6-3"><a aria-hidden="true" href="#cb6-3"></a><span class="dt">int</span> a[maxn], n;</span>
<span id="cb6-4"><a aria-hidden="true" href="#cb6-4"></a></span>
<span id="cb6-5"><a aria-hidden="true" href="#cb6-5"></a><span class="kw">struct</span> node {</span>
<span id="cb6-6"><a aria-hidden="true" href="#cb6-6"></a>    <span class="dt">int</span> a;</span>
<span id="cb6-7"><a aria-hidden="true" href="#cb6-7"></a>    modint v;</span>
<span id="cb6-8"><a aria-hidden="true" href="#cb6-8"></a>} st1[maxn], st2[maxn];</span>
<span id="cb6-9"><a aria-hidden="true" href="#cb6-9"></a><span class="dt">int</span> top1, top2;</span>
<span id="cb6-10"><a aria-hidden="true" href="#cb6-10"></a></span>
<span id="cb6-11"><a aria-hidden="true" href="#cb6-11"></a><span class="dt">int</span> main() {</span>
<span id="cb6-12"><a aria-hidden="true" href="#cb6-12"></a>    read(n);</span>
<span id="cb6-13"><a aria-hidden="true" href="#cb6-13"></a>    FOR(i, <span class="dv">1</span>, n) read(a[i]);</span>
<span id="cb6-14"><a aria-hidden="true" href="#cb6-14"></a>    f[<span class="dv">1</span>] = <span class="dv">1</span>;</span>
<span id="cb6-15"><a aria-hidden="true" href="#cb6-15"></a>    modint maxsum = <span class="dv">0</span>, minsum = <span class="dv">0</span>;</span>
<span id="cb6-16"><a aria-hidden="true" href="#cb6-16"></a>    FOR(i, <span class="dv">1</span>, n) {</span>
<span id="cb6-17"><a aria-hidden="true" href="#cb6-17"></a>        modint sumv = f[i];</span>
<span id="cb6-18"><a aria-hidden="true" href="#cb6-18"></a>        <span class="cf">while</span> (top1 &amp;&amp; st1[top1].a &lt; a[i]) {</span>
<span id="cb6-19"><a aria-hidden="true" href="#cb6-19"></a>            maxsum -= st1[top1].a * st1[top1].v;</span>
<span id="cb6-20"><a aria-hidden="true" href="#cb6-20"></a>            sumv += st1[top1].v;</span>
<span id="cb6-21"><a aria-hidden="true" href="#cb6-21"></a>            --top1;</span>
<span id="cb6-22"><a aria-hidden="true" href="#cb6-22"></a>        }</span>
<span id="cb6-23"><a aria-hidden="true" href="#cb6-23"></a>        maxsum += sumv * a[i];</span>
<span id="cb6-24"><a aria-hidden="true" href="#cb6-24"></a>        ++top1, st1[top1] = {a[i], sumv};</span>
<span id="cb6-25"><a aria-hidden="true" href="#cb6-25"></a>        sumv = f[i];</span>
<span id="cb6-26"><a aria-hidden="true" href="#cb6-26"></a>        <span class="cf">while</span> (top2 &amp;&amp; st2[top2].a &gt; a[i]) {</span>
<span id="cb6-27"><a aria-hidden="true" href="#cb6-27"></a>            minsum -= st2[top2].a * st2[top2].v;</span>
<span id="cb6-28"><a aria-hidden="true" href="#cb6-28"></a>            sumv += st2[top2].v;</span>
<span id="cb6-29"><a aria-hidden="true" href="#cb6-29"></a>            --top2;</span>
<span id="cb6-30"><a aria-hidden="true" href="#cb6-30"></a>        }</span>
<span id="cb6-31"><a aria-hidden="true" href="#cb6-31"></a>        minsum += sumv * a[i];</span>
<span id="cb6-32"><a aria-hidden="true" href="#cb6-32"></a>        ++top2, st2[top2] = {a[i], sumv};</span>
<span id="cb6-33"><a aria-hidden="true" href="#cb6-33"></a>        f[i + <span class="dv">1</span>] = maxsum - minsum;</span>
<span id="cb6-34"><a aria-hidden="true" href="#cb6-34"></a>    }</span>
<span id="cb6-35"><a aria-hidden="true" href="#cb6-35"></a>    print(f[n + <span class="dv">1</span>]);</span>
<span id="cb6-36"><a aria-hidden="true" href="#cb6-36"></a>    <span class="cf">return</span> output(), <span class="dv">0</span>;</span>
<span id="cb6-37"><a aria-hidden="true" href="#cb6-37"></a>}</span></code></pre></div>
<h4 id="abc234ex---enumerate-pairs">ABC234Ex - Enumerate Pairs</h4>
<p>给定二维平面上的 <span class="math inline">\(N\)</span> 个点 <span class="math inline">\((x_i, y_i)\)</span> 和一个正整数 <span class="math inline">\(K\)</span>。请列出所有欧几里得距离小于等于 <span class="math inline">\(K\)</span> 的点对。<span class="math inline">\(1\le N\le 2\times 10^5\)</span>，<span class="math inline">\(1\le K\le 1.5\times 10^9\)</span>。保证最多 <span class="math inline">\(4\times 10^5\)</span> 对点对将被枚举。</p>
<p><strong>以下题解参考了 AtCoder 官方题解</strong>，<a href="https://atcoder.jp/contests/abc234/editorial/3235">传送门</a>。神仙结论题，先给出结论：</p>
<ul>
<li>对于每个点 <span class="math inline">\((x_i, y_i)\)</span>，将其分配到集合 <span class="math inline">\((\lfloor x_i/K\rfloor, \lfloor y_i/K\rfloor)\)</span> 中。</li>
<li>然后对于任意一个点，若其被分配到了 <span class="math inline">\((X, Y)\)</span> 集合中，则能与其配对的点一定在 <span class="math inline">\((X + m, Y + l)\)</span> 集合中，其中 <span class="math inline">\(-1\le m,l\le 1\)</span>。直接枚举即可得到答案。</li>
</ul>
<p>然后，其时间复杂度为 <span class="math inline">\(O(N + M)\)</span>，其中 <span class="math inline">\(M\)</span> 为输出的答案个数（忽略了使用数据结构产生的 <span class="math inline">\(\log\)</span>）。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a aria-hidden="true" href="#cb7-1"></a><span class="kw">using</span> ll = <span class="dt">long</span> <span class="dt">long</span>;</span>
<span id="cb7-2"><a aria-hidden="true" href="#cb7-2"></a><span class="kw">using</span> pii = pair&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt;;</span>
<span id="cb7-3"><a aria-hidden="true" href="#cb7-3"></a><span class="kw">using</span> pll = pair&lt;ll, ll&gt;;</span>
<span id="cb7-4"><a aria-hidden="true" href="#cb7-4"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">2e5</span> + <span class="dv">5</span>;</span>
<span id="cb7-5"><a aria-hidden="true" href="#cb7-5"></a><span class="at">const</span> ll big = <span class="dv">2000000000</span>;</span>
<span id="cb7-6"><a aria-hidden="true" href="#cb7-6"></a><span class="dt">int</span> n; ll K;</span>
<span id="cb7-7"><a aria-hidden="true" href="#cb7-7"></a>pll p[maxn];</span>
<span id="cb7-8"><a aria-hidden="true" href="#cb7-8"></a>map&lt;ll, vector&lt;<span class="dt">int</span>&gt; &gt; mp;</span>
<span id="cb7-9"><a aria-hidden="true" href="#cb7-9"></a>vector&lt;ll&gt; delta = {-big - <span class="dv">1</span>, -big, -big + <span class="dv">1</span>, -<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>, big - <span class="dv">1</span>, big, big + <span class="dv">1</span>};</span>
<span id="cb7-10"><a aria-hidden="true" href="#cb7-10"></a></span>
<span id="cb7-11"><a aria-hidden="true" href="#cb7-11"></a><span class="dt">int</span> main() {</span>
<span id="cb7-12"><a aria-hidden="true" href="#cb7-12"></a>    read(n, K);</span>
<span id="cb7-13"><a aria-hidden="true" href="#cb7-13"></a>    FOR(i, <span class="dv">1</span>, n) {</span>
<span id="cb7-14"><a aria-hidden="true" href="#cb7-14"></a>        read(p[i].first, p[i].second);</span>
<span id="cb7-15"><a aria-hidden="true" href="#cb7-15"></a>        ll id = (p[i].first / K) * big + (p[i].second / K);</span>
<span id="cb7-16"><a aria-hidden="true" href="#cb7-16"></a>        mp[id].push_back(i);</span>
<span id="cb7-17"><a aria-hidden="true" href="#cb7-17"></a>    }</span>
<span id="cb7-18"><a aria-hidden="true" href="#cb7-18"></a>    vector&lt;pii&gt; ans;</span>
<span id="cb7-19"><a aria-hidden="true" href="#cb7-19"></a>    FOR(i, <span class="dv">1</span>, n) {</span>
<span id="cb7-20"><a aria-hidden="true" href="#cb7-20"></a>        ll id = (p[i].first / K) * big + (p[i].second / K);</span>
<span id="cb7-21"><a aria-hidden="true" href="#cb7-21"></a>        <span class="cf">for</span> (<span class="kw">auto</span> &amp;d : delta) {</span>
<span id="cb7-22"><a aria-hidden="true" href="#cb7-22"></a>            ll curid = id + d;</span>
<span id="cb7-23"><a aria-hidden="true" href="#cb7-23"></a>            <span class="cf">for</span> (<span class="kw">auto</span> &amp;j : mp[curid]) {</span>
<span id="cb7-24"><a aria-hidden="true" href="#cb7-24"></a>                <span class="cf">if</span> (j &gt;= i) <span class="cf">continue</span>;</span>
<span id="cb7-25"><a aria-hidden="true" href="#cb7-25"></a>                ll dis = (p[i].first - p[j].first) * (p[i].first - p[j].first) + (p[i].second - p[j].second) * (p[i].second - p[j].second);</span>
<span id="cb7-26"><a aria-hidden="true" href="#cb7-26"></a>                <span class="cf">if</span> (dis &lt;= K * K) ans.push_back(pii(j, i));</span>
<span id="cb7-27"><a aria-hidden="true" href="#cb7-27"></a>            }</span>
<span id="cb7-28"><a aria-hidden="true" href="#cb7-28"></a>        }</span>
<span id="cb7-29"><a aria-hidden="true" href="#cb7-29"></a>    }</span>
<span id="cb7-30"><a aria-hidden="true" href="#cb7-30"></a>    sort(ans.begin(), ans.end());</span>
<span id="cb7-31"><a aria-hidden="true" href="#cb7-31"></a>    print(ans.size());</span>
<span id="cb7-32"><a aria-hidden="true" href="#cb7-32"></a>    <span class="cf">for</span> (<span class="kw">auto</span> &amp;p : ans) print(p.first, p.second);</span>
<span id="cb7-33"><a aria-hidden="true" href="#cb7-33"></a>    <span class="cf">return</span> output(), <span class="dv">0</span>;</span>
<span id="cb7-34"><a aria-hidden="true" href="#cb7-34"></a>}</span></code></pre></div>
<p>上述做法得解的正确性较为显然，这里不说明。下面对时间复杂度给出证明。</p>
<p>令 <span class="math inline">\(B_{X, Y}\)</span> 为集合 <span class="math inline">\((X,Y)\)</span> 中的点的数量，<span class="math inline">\(f(x)\)</span> 为“含 <span class="math inline">\(x\)</span> 个点的集合内最少的距离小于等于 <span class="math inline">\(K\)</span> 的点对数”。<span class="math inline">\(f(x)\)</span> 的上界显然为 <span class="math inline">\(O(n^2)\)</span>，下面证明其下界为 <span class="math inline">\(\Omega(n^2)\)</span>：</p>
<blockquote>
<p>在一个边长小于 <span class="math inline">\(\dfrac{K}{\sqrt 2}\)</span> 的子正方形区域中，每一对点对的距离都小于 <span class="math inline">\(K\)</span>。而一个 <span class="math inline">\(K\times K\)</span> 的正方形区域能由 <span class="math inline">\(4\)</span> 个小的边长为 <span class="math inline">\(\dfrac{K}{\sqrt 2}\)</span> 的小正方形覆盖。考虑往大区域中放 <span class="math inline">\(4n\)</span> 个点，则至少一个小区域包含至少 <span class="math inline">\(n\)</span> 个点。该小区域有 <span class="math inline">\(\dfrac{n(n - 1)}{2}\)</span> 个点对，所以 <span class="math inline">\(f(x)\)</span> 的下界为 <span class="math inline">\(\Omega(n^2)\)</span>。</p>
</blockquote>
<p>而 <span class="math inline">\(\sum_{X,Y}f(B_{X,Y}) \le M\)</span>，故 <span class="math inline">\(\sum_{X,Y}B^2_{X,Y}\)</span> 的上界为 <span class="math inline">\(O(N + M)\)</span>。</p>
<p>然后我们的算法里面，要枚举的点对数为 <span class="math inline">\(\sum_{X,Y}\sum_{m = -1}^1\sum_{l = -1}^1B_{X,Y}B_{X+m,Y+l}\)</span>。因为 <span class="math inline">\(\sum_{X,Y}B^2_{X,Y}\)</span> 的上界为 <span class="math inline">\(O(N + M)\)</span>，然后，根据均值不等式，<span class="math inline">\(B_{X,Y}B_{X + m,Y+l}\le \dfrac12(B_{X,Y}^2 + B_{X + m, Y + l}^2)\)</span>，所以整体的上界也是 <span class="math inline">\(O(N + M)\)</span>。</p>
<p>证毕。</p>
<h3 id="abc235">ABC235</h3>
<p>A, B, C 略。</p>
<p>D 考虑一个 BFS，每次变换看作一次转移，由于有效状态最多 <span class="math inline">\(10^7\)</span> 个，所以是正确的。</p>
<h4 id="abc235f---variety-of-digits">ABC235F - Variety of Digits</h4>
<p>给 <span class="math inline">\(m\)</span> 个数位 <span class="math inline">\(c_i\)</span>，问 <span class="math inline">\([1, n]\)</span> 中十进制下包含了全部 <span class="math inline">\(c_1,\cdots, c_m\)</span> 数位的整数的和（前导 <span class="math inline">\(0\)</span> 不算），答案对 <span class="math inline">\(998244353\)</span> 取模。<span class="math inline">\(1\le n\le 10^{10^4}\)</span>，<span class="math inline">\(1\le m\le 10\)</span>，<span class="math inline">\(0\le c_1&lt;\cdots&lt;c_m\le 9\)</span>。</p>
<p>数位 DP。考虑到我们可以将数位集合压起来，所以设 <span class="math inline">\(f_{i, S}\)</span> 表示从低到高第 <span class="math inline">\(i\)</span> 位，从高到低已经选的数位集合为 <span class="math inline">\(S\)</span> 的数字个数和数字和（注意这两个东西需要同时维护）。</p>
<p>那么转移应该是比较好想的，注意前导 <span class="math inline">\(0\)</span> 不应计算在 <span class="math inline">\(S\)</span> 内。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a aria-hidden="true" href="#cb8-1"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">1e4</span> + <span class="dv">5</span>;</span>
<span id="cb8-2"><a aria-hidden="true" href="#cb8-2"></a><span class="dt">char</span> s[maxn];</span>
<span id="cb8-3"><a aria-hidden="true" href="#cb8-3"></a><span class="dt">int</span> n, m, c[<span class="dv">11</span>], S0, a[maxn];</span>
<span id="cb8-4"><a aria-hidden="true" href="#cb8-4"></a>pair&lt;modint, modint&gt; f[maxn][<span class="dv">1</span> &lt;&lt; <span class="dv">10</span>];</span>
<span id="cb8-5"><a aria-hidden="true" href="#cb8-5"></a>modint pow10[maxn];</span>
<span id="cb8-6"><a aria-hidden="true" href="#cb8-6"></a><span class="dt">bool</span> vis[maxn][<span class="dv">1</span> &lt;&lt; <span class="dv">10</span>];</span>
<span id="cb8-7"><a aria-hidden="true" href="#cb8-7"></a></span>
<span id="cb8-8"><a aria-hidden="true" href="#cb8-8"></a>pair&lt;modint, modint&gt; dfs(<span class="dt">int</span> pos, <span class="dt">int</span> S, <span class="dt">int</span> lim, <span class="dt">int</span> zero) {</span>
<span id="cb8-9"><a aria-hidden="true" href="#cb8-9"></a>    <span class="cf">if</span> (pos == -<span class="dv">1</span>) {</span>
<span id="cb8-10"><a aria-hidden="true" href="#cb8-10"></a>        <span class="cf">if</span> ((S &amp; S0) == S0) <span class="cf">return</span> {<span class="dv">1</span>, <span class="dv">0</span>};</span>
<span id="cb8-11"><a aria-hidden="true" href="#cb8-11"></a>        <span class="cf">else</span> <span class="cf">return</span> {<span class="dv">0</span>, <span class="dv">0</span>};</span>
<span id="cb8-12"><a aria-hidden="true" href="#cb8-12"></a>    }</span>
<span id="cb8-13"><a aria-hidden="true" href="#cb8-13"></a>    <span class="cf">if</span> (!lim &amp;&amp; !zero &amp;&amp; vis[pos][S]) <span class="cf">return</span> f[pos][S];</span>
<span id="cb8-14"><a aria-hidden="true" href="#cb8-14"></a>    <span class="dt">int</span> up = lim ? a[pos] : <span class="dv">9</span>;</span>
<span id="cb8-15"><a aria-hidden="true" href="#cb8-15"></a>    pair&lt;modint, modint&gt; ret = {<span class="dv">0</span>, <span class="dv">0</span>};</span>
<span id="cb8-16"><a aria-hidden="true" href="#cb8-16"></a>    FOR(i, <span class="dv">0</span>, up) {</span>
<span id="cb8-17"><a aria-hidden="true" href="#cb8-17"></a>        pair&lt;modint, modint&gt; tmp;</span>
<span id="cb8-18"><a aria-hidden="true" href="#cb8-18"></a>        <span class="cf">if</span> (zero &amp;&amp; !i) tmp = dfs(pos - <span class="dv">1</span>, S, lim &amp;&amp; i == up, zero);</span>
<span id="cb8-19"><a aria-hidden="true" href="#cb8-19"></a>        <span class="cf">else</span> tmp = dfs(pos - <span class="dv">1</span>, S | (<span class="dv">1</span> &lt;&lt; i), lim &amp;&amp; i == up, <span class="dv">0</span>);</span>
<span id="cb8-20"><a aria-hidden="true" href="#cb8-20"></a>        ret.first += tmp.first;</span>
<span id="cb8-21"><a aria-hidden="true" href="#cb8-21"></a>        ret.second += tmp.second + tmp.first * pow10[pos] * i;</span>
<span id="cb8-22"><a aria-hidden="true" href="#cb8-22"></a>    }</span>
<span id="cb8-23"><a aria-hidden="true" href="#cb8-23"></a>    <span class="cf">if</span> (!lim &amp;&amp; !zero) vis[pos][S] = <span class="dv">1</span>, f[pos][S] = ret;</span>
<span id="cb8-24"><a aria-hidden="true" href="#cb8-24"></a>    <span class="cf">return</span> ret;</span>
<span id="cb8-25"><a aria-hidden="true" href="#cb8-25"></a>}</span>
<span id="cb8-26"><a aria-hidden="true" href="#cb8-26"></a></span>
<span id="cb8-27"><a aria-hidden="true" href="#cb8-27"></a><span class="dt">int</span> main() {</span>
<span id="cb8-28"><a aria-hidden="true" href="#cb8-28"></a>    read(s + <span class="dv">1</span>), n = strlen(s + <span class="dv">1</span>);</span>
<span id="cb8-29"><a aria-hidden="true" href="#cb8-29"></a>    pow10[<span class="dv">0</span>] = <span class="dv">1</span>;</span>
<span id="cb8-30"><a aria-hidden="true" href="#cb8-30"></a>    FOR(i, <span class="dv">1</span>, n) a[i - <span class="dv">1</span>] = s[n - i + <span class="dv">1</span>] - <span class="ch">'0'</span>, pow10[i] = <span class="dv">10</span> * pow10[i - <span class="dv">1</span>];</span>
<span id="cb8-31"><a aria-hidden="true" href="#cb8-31"></a>    read(m);</span>
<span id="cb8-32"><a aria-hidden="true" href="#cb8-32"></a>    FOR(i, <span class="dv">1</span>, m) read(c[i]), S0 |= (<span class="dv">1</span> &lt;&lt; c[i]);</span>
<span id="cb8-33"><a aria-hidden="true" href="#cb8-33"></a>    print(dfs(n - <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>).second);</span>
<span id="cb8-34"><a aria-hidden="true" href="#cb8-34"></a>    <span class="cf">return</span> output(), <span class="dv">0</span>;</span>
<span id="cb8-35"><a aria-hidden="true" href="#cb8-35"></a>}</span></code></pre></div>
<h4 id="abc235g---gardens">ABC235G - Gardens</h4>
<p>三种颜色的球分别有 <span class="math inline">\(A, B, C\)</span> 个，同种颜色的球不区分，现将其放入 <span class="math inline">\(N\)</span> 个有标号的箱子内，要求</p>
<ul>
<li>每个箱子至少有 <span class="math inline">\(1\)</span> 个球。</li>
<li>每个箱子内至多有 <span class="math inline">\(1\)</span> 个同种球。</li>
<li>不必放完所有的球。</li>
</ul>
<p>求方案数模 <span class="math inline">\(998244353\)</span>，<span class="math inline">\(1\le N\le 5\times 10^6\)</span>，<span class="math inline">\(0\le A,B,C\le N\)</span>。</p>
<p>朴素的 DP 容易想到，<span class="math inline">\(O(NABC) = O(N^4)\)</span>，铁定过不去。不妨反着考虑问题，发现“为空”比“不为空”要好想得多，考虑对于一个 <span class="math inline">\(i\)</span>，计算“至少有 <span class="math inline">\(i\)</span> 个箱子为空”的方案数，不难发现其就为 <span class="math display">\[
\binom{N}{i}\left(\sum_{a=0}^{\min\{N-  i, A\}}\binom{N - i}{a}\right)\left(\sum_{b=0}^{\min\{N-  i, B\}}\binom{N - i}{b}\right)\left(\sum_{c=0}^{\min\{N-  i, C\}}\binom{N - i}{c}\right)
\]</span> 解释：首先选 <span class="math inline">\(i\)</span> 个一定为空的箱子，然后分别枚举三种颜色的球放的个数并放入 <span class="math inline">\(N - i\)</span> 个可能不为空的箱子。</p>
<p>答案为“恰好有 <span class="math inline">\(0\)</span> 个箱子为空”，二项式反演一下（中间推导过程省略，就是一个简单容斥）得到答案为 <span class="math display">\[
\sum_{i=0}^N(-1)^i\binom{N}{i}\left(\sum_{a=0}^{\min\{N-  i, A\}}\binom{N - i}{a}\right)\left(\sum_{b=0}^{\min\{N-  i, B\}}\binom{N - i}{b}\right)\left(\sum_{c=0}^{\min\{N-  i, C\}}\binom{N - i}{c}\right)
\]</span> 化的好看点就是 <span class="math display">\[
\sum_{i=0}^N(-1)^{N - i}\binom{N}{i}\left(\sum_{a=0}^{\min\{i, A\}}\binom{i}{a}\right)\left(\sum_{b=0}^{\min\{i, B\}}\binom{i}{b}\right)\left(\sum_{c=0}^{\min\{i, C\}}\binom{i}{c}\right)
\]</span> 然而直接计算还是需要 <span class="math inline">\(O(N^2)\)</span>，继续优化计算过程。</p>
<p>设 <span class="math inline">\(f_{M}(N) = \displaystyle\sum_{i=0}^{\min\{N, M\}}\binom N i\)</span>，则答案可以改写为 <span class="math display">\[
\sum_{i=0}^N(-1)^{N-i}\binom Ni f_{A}(i)f_{B}(i)f_C(i)
\]</span> 如果我们知道了 <span class="math inline">\(f_M(N)\)</span> 的值后能 <span class="math inline">\(O(1)\)</span> 推出 <span class="math inline">\(f_{M}(N + 1)\)</span> 的值，整个问题就可以 <span class="math inline">\(O(N)\)</span> 解决了。</p>
<p>当 <span class="math inline">\(N+ 1\le M\)</span> 的时候，<span class="math inline">\(\min\{N+1,M\} = N+1\)</span>，所以根据二项式定理，<span class="math inline">\(f_{M}(N+1)=2f_M(N)\)</span>。</p>
<p>下面的解法参考 <a href="https://atcoder.jp/contests/abc235/editorial/3262">AtCoder 官方题解</a>，推荐去学习一下这个思想。</p>
<p><img src="https://img.atcoder.jp/ghi/d93c643497867d310c6255fb673d9682.png"/></p>
<p>实际上，<span class="math inline">\(f_M(N)\)</span> 就可以看作从左下角出发，每一步往上/右走一格，走到橙色点的方案数（总步数都是 <span class="math inline">\(N\)</span>，我们枚举了横向走的步数 <span class="math inline">\(i\)</span> 而已）。</p>
<p>于是 <span class="math inline">\(f_M(N)\)</span> 与 <span class="math inline">\(f_M(N + 1)\)</span> 的关系就变成了求走到橙色点的方案数与走到蓝色点的方案数之间的关系。发现，我们在一个橙色点的时候总可以往上/右走一格到达蓝色点，除去最右下角那个点即可。所以 <span class="math display">\[
f_M(N+ 1) = 2f_M(N) - \binom{N}{M}
\]</span> 发现对于上面的情况，只需定义 <span class="math inline">\(N&lt;M\)</span> 的 <span class="math inline">\(\dbinom NM\)</span> 为 <span class="math inline">\(0\)</span>，下面的公式也是完全适用的。<span class="math inline">\(f_M(0) = 0\)</span>。</p>
<p>于是这道题 <span class="math inline">\(O(N)\)</span> 解决了。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a aria-hidden="true" href="#cb9-1"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">5e6</span> + <span class="dv">5</span>;</span>
<span id="cb9-2"><a aria-hidden="true" href="#cb9-2"></a>modint fac[maxn], ifac[maxn];</span>
<span id="cb9-3"><a aria-hidden="true" href="#cb9-3"></a><span class="dt">int</span> n, A, B, C;</span>
<span id="cb9-4"><a aria-hidden="true" href="#cb9-4"></a></span>
<span id="cb9-5"><a aria-hidden="true" href="#cb9-5"></a>modint binom(<span class="dt">int</span> n, <span class="dt">int</span> m) {</span>
<span id="cb9-6"><a aria-hidden="true" href="#cb9-6"></a>    <span class="cf">if</span> (n &lt; m) <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb9-7"><a aria-hidden="true" href="#cb9-7"></a>    <span class="cf">return</span> fac[n] * ifac[m] * ifac[n - m];</span>
<span id="cb9-8"><a aria-hidden="true" href="#cb9-8"></a>}</span>
<span id="cb9-9"><a aria-hidden="true" href="#cb9-9"></a></span>
<span id="cb9-10"><a aria-hidden="true" href="#cb9-10"></a><span class="dt">int</span> main() {</span>
<span id="cb9-11"><a aria-hidden="true" href="#cb9-11"></a>    read(n, A, B, C);</span>
<span id="cb9-12"><a aria-hidden="true" href="#cb9-12"></a>    fac[<span class="dv">0</span>] = <span class="dv">1</span>;</span>
<span id="cb9-13"><a aria-hidden="true" href="#cb9-13"></a>    FOR(i, <span class="dv">1</span>, n) fac[i] = fac[i - <span class="dv">1</span>] * i;</span>
<span id="cb9-14"><a aria-hidden="true" href="#cb9-14"></a>    ifac[n] = qPow(fac[n], mod - <span class="dv">2</span>);</span>
<span id="cb9-15"><a aria-hidden="true" href="#cb9-15"></a>    DEC(i, n - <span class="dv">1</span>, <span class="dv">0</span>) ifac[i] = (i + <span class="dv">1</span>) * ifac[i + <span class="dv">1</span>];</span>
<span id="cb9-16"><a aria-hidden="true" href="#cb9-16"></a>    modint ans = <span class="dv">0</span>, a = <span class="dv">1</span>, b = <span class="dv">1</span>, c = <span class="dv">1</span>;</span>
<span id="cb9-17"><a aria-hidden="true" href="#cb9-17"></a>    FOR(i, <span class="dv">0</span>, n) {</span>
<span id="cb9-18"><a aria-hidden="true" href="#cb9-18"></a>        modint tmp = ((n - i) &amp; <span class="dv">1</span>) ? -<span class="dv">1</span> : <span class="dv">1</span>;</span>
<span id="cb9-19"><a aria-hidden="true" href="#cb9-19"></a>        tmp *= binom(n, i);</span>
<span id="cb9-20"><a aria-hidden="true" href="#cb9-20"></a>        <span class="cf">if</span> (i &gt; <span class="dv">0</span>) {</span>
<span id="cb9-21"><a aria-hidden="true" href="#cb9-21"></a>            a = <span class="dv">2</span> * a - binom(i - <span class="dv">1</span>, A);</span>
<span id="cb9-22"><a aria-hidden="true" href="#cb9-22"></a>            b = <span class="dv">2</span> * b - binom(i - <span class="dv">1</span>, B);</span>
<span id="cb9-23"><a aria-hidden="true" href="#cb9-23"></a>            c = <span class="dv">2</span> * c - binom(i - <span class="dv">1</span>, C);</span>
<span id="cb9-24"><a aria-hidden="true" href="#cb9-24"></a>        }</span>
<span id="cb9-25"><a aria-hidden="true" href="#cb9-25"></a>        tmp *= a * b * c;</span>
<span id="cb9-26"><a aria-hidden="true" href="#cb9-26"></a>        ans += tmp;</span>
<span id="cb9-27"><a aria-hidden="true" href="#cb9-27"></a>    }</span>
<span id="cb9-28"><a aria-hidden="true" href="#cb9-28"></a>    print(ans);</span>
<span id="cb9-29"><a aria-hidden="true" href="#cb9-29"></a>    <span class="cf">return</span> output(), <span class="dv">0</span>;</span>
<span id="cb9-30"><a aria-hidden="true" href="#cb9-30"></a>}</span></code></pre></div>
<h4 id="abc235ex---painting-weighted-graph">ABC235Ex - Painting Weighted Graph</h4>
<p>给定 <span class="math inline">\(N\)</span> 点 <span class="math inline">\(M\)</span> 边带边权无向图，<span class="math inline">\(2\le N\le 10^5\)</span>，<span class="math inline">\(0\le M\le 10^5\)</span>。一开始，每个节点上涂黑色，可以进行如下操作至多 <span class="math inline">\(K\)</span> 次：</p>
<blockquote>
<p>选择一个节点 <span class="math inline">\(v\)</span> 和一个数 <span class="math inline">\(x\)</span>，将所有的从 <span class="math inline">\(v\)</span> 出发，不经过任何权值大于 <span class="math inline">\(x\)</span> 的边能到达的点涂为红色。</p>
</blockquote>
<p>问可能的红色点集的数量，模 <span class="math inline">\(998244353\)</span>。图可能有重边和自环。</p>
<p>咕，以后有空来补。</p>
<h3 id="abc237">ABC237</h3>
<p>A 可以投机取巧一下强制转为 <code>int</code> 之后是否与原来相等。</p>
<p>B 略，C 随便观察一下即可，略。D 可以实现一个 <code>deque</code> 或者倒序考虑问题，略。</p>
<p>E 建出图后发现是一个带有负权边的最短路模型，跑个 SPFA 可以过，略。</p>
<h4 id="abc237e---skiing">ABC237E - Skiing</h4>
<p>滑雪场有 <span class="math inline">\(n\)</span> 个地点，有 <span class="math inline">\(m\)</span> 个坡，保证图连通。每个节点有高度 <span class="math inline">\(h_u\)</span>。当从边 <span class="math inline">\(u\to v\)</span> 通过时，</p>
<ul>
<li>若 <span class="math inline">\(h_u &gt; h_v\)</span>，则快乐指数增加 <span class="math inline">\(h_u - h_v\)</span>。</li>
<li>否则，快乐指数减小 <span class="math inline">\(2(h_v - h_u)\)</span>。</li>
</ul>
<p>从 <span class="math inline">\(1\)</span> 出发，初始快乐指数为 <span class="math inline">\(0\)</span>，问能达到的最大快乐指数。<span class="math inline">\(n, m\)</span> 均为 <span class="math inline">\(2\times 10^5\)</span> 级别。</p>
<p>首先对边权取相反数建模成最短路模型，发现其有负权边，无法直接使用 Dijkstra，而数据范围又极有可能卡死 SPFA（事实证明 SPFA 能过）。</p>
<p>考虑势能 Dijkstra，为每个点增加一个势能 <span class="math inline">\(h_u\)</span>，然后对边 <span class="math inline">\(u\to v\)</span> 的权值加上 <span class="math inline">\(h_u - h_v\)</span>，使得所有边权非负，最后每个点的答案就为 <span class="math inline">\(d_u + h_u - h_1\)</span>。但是求势能的过程仍然需要 SPFA，怎么办呢？</p>
<p>注意到本题中的“高度”就是一个现成的势能，满足了势能之差只和相对高度有关这一性质，所以直接将其当作势能来做就可以了，时间复杂度 <span class="math inline">\(O(m\log n)\)</span>，<a href="https://atcoder.jp/contests/abc237/submissions/29219115">评测记录</a>。</p>
<h4 id="abc237f---lis-3">ABC237F - |LIS| = 3</h4>
<p>给定 <span class="math inline">\(N\)</span> 和 <span class="math inline">\(M\)</span>，求满足以下条件的正整数序列的个数：</p>
<ul>
<li>长度为 <span class="math inline">\(N\)</span>，每个元素 <span class="math inline">\(\in[1, M]\)</span>。</li>
<li>其 LIS 的长度恰好为 <span class="math inline">\(3\)</span>。</li>
</ul>
<p><span class="math inline">\(3\le N\le 1000\)</span>，<span class="math inline">\(3\le M\le 10\)</span>。</p>
<p>考虑经典的 <span class="math inline">\(O(n\log n)\)</span> 的 LIS 的做法，发现 <span class="math inline">\(f_i\)</span> 为“长度为 <span class="math inline">\(i\)</span> 的 LIS 的最小结尾数字”，而 DP 数组的长度即为 LIS 的长度，所以干脆考虑令 <span class="math inline">\(f_{i, a, b, c}\)</span> 表示当前考虑到 <span class="math inline">\([1, i]\)</span>，LIS 的 DP 数组为 <span class="math inline">\(a, b, c\)</span> 的序列个数。不难发现这个状态是没有后效性的，转移就考虑当前填什么数，然后仿照 <span class="math inline">\(O(n\log n)\)</span> LIS 的转移方式进行转移。时间复杂度 <span class="math inline">\(O(NM^4)\)</span>，可以通过。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a aria-hidden="true" href="#cb10-1"></a>modint f[<span class="dv">1005</span>][<span class="dv">15</span>][<span class="dv">15</span>][<span class="dv">15</span>];</span>
<span id="cb10-2"><a aria-hidden="true" href="#cb10-2"></a><span class="dt">int</span> n, m;</span>
<span id="cb10-3"><a aria-hidden="true" href="#cb10-3"></a></span>
<span id="cb10-4"><a aria-hidden="true" href="#cb10-4"></a><span class="dt">int</span> main() {</span>
<span id="cb10-5"><a aria-hidden="true" href="#cb10-5"></a>    read(n, m);</span>
<span id="cb10-6"><a aria-hidden="true" href="#cb10-6"></a>    f[<span class="dv">0</span>][m + <span class="dv">1</span>][m + <span class="dv">1</span>][m + <span class="dv">1</span>] = <span class="dv">1</span>;</span>
<span id="cb10-7"><a aria-hidden="true" href="#cb10-7"></a>    FOR(i, <span class="dv">1</span>, n) FOR(j, <span class="dv">1</span>, m + <span class="dv">1</span>) FOR(k, j, m + <span class="dv">1</span>) FOR(l, k, m + <span class="dv">1</span>) FOR(t, <span class="dv">1</span>, m) {</span>
<span id="cb10-8"><a aria-hidden="true" href="#cb10-8"></a>        <span class="cf">if</span> (t &lt;= j) f[i][t][k][l] += f[i - <span class="dv">1</span>][j][k][l];</span>
<span id="cb10-9"><a aria-hidden="true" href="#cb10-9"></a>        <span class="cf">else</span> <span class="cf">if</span> (t &lt;= k) f[i][j][t][l] += f[i - <span class="dv">1</span>][j][k][l];</span>
<span id="cb10-10"><a aria-hidden="true" href="#cb10-10"></a>        <span class="cf">else</span> <span class="cf">if</span> (t &lt;= l) f[i][j][k][t] += f[i - <span class="dv">1</span>][j][k][l];</span>
<span id="cb10-11"><a aria-hidden="true" href="#cb10-11"></a>    }</span>
<span id="cb10-12"><a aria-hidden="true" href="#cb10-12"></a>    modint ans = <span class="dv">0</span>;</span>
<span id="cb10-13"><a aria-hidden="true" href="#cb10-13"></a>    FOR(i, <span class="dv">1</span>, m) FOR(j, i + <span class="dv">1</span>, m) FOR(k, j + <span class="dv">1</span>, m) ans += f[n][i][j][k];</span>
<span id="cb10-14"><a aria-hidden="true" href="#cb10-14"></a>    print(ans);</span>
<span id="cb10-15"><a aria-hidden="true" href="#cb10-15"></a>    <span class="cf">return</span> output(), <span class="dv">0</span>;</span>
<span id="cb10-16"><a aria-hidden="true" href="#cb10-16"></a>}</span></code></pre></div>
<h4 id="abc237g---range-sort-query">ABC237G - Range Sort Query</h4>
<p>给定长度为 <span class="math inline">\(N\)</span> 的排列，<span class="math inline">\(Q\)</span> 次操作，操作为选定一区间 <span class="math inline">\([l, r]\)</span> 然后升序/降序排序，问元素 <span class="math inline">\(X\)</span> 最后的下标在哪里。<span class="math inline">\(1\le N, Q\le 2\times 10^5\)</span>。</p>
<p>这是一个经典问题（HEOI 排序）的变式。最强大的解法显然为线段树合并/分裂，但是在这里不需要。</p>
<p>注意到，0-1 序列的区间排序很好使用线段树来完成，只需要实现区间染色和区间求和。所以我们考虑将其转为 0-1 序列。</p>
<p>具体地，将 <span class="math inline">\(&lt; X\)</span> 的元素变为 <span class="math inline">\(0\)</span>，其他变为 <span class="math inline">\(1\)</span>，操作，得到一个结果。将 <span class="math inline">\(\le X\)</span> 的元素变为 <span class="math inline">\(0\)</span>，其他变为 <span class="math inline">\(1\)</span>，操作，得到另一个结果，然后然后然后发现这两个序列唯一一个不一样的地方显然就是 <span class="math inline">\(X\)</span> 最后的位置。</p>
<p>所以复杂度为 <span class="math inline">\(O(N\log N)\)</span>，视 <span class="math inline">\(N\)</span> 和 <span class="math inline">\(Q\)</span> 同阶。<a href="https://atcoder.jp/contests/abc237/submissions/29158241">评测记录</a>。</p>
<h4 id="abc237ex---hakata">ABC237Ex - Hakata</h4>
<p>给定长度 <span class="math inline">\(\le 200\)</span> 的字符串 <span class="math inline">\(S\)</span>，问最多能从里面选出多少个<strong>回文子段</strong>，使得一个子段不是另一个子段的子段。子段指连续的。</p>
<p>我们发现，不同回文子串的个数 <span class="math inline">\(\le |S|\)</span>，然后子串间的包含关系是一种偏序关系，可以形成一个 DAG，而原问题问的就是其的最大反链。</p>
<p>复习一下 <a href="https://www.luogu.com.cn/problem/P4298">P4298 [CTSC2008]祭祀</a> 便知道最大反链 = 最小链覆盖（Dilworth 引理），而最小链覆盖可以通过拆点二分图匹配来求。</p>
<p>放到本题里面，就对于每个不同回文子段（这部分顶天 <span class="math inline">\(O(|S|^3)\)</span>），为其标号，然后对于 <span class="math inline">\(i\)</span> 为 <span class="math inline">\(j\)</span> 的子串，连边 <span class="math inline">\(i_{\mathrm {left}}\to j_{\mathrm{right}}\)</span>，然后跑二分图最大匹配，用回文串数量减去匹配即得到答案。时间复杂度就不分析了，<span class="math inline">\(400\)</span> 个点的二分图匹配并不慢，<a href="https://atcoder.jp/contests/abc237/submissions/29158769">评测记录</a>。</p>
<h3 id="abc244">ABC244</h3>
<h4 id="abc244d---swap-hats">ABC244D - Swap Hats</h4>
<p><del>大胆猜结论</del>。</p>
<p>发现若相同的位置有 <span class="math inline">\(3\)</span> 个或 <span class="math inline">\(0\)</span> 个时为 Yes，否则为 No，下面给出简要说明。</p>
<p>为 <span class="math inline">\(3\)</span> 个的时候就把两个反复横跳即可，为 <span class="math inline">\(0\)</span> 个的话可以构造方案在操作两次后转化为 <span class="math inline">\(3\)</span> 个一样的情况。</p>
<p>否则相同的位置只可能有 <span class="math inline">\(1\)</span> 个，做任意一次交换后都会变成上面两种情况，所以寄了。</p>
<h4 id="abc244f---shortest-good-path">ABC244F - Shortest Good Path</h4>
<p>给定 <span class="math inline">\(N\)</span> 点 <span class="math inline">\(M\)</span> 边无向图，令长度为 <span class="math inline">\(K\)</span> 的路径 <span class="math inline">\(A_{1,\cdots, K}\)</span> 对长度为 <span class="math inline">\(K\)</span> 的 0-1 串 <span class="math inline">\(S\)</span> 为合法的当且仅当 <span class="math inline">\(i\)</span> 的出现次数模 <span class="math inline">\(2\)</span> 后等于 <span class="math inline">\(S_i\)</span>。对于 <span class="math inline">\(2^n\)</span> 种不同的 <span class="math inline">\(S\)</span>，求出最小的合法的路径的 <span class="math inline">\(K\)</span> 之和。<span class="math inline">\(n\le 17\)</span>。</p>
<p>范围让我们想到状压 dp。</p>
<p>对于这种图上有链的，就令 <span class="math inline">\(f_{i,S}\)</span> 为以 <span class="math inline">\(i\)</span> 结尾，点集为 <span class="math inline">\(S\)</span> 的链的什么什么。然后注意到这个状态是没法转移的，因为接上一个在 <span class="math inline">\(S\)</span> 里面存在的点之后，<span class="math inline">\(S'\)</span> 是小于 <span class="math inline">\(S\)</span> 的。</p>
<p>那就考虑翻转一下状态和值，令 <span class="math inline">\(f_{i,k,S}\)</span> 为以 <span class="math inline">\(i\)</span> 结尾，长度为 <span class="math inline">\(k\)</span>，点集为 <span class="math inline">\(S\)</span> 的链是否存在。然后转移就很好做到了，毛估估复杂度为 <span class="math inline">\(O(n^32^n)\)</span>，有点勉强但是实现的好的话可以通过。</p>
<p><em>解释一下为什么长度上界是 <span class="math inline">\(4n\)</span>，因为 G 题说了上界是 <span class="math inline">\(4n\)</span></em>。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a aria-hidden="true" href="#cb11-1"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="dv">18</span>, maxS = (<span class="dv">1</span> &lt;&lt; <span class="dv">17</span>) | <span class="dv">5</span>;</span>
<span id="cb11-2"><a aria-hidden="true" href="#cb11-2"></a><span class="dt">int</span> n, m, G[maxn][maxn];</span>
<span id="cb11-3"><a aria-hidden="true" href="#cb11-3"></a><span class="dt">bool</span> f[maxn][<span class="dv">4</span> * maxn][maxS];</span>
<span id="cb11-4"><a aria-hidden="true" href="#cb11-4"></a><span class="dt">int</span> vis[maxS];</span>
<span id="cb11-5"><a aria-hidden="true" href="#cb11-5"></a></span>
<span id="cb11-6"><a aria-hidden="true" href="#cb11-6"></a><span class="dt">int</span> main() {</span>
<span id="cb11-7"><a aria-hidden="true" href="#cb11-7"></a>    read(n, m);</span>
<span id="cb11-8"><a aria-hidden="true" href="#cb11-8"></a>    FOR(i, <span class="dv">1</span>, m) {</span>
<span id="cb11-9"><a aria-hidden="true" href="#cb11-9"></a>        <span class="dt">int</span> u, v; read(u, v);</span>
<span id="cb11-10"><a aria-hidden="true" href="#cb11-10"></a>        G[u][v] = G[v][u] = <span class="dv">1</span>;</span>
<span id="cb11-11"><a aria-hidden="true" href="#cb11-11"></a>    }</span>
<span id="cb11-12"><a aria-hidden="true" href="#cb11-12"></a>    memset(vis, <span class="bn">0x3f</span>, <span class="kw">sizeof</span> vis);</span>
<span id="cb11-13"><a aria-hidden="true" href="#cb11-13"></a>    FOR(i, <span class="dv">1</span>, n) f[i][<span class="dv">1</span>][<span class="dv">1</span> &lt;&lt; (i - <span class="dv">1</span>)] = <span class="dv">1</span>;</span>
<span id="cb11-14"><a aria-hidden="true" href="#cb11-14"></a>    <span class="dt">int</span> ans = <span class="dv">0</span>; vis[<span class="dv">0</span>] = <span class="dv">0</span>;</span>
<span id="cb11-15"><a aria-hidden="true" href="#cb11-15"></a>    FOR(k, <span class="dv">1</span>, <span class="dv">4</span> * n) { <span class="co">// length</span></span>
<span id="cb11-16"><a aria-hidden="true" href="#cb11-16"></a>        FOR(i, <span class="dv">1</span>, n) {</span>
<span id="cb11-17"><a aria-hidden="true" href="#cb11-17"></a>            FOR(S, <span class="dv">0</span>, (<span class="dv">1</span> &lt;&lt; n) - <span class="dv">1</span>) {</span>
<span id="cb11-18"><a aria-hidden="true" href="#cb11-18"></a>                FOR(j, <span class="dv">1</span>, n) <span class="cf">if</span> (G[i][j]) {</span>
<span id="cb11-19"><a aria-hidden="true" href="#cb11-19"></a>                    f[i][k + <span class="dv">1</span>][S] |= f[j][k][S ^ (<span class="dv">1</span> &lt;&lt; (i - <span class="dv">1</span>))];</span>
<span id="cb11-20"><a aria-hidden="true" href="#cb11-20"></a>                    <span class="cf">if</span> (f[i][k + <span class="dv">1</span>][S]) <span class="cf">break</span>;</span>
<span id="cb11-21"><a aria-hidden="true" href="#cb11-21"></a>                }</span>
<span id="cb11-22"><a aria-hidden="true" href="#cb11-22"></a>                chkmin(vis[S], f[i][k][S] ? k : (<span class="dt">int</span>)<span class="fl">1e9</span>);</span>
<span id="cb11-23"><a aria-hidden="true" href="#cb11-23"></a>            }</span>
<span id="cb11-24"><a aria-hidden="true" href="#cb11-24"></a>        }</span>
<span id="cb11-25"><a aria-hidden="true" href="#cb11-25"></a>    }</span>
<span id="cb11-26"><a aria-hidden="true" href="#cb11-26"></a>    FOR(i, <span class="dv">0</span>, (<span class="dv">1</span> &lt;&lt; n) - <span class="dv">1</span>) ans += vis[i];</span>
<span id="cb11-27"><a aria-hidden="true" href="#cb11-27"></a>    print(ans);</span>
<span id="cb11-28"><a aria-hidden="true" href="#cb11-28"></a>    <span class="cf">return</span> output(), <span class="dv">0</span>;</span>
<span id="cb11-29"><a aria-hidden="true" href="#cb11-29"></a>}</span></code></pre></div>
<p>但是这还不是最优的，而且这个拿结论来推的想法很不优美。我们注意到，若将 dp 状态 <span class="math inline">\((i, S)\)</span> 看作点，转移看作边，那么问题就变成了最短路。</p>
<p>时间复杂度会少一个 <span class="math inline">\(n\)</span>，<span class="math inline">\(O(n^22^n)\)</span> 跑的还是很快的，而且少了 <span class="math inline">\(4\)</span> 倍常数。</p>
<h4 id="abc244g---construct-good-path">ABC244G - Construct Good Path</h4>
<p>全部继承 F 的定义，将范围改成 <span class="math inline">\(N\le 10^5\)</span>，<span class="math inline">\(M\le 2\times 10^5\)</span>，并给定 <span class="math inline">\(S\)</span> 然后让你构造一个合法的 <span class="math inline">\(A\)</span>。要求长度不超过 <span class="math inline">\(4N\)</span>，保证有解。</p>
<p>首先将这个问题放到生成树上。然后就从根节点往下走。对于 <span class="math inline">\(u\)</span>，若从他的子树出来后还是不对头，那就反复横跳一次。</p>
<p>对于根节点特判一下即可。</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a aria-hidden="true" href="#cb12-1"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">1e5</span> + <span class="dv">5</span>;</span>
<span id="cb12-2"><a aria-hidden="true" href="#cb12-2"></a><span class="dt">char</span> s[maxn];</span>
<span id="cb12-3"><a aria-hidden="true" href="#cb12-3"></a><span class="dt">int</span> n, m, vis[maxn];</span>
<span id="cb12-4"><a aria-hidden="true" href="#cb12-4"></a>vector&lt;<span class="dt">int</span>&gt; G[maxn], ans;</span>
<span id="cb12-5"><a aria-hidden="true" href="#cb12-5"></a></span>
<span id="cb12-6"><a aria-hidden="true" href="#cb12-6"></a><span class="dt">void</span> dfs(<span class="dt">int</span> u) {</span>
<span id="cb12-7"><a aria-hidden="true" href="#cb12-7"></a>    ans.push_back(u), ++vis[u];</span>
<span id="cb12-8"><a aria-hidden="true" href="#cb12-8"></a>    <span class="cf">for</span> (<span class="dt">int</span> &amp;v : G[u]) {</span>
<span id="cb12-9"><a aria-hidden="true" href="#cb12-9"></a>        <span class="cf">if</span> (vis[v]) <span class="cf">continue</span>;</span>
<span id="cb12-10"><a aria-hidden="true" href="#cb12-10"></a>        dfs(v);</span>
<span id="cb12-11"><a aria-hidden="true" href="#cb12-11"></a>        <span class="cf">if</span> ((vis[v] &amp; <span class="dv">1</span>) != s[v] - <span class="ch">'0'</span>)</span>
<span id="cb12-12"><a aria-hidden="true" href="#cb12-12"></a>            ans.push_back(u), ++vis[u], ans.push_back(v), ++vis[v];</span>
<span id="cb12-13"><a aria-hidden="true" href="#cb12-13"></a>        ans.push_back(u), ++vis[u];</span>
<span id="cb12-14"><a aria-hidden="true" href="#cb12-14"></a>    }</span>
<span id="cb12-15"><a aria-hidden="true" href="#cb12-15"></a>    <span class="cf">return</span>;</span>
<span id="cb12-16"><a aria-hidden="true" href="#cb12-16"></a>}</span>
<span id="cb12-17"><a aria-hidden="true" href="#cb12-17"></a></span>
<span id="cb12-18"><a aria-hidden="true" href="#cb12-18"></a><span class="dt">int</span> main() {</span>
<span id="cb12-19"><a aria-hidden="true" href="#cb12-19"></a>    read(n, m);</span>
<span id="cb12-20"><a aria-hidden="true" href="#cb12-20"></a>    FOR(i, <span class="dv">1</span>, m) {</span>
<span id="cb12-21"><a aria-hidden="true" href="#cb12-21"></a>        <span class="dt">int</span> u, v; read(u, v);</span>
<span id="cb12-22"><a aria-hidden="true" href="#cb12-22"></a>        G[u].push_back(v), G[v].push_back(u);</span>
<span id="cb12-23"><a aria-hidden="true" href="#cb12-23"></a>    }</span>
<span id="cb12-24"><a aria-hidden="true" href="#cb12-24"></a>    read(s + <span class="dv">1</span>);</span>
<span id="cb12-25"><a aria-hidden="true" href="#cb12-25"></a>    dfs(<span class="dv">1</span>);</span>
<span id="cb12-26"><a aria-hidden="true" href="#cb12-26"></a>    <span class="cf">if</span> ((vis[<span class="dv">1</span>] &amp; <span class="dv">1</span>) != s[<span class="dv">1</span>] - <span class="ch">'0'</span>) ans.pop_back();</span>
<span id="cb12-27"><a aria-hidden="true" href="#cb12-27"></a>    print(ans.size());</span>
<span id="cb12-28"><a aria-hidden="true" href="#cb12-28"></a>    <span class="cf">for</span> (<span class="dt">int</span> &amp;x : ans) print(x, <span class="ch">' '</span>);</span>
<span id="cb12-29"><a aria-hidden="true" href="#cb12-29"></a>    <span class="cf">return</span> output(), <span class="dv">0</span>;</span>
<span id="cb12-30"><a aria-hidden="true" href="#cb12-30"></a>}</span></code></pre></div>
<h4 id="abc244ex---linear-maximization未写代码">ABC244Ex - Linear Maximization（未写代码）</h4>
<p>维护二维平面上的点集 <span class="math inline">\(S = \{(x, y)\}\)</span>，初始为空。下面进行 <span class="math inline">\(Q\)</span> 次操作，每次往 <span class="math inline">\(S\)</span> 中加入点 <span class="math inline">\((x, y)\)</span> 并给定 <span class="math inline">\(a,b\)</span> 并查询 <span class="math inline">\(\max_{(x,y)\in S}\{ax + by\}\)</span>。<span class="math inline">\(Q\le 2\times 10^5\)</span>，坐标绝对值 <span class="math inline">\(\le 10^9\)</span>。</p>
<p>解法 <span class="math inline">\(1\)</span>：考虑 <span class="math inline">\(ax + by = b(\frac ab\cdot x + y)\)</span>，看出一次函数的形式之后无脑李超树即可。但是需要注意特判符号，<span class="math inline">\(b=0\)</span> 等情况。而且浮点误差似乎有点心烦所以我没写。</p>
<p>解法 <span class="math inline">\(2\)</span>：拿平衡树维护动态凸包，然后在凸包上三分查询。</p>
<p>不想写代码了。</p>
<h3 id="abc246">ABC246</h3>
<p>A 直接随便做。</p>
<p>B 输出 <span class="math inline">\(\cos(\theta)\)</span> 和 <span class="math inline">\(\sin(\theta)\)</span> 即可。</p>
<p>C 先按照物品大小贪一次心，然后再将剩下部分（<span class="math inline">\(a_i\bmod x\)</span> 的部分）重新排序再做一次贪心。容易说明其正确性。</p>
<p>D 发现 <span class="math inline">\((a+b)(a^2+b^2)\le 10^{18}\)</span>，钦定 <span class="math inline">\(a\ge b\)</span> 的话发现 <span class="math inline">\(a\)</span> 的上界只能为 <span class="math inline">\(10^6\)</span>，所以枚举 <span class="math inline">\(a\)</span> 然后二分 <span class="math inline">\(b\)</span> 即可。</p>
<h4 id="abc246e---bishop-2">ABC246E - Bishop 2</h4>
<p>场上调这题调到最后都寄了。。。</p>
<p>发现整个就是一个 0-1 bfs 的模型，每次看成走一格，同向走相当于比边权为 <span class="math inline">\(0\)</span>，转向相当于边权为 <span class="math inline">\(1\)</span>。</p>
<p>复杂度就是 bfs 的复杂度，容易说明其为 <span class="math inline">\(O(n^2)\)</span>。</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a aria-hidden="true" href="#cb13-1"></a><span class="pp">#include </span><span class="im">&lt;bits/stdc++.h&gt;</span></span>
<span id="cb13-2"><a aria-hidden="true" href="#cb13-2"></a><span class="pp">#define FOR</span>(i,<span class="pp"> </span>a,<span class="pp"> </span>b)<span class="pp"> </span><span class="cf">for</span><span class="pp"> </span>(<span class="dt">int</span><span class="pp"> </span>i<span class="pp"> </span>=<span class="pp"> </span>(a);<span class="pp"> </span>i<span class="pp"> </span>&lt;=<span class="pp"> </span>(b);<span class="pp"> </span>++i)</span>
<span id="cb13-3"><a aria-hidden="true" href="#cb13-3"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb13-4"><a aria-hidden="true" href="#cb13-4"></a></span>
<span id="cb13-5"><a aria-hidden="true" href="#cb13-5"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="dv">1505</span>, fx[] = {<span class="dv">1</span>, <span class="dv">1</span>, -<span class="dv">1</span>, -<span class="dv">1</span>}, fy[] = {<span class="dv">1</span>, -<span class="dv">1</span>, <span class="dv">1</span>, -<span class="dv">1</span>};</span>
<span id="cb13-6"><a aria-hidden="true" href="#cb13-6"></a>queue&lt;pair&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt;&gt; q;</span>
<span id="cb13-7"><a aria-hidden="true" href="#cb13-7"></a><span class="dt">char</span> mp[maxn][maxn];</span>
<span id="cb13-8"><a aria-hidden="true" href="#cb13-8"></a><span class="dt">int</span> n, sx, sy, tx, ty, f[maxn][maxn];</span>
<span id="cb13-9"><a aria-hidden="true" href="#cb13-9"></a></span>
<span id="cb13-10"><a aria-hidden="true" href="#cb13-10"></a><span class="dt">int</span> main() {</span>
<span id="cb13-11"><a aria-hidden="true" href="#cb13-11"></a>    cin &gt;&gt; n &gt;&gt; sx &gt;&gt; sy &gt;&gt; tx &gt;&gt; ty;</span>
<span id="cb13-12"><a aria-hidden="true" href="#cb13-12"></a>    FOR(i, <span class="dv">1</span>, n) cin &gt;&gt; &amp;mp[i][<span class="dv">1</span>];</span>
<span id="cb13-13"><a aria-hidden="true" href="#cb13-13"></a>    f[sx][sy] = <span class="dv">1</span>, q.push({sx, sy});</span>
<span id="cb13-14"><a aria-hidden="true" href="#cb13-14"></a>    <span class="kw">auto</span> check = [](<span class="dt">int</span> x, <span class="dt">int</span> y) {<span class="cf">return</span> x &gt;= <span class="dv">1</span> &amp;&amp; x &lt;= n &amp;&amp; y &gt;= <span class="dv">1</span> &amp;&amp; y &lt;= n &amp;&amp; mp[x][y] == <span class="ch">'.'</span>;};</span>
<span id="cb13-15"><a aria-hidden="true" href="#cb13-15"></a>    <span class="cf">while</span> (!q.empty()) {</span>
<span id="cb13-16"><a aria-hidden="true" href="#cb13-16"></a>        <span class="kw">auto</span> now = q.front(); q.pop();</span>
<span id="cb13-17"><a aria-hidden="true" href="#cb13-17"></a>        FOR(k, <span class="dv">0</span>, <span class="dv">3</span>) {</span>
<span id="cb13-18"><a aria-hidden="true" href="#cb13-18"></a>            <span class="dt">int</span> x = now.first, y = now.second;</span>
<span id="cb13-19"><a aria-hidden="true" href="#cb13-19"></a>            <span class="cf">while</span> (<span class="kw">true</span>) {</span>
<span id="cb13-20"><a aria-hidden="true" href="#cb13-20"></a>                x += fx[k], y += fy[k];</span>
<span id="cb13-21"><a aria-hidden="true" href="#cb13-21"></a>                <span class="cf">if</span> (!check(x, y)) <span class="cf">break</span>;</span>
<span id="cb13-22"><a aria-hidden="true" href="#cb13-22"></a>                <span class="cf">if</span> (!f[x][y]) f[x][y] = f[now.first][now.second] + <span class="dv">1</span>, q.push({x, y});</span>
<span id="cb13-23"><a aria-hidden="true" href="#cb13-23"></a>                <span class="cf">else</span> <span class="cf">if</span> (f[x][y] &lt;= f[now.first][now.second]) <span class="cf">break</span>;</span>
<span id="cb13-24"><a aria-hidden="true" href="#cb13-24"></a>            }</span>
<span id="cb13-25"><a aria-hidden="true" href="#cb13-25"></a>        }</span>
<span id="cb13-26"><a aria-hidden="true" href="#cb13-26"></a>    }</span>
<span id="cb13-27"><a aria-hidden="true" href="#cb13-27"></a>    cout &lt;&lt; f[tx][ty] - <span class="dv">1</span> &lt;&lt; endl;</span>
<span id="cb13-28"><a aria-hidden="true" href="#cb13-28"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb13-29"><a aria-hidden="true" href="#cb13-29"></a>}</span></code></pre></div>
<h4 id="abc246f---typewriter">ABC246F - typewriter</h4>
<p>考虑对单个串我们怎么计数，不难发现是 <span class="math inline">\(\text{字母个数}^L\)</span>。</p>
<p>那么多个串来了，我们就需要去重。具体地，我们取两个串字母的交，然后扣掉这一部分的答案。</p>
<p>那么扩展一下就是最基本的容斥，看到 <span class="math inline">\(n\le 18\)</span> 就枚举所有串的子集，算其交的答案，贡献乘上容斥系数 <span class="math inline">\((-1)^{|S|}\)</span>。时间复杂度 <span class="math inline">\(O(2^nc)\)</span>，<span class="math inline">\(c\)</span> 为某和字符集大小有关的常数（<del>懒得分析了</del>）。</p>
<h4 id="abc246g---game-on-tree-3">ABC246G - Game on Tree 3</h4>
<p>点带权 <span class="math inline">\(1\)</span> 根树，初始有一个指针在 <span class="math inline">\(1\)</span> 点，每轮游戏中先青木选择一个非根点并将其权置零，然后高桥将指针移向其所在位置的任意儿子。高桥可以在任意时刻结束游戏（但当指针移到叶子节点后游戏强制结束）。分数为指针最后指向的点的权。青木想最小化分数，高桥想最大化分数，两人绝顶聪明，问最后的分数。</p>
<p>直接做似乎不太可能，我们考虑二分答案，即“最优策略下，高桥能否至少拿到 <span class="math inline">\(c\)</span> 分”。</p>
<p>下面是一个转化：将 <span class="math inline">\(\ge c\)</span> 的权看作 <span class="math inline">\(1\)</span>，<span class="math inline">\(&lt; c\)</span> 的权看作 <span class="math inline">\(0\)</span>，然后发现，只要高桥君走到了一个 <span class="math inline">\(1\)</span> 点，那么他就赢了，否则输了。</p>
<p>那么，显然，若高桥将指针移向一个点 <span class="math inline">\(u\)</span> 后，青木会选择在 <span class="math inline">\(u\)</span> 子树内将一个 <span class="math inline">\(1\)</span> 变成 <span class="math inline">\(0\)</span>。树形 dp，设 <span class="math inline">\(f_u\)</span> 为 <span class="math inline">\(u\)</span> 子树内高桥君能走到的 <span class="math inline">\(1\)</span> 点个数，则 <span class="math inline">\(f_u = \max(\sum f_v - 1, 0) + [a_u\ge c]\)</span>。<span class="math inline">\(f_1 &gt; 0\)</span> 时合法。</p>
<h4 id="abc246ex---01-queries">ABC246Ex - 01? Queries</h4>
<p>给定长为 <span class="math inline">\(n\le 10^5\)</span> 的包含 <code>0</code>，<code>1</code> 和 <code>?</code> 的串 <span class="math inline">\(S\)</span>，以及 <span class="math inline">\(q\le 10^5\)</span> 次操作 <span class="math inline">\((x_i, c_i)\)</span>，其中 <span class="math inline">\(x_i\)</span> 为下标，<span class="math inline">\(c_i\)</span> 为字符集中的某字符。按照 <span class="math inline">\(1,\cdots, q\)</span> 的顺序，每次将 <span class="math inline">\(S_{x_i}\leftarrow c_i\)</span>，然后计算 <span class="math inline">\(S\)</span> 的 0-1 子串个数（<code>?</code> 视为通配符），答案对 <span class="math inline">\(998244353\)</span> 取模。</p>
<p>先思考对于一个固定的 0-1 串如何计数。</p>
<p>可以设计一个 dp 状态 <span class="math inline">\(f_{i,0/1}\)</span> 表示考虑 <span class="math inline">\([1, i]\)</span>，结尾为 <span class="math inline">\(0/1\)</span> 的子序列数量，则答案显然为 <span class="math inline">\(f_{n, 0} + f_{n,1}\)</span>，现在考虑转移：发现可以对于 <span class="math inline">\(s_i\)</span> 为 <code>0</code>，<code>1</code> 还是 <code>?</code> 分类讨论： <span class="math display">\[
\begin{aligned}
f_{i,0} &amp;=
\begin{cases}
f_{i - 1, 0} + (f_{i - 1, 1} + 1) &amp; S_i = \texttt 0\lor S_i = \texttt{?}\\
f_{i - 1, 0} &amp; S_i = \texttt 1\\
\end{cases}
\\
f_{i,1} &amp;= 
\begin{cases}
f_{i - 1, 1} + (f_{i - 1, 0} + 1) &amp; S_i = \texttt 1 \lor S_i = \texttt{?}\\
f_{i - 1, 1} &amp; S_i = \texttt 0
\end{cases}
\end{aligned}
\]</span> 那么我们会发现，dp 数组的转移是很有规律的，而且我们每次修改都是修改一个点处的转移方式，而且询问 <span class="math inline">\(f_{n,0} + f_{n, 1}\)</span>。</p>
<p>这让你想到什么！动态 dp。具体地，令向量 <span class="math display">\[
\boldsymbol F_i = \begin{bmatrix}
f_{i, 0}\\
f_{i, 1}\\
1
\end{bmatrix}
\]</span> （最下面的 <span class="math inline">\(1\)</span> 是因为常数项需要转移）那么就可以写出三个转移矩阵： <span class="math display">\[
\boldsymbol A_{\texttt 0} = \begin{bmatrix}
1 &amp; 1 &amp; 1\\
0 &amp; 1 &amp; 0\\
0 &amp; 0 &amp; 1
\end{bmatrix}, \boldsymbol A_{\texttt 1} = \begin{bmatrix}
1 &amp; 0 &amp; 0\\
1 &amp; 1 &amp; 1\\
0 &amp; 0 &amp; 1
\end{bmatrix}, A_{\texttt{?}} = \begin{bmatrix}
1 &amp; 1 &amp; 1\\
1 &amp; 1 &amp; 1\\
0 &amp; 0 &amp; 1
\end{bmatrix}
\]</span> 于是就有 <span class="math display">\[
\boldsymbol F_i = \boldsymbol A_{S_i}\times \boldsymbol F_{i - 1} = A_{S_i}A_{S_{i-1}}\cdots \boldsymbol F_0
\]</span> 线段树维护矩阵连乘积，单点修改一下。时间复杂度 <span class="math inline">\(O((n + q)\log n)\)</span>。</p>
<h3 id="abc247">ABC247</h3>
<h4 id="abc247ex---rearranging-problem">ABC247Ex - Rearranging Problem</h4>
<p>题意：给定值域为 <span class="math inline">\([1, n]\)</span> 的序列 <span class="math inline">\(c_i\)</span>，进行 <span class="math inline">\(k\)</span> 次操作：每次选定任意 <span class="math inline">\(i\ne j\)</span> 然后交换 <span class="math inline">\(c_i\)</span> 和 <span class="math inline">\(c_j\)</span>。显然这样会得到一个下标的新排列，问有多少种这样的排列使得最后的序列和原来的 <span class="math inline">\(c_i\)</span> 相同。<span class="math inline">\(n\le 2\times 10^5\)</span>，<span class="math inline">\(k\le 10^9\)</span>。</p>
<p>应该是比较经典但我不会的计数套路。发现其实最后相当于只在相同的 <span class="math inline">\(c_i\)</span> 形成的连通块内部做交换，即排列的每个置换环内 <span class="math inline">\(c_i\)</span> 要相同。</p>
<blockquote>
<p>Lemma 1：交换两个数，置换环的个数会 <span class="math inline">\(+1/-1\)</span>。</p>
</blockquote>
<p>这个引理应该不难证明（随便画图分讨一下即可），而且貌似是个经典结论。</p>
<blockquote>
<p>Lemma 2：一个排列能在交换 <span class="math inline">\(k\)</span> 次后得到当且仅当 <span class="math inline">\(n - c\le k\land (n - c)\equiv k\pmod 2\)</span>，其中 <span class="math inline">\(c\)</span> 为置换环个数。</p>
</blockquote>
<p>这个引理可以用 Lemma 1 证明。注意到到一开始有 <span class="math inline">\(n\)</span> 个环，然后奇偶性讨论一下即可。</p>
<p>所以我们现在要求的就是对于每个合法的 <span class="math inline">\(c\)</span> 求出合法的置换个数。</p>
<p>可以 dp，设 <span class="math inline">\(f_{i,j}\)</span> 为考虑 <span class="math inline">\([1, i]\)</span> 的排列，置换环个数为 <span class="math inline">\(j\)</span> 的合法排列个数。转移的话考虑添加 <span class="math inline">\(i\)</span> 的时候其是形成了新环还是塞入了某个老环。 <span class="math display">\[
f_{i, j} = f_{i, j - 1} + f_{i - 1, j}\times |\{x\mid 1\le x&lt; i, c_i = c_x\}|
\]</span> 这个东西类似于第一类斯特林数的转移，所以可以分治 NTT，时间复杂度 <span class="math inline">\(O(n\log^2n)\)</span>。<del>偷懒用了他给的 NTT。</del></p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a aria-hidden="true" href="#cb14-1"></a><span class="pp">#include </span><span class="im">&lt;bits/stdc++.h&gt;</span></span>
<span id="cb14-2"><a aria-hidden="true" href="#cb14-2"></a><span class="pp">#include </span><span class="im">&lt;atcoder/modint&gt;</span></span>
<span id="cb14-3"><a aria-hidden="true" href="#cb14-3"></a><span class="pp">#include </span><span class="im">&lt;atcoder/convolution&gt;</span></span>
<span id="cb14-4"><a aria-hidden="true" href="#cb14-4"></a><span class="pp">#define FOR</span>(i,<span class="pp"> </span>a,<span class="pp"> </span>b)<span class="pp"> </span><span class="cf">for</span><span class="pp"> </span>(<span class="dt">int</span><span class="pp"> </span>i<span class="pp"> </span>=<span class="pp"> </span>(a);<span class="pp"> </span>i<span class="pp"> </span>&lt;=<span class="pp"> </span>(b);<span class="pp"> </span>++i)</span>
<span id="cb14-5"><a aria-hidden="true" href="#cb14-5"></a></span>
<span id="cb14-6"><a aria-hidden="true" href="#cb14-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb14-7"><a aria-hidden="true" href="#cb14-7"></a><span class="kw">using</span> mint = atcoder::modint998244353;</span>
<span id="cb14-8"><a aria-hidden="true" href="#cb14-8"></a><span class="kw">using</span> atcoder::convolution;</span>
<span id="cb14-9"><a aria-hidden="true" href="#cb14-9"></a></span>
<span id="cb14-10"><a aria-hidden="true" href="#cb14-10"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">2e5</span> + <span class="dv">5</span>;</span>
<span id="cb14-11"><a aria-hidden="true" href="#cb14-11"></a>vector&lt;vector&lt;mint&gt;&gt; P;</span>
<span id="cb14-12"><a aria-hidden="true" href="#cb14-12"></a><span class="dt">int</span> cnt[maxn], n, k;</span>
<span id="cb14-13"><a aria-hidden="true" href="#cb14-13"></a></span>
<span id="cb14-14"><a aria-hidden="true" href="#cb14-14"></a><span class="dt">int</span> main() {</span>
<span id="cb14-15"><a aria-hidden="true" href="#cb14-15"></a>    cin &gt;&gt; n &gt;&gt; k;</span>
<span id="cb14-16"><a aria-hidden="true" href="#cb14-16"></a>    FOR(i, <span class="dv">1</span>, n) {</span>
<span id="cb14-17"><a aria-hidden="true" href="#cb14-17"></a>        <span class="dt">int</span> x; cin &gt;&gt; x;</span>
<span id="cb14-18"><a aria-hidden="true" href="#cb14-18"></a>        P.push_back({cnt[x]++, <span class="dv">1</span>});</span>
<span id="cb14-19"><a aria-hidden="true" href="#cb14-19"></a>    }</span>
<span id="cb14-20"><a aria-hidden="true" href="#cb14-20"></a>    <span class="cf">while</span> (P.size() &gt;= <span class="dv">2</span>) {</span>
<span id="cb14-21"><a aria-hidden="true" href="#cb14-21"></a>        <span class="kw">decltype</span>(P) nxt;</span>
<span id="cb14-22"><a aria-hidden="true" href="#cb14-22"></a>        <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; P.size() - <span class="dv">1</span>; i += <span class="dv">2</span>) nxt.push_back(convolution(P[i], P[i + <span class="dv">1</span>]));</span>
<span id="cb14-23"><a aria-hidden="true" href="#cb14-23"></a>        <span class="cf">if</span> (P.size() &amp; <span class="dv">1</span>) nxt.push_back(P.back());</span>
<span id="cb14-24"><a aria-hidden="true" href="#cb14-24"></a>        nxt.swap(P);</span>
<span id="cb14-25"><a aria-hidden="true" href="#cb14-25"></a>    }</span>
<span id="cb14-26"><a aria-hidden="true" href="#cb14-26"></a>    <span class="kw">auto</span> &amp;f = P.front();</span>
<span id="cb14-27"><a aria-hidden="true" href="#cb14-27"></a>    mint ans = <span class="dv">0</span>;</span>
<span id="cb14-28"><a aria-hidden="true" href="#cb14-28"></a>    FOR(c, <span class="dv">0</span>, (<span class="dt">int</span>)f.size() - <span class="dv">1</span>) <span class="cf">if</span> (n - c &lt;= k &amp;&amp; ((n - c) &amp; <span class="dv">1</span>) == (k &amp; <span class="dv">1</span>)) ans += f[c];</span>
<span id="cb14-29"><a aria-hidden="true" href="#cb14-29"></a>    cout &lt;&lt; ans.val() &lt;&lt; endl;</span>
<span id="cb14-30"><a aria-hidden="true" href="#cb14-30"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb14-31"><a aria-hidden="true" href="#cb14-31"></a>}</span></code></pre></div>
<h2 id="arc">ARC</h2>
<h3 id="arc-补题表">ARC 补题表</h3>
<p>近期目标：ARC 稳定做出 3 题，尽力补完 A-D。</p>
<div class="table-wrapper"><table>
<thead>
<tr class="header">
<th>Round</th>
<th style="text-align: center;">Rank</th>
<th style="text-align: center;">Perf</th>
<th style="text-align: center;">Sol</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ARC116</td>
<td style="text-align: center;">vp</td>
<td style="text-align: center;">vp</td>
<td style="text-align: center;">3</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>👀</td>
<td>😅</td>
<td>😅</td>
</tr>
<tr class="even">
<td>ARC117</td>
<td style="text-align: center;"><a href="https://atcoder.jp/contests/arc117/standings?watching=YangTY">597</a></td>
<td style="text-align: center;">1736</td>
<td style="text-align: center;">3</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>😅</td>
<td>😅</td>
</tr>
<tr class="odd">
<td>ARC118</td>
<td style="text-align: center;"><a href="https://atcoder.jp/contests/arc118/standings?watching=YangTY">1679</a></td>
<td style="text-align: center;">807</td>
<td style="text-align: center;">3</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>👀</td>
<td>😅</td>
<td>😅</td>
</tr>
<tr class="even">
<td>ARC119</td>
<td style="text-align: center;"><a href="https://atcoder.jp/contests/arc119/standings?watching=YangTY">1141</a></td>
<td style="text-align: center;">1180</td>
<td style="text-align: center;">2</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>😅</td>
<td>😅</td>
</tr>
<tr class="odd">
<td>ARC120</td>
<td style="text-align: center;"><a href="https://atcoder.jp/contests/arc120/standings?watching=YangTY">785</a></td>
<td style="text-align: center;">1345</td>
<td style="text-align: center;">2</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>😅</td>
<td>😅</td>
</tr>
<tr class="even">
<td>ARC123</td>
<td style="text-align: center;"><a href="https://atcoder.jp/contests/arc123/standings?watching=YangTY">608</a></td>
<td style="text-align: center;">1756</td>
<td style="text-align: center;">3</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>👀</td>
<td>😅</td>
<td>😅</td>
</tr>
<tr class="odd">
<td>ARC124</td>
<td style="text-align: center;"><a href="https://atcoder.jp/contests/arc124/standings?watching=YangTY">1276</a></td>
<td style="text-align: center;">1004</td>
<td style="text-align: center;">2</td>
<td>🉑</td>
<td>🉑</td>
<td>👀</td>
<td>👀</td>
<td>😅</td>
<td>😅</td>
</tr>
<tr class="even">
<td>ARC125</td>
<td style="text-align: center;"><a href="https://atcoder.jp/contests/arc125/standings?watching=Cgfyufsygsm">463</a></td>
<td style="text-align: center;">1850</td>
<td style="text-align: center;">3</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>😅</td>
<td>😅</td>
</tr>
<tr class="odd">
<td>ARC126</td>
<td style="text-align: center;"><a href="https://atcoder.jp/contests/arc126/standings?watching=YangTY">876</a></td>
<td style="text-align: center;">1371</td>
<td style="text-align: center;">2</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>👀</td>
<td>😅</td>
<td>😅</td>
</tr>
<tr class="even">
<td>ARC128</td>
<td style="text-align: center;"><a href="https://atcoder.jp/contests/arc128/standings?watching=YangTY">340</a></td>
<td style="text-align: center;">1998</td>
<td style="text-align: center;">3</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>👀</td>
<td>😅</td>
<td>😅</td>
</tr>
<tr class="odd">
<td>ARC131</td>
<td style="text-align: center;"><a href="https://atcoder.jp/contests/arc131/standings?watching=YangTY">220</a></td>
<td style="text-align: center;">2230</td>
<td style="text-align: center;">4</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>👀</td>
<td>🉑</td>
<td>😅</td>
</tr>
<tr class="even">
<td>ARC132</td>
<td style="text-align: center;"><a href="https://atcoder.jp/contests/arc132/standings?watching=YangTY">566</a></td>
<td style="text-align: center;">1728</td>
<td style="text-align: center;">3</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>😅</td>
<td>😅</td>
</tr>
<tr class="odd">
<td>ARC134</td>
<td style="text-align: center;"><a href="https://atcoder.jp/contests/arc134/standings?watching=YangTY">877</a></td>
<td style="text-align: center;">1538</td>
<td style="text-align: center;">3</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>😅</td>
<td>😅</td>
</tr>
<tr class="even">
<td>ARC137</td>
<td style="text-align: center;"><a href="https://atcoder.jp/contests/arc137/standings?watching=YangTY">281</a></td>
<td style="text-align: center;">2148</td>
<td style="text-align: center;">3</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>😅</td>
</tr>
<tr class="odd">
<td>ARC138</td>
<td style="text-align: center;"><a href="https://atcoder.jp/contests/arc138/standings?watching=YangTY">246</a></td>
<td style="text-align: center;">2242</td>
<td style="text-align: center;">4</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>🉑</td>
<td>👀</td>
<td>😅</td>
</tr>
</tbody>
</table></div>
<h3 id="一些新见到的-trick-1">一些新见到的 trick</h3>
<ul>
<li>ARC116B：将 <span class="math inline">\(\max\times \min\)</span> 拆开贡献。</li>
<li>ARC125D：子序列自动机 dp。</li>
<li>ARC128C：线性规划的最值一定在边界取到。</li>
<li>ARC134C：<strong>某种元素至少占一半</strong>，考虑先强行配对，然后正常做。</li>
<li>ARC137D：模 <span class="math inline">\(2\)</span> 意义下的 Lucas → 高维前缀和。</li>
<li>ARC137E：最小费用循环流的建图。</li>
</ul>
<h3 id="arc116">ARC116</h3>
<p>VP。</p>
<h4 id="arc116a---odd-vs-even">ARC116A - Odd vs Even</h4>
<p>给定 <span class="math inline">\(T\)</span>（<span class="math inline">\(T\le 2\times 10^5\)</span>）个正整数 <span class="math inline">\(n\)</span>（<span class="math inline">\(1\le n\le 10^{18}\)</span>），问 <span class="math inline">\(n\)</span> 的奇约数多还是偶约数多。（约数均为正约数）</p>
<p>很明显，如果 <span class="math inline">\(n\bmod 2 = 1\)</span>，则答案为奇约数多。</p>
<p>否则考察约数们怎么来的。对于一个偶数 <span class="math inline">\(n\)</span> 我们总能将其这样拆分：<span class="math inline">\(n = 2^k\times p\)</span>（<span class="math inline">\(p\)</span> 为奇数）。那么如果 <span class="math inline">\(k = 1\)</span>，则不难发现奇偶约数一样多，否则肯定是偶约数多。</p>
<h4 id="arc116b---products-of-min-max">ARC116B - Products of Min-Max</h4>
<p>给定一含正整数的集合 <span class="math inline">\(A\)</span>，求 <span class="math display">\[
\sum_{S\subseteq A}\max_{a\in S}\lbrace a\rbrace\min_{a\in S}\lbrace a\rbrace\bmod{998244353}
\]</span> 的值。</p>
<p>比较妙的题。</p>
<p>首先考虑把最大值和最小值拎出来考虑贡献：将其 <span class="math inline">\(A\)</span> 从小到大排序。</p>
<p>然后假设此时 <span class="math inline">\(i&lt;j\)</span>，则 <span class="math inline">\(a_i\le a_j\)</span>，这一对元素贡献的子集个数为 <span class="math inline">\(2^{j - i - 1}\)</span>。所以答案就为 <span class="math display">\[
\sum_{i = 1}^{n - 1}\sum_{j = i + 1}^na_ia_j\cdot2^{j - i} + \sum_{i = 1}^na_i^2
\]</span> 化简下来可以得到 <span class="math display">\[
\sum_{i = 1}^{n - 1}\left(a_i\cdot 2^{-i}\sum_{j = i + 1}^na_j\cdot2^{j - 1}\right) + \sum_{i = 1}^na_i^2
\]</span> 预处理 <span class="math inline">\(a_i2^{i - 1}\)</span> 的后缀和就可以直接做了，复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<h4 id="arc116c---multiple-sequences">ARC116C - Multiple Sequences</h4>
<p>给定 <span class="math inline">\(n\)</span> 和 <span class="math inline">\(m\)</span>（<span class="math inline">\(1\le n,m\le 2\times 10^5\)</span>），求满足下列条件的长度为 <span class="math inline">\(n\)</span> 的整数序列 <span class="math inline">\(A\)</span> 的个数。</p>
<ul>
<li><span class="math inline">\(1\le A_i\le m\)</span></li>
<li><span class="math inline">\(A_{i + 1}\)</span> 为 <span class="math inline">\(A_i\)</span> 的整数倍</li>
</ul>
<p>结果模 <span class="math inline">\(998244353\)</span>。</p>
<p>很妙的计数题。</p>
<p>考虑从 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(m\)</span> 枚举 <span class="math inline">\(A_n\)</span> 的值。我们可以发现其就是把 <span class="math inline">\(A_n\)</span> 每个质因子给安排在 <span class="math inline">\(n\)</span> 个不同的位置上，求方案数。但是此时需要对每个质因子分开考虑，假设 <span class="math inline">\(A_n = \prod p_i^{c_i}\)</span>，则我们需要对每个质因子都用插板法然后再乘起来得到总方案，即 <span class="math display">\[
f(A_n) = \prod\binom{n + c_i - 1}{c_i}
\]</span> 最后把所有的结果加起来即为答案。</p>
<h3 id="arc117">ARC117</h3>
<p>A + B + C + D</p>
<h4 id="arc117c---tricolor-pyramid">ARC117C - Tricolor Pyramid</h4>
<p><a href="https://atcoder.jp/contests/arc117/tasks/arc117_c">题目</a></p>
<p>比较妙的题。首先把颜色分别看成 <span class="math inline">\(0,1,2\)</span>，那么上一层的方块就由 <span class="math inline">\(-(a_1 + a_2) \bmod 3\)</span> 可以得到。把所有的一直累加上去就是杨辉三角的形式：</p>
<p><img src="https://img.atcoder.jp/arc117/6d089e1cdfb0ed3c0bf6daee87fc198e.png"/></p>
<p>图源 AtCoder 官方题解。</p>
<p>所以求二项式系数即可，使用 Lucas 定理。</p>
<h4 id="arc117d---miracle-tree">ARC117D - Miracle Tree</h4>
<p>给一棵树的每个顶点标号，满足 <span class="math inline">\(E_i \ge 1\)</span>，且 <span class="math inline">\(|E_i - E_j|\le \operatorname{dist}(i, j)\)</span>。寻找一种最大标号最小的方案并输出。</p>
<p>相当好的思维题。</p>
<p>首先考虑随便标一个图。</p>
<p><img src="https://img.atcoder.jp/arc117/a4103a74b2e0196e17a1a389f8fad851.png"/></p>
<p>图源 AtCoder 官方题解。</p>
<p>不难发现我们标的号应该为：<span class="math inline">\(\lbrace1, 2, 3, 5, 8, 9\rbrace\)</span> 是最优的。相当于就是遇到一个点，首先走一条子链，然后回溯回来的时候仍然需要统计回溯链长，然后加到下一条子链的贡献里面去（因为要 <span class="math inline">\(|E_i - E_j|\le \operatorname{dist}(i, j)\)</span>）。我们自然希望的是尽可能回溯的少，所以做的时候从直径的一端开始走，然后遇到分叉就优先走非直径的边。</p>
<h3 id="arc118">ARC118</h3>
<p>A</p>
<h4 id="arc118a---tax-included-price">ARC118A - Tax Included Price</h4>
<p>打表可做。</p>
<h4 id="arc118b---village-of-m-people">ARC118B - Village of M People</h4>
<p>给定 <span class="math inline">\(K\)</span>，<span class="math inline">\(N\)</span> 和 <span class="math inline">\(M\)</span> 以及 <span class="math inline">\(K\)</span> 个 <span class="math inline">\(A_i\)</span>，构造 <span class="math inline">\(B_i\)</span>，使得 <span class="math inline">\(\sum B_i = M\)</span> 且 <span class="math display">\[
\max_i\left|\frac{B_i}{M} - \frac{A_i}{N}\right|
\]</span> 最小。</p>
<p>“最大的最小”，二分答案即可。</p>
<p>要让 <span class="math inline">\(\max_i\left|\frac{B_i}{M} - \frac{A_i}{N}\right|\)</span> 最小，即为让 <span class="math inline">\(\max_i|B_iN - A_iM|\)</span> 最小，设为 <span class="math inline">\(x\)</span> 即可。</p>
<p>然后我们可以得到 <span class="math inline">\(\forall i, \left\lceil \frac{MA_i-x}{N}\right\rceil\leq B_i\leq \left\lfloor\frac{MA_i+x}{N}\right\rfloor\)</span>。这样子 <span class="math inline">\(B_i\)</span> 的上界和下界就出来了，设为 <span class="math inline">\(L_i\)</span> 和 <span class="math inline">\(R_i\)</span>。</p>
<p>然后，如果 <span class="math inline">\(\sum L_i\le M\le \sum R_i\)</span>，则答案一定是可以被构造出来的。这样子我们就可以完成对于一个 <span class="math inline">\(x\)</span> 的 check。</p>
<p>如何构造这个答案呢？把所有的 <span class="math inline">\(B_i\)</span> 设为 <span class="math inline">\(L_i\)</span>，然后依次上调来补齐余量 <span class="math inline">\(M - \sum L_i\)</span>。</p>
<p>这题就做完了。</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a aria-hidden="true" href="#cb15-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb15-2"><a aria-hidden="true" href="#cb15-2"></a><span class="pp">#include </span><span class="im">&lt;cctype&gt;</span></span>
<span id="cb15-3"><a aria-hidden="true" href="#cb15-3"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb15-4"><a aria-hidden="true" href="#cb15-4"></a><span class="pp">#define FOR</span>(i,<span class="pp"> </span>a,<span class="pp"> </span>b)<span class="pp"> </span><span class="cf">for</span><span class="pp"> </span>(<span class="dt">int</span><span class="pp"> </span>i<span class="pp"> </span>=<span class="pp"> </span>a;<span class="pp"> </span>i<span class="pp"> </span>&lt;=<span class="pp"> </span>b;<span class="pp"> </span>++i)</span>
<span id="cb15-5"><a aria-hidden="true" href="#cb15-5"></a><span class="pp">#define DEC</span>(i,<span class="pp"> </span>a,<span class="pp"> </span>b)<span class="pp"> </span><span class="cf">for</span><span class="pp"> </span>(<span class="dt">int</span><span class="pp"> </span>i<span class="pp"> </span>=<span class="pp"> </span>a;<span class="pp"> </span>i<span class="pp"> </span>&gt;=<span class="pp"> </span>b;<span class="pp"> </span>--i)</span>
<span id="cb15-6"><a aria-hidden="true" href="#cb15-6"></a><span class="pp">#define int </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb15-7"><a aria-hidden="true" href="#cb15-7"></a></span>
<span id="cb15-8"><a aria-hidden="true" href="#cb15-8"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">1e5</span> + <span class="dv">5</span>;</span>
<span id="cb15-9"><a aria-hidden="true" href="#cb15-9"></a></span>
<span id="cb15-10"><a aria-hidden="true" href="#cb15-10"></a><span class="dt">int</span> read()</span>
<span id="cb15-11"><a aria-hidden="true" href="#cb15-11"></a>{</span>
<span id="cb15-12"><a aria-hidden="true" href="#cb15-12"></a>    <span class="dt">int</span> s = <span class="dv">0</span>, x = <span class="dv">0</span>;</span>
<span id="cb15-13"><a aria-hidden="true" href="#cb15-13"></a>    <span class="dt">char</span> c = getchar();</span>
<span id="cb15-14"><a aria-hidden="true" href="#cb15-14"></a>    <span class="cf">while</span> (!isdigit(c))</span>
<span id="cb15-15"><a aria-hidden="true" href="#cb15-15"></a>        x |= (c == <span class="ch">'-'</span>), c = getchar();</span>
<span id="cb15-16"><a aria-hidden="true" href="#cb15-16"></a>    <span class="cf">while</span> (isdigit(c))</span>
<span id="cb15-17"><a aria-hidden="true" href="#cb15-17"></a>        s = s * <span class="dv">10</span> + c - <span class="ch">'0'</span>, c = getchar();</span>
<span id="cb15-18"><a aria-hidden="true" href="#cb15-18"></a>    <span class="cf">return</span> x ? -s : s;</span>
<span id="cb15-19"><a aria-hidden="true" href="#cb15-19"></a>}</span>
<span id="cb15-20"><a aria-hidden="true" href="#cb15-20"></a></span>
<span id="cb15-21"><a aria-hidden="true" href="#cb15-21"></a><span class="dt">int</span> k, a[maxn], n, m;</span>
<span id="cb15-22"><a aria-hidden="true" href="#cb15-22"></a><span class="dt">int</span> L[maxn], R[maxn], suml, sumr;</span>
<span id="cb15-23"><a aria-hidden="true" href="#cb15-23"></a></span>
<span id="cb15-24"><a aria-hidden="true" href="#cb15-24"></a><span class="kw">inline</span> <span class="dt">int</span> max(<span class="dt">int</span> a, <span class="dt">int</span> b) {<span class="cf">return</span> a &gt; b ? a : b;}</span>
<span id="cb15-25"><a aria-hidden="true" href="#cb15-25"></a><span class="kw">inline</span> <span class="dt">int</span> min(<span class="dt">int</span> a, <span class="dt">int</span> b) {<span class="cf">return</span> a &lt; b ? a : b;}</span>
<span id="cb15-26"><a aria-hidden="true" href="#cb15-26"></a></span>
<span id="cb15-27"><a aria-hidden="true" href="#cb15-27"></a><span class="dt">bool</span> check(<span class="dt">int</span> x)</span>
<span id="cb15-28"><a aria-hidden="true" href="#cb15-28"></a>{</span>
<span id="cb15-29"><a aria-hidden="true" href="#cb15-29"></a>    memset(L, <span class="dv">0</span>, <span class="kw">sizeof</span> L), memset(R, <span class="dv">0</span>, <span class="kw">sizeof</span> R);</span>
<span id="cb15-30"><a aria-hidden="true" href="#cb15-30"></a>    suml = sumr = <span class="dv">0</span>;</span>
<span id="cb15-31"><a aria-hidden="true" href="#cb15-31"></a>    FOR(i, <span class="dv">1</span>, k)</span>
<span id="cb15-32"><a aria-hidden="true" href="#cb15-32"></a>    {</span>
<span id="cb15-33"><a aria-hidden="true" href="#cb15-33"></a>        L[i] = max(<span class="dv">0</span>, (m * a[i] - x + n - <span class="dv">1</span>) / n);</span>
<span id="cb15-34"><a aria-hidden="true" href="#cb15-34"></a>        R[i] = (m * a[i] + x) / n;</span>
<span id="cb15-35"><a aria-hidden="true" href="#cb15-35"></a>        suml += L[i], sumr += R[i];</span>
<span id="cb15-36"><a aria-hidden="true" href="#cb15-36"></a>    }</span>
<span id="cb15-37"><a aria-hidden="true" href="#cb15-37"></a>    <span class="cf">return</span> suml &lt;= m &amp;&amp; m &lt;= sumr;</span>
<span id="cb15-38"><a aria-hidden="true" href="#cb15-38"></a>}</span>
<span id="cb15-39"><a aria-hidden="true" href="#cb15-39"></a></span>
<span id="cb15-40"><a aria-hidden="true" href="#cb15-40"></a><span class="dt">signed</span> main()</span>
<span id="cb15-41"><a aria-hidden="true" href="#cb15-41"></a>{</span>
<span id="cb15-42"><a aria-hidden="true" href="#cb15-42"></a>    k = read(), n = read(), m = read();</span>
<span id="cb15-43"><a aria-hidden="true" href="#cb15-43"></a>    FOR(i, <span class="dv">1</span>, k) a[i] = read();</span>
<span id="cb15-44"><a aria-hidden="true" href="#cb15-44"></a>    <span class="dt">int</span> l = <span class="dv">0</span>, r = n * m, x;</span>
<span id="cb15-45"><a aria-hidden="true" href="#cb15-45"></a>    <span class="cf">while</span> (l &lt;= r)</span>
<span id="cb15-46"><a aria-hidden="true" href="#cb15-46"></a>    {</span>
<span id="cb15-47"><a aria-hidden="true" href="#cb15-47"></a>        <span class="dt">int</span> mid = (l + r) &gt;&gt; <span class="dv">1</span>;</span>
<span id="cb15-48"><a aria-hidden="true" href="#cb15-48"></a>        <span class="cf">if</span> (check(mid)) x = mid, r = mid - <span class="dv">1</span>;</span>
<span id="cb15-49"><a aria-hidden="true" href="#cb15-49"></a>        <span class="cf">else</span> l = mid + <span class="dv">1</span>;</span>
<span id="cb15-50"><a aria-hidden="true" href="#cb15-50"></a>    }</span>
<span id="cb15-51"><a aria-hidden="true" href="#cb15-51"></a>    check(x);</span>
<span id="cb15-52"><a aria-hidden="true" href="#cb15-52"></a>    <span class="dt">int</span> sumb = suml;</span>
<span id="cb15-53"><a aria-hidden="true" href="#cb15-53"></a>    FOR(i, <span class="dv">1</span>, k)</span>
<span id="cb15-54"><a aria-hidden="true" href="#cb15-54"></a>    {</span>
<span id="cb15-55"><a aria-hidden="true" href="#cb15-55"></a>        <span class="dt">int</span> x = min(R[i] - L[i], m - sumb);</span>
<span id="cb15-56"><a aria-hidden="true" href="#cb15-56"></a>        sumb += x;</span>
<span id="cb15-57"><a aria-hidden="true" href="#cb15-57"></a>        printf(<span class="st">"</span><span class="sc">%d</span><span class="st"> "</span>, x + L[i]);</span>
<span id="cb15-58"><a aria-hidden="true" href="#cb15-58"></a>    }</span>
<span id="cb15-59"><a aria-hidden="true" href="#cb15-59"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb15-60"><a aria-hidden="true" href="#cb15-60"></a>}</span></code></pre></div>
<h4 id="arc118c---coprime-set">ARC118C - Coprime Set</h4>
<p>给定 <span class="math inline">\(N\)</span>（<span class="math inline">\(3\le N\le 2500\)</span>），构造 <span class="math inline">\(N\)</span> 个正整数 <span class="math inline">\(A_i\)</span> 使得：</p>
<ul>
<li><span class="math inline">\(A_i\)</span> 互不相同且 <span class="math inline">\(A_i\in[1, 10000]\)</span></li>
<li><span class="math inline">\(\forall i \not= j, \gcd(A_i, A_j) &gt; 1\)</span></li>
<li><span class="math inline">\(\gcd_i\{A_i\} = 1\)</span></li>
</ul>
<p>这个题需要一个引理：对于一系列已经满足条件的 <span class="math inline">\(A_i\)</span>，将任意 <span class="math inline">\(A_i\)</span> 的倍数加进去，新得到的集合也是满足条件的。</p>
<p>正确性比较显然，不证。所以从 <span class="math inline">\(\{6, 10, 15\}\)</span> 出发，就可以构造出所有的合法答案。</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a aria-hidden="true" href="#cb16-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb16-2"><a aria-hidden="true" href="#cb16-2"></a></span>
<span id="cb16-3"><a aria-hidden="true" href="#cb16-3"></a><span class="dt">int</span> vis[<span class="dv">10005</span>];</span>
<span id="cb16-4"><a aria-hidden="true" href="#cb16-4"></a></span>
<span id="cb16-5"><a aria-hidden="true" href="#cb16-5"></a><span class="dt">int</span> main()</span>
<span id="cb16-6"><a aria-hidden="true" href="#cb16-6"></a>{</span>
<span id="cb16-7"><a aria-hidden="true" href="#cb16-7"></a>    <span class="dt">int</span> n = <span class="dv">0</span>;</span>
<span id="cb16-8"><a aria-hidden="true" href="#cb16-8"></a>    scanf(<span class="st">"</span><span class="sc">%d</span><span class="st">"</span>, &amp;n);</span>
<span id="cb16-9"><a aria-hidden="true" href="#cb16-9"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i * <span class="dv">6</span> &lt;= <span class="dv">10000</span>; ++i) vis[i * <span class="dv">6</span>] = <span class="dv">1</span>;</span>
<span id="cb16-10"><a aria-hidden="true" href="#cb16-10"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i * <span class="dv">10</span> &lt;= <span class="dv">10000</span>; ++i) vis[i * <span class="dv">10</span>] = <span class="dv">1</span>;</span>
<span id="cb16-11"><a aria-hidden="true" href="#cb16-11"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i * <span class="dv">15</span> &lt;= <span class="dv">10000</span>; ++i) vis[i * <span class="dv">15</span>] = <span class="dv">1</span>;</span>
<span id="cb16-12"><a aria-hidden="true" href="#cb16-12"></a>    <span class="dt">int</span> cnt = <span class="dv">4</span>;</span>
<span id="cb16-13"><a aria-hidden="true" href="#cb16-13"></a>    printf(<span class="st">"</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d\n</span><span class="st">"</span>, <span class="dv">6</span>, <span class="dv">10</span>, <span class="dv">15</span>), vis[<span class="dv">6</span>] = vis[<span class="dv">10</span>] = vis[<span class="dv">15</span>] = <span class="dv">0</span>;</span>
<span id="cb16-14"><a aria-hidden="true" href="#cb16-14"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">6</span>; i &lt;= <span class="dv">10000</span> &amp;&amp; cnt &lt;= n; ++i) <span class="cf">if</span> (vis[i]) printf(<span class="st">"</span><span class="sc">%d</span><span class="st"> "</span>, i), ++cnt;</span>
<span id="cb16-15"><a aria-hidden="true" href="#cb16-15"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb16-16"><a aria-hidden="true" href="#cb16-16"></a>}</span></code></pre></div>
<h3 id="arc119">ARC119</h3>
<p>A + B</p>
<h4 id="arc119b---electric-board">ARC119B - Electric Board</h4>
<p>给定两个 01 串 <span class="math inline">\(S\)</span> 和 <span class="math inline">\(T\)</span>，每次对 <span class="math inline">\(S\)</span> 的操作可以选取 <span class="math inline">\((l,r)\)</span>，满足</p>
<ul>
<li><span class="math inline">\(S_l = 0\land S_{l+ 1} = S_{l + 2} = \cdots = S_{r} = 1\)</span></li>
<li><span class="math inline">\(S_l = S_{l + 1} = \cdots = S_{r - 1} = 1 \land S_r = 0\)</span></li>
</ul>
<p>然后交换 <span class="math inline">\(S_l\)</span> 和 <span class="math inline">\(S_r\)</span>。问最少多少次操作之后可以将 <span class="math inline">\(S\)</span> 变成 <span class="math inline">\(T\)</span>。</p>
<p>我们不妨将每次操作看为 <span class="math inline">\(0\)</span> 的移动操作，因为 <span class="math inline">\(1\)</span> 是连续动的，不好考虑。那么就只需要从左往右进行贪心，把 <span class="math inline">\(S\)</span> 的每个 <span class="math inline">\(0\)</span> 依次往右移直到与 <span class="math inline">\(T\)</span> 的 <span class="math inline">\(0\)</span> 对应。记录下每个 <span class="math inline">\(0\)</span> 的位置然后直接贪心就可以了。</p>
<h4 id="arc119c---arc-wrecker-2">ARC119C - ARC Wrecker 2</h4>
<p>给定长度为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(A_i\)</span>，对于区间 <span class="math inline">\([l,r]\)</span>，每次可选择 <span class="math inline">\([l, r - 1]\)</span> 间的一个整数 <span class="math inline">\(x\)</span>，然后将 <span class="math inline">\(A_x\)</span> 和 <span class="math inline">\(A_{x + 1}\)</span> 同时加一或减一。问有多少个 <span class="math inline">\([l,r ]\)</span> 可以在有限次操作之后变为全 <span class="math inline">\(0\)</span>。</p>
<p>比较妙的思路。</p>
<p>每次操作相当于是给奇数下标的数和偶数下标的数同时加减 <span class="math inline">\(1\)</span>，所以为了最后得到全 <span class="math inline">\(0\)</span>，一开始选的区间中奇下标和偶下标数的和必须相等。</p>
<p>注意到这条性质之后记录一下前缀和，然后用 <code>map</code> 随便记录以下就可以做了。</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a aria-hidden="true" href="#cb17-1"></a><span class="dt">int</span> n;</span>
<span id="cb17-2"><a aria-hidden="true" href="#cb17-2"></a></span>
<span id="cb17-3"><a aria-hidden="true" href="#cb17-3"></a>ll ans, a[maxn], s[maxn];</span>
<span id="cb17-4"><a aria-hidden="true" href="#cb17-4"></a></span>
<span id="cb17-5"><a aria-hidden="true" href="#cb17-5"></a><span class="bu">std::</span>map&lt;ll, ll&gt; m;</span>
<span id="cb17-6"><a aria-hidden="true" href="#cb17-6"></a></span>
<span id="cb17-7"><a aria-hidden="true" href="#cb17-7"></a><span class="dt">int</span> main()</span>
<span id="cb17-8"><a aria-hidden="true" href="#cb17-8"></a>{</span>
<span id="cb17-9"><a aria-hidden="true" href="#cb17-9"></a>    n = read();</span>
<span id="cb17-10"><a aria-hidden="true" href="#cb17-10"></a>    FOR(i, <span class="dv">1</span>, n) a[i] = read() * ((i &amp; <span class="dv">1</span>) ? -<span class="dv">1</span> : <span class="dv">1</span>);</span>
<span id="cb17-11"><a aria-hidden="true" href="#cb17-11"></a>    FOR(i, <span class="dv">1</span>, n) s[i] = a[i] + s[i - <span class="dv">1</span>], ++m[s[i]];</span>
<span id="cb17-12"><a aria-hidden="true" href="#cb17-12"></a>    ++m[<span class="dv">0</span>];</span>
<span id="cb17-13"><a aria-hidden="true" href="#cb17-13"></a>    <span class="cf">for</span> (<span class="bu">std::</span>map&lt;ll, ll&gt;::iterator it = m.begin(); it != m.end(); ++it)</span>
<span id="cb17-14"><a aria-hidden="true" href="#cb17-14"></a>        ans += (*it).second * ((*it).second - <span class="dv">1</span><span class="bu">ll</span>) / <span class="dv">2</span>;</span>
<span id="cb17-15"><a aria-hidden="true" href="#cb17-15"></a>    printf(<span class="st">"</span><span class="sc">%lld\n</span><span class="st">"</span>, ans);</span>
<span id="cb17-16"><a aria-hidden="true" href="#cb17-16"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb17-17"><a aria-hidden="true" href="#cb17-17"></a>}</span></code></pre></div>
<p>答案的上界是会爆 <code>int</code>，要开 <code>long long</code>。</p>
<h4 id="arc119d---grid-repainting-3">ARC119D - Grid Repainting 3</h4>
<p>给定一 <span class="math inline">\(H\)</span> 行 <span class="math inline">\(W\)</span> 列的方格，每个方格一开始涂了红色或者蓝色。进行如下操作：对于当前的每个红色格子，可以选择它并将其所在的一行或一列全部涂满白色。问最后最多多少个格子可以是白色并构造方案。</p>
<p>对于这种方格并且操作是对于整行或整列的题，很容易想到构建一张二分图来解决问题。左部的点代表每行，右部的点代表每列，一个红格子代表一条边。</p>
<p>然后我们分析这个涂色方案。涂掉一整行/列相当于废掉这一个点，同时把这个点相关的所有边全部废掉（即为废掉在这行/列上的红格子）。当然废掉这个点的条件是它能引出至少一条边（即必须有至少一个红格子在这行/列上面）。依据这个想法，我们肯定希望一个连通分量内，废掉的点（即涂掉的行/列）越多越好，考虑如何使它最多。</p>
<p>注意到，一个连通分量删到最后一定会剩下一个点（至于为什么可以自己思考一下）。我们尝试构造一下方案：假设我们剩点 <span class="math inline">\(u\)</span>，那么就可以从 <span class="math inline">\(u\)</span> 构建这个连通分量的 dfs 生成树，然后从叶子节点往上删点，这样一定可以保证是合法而且除了 <span class="math inline">\(u\)</span>，其他的点会被删干净。</p>
<p>一张图是有很多个连通分量的，而我们需要对每个连通分量进行决策：留下哪个点最优。我们要涂白的格子最多，假设涂了 <span class="math inline">\(r\)</span> 行 <span class="math inline">\(c\)</span> 列，则剩下的蓝格子为 <span class="math inline">\((h - r)(w - c)\)</span> 个，我们需要将其最小化。不难发现我们可以直接枚举留下来的行点和列点的个数，然后找到最优解就直接决策每个连通分量剩下行还是列（反正哪一行哪一列不重要），这题就做完了。</p>
<p>主要的流程：</p>
<ul>
<li>染色标记连通分量</li>
<li>决策剩下多少列点和多少行点</li>
<li>dfs 记录答案</li>
<li>输出</li>
</ul>
<h3 id="arc120">ARC120</h3>
<p>A + B</p>
<h4 id="arc120b---uniformly-distributed">ARC120B - Uniformly Distributed</h4>
<p>给定 <span class="math inline">\(H \times W\)</span> 的方格，其中一些涂了红色，一些涂了蓝色，一些什么都没涂。问对于剩余的格子，有多少种涂色的方案使得从 <span class="math inline">\((1,1)\)</span> 到 <span class="math inline">\((H,W)\)</span> 上的所有路径经过的红格子数量都相等。</p>
<p>不难发现，对于一个从右上到左下的副对角线，其要么全为红色，要么全为蓝色。大体的理由如下：（非严格证明）</p>
<p>从 <span class="math inline">\((1,1)\)</span> 到 <span class="math inline">\((H,W)\)</span> 一定是会经过 <span class="math inline">\(H + W - 1\)</span> 条如上面这样的副对角线的，所以我们一定要保证无论怎么穿过一条副对角线，其经过的红格子数量都是相同的。</p>
<p>所以直接做就行了，对于一条有红格子的副对角线，其对答案的贡献是 <span class="math inline">\(1\)</span>；对于一条全空的副对角线，其对答案的贡献为 <span class="math inline">\(2\)</span>（两种涂色方案）；对于既有蓝色又有红色的副对角线，其对答案的贡献为 <span class="math inline">\(0\)</span>。把这些贡献用乘法原理合并即可。</p>
<h4 id="arc120c---swaps-2">ARC120C - Swaps 2</h4>
<p>给定两个长度为 <span class="math inline">\(N\)</span> 的序列 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span>。问对 <span class="math inline">\(A\)</span> 进行有限次如下操作后能否使 <span class="math inline">\(A\)</span> 变成 <span class="math inline">\(B\)</span>：</p>
<ul>
<li>选择一个正整数 <span class="math inline">\(i\)</span> 使得 <span class="math inline">\(1\le i\lt N\)</span>
<ul>
<li>交换 <span class="math inline">\(A_i\)</span> 和 <span class="math inline">\(A_{i+ 1}\)</span> 的值</li>
<li>使 <span class="math inline">\(A_i\)</span> 加一</li>
<li>使 <span class="math inline">\(A_{i + 1}\)</span> 减一</li>
</ul></li>
</ul>
<p>如果能，问最少操作步数。</p>
<p>先考虑解的存在性。</p>
<p>我们观察一个数移动的情况：显然是往右走就减小，往左走就增大。设 <span class="math inline">\(A_i\)</span> 的新位置为 <span class="math inline">\(D_i\)</span>，则必然有： <span class="math display">\[
B_{D_i} = A_i + i - D_i
\]</span> 移项， <span class="math display">\[
B_{D_i} + D_i = A_i + i
\]</span> 发现两边的形式很像，所以我们只需要建立两个新序列 <span class="math inline">\(\{A_i + i\}\)</span> 和 <span class="math inline">\(\{B_i + i\}\)</span> 然后将其值排序判断其能不能一一对应就可以判断有没有解了。</p>
<p>然后考虑解的最优性。</p>
<p>刚才的排序中，若按照值为第一关键字排序，原下标为第二关键字排序，则我们不难证明，此时一一对应的结果是最优的。这样子 <span class="math inline">\(D_i\)</span> 就找到了。</p>
<p>然后我们把 <span class="math inline">\(A_i\)</span> 移到 <span class="math inline">\(A_{D_i}\)</span> 的过程很像冒泡排序，用线段树维护一下 <span class="math inline">\(A\)</span> 中元素的下标就可以做了。</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a aria-hidden="true" href="#cb18-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb18-2"><a aria-hidden="true" href="#cb18-2"></a><span class="pp">#include </span><span class="im">&lt;cctype&gt;</span></span>
<span id="cb18-3"><a aria-hidden="true" href="#cb18-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb18-4"><a aria-hidden="true" href="#cb18-4"></a><span class="pp">#define FOR</span>(i,<span class="pp"> </span>a,<span class="pp"> </span>b)<span class="pp"> </span><span class="cf">for</span><span class="pp"> </span>(<span class="dt">int</span><span class="pp"> </span>i<span class="pp"> </span>=<span class="pp"> </span>a;<span class="pp"> </span>i<span class="pp"> </span>&lt;=<span class="pp"> </span>b;<span class="pp"> </span>++i)</span>
<span id="cb18-5"><a aria-hidden="true" href="#cb18-5"></a><span class="pp">#define DEC</span>(i,<span class="pp"> </span>a,<span class="pp"> </span>b)<span class="pp"> </span><span class="cf">for</span><span class="pp"> </span>(<span class="dt">int</span><span class="pp"> </span>i<span class="pp"> </span>=<span class="pp"> </span>a;<span class="pp"> </span>i<span class="pp"> </span>&gt;=<span class="pp"> </span>b;<span class="pp"> </span>--i)</span>
<span id="cb18-6"><a aria-hidden="true" href="#cb18-6"></a><span class="pp">#define int </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb18-7"><a aria-hidden="true" href="#cb18-7"></a></span>
<span id="cb18-8"><a aria-hidden="true" href="#cb18-8"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">2e5</span> + <span class="dv">5</span>;</span>
<span id="cb18-9"><a aria-hidden="true" href="#cb18-9"></a></span>
<span id="cb18-10"><a aria-hidden="true" href="#cb18-10"></a><span class="dt">int</span> read()</span>
<span id="cb18-11"><a aria-hidden="true" href="#cb18-11"></a>{</span>
<span id="cb18-12"><a aria-hidden="true" href="#cb18-12"></a>    <span class="dt">int</span> s = <span class="dv">0</span>, x = <span class="dv">0</span>;</span>
<span id="cb18-13"><a aria-hidden="true" href="#cb18-13"></a>    <span class="dt">char</span> c = getchar();</span>
<span id="cb18-14"><a aria-hidden="true" href="#cb18-14"></a>    <span class="cf">while</span> (!isdigit(c))</span>
<span id="cb18-15"><a aria-hidden="true" href="#cb18-15"></a>        x |= (c == <span class="ch">'-'</span>), c = getchar();</span>
<span id="cb18-16"><a aria-hidden="true" href="#cb18-16"></a>    <span class="cf">while</span> (isdigit(c))</span>
<span id="cb18-17"><a aria-hidden="true" href="#cb18-17"></a>        s = s * <span class="dv">10</span> + c - <span class="ch">'0'</span>, c = getchar();</span>
<span id="cb18-18"><a aria-hidden="true" href="#cb18-18"></a>    <span class="cf">return</span> x ? -s : s;</span>
<span id="cb18-19"><a aria-hidden="true" href="#cb18-19"></a>}</span>
<span id="cb18-20"><a aria-hidden="true" href="#cb18-20"></a></span>
<span id="cb18-21"><a aria-hidden="true" href="#cb18-21"></a><span class="kw">struct</span> node</span>
<span id="cb18-22"><a aria-hidden="true" href="#cb18-22"></a>{</span>
<span id="cb18-23"><a aria-hidden="true" href="#cb18-23"></a>    <span class="dt">int</span> val, id;</span>
<span id="cb18-24"><a aria-hidden="true" href="#cb18-24"></a>    <span class="dt">bool</span> <span class="kw">operator</span>&lt;(<span class="at">const</span> node &amp;b)<span class="at">const</span></span>
<span id="cb18-25"><a aria-hidden="true" href="#cb18-25"></a>    {</span>
<span id="cb18-26"><a aria-hidden="true" href="#cb18-26"></a>        <span class="cf">return</span> val == b.val ? id &lt; b.id : val &lt; b.val;</span>
<span id="cb18-27"><a aria-hidden="true" href="#cb18-27"></a>    }</span>
<span id="cb18-28"><a aria-hidden="true" href="#cb18-28"></a>} ai[maxn], bi[maxn];</span>
<span id="cb18-29"><a aria-hidden="true" href="#cb18-29"></a></span>
<span id="cb18-30"><a aria-hidden="true" href="#cb18-30"></a><span class="dt">int</span> a[maxn], b[maxn], n;</span>
<span id="cb18-31"><a aria-hidden="true" href="#cb18-31"></a></span>
<span id="cb18-32"><a aria-hidden="true" href="#cb18-32"></a><span class="kw">inline</span> <span class="dt">int</span> myabs(<span class="dt">int</span> x)</span>
<span id="cb18-33"><a aria-hidden="true" href="#cb18-33"></a>{</span>
<span id="cb18-34"><a aria-hidden="true" href="#cb18-34"></a>    <span class="cf">return</span> x &gt;= <span class="dv">0</span> ? x : -x;</span>
<span id="cb18-35"><a aria-hidden="true" href="#cb18-35"></a>}</span>
<span id="cb18-36"><a aria-hidden="true" href="#cb18-36"></a></span>
<span id="cb18-37"><a aria-hidden="true" href="#cb18-37"></a><span class="dt">int</span> f[maxn &lt;&lt; <span class="dv">2</span>], tag[maxn &lt;&lt; <span class="dv">1</span>], d[maxn];</span>
<span id="cb18-38"><a aria-hidden="true" href="#cb18-38"></a></span>
<span id="cb18-39"><a aria-hidden="true" href="#cb18-39"></a><span class="pp">#define L </span>(k<span class="pp"> </span>&lt;&lt;<span class="pp"> </span><span class="dv">1</span>)</span>
<span id="cb18-40"><a aria-hidden="true" href="#cb18-40"></a><span class="pp">#define R </span>(L<span class="pp"> </span>|<span class="pp"> </span><span class="dv">1</span>)</span>
<span id="cb18-41"><a aria-hidden="true" href="#cb18-41"></a><span class="pp">#define M </span>((i<span class="pp"> </span>+<span class="pp"> </span>j)<span class="pp"> </span>&gt;&gt;<span class="pp"> </span><span class="dv">1</span>)</span>
<span id="cb18-42"><a aria-hidden="true" href="#cb18-42"></a></span>
<span id="cb18-43"><a aria-hidden="true" href="#cb18-43"></a><span class="dt">void</span> build(<span class="dt">int</span> i, <span class="dt">int</span> j, <span class="dt">int</span> k)</span>
<span id="cb18-44"><a aria-hidden="true" href="#cb18-44"></a>{</span>
<span id="cb18-45"><a aria-hidden="true" href="#cb18-45"></a>    <span class="cf">if</span> (i == j)</span>
<span id="cb18-46"><a aria-hidden="true" href="#cb18-46"></a>        <span class="cf">return</span> <span class="dt">void</span>(f[k] = i);</span>
<span id="cb18-47"><a aria-hidden="true" href="#cb18-47"></a>    build(i, M, L);</span>
<span id="cb18-48"><a aria-hidden="true" href="#cb18-48"></a>    build(M + <span class="dv">1</span>, j, R);</span>
<span id="cb18-49"><a aria-hidden="true" href="#cb18-49"></a>    f[k] = f[L] + f[R];</span>
<span id="cb18-50"><a aria-hidden="true" href="#cb18-50"></a>    <span class="cf">return</span>;</span>
<span id="cb18-51"><a aria-hidden="true" href="#cb18-51"></a>}</span>
<span id="cb18-52"><a aria-hidden="true" href="#cb18-52"></a></span>
<span id="cb18-53"><a aria-hidden="true" href="#cb18-53"></a><span class="dt">void</span> pushdown(<span class="dt">int</span> i, <span class="dt">int</span> j, <span class="dt">int</span> k)</span>
<span id="cb18-54"><a aria-hidden="true" href="#cb18-54"></a>{</span>
<span id="cb18-55"><a aria-hidden="true" href="#cb18-55"></a>    tag[L] += tag[k], tag[R] += tag[k];</span>
<span id="cb18-56"><a aria-hidden="true" href="#cb18-56"></a>    f[L] += (M - i + <span class="dv">1</span>) * tag[k];</span>
<span id="cb18-57"><a aria-hidden="true" href="#cb18-57"></a>    f[R] += (j - M) * tag[k];</span>
<span id="cb18-58"><a aria-hidden="true" href="#cb18-58"></a>    tag[k] = <span class="dv">0</span>;</span>
<span id="cb18-59"><a aria-hidden="true" href="#cb18-59"></a>    <span class="cf">return</span>;</span>
<span id="cb18-60"><a aria-hidden="true" href="#cb18-60"></a>}</span>
<span id="cb18-61"><a aria-hidden="true" href="#cb18-61"></a></span>
<span id="cb18-62"><a aria-hidden="true" href="#cb18-62"></a><span class="dt">void</span> modify(<span class="dt">int</span> i, <span class="dt">int</span> j, <span class="dt">int</span> k, <span class="dt">int</span> x, <span class="dt">int</span> y, <span class="dt">int</span> d)</span>
<span id="cb18-63"><a aria-hidden="true" href="#cb18-63"></a>{</span>
<span id="cb18-64"><a aria-hidden="true" href="#cb18-64"></a>    <span class="cf">if</span> (x &gt; y) <span class="cf">return</span>;</span>
<span id="cb18-65"><a aria-hidden="true" href="#cb18-65"></a>    <span class="cf">if</span> (i &gt;= x &amp;&amp; j &lt;= y)</span>
<span id="cb18-66"><a aria-hidden="true" href="#cb18-66"></a>    {</span>
<span id="cb18-67"><a aria-hidden="true" href="#cb18-67"></a>        f[k] += d * (j - i + <span class="dv">1</span>);</span>
<span id="cb18-68"><a aria-hidden="true" href="#cb18-68"></a>        tag[k] += d;</span>
<span id="cb18-69"><a aria-hidden="true" href="#cb18-69"></a>        <span class="cf">return</span>;</span>
<span id="cb18-70"><a aria-hidden="true" href="#cb18-70"></a>    }</span>
<span id="cb18-71"><a aria-hidden="true" href="#cb18-71"></a>    pushdown(i, j, k);</span>
<span id="cb18-72"><a aria-hidden="true" href="#cb18-72"></a>    <span class="cf">if</span> (x &lt;= M) modify(i, M, L, x, y, d);</span>
<span id="cb18-73"><a aria-hidden="true" href="#cb18-73"></a>    <span class="cf">if</span> (y &gt; M) modify(M + <span class="dv">1</span>, j, R, x, y, d);</span>
<span id="cb18-74"><a aria-hidden="true" href="#cb18-74"></a>    f[k] = f[L] + f[R];</span>
<span id="cb18-75"><a aria-hidden="true" href="#cb18-75"></a>    <span class="cf">return</span>;</span>
<span id="cb18-76"><a aria-hidden="true" href="#cb18-76"></a>}</span>
<span id="cb18-77"><a aria-hidden="true" href="#cb18-77"></a></span>
<span id="cb18-78"><a aria-hidden="true" href="#cb18-78"></a><span class="dt">int</span> query(<span class="dt">int</span> i, <span class="dt">int</span> j, <span class="dt">int</span> k, <span class="dt">int</span> x)</span>
<span id="cb18-79"><a aria-hidden="true" href="#cb18-79"></a>{</span>
<span id="cb18-80"><a aria-hidden="true" href="#cb18-80"></a>    <span class="cf">if</span> (i == j) <span class="cf">return</span> f[k];</span>
<span id="cb18-81"><a aria-hidden="true" href="#cb18-81"></a>    pushdown(i, j, k);</span>
<span id="cb18-82"><a aria-hidden="true" href="#cb18-82"></a>    <span class="cf">if</span> (x &lt;= M) <span class="cf">return</span> query(i, M, L, x);</span>
<span id="cb18-83"><a aria-hidden="true" href="#cb18-83"></a>    <span class="cf">else</span> <span class="cf">return</span> query(M + <span class="dv">1</span>, j, R, x);</span>
<span id="cb18-84"><a aria-hidden="true" href="#cb18-84"></a>}</span>
<span id="cb18-85"><a aria-hidden="true" href="#cb18-85"></a></span>
<span id="cb18-86"><a aria-hidden="true" href="#cb18-86"></a><span class="dt">signed</span> main()</span>
<span id="cb18-87"><a aria-hidden="true" href="#cb18-87"></a>{</span>
<span id="cb18-88"><a aria-hidden="true" href="#cb18-88"></a>    n = read();</span>
<span id="cb18-89"><a aria-hidden="true" href="#cb18-89"></a>    FOR(i, <span class="dv">1</span>, n) a[i] = read(), ai[i].val = a[i] + i, ai[i].id = i;</span>
<span id="cb18-90"><a aria-hidden="true" href="#cb18-90"></a>    FOR(i, <span class="dv">1</span>, n) b[i] = read(), bi[i].val = b[i] + i, bi[i].id = i;</span>
<span id="cb18-91"><a aria-hidden="true" href="#cb18-91"></a>    <span class="bu">std::</span>sort(ai + <span class="dv">1</span>, ai + n + <span class="dv">1</span>);</span>
<span id="cb18-92"><a aria-hidden="true" href="#cb18-92"></a>    <span class="bu">std::</span>sort(bi + <span class="dv">1</span>, bi + n + <span class="dv">1</span>);</span>
<span id="cb18-93"><a aria-hidden="true" href="#cb18-93"></a>    FOR(i, <span class="dv">1</span>, n)</span>
<span id="cb18-94"><a aria-hidden="true" href="#cb18-94"></a>        <span class="cf">if</span> (ai[i].val != bi[i].val) <span class="cf">return</span> printf(<span class="st">"-1</span><span class="sc">\n</span><span class="st">"</span>), <span class="dv">0</span>;</span>
<span id="cb18-95"><a aria-hidden="true" href="#cb18-95"></a>        <span class="cf">else</span> d[bi[i].id] = ai[i].id;</span>
<span id="cb18-96"><a aria-hidden="true" href="#cb18-96"></a>    build(<span class="dv">1</span>, n, <span class="dv">1</span>);</span>
<span id="cb18-97"><a aria-hidden="true" href="#cb18-97"></a>    <span class="dt">int</span> ans = <span class="dv">0</span>;</span>
<span id="cb18-98"><a aria-hidden="true" href="#cb18-98"></a>    FOR(i, <span class="dv">1</span>, n)</span>
<span id="cb18-99"><a aria-hidden="true" href="#cb18-99"></a>    {</span>
<span id="cb18-100"><a aria-hidden="true" href="#cb18-100"></a>        ans += abs(query(<span class="dv">1</span>, n, <span class="dv">1</span>, d[i]) - i);</span>
<span id="cb18-101"><a aria-hidden="true" href="#cb18-101"></a>        modify(<span class="dv">1</span>, n, <span class="dv">1</span>, <span class="dv">1</span>, d[i], <span class="dv">1</span>);</span>
<span id="cb18-102"><a aria-hidden="true" href="#cb18-102"></a>    }</span>
<span id="cb18-103"><a aria-hidden="true" href="#cb18-103"></a>    printf(<span class="st">"</span><span class="sc">%lld\n</span><span class="st">"</span>, ans);</span>
<span id="cb18-104"><a aria-hidden="true" href="#cb18-104"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb18-105"><a aria-hidden="true" href="#cb18-105"></a>}</span></code></pre></div>
<h4 id="arc120d---bracket-score-2">ARC120D - Bracket Score 2</h4>
<p>给定一个长度为 <span class="math inline">\(2N\)</span> 的整数序列 <span class="math inline">\(A_i\)</span>，依照其构造一个长度为 <span class="math inline">\(2N\)</span> 的合法括号序列，使得其分数最大，分数的计算方式：</p>
<ul>
<li>对于每一对匹配的括号 <span class="math inline">\(S_i\)</span> 和 <span class="math inline">\(S_j\)</span>，其贡献为 <span class="math inline">\(|A_j - A_i|\)</span></li>
<li>将每一对匹配的括号的分数加起来得到总分</li>
</ul>
<p>眼前一亮的构造。</p>
<p>不难发现，让大的尽量大，小的尽量小就可以使得总分最大。因此选出最大的 <span class="math inline">\(N\)</span> 个 <span class="math inline">\(A_i\)</span>，标记为黑色，剩余的标记为白色。然后根据一黑一白配对的原则直接构造括号序列即可。</p>
<h3 id="arc123">ARC123</h3>
<p>A + B + C</p>
<h4 id="arc123b---increasing-triples">ARC123<strong>B - Increasing Triples</strong></h4>
<p><span class="math inline">\(3\)</span> 个 <span class="math inline">\(10^5\)</span> 级别的序列，可以任意排列，问最多能有多少 <span class="math inline">\(i\)</span> 满足 <span class="math inline">\(A_i &lt; B_i &lt; C_i\)</span>。</p>
<p>用堆实现的贪心。</p>
<h4 id="arc123c---1-2-3---decomposition">ARC123C - 1, 2, 3 - Decomposition</h4>
<p>给定 <span class="math inline">\(n\)</span>，需要求出最小的 <span class="math inline">\(k\)</span> 使得存在长度为 <span class="math inline">\(k\)</span> 的序列 <span class="math inline">\(\{A_i\}\)</span> 满足 <span class="math inline">\(\sum A_i = n\)</span> 且 <span class="math inline">\(A_i\)</span> 的每个数位都为 <span class="math inline">\(1\)</span>，<span class="math inline">\(2\)</span> 或 <span class="math inline">\(3\)</span> 之一。</p>
<p><span class="math inline">\(T\)</span> （<span class="math inline">\(1000\)</span>）组数据，<span class="math inline">\(n\le 10^{18}\)</span>。</p>
<p>考虑数位 dp。</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a aria-hidden="true" href="#cb19-1"></a><span class="dt">int</span> solve() {</span>
<span id="cb19-2"><a aria-hidden="true" href="#cb19-2"></a>    <span class="at">static</span> <span class="dt">int</span> f[<span class="dv">20</span>][<span class="dv">25</span>][<span class="dv">25</span>];</span>
<span id="cb19-3"><a aria-hidden="true" href="#cb19-3"></a>    memset(f, <span class="dv">0</span>, <span class="kw">sizeof</span> f);</span>
<span id="cb19-4"><a aria-hidden="true" href="#cb19-4"></a>    f[<span class="dv">1</span>][a[<span class="dv">1</span>] - <span class="ch">'0'</span>][<span class="dv">0</span>] = <span class="dv">1</span>;</span>
<span id="cb19-5"><a aria-hidden="true" href="#cb19-5"></a>    <span class="dt">int</span> n = strlen(a + <span class="dv">1</span>);</span>
<span id="cb19-6"><a aria-hidden="true" href="#cb19-6"></a>    FOR(i, <span class="dv">1</span>, n - <span class="dv">1</span>) {</span>
<span id="cb19-7"><a aria-hidden="true" href="#cb19-7"></a>        FOR(j, <span class="dv">1</span>, <span class="dv">20</span>) {</span>
<span id="cb19-8"><a aria-hidden="true" href="#cb19-8"></a>            FOR(k, <span class="dv">0</span>, <span class="dv">20</span>) {</span>
<span id="cb19-9"><a aria-hidden="true" href="#cb19-9"></a>                <span class="cf">if</span> (f[i][j][k]) {</span>
<span id="cb19-10"><a aria-hidden="true" href="#cb19-10"></a>                    FOR(l, max((j + <span class="dv">2</span>) / <span class="dv">3</span>, k), min(j, a[i + <span class="dv">1</span>] - <span class="ch">'0'</span>))</span>
<span id="cb19-11"><a aria-hidden="true" href="#cb19-11"></a>                        f[i + <span class="dv">1</span>][a[i + <span class="dv">1</span>] - <span class="ch">'0'</span>][l] = <span class="dv">1</span>;</span>
<span id="cb19-12"><a aria-hidden="true" href="#cb19-12"></a>                    FOR(l, max((j + <span class="dv">1</span>) / <span class="dv">3</span>, k), min(j - <span class="dv">1</span>, a[i + <span class="dv">1</span>] - <span class="ch">'0'</span> + <span class="dv">10</span>))</span>
<span id="cb19-13"><a aria-hidden="true" href="#cb19-13"></a>                        f[i + <span class="dv">1</span>][a[i + <span class="dv">1</span>] - <span class="ch">'0'</span> + <span class="dv">10</span>][l] = <span class="dv">1</span>;</span>
<span id="cb19-14"><a aria-hidden="true" href="#cb19-14"></a>                }</span>
<span id="cb19-15"><a aria-hidden="true" href="#cb19-15"></a>            }</span>
<span id="cb19-16"><a aria-hidden="true" href="#cb19-16"></a>        }</span>
<span id="cb19-17"><a aria-hidden="true" href="#cb19-17"></a>    }</span>
<span id="cb19-18"><a aria-hidden="true" href="#cb19-18"></a>    <span class="dt">int</span> ans = <span class="fl">1e9</span>;</span>
<span id="cb19-19"><a aria-hidden="true" href="#cb19-19"></a>    FOR(i, <span class="dv">1</span>, <span class="dv">20</span>)</span>
<span id="cb19-20"><a aria-hidden="true" href="#cb19-20"></a>        FOR(j, <span class="dv">0</span>, <span class="dv">20</span>)</span>
<span id="cb19-21"><a aria-hidden="true" href="#cb19-21"></a>            <span class="cf">if</span> (f[n][i][j])</span>
<span id="cb19-22"><a aria-hidden="true" href="#cb19-22"></a>                ans = min(ans, max((i + <span class="dv">2</span>) / <span class="dv">3</span>, j));</span>
<span id="cb19-23"><a aria-hidden="true" href="#cb19-23"></a>    <span class="cf">return</span> ans;</span>
<span id="cb19-24"><a aria-hidden="true" href="#cb19-24"></a>}</span></code></pre></div>
<h3 id="arc124">ARC124</h3>
<p>状态很差 A + B</p>
<h3 id="arc125">ARC125</h3>
<p>A + B + C</p>
<h4 id="arc125a---dial-up">ARC125A - Dial Up</h4>
<p>直接贪心即可，细节略多。</p>
<h4 id="arc125b---squares">ARC125B - Squares</h4>
<p>求有序数对 <span class="math inline">\((x, y)\)</span> 其中</p>
<ul>
<li><span class="math inline">\(1\le x, y\le n\)</span>（<span class="math inline">\(n\le 10^{12}\)</span>）</li>
<li><span class="math inline">\(x^2 - y\)</span> 为完全平方数</li>
</ul>
<p>的数量模 <span class="math inline">\(998244353\)</span> 的值。</p>
<p>考虑令 <span class="math inline">\(x^2 - y = z^2\)</span>，然后平方差怼过去就是 <span class="math inline">\((x + z)(x - z) = y\)</span>。令 <span class="math inline">\(x + z = p\)</span>，<span class="math inline">\(x - z = q\)</span>。则问题化为求 <span class="math inline">\((p, q)\)</span> 的数量：</p>
<ul>
<li><span class="math inline">\(p\ge q\)</span>；</li>
<li><span class="math inline">\(x = \dfrac{p + q}{2}\)</span> 为整数；</li>
<li><span class="math inline">\(1\le x = \dfrac{p + q}{2}\le n\)</span>；</li>
<li><span class="math inline">\(1 \le y = pq\le n\)</span>；</li>
</ul>
<p>考虑 <span class="math inline">\(O(\sqrt n)\)</span> 枚举 <span class="math inline">\(q\)</span>，然后 <span class="math inline">\(p\)</span> 要满足 <span class="math inline">\(q\le p\le n\)</span> 且 <span class="math inline">\(p\equiv q\pmod 2\)</span>。这个东西可以 <span class="math inline">\(O(1)\)</span> 算。于是总复杂度 <span class="math inline">\(O(\sqrt n)\)</span>。</p>
<h4 id="arc125c---lis-to-original-sequence">ARC125C - LIS to Original Sequence</h4>
<p>构造题。</p>
<p>给定 <span class="math inline">\(k\)</span> 个单调增整数 <span class="math inline">\(\{a_1, \cdots, a_k\}\)</span>，构造字典序最小的排列 <span class="math inline">\(\{p_1, \cdots, p_n\}\)</span> 使得 <span class="math inline">\(\{a_i\}\)</span> 为 <span class="math inline">\(\{p_i\}\)</span> 的 LIS 之一。</p>
<p>考虑子问题。</p>
<p><span class="math inline">\(k = 1\)</span> 时，答案显然为 <span class="math inline">\(\{n, n - 1, n - 2, \cdots, 1\}\)</span>。</p>
<p><span class="math inline">\(k \ge 2\)</span> 时，考虑到 LIS 的性质，<span class="math inline">\(p_1 = a_1\)</span>，然后如果 <span class="math inline">\(p_1\not= 1\)</span>，为了使得字典序最小且不破坏最长 LIS 的性质，<span class="math inline">\(p_2 = 1\)</span>。然后就可以依次类推下去推导。</p>
<p>结论是，对于 <span class="math inline">\(1\le i\le k - 1\)</span>，可以在 <span class="math inline">\(a_i\)</span> 和 <span class="math inline">\(a_{i + 1}\)</span> 中插入至多一个 <span class="math inline">\(x\)</span> 满足 <span class="math inline">\(x &lt; a_i\)</span> 且 <span class="math inline">\(x &lt; a_{i + 1}\)</span>。最后的所有元素降序排列即可。</p>
<h4 id="arc125d---unique-subsequence">ARC125D - Unique Subsequence</h4>
<p>给定 <span class="math inline">\(\{a_1, \cdots, a_n\}\)</span>，问出现次数为 <span class="math inline">\(1\)</span> 的子序列的数量。</p>
<p>考虑 <span class="math inline">\(a_0 = 0\)</span>，<span class="math inline">\(a_{n + 1} = n + 1\)</span>，然后设计一个 dp 状态 <span class="math inline">\(f_i\)</span> 表示 <span class="math inline">\(\{a_0, \cdots, a_i\}\)</span> 且 <span class="math inline">\(a_i\)</span> 强制选的答案，则最终答案为所有数字最后出现位置的 <span class="math inline">\(f\)</span> 之和。</p>
<p>注意到我们一定不能让 <span class="math inline">\(a_i\)</span> 上一个出现的位置 <span class="math inline">\(lst_i\)</span> 前的 <span class="math inline">\(f\)</span> 对 <span class="math inline">\(f_i\)</span> 产生贡献，否则选取子序列的方式就不唯一了。然后一定要保证是最后一个出现的数产生贡献，所以用一个 BIT 维护就行了。</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a aria-hidden="true" href="#cb20-1"></a><span class="dt">int</span> main() {</span>
<span id="cb20-2"><a aria-hidden="true" href="#cb20-2"></a>    read(n);</span>
<span id="cb20-3"><a aria-hidden="true" href="#cb20-3"></a>    FOR(i, <span class="dv">1</span>, n) read(a[i]);</span>
<span id="cb20-4"><a aria-hidden="true" href="#cb20-4"></a>    FOR(i, <span class="dv">1</span>, n) {</span>
<span id="cb20-5"><a aria-hidden="true" href="#cb20-5"></a>        last[i] = now[a[i]];</span>
<span id="cb20-6"><a aria-hidden="true" href="#cb20-6"></a>        now[a[i]] = i;</span>
<span id="cb20-7"><a aria-hidden="true" href="#cb20-7"></a>    }</span>
<span id="cb20-8"><a aria-hidden="true" href="#cb20-8"></a>    add(<span class="dv">0</span>, <span class="dv">1</span>);</span>
<span id="cb20-9"><a aria-hidden="true" href="#cb20-9"></a>    FOR(i, <span class="dv">1</span>, n) {</span>
<span id="cb20-10"><a aria-hidden="true" href="#cb20-10"></a>        f[i] = sum(i - <span class="dv">1</span>) - sum(last[i] - <span class="dv">1</span>);</span>
<span id="cb20-11"><a aria-hidden="true" href="#cb20-11"></a>        add(last[i], -f[last[i]]);</span>
<span id="cb20-12"><a aria-hidden="true" href="#cb20-12"></a>        add(i, f[i]);</span>
<span id="cb20-13"><a aria-hidden="true" href="#cb20-13"></a>    }</span>
<span id="cb20-14"><a aria-hidden="true" href="#cb20-14"></a>    modint ans = <span class="dv">0</span>;</span>
<span id="cb20-15"><a aria-hidden="true" href="#cb20-15"></a>    FOR(i, <span class="dv">1</span>, n)</span>
<span id="cb20-16"><a aria-hidden="true" href="#cb20-16"></a>        <span class="cf">if</span> (now[i])</span>
<span id="cb20-17"><a aria-hidden="true" href="#cb20-17"></a>            ans += f[now[i]];</span>
<span id="cb20-18"><a aria-hidden="true" href="#cb20-18"></a>    print(ans);</span>
<span id="cb20-19"><a aria-hidden="true" href="#cb20-19"></a>    <span class="cf">return</span> output(), <span class="dv">0</span>;</span>
<span id="cb20-20"><a aria-hidden="true" href="#cb20-20"></a>}</span></code></pre></div>
<h3 id="arc126">ARC126</h3>
<p>状态差。A + B。</p>
<h4 id="arc126c---maximize-gcd">ARC126C - Maximize GCD</h4>
<p>给定一个正整数序列 <span class="math inline">\((A_1, \cdots, A_n)\)</span>，每次操作可以选择一个 <span class="math inline">\(A_i\)</span> 然后 <span class="math inline">\(A_i\gets A_i + 1\)</span>，问最多 <span class="math inline">\(k\)</span> 次操作之后能达到的最大的 <span class="math inline">\(\gcd_i\{A_i\}\)</span>。<span class="math inline">\(1\le A_i, n\le 3\times 10^5\)</span>，<span class="math inline">\(1\le k\le 10^{18}\)</span>。</p>
<p>考虑从 <span class="math inline">\([1, A_{\max}]\)</span> 先枚举这个 <span class="math inline">\(\gcd\{A_i\}\)</span>，那么我们要做的就是计算对于每个 <span class="math inline">\(A_i\)</span> 要进行多少次操作。</p>
<p>不妨设当前这个 <span class="math inline">\(\gcd\)</span> 为 <span class="math inline">\(x\)</span>，则我们枚举 <span class="math inline">\(k\)</span>，对于 <span class="math inline">\((k - 1)x &lt; A_i \le kx\)</span> 的 <span class="math inline">\(A_i\)</span>，这个代价是很好算的，随便前缀和优化一下就可以了。所以对于一个 <span class="math inline">\(x\)</span>，计算其操作次数的时间复杂度为 <span class="math inline">\(O(A_{\max} / x)\)</span>。</p>
<p>如果到了最后每个数都变成 <span class="math inline">\(A_{\max}\)</span> 了，还有剩余的操作次数，则考虑继续往上走 <span class="math inline">\(\lfloor k / n\rfloor\)</span> 个。总时间复杂度为 <span class="math inline">\(O(n + A_{\max}\ln A_{\max})\)</span>。</p>
<h3 id="arc128">ARC128</h3>
<p>A + B + C，rk 340。</p>
<h4 id="arc128c---max-dot">ARC128C - Max Dot</h4>
<p><span class="math display">\[
\begin{aligned}
\text{maximize } \sum_{i = 1}^nA_ix_i\\
\text{s.t. } \begin{cases}
0\le x_1\le x_2\\
0\le x_2\le x_3\\
\cdots\\
0\le x_n\le m\\
x_1 + x_2 + \cdots x_n = S
\end{cases}
\end{aligned}
\]</span></p>
<p>考虑线性规划的解一定在可行域的端点处取到。所以前几个取 <span class="math inline">\(0\)</span>，后几个取 <span class="math inline">\(m\)</span>，中间几个取平均数。枚举前后缀端点即可。<span class="math inline">\(O(n^2)\)</span>。</p>
<h3 id="arc131">ARC131</h3>
<p>A + B + C + E，rk220。</p>
<h4 id="arc131b---grid-repainting-4">ARC131B - Grid Repainting 4</h4>
<p>由四色定理知直接构造即可。</p>
<h4 id="arc131c---zero-xor">ARC131C - Zero XOR</h4>
<p>牛逼题。给定一数集，两人博弈，一步可以删除一个数字。删到剩下数集的异或和为 <span class="math inline">\(0\)</span> 时获胜。两人都最优方案，问先手是否必胜。</p>
<p>结论：所有数字异或和 <span class="math inline">\(x\)</span> 若 <span class="math inline">\(\in S\)</span>，则先手必胜，否则若 <span class="math inline">\(n \equiv 1\pmod 2\)</span>，先手必胜，否则后手必胜。</p>
<p><span class="math inline">\(x\in S\)</span> 的情况非常好理解，先手只需要取出 <span class="math inline">\(S\)</span> 即可。</p>
<p>否则，游戏将在两人取完所有数字之后结束。最后一个取的人将为赢家。</p>
<h4 id="arc131e---christmas-wreath">ARC131E - Christmas Wreath</h4>
<p>题意：给完全图的边染色 <span class="math inline">\((R,B,W)\)</span>，要求三种颜色出现的频率相等，且任意一个三元环不能出现三边颜色不一样，求构造方案或输出无解。</p>
<p>考虑邻接矩阵，发现每一行颜色相同就能满足第二个条件。</p>
<p>第一个条件就随便构造即可。</p>
<h3 id="arc132">ARC132</h3>
<h4 id="arc132a---permutation-grid">ARC132A - Permutation Grid</h4>
<p>比较妙的思路。考虑初始构造出一个状态然后根据排列变换。结论为 <span class="math inline">\(R_x +C_y\ge n\)</span>。</p>
<h4 id="arc132b---shift-and-reverse">ARC132B - Shift and Reverse</h4>
<p>可以注意到翻转操作至多进行两次。</p>
<p>直接分类讨论然后做做就行了。</p>
<h4 id="arc132c---almost-sorted">ARC132C - Almost Sorted</h4>
<p>比较好的状压题。</p>
<p>给定一个序列 <span class="math inline">\(a_i\)</span>，<span class="math inline">\(a_i\in\{-1, 1, 2, 3,\cdots, n\}\)</span>，和一个整数 <span class="math inline">\(d\)</span>。问满足如下条件的排列 <span class="math inline">\(p_i\)</span> 的个数模 <span class="math inline">\(998244353\)</span>。</p>
<ul>
<li><span class="math inline">\(p_1,\cdots,p_n\)</span> 为 <span class="math inline">\([1,n]\)</span> 排列。</li>
<li>若 <span class="math inline">\(a_i\ne -1\)</span>，则 <span class="math inline">\(p_i = a_i\)</span>。</li>
<li><span class="math inline">\(\forall i\)</span>，满足 <span class="math inline">\(|p_i - i|\le d\)</span>。</li>
</ul>
<p><span class="math inline">\(1\le d\le 5\)</span>，<span class="math inline">\(d &lt; n\le 500\)</span>。</p>
<p>首先我们注意到，<span class="math inline">\(p_i\in[i - d, i + d]\)</span>，值域区间长度最大为 <span class="math inline">\(11\)</span>，所以可以考虑状压起来。我们令 <span class="math inline">\(f_{i, S}\)</span> 表示 <span class="math inline">\([i - d, i + d]\)</span> 的值域区间的占用情况为 <span class="math inline">\(S\)</span> 的方案数。</p>
<p>然后我们就可以进行转移了，每次就枚举第 <span class="math inline">\(i\)</span> 格填的数，细节比较多，参见如下代码。时间复杂度为 <span class="math inline">\(O(4^ddn)\)</span>，可以通过本题。</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a aria-hidden="true" href="#cb21-1"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="dv">505</span>;</span>
<span id="cb21-2"><a aria-hidden="true" href="#cb21-2"></a><span class="dt">int</span> a[maxn], n, d, vis[maxn];</span>
<span id="cb21-3"><a aria-hidden="true" href="#cb21-3"></a>modint f[maxn][<span class="dv">1</span> &lt;&lt; <span class="dv">12</span>];</span>
<span id="cb21-4"><a aria-hidden="true" href="#cb21-4"></a></span>
<span id="cb21-5"><a aria-hidden="true" href="#cb21-5"></a><span class="dt">int</span> getfirst() {</span>
<span id="cb21-6"><a aria-hidden="true" href="#cb21-6"></a>    <span class="dt">int</span> ans = <span class="dv">0</span>;</span>
<span id="cb21-7"><a aria-hidden="true" href="#cb21-7"></a>    FOR(i, <span class="dv">1</span>, d) {</span>
<span id="cb21-8"><a aria-hidden="true" href="#cb21-8"></a>        ans |= (<span class="dv">1</span> &lt;&lt; (i + d)) * vis[i];</span>
<span id="cb21-9"><a aria-hidden="true" href="#cb21-9"></a>    }</span>
<span id="cb21-10"><a aria-hidden="true" href="#cb21-10"></a>    <span class="cf">return</span> ans;</span>
<span id="cb21-11"><a aria-hidden="true" href="#cb21-11"></a>}</span>
<span id="cb21-12"><a aria-hidden="true" href="#cb21-12"></a></span>
<span id="cb21-13"><a aria-hidden="true" href="#cb21-13"></a><span class="dt">int</span> main() {</span>
<span id="cb21-14"><a aria-hidden="true" href="#cb21-14"></a>    read(n, d);</span>
<span id="cb21-15"><a aria-hidden="true" href="#cb21-15"></a>    FOR(i, <span class="dv">1</span>, n) read(a[i]);</span>
<span id="cb21-16"><a aria-hidden="true" href="#cb21-16"></a>    FOR(j, <span class="dv">1</span>, n) FOR(i, <span class="dv">1</span>, n) <span class="cf">if</span> (a[i] == j) vis[j] = <span class="dv">1</span>;</span>
<span id="cb21-17"><a aria-hidden="true" href="#cb21-17"></a>    f[<span class="dv">0</span>][getfirst()] = <span class="dv">1</span>;</span>
<span id="cb21-18"><a aria-hidden="true" href="#cb21-18"></a>    FOR(i, <span class="dv">1</span>, n) {</span>
<span id="cb21-19"><a aria-hidden="true" href="#cb21-19"></a>        FOR(S, <span class="dv">0</span>, (<span class="dv">1</span> &lt;&lt; (<span class="dv">2</span> * d + <span class="dv">1</span>)) - <span class="dv">1</span>) {</span>
<span id="cb21-20"><a aria-hidden="true" href="#cb21-20"></a>            <span class="dt">int</span> now = (S &gt;&gt; <span class="dv">1</span>) | (vis[i + d] &lt;&lt; (<span class="dv">2</span> * d));</span>
<span id="cb21-21"><a aria-hidden="true" href="#cb21-21"></a>            <span class="cf">if</span> (~a[i]) f[i][now] += f[i - <span class="dv">1</span>][S];</span>
<span id="cb21-22"><a aria-hidden="true" href="#cb21-22"></a>            <span class="cf">else</span> FOR(j, -d, d) {</span>
<span id="cb21-23"><a aria-hidden="true" href="#cb21-23"></a>                <span class="cf">if</span> (i + j &lt; <span class="dv">1</span> || i + j &gt; n || now &amp; (<span class="dv">1</span> &lt;&lt; (j + d))) <span class="cf">continue</span>;</span>
<span id="cb21-24"><a aria-hidden="true" href="#cb21-24"></a>                f[i][now | (<span class="dv">1</span> &lt;&lt; (j + d))] += f[i - <span class="dv">1</span>][S];</span>
<span id="cb21-25"><a aria-hidden="true" href="#cb21-25"></a>            }</span>
<span id="cb21-26"><a aria-hidden="true" href="#cb21-26"></a>        }</span>
<span id="cb21-27"><a aria-hidden="true" href="#cb21-27"></a>    }</span>
<span id="cb21-28"><a aria-hidden="true" href="#cb21-28"></a>    print(f[n][(<span class="dv">1</span> &lt;&lt; (d + <span class="dv">1</span>)) - <span class="dv">1</span>]);</span>
<span id="cb21-29"><a aria-hidden="true" href="#cb21-29"></a>    <span class="cf">return</span> output(), <span class="dv">0</span>;</span>
<span id="cb21-30"><a aria-hidden="true" href="#cb21-30"></a>}</span></code></pre></div>
<h4 id="arc132d---between-two-binary-strings">ARC132D - Between Two Binary Strings</h4>
<p>设 <span class="math inline">\(S_{n,m}\)</span> 为所有的长度为 <span class="math inline">\(n+ m\)</span>，且包含恰好 <span class="math inline">\(n\)</span> 个 <code>0</code> 和 <span class="math inline">\(m\)</span> 个 <code>1</code> 的字符串的集合。定义一个字符串的美丽程度为相邻两位相同的个数，定义 <span class="math inline">\(S_1\)</span> 与 <span class="math inline">\(S_2\)</span> 的编辑距离 <span class="math inline">\(d_{S_1, S_2}\)</span> 为将 <span class="math inline">\(S_1\)</span> 变成 <span class="math inline">\(S_2\)</span> 的操作次数，其中每次操作能交换相邻的两个字符，且 <span class="math inline">\(S_1, S_2\in S_{n,m}\)</span>。</p>
<p>定义 <span class="math inline">\(S_2\)</span> 在 <span class="math inline">\(S_1\)</span> 与 <span class="math inline">\(S_3\)</span> 间当且仅当 <span class="math inline">\(d_{S_1, S_3} = d_{S_1, S_2} + d_{S_2, S_3}\)</span>。给定 <span class="math inline">\(S\)</span> 和 <span class="math inline">\(T\)</span>，问在 <span class="math inline">\(S\)</span> 与 <span class="math inline">\(T\)</span> 间的字符串的最大美丽程度。</p>
<p>这题是一道比较妙的结论题：当确定第一个字母时，整个字符串可以贪心的进行构造，只需保证<strong>前 <span class="math inline">\(x\)</span> 个里面 <code>1</code> 的个数处于 <span class="math inline">\(S\)</span> 和 <span class="math inline">\(T\)</span> 的中间</strong>。然后我们又要最大化美丽值，依此构造即可。</p>
<p>证明：考虑一个字符串就是二维平面上一条从 <span class="math inline">\((0, 0)\)</span> 走到 <span class="math inline">\((n, m)\)</span> 的路径。某一位是 <code>1</code> 表示向上走一格，某一位是 <code>0</code> 表示向右走一格。同时，一个字符串的美丽值就是长度减一再减拐点个数。</p>
<p>而我们发现，交换两个相邻的 <code>01</code> 相当于是将一个拐点翻折，故在平面上处于 <span class="math inline">\(S\)</span> 和 <span class="math inline">\(T\)</span> 中间的路径都是可行的。那么我们其实就是，能不拐就不拐。</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a aria-hidden="true" href="#cb22-1"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">3e5</span> + <span class="dv">5</span>;</span>
<span id="cb22-2"><a aria-hidden="true" href="#cb22-2"></a><span class="dt">char</span> s[maxn], t[maxn];</span>
<span id="cb22-3"><a aria-hidden="true" href="#cb22-3"></a><span class="dt">int</span> n, m;</span>
<span id="cb22-4"><a aria-hidden="true" href="#cb22-4"></a></span>
<span id="cb22-5"><a aria-hidden="true" href="#cb22-5"></a><span class="dt">int</span> main() {</span>
<span id="cb22-6"><a aria-hidden="true" href="#cb22-6"></a>    read(n, m);</span>
<span id="cb22-7"><a aria-hidden="true" href="#cb22-7"></a>    read(s + <span class="dv">1</span>), read(t + <span class="dv">1</span>);</span>
<span id="cb22-8"><a aria-hidden="true" href="#cb22-8"></a>    <span class="dt">int</span> ans = <span class="dv">0</span>, len = n + m;</span>
<span id="cb22-9"><a aria-hidden="true" href="#cb22-9"></a>    FOR(init, <span class="dv">0</span>, <span class="dv">1</span>) {</span>
<span id="cb22-10"><a aria-hidden="true" href="#cb22-10"></a>        <span class="dt">int</span> s0 = <span class="dv">0</span>, t0 = <span class="dv">0</span>, x0 = <span class="dv">0</span>;</span>
<span id="cb22-11"><a aria-hidden="true" href="#cb22-11"></a>        <span class="cf">if</span> (init != s[<span class="dv">1</span>] - <span class="ch">'0'</span> &amp;&amp; init != t[<span class="dv">1</span>] - <span class="ch">'0'</span>) <span class="cf">continue</span>;</span>
<span id="cb22-12"><a aria-hidden="true" href="#cb22-12"></a>        <span class="dt">int</span> cnt = <span class="dv">0</span>;</span>
<span id="cb22-13"><a aria-hidden="true" href="#cb22-13"></a>        <span class="dt">int</span> now = init;</span>
<span id="cb22-14"><a aria-hidden="true" href="#cb22-14"></a>        FOR(i, <span class="dv">1</span>, len) {</span>
<span id="cb22-15"><a aria-hidden="true" href="#cb22-15"></a>            s0 += (s[i] == <span class="ch">'0'</span>), t0 += (t[i] == <span class="ch">'0'</span>);</span>
<span id="cb22-16"><a aria-hidden="true" href="#cb22-16"></a>            <span class="cf">if</span> (now == <span class="dv">0</span>) {</span>
<span id="cb22-17"><a aria-hidden="true" href="#cb22-17"></a>                <span class="cf">if</span> (x0 + <span class="dv">1</span> &lt;= max(s0, t0)) ++cnt;</span>
<span id="cb22-18"><a aria-hidden="true" href="#cb22-18"></a>                <span class="cf">else</span> now = <span class="dv">1</span>;</span>
<span id="cb22-19"><a aria-hidden="true" href="#cb22-19"></a>            } <span class="cf">else</span> {</span>
<span id="cb22-20"><a aria-hidden="true" href="#cb22-20"></a>                <span class="cf">if</span> (x0 &gt;= min(s0, t0)) ++cnt;</span>
<span id="cb22-21"><a aria-hidden="true" href="#cb22-21"></a>                <span class="cf">else</span> now = <span class="dv">0</span>;</span>
<span id="cb22-22"><a aria-hidden="true" href="#cb22-22"></a>            }</span>
<span id="cb22-23"><a aria-hidden="true" href="#cb22-23"></a>            <span class="cf">if</span> (now == <span class="dv">0</span>) ++x0;</span>
<span id="cb22-24"><a aria-hidden="true" href="#cb22-24"></a>        }</span>
<span id="cb22-25"><a aria-hidden="true" href="#cb22-25"></a>        chkmax(ans, cnt - <span class="dv">1</span>);</span>
<span id="cb22-26"><a aria-hidden="true" href="#cb22-26"></a>    }</span>
<span id="cb22-27"><a aria-hidden="true" href="#cb22-27"></a>    print(ans);</span>
<span id="cb22-28"><a aria-hidden="true" href="#cb22-28"></a>    <span class="cf">return</span> output(), <span class="dv">0</span>;</span>
<span id="cb22-29"><a aria-hidden="true" href="#cb22-29"></a>}</span></code></pre></div>
<h3 id="arc134">ARC134</h3>
<h4 id="arc134c---the-majority">ARC134C - The Majority</h4>
<p><span class="math inline">\(K\)</span> 个有标号盒子，初始全为空。有 <span class="math inline">\(N\)</span> 种颜色的球，第 <span class="math inline">\(i\)</span> 种颜色有 <span class="math inline">\(a_i\)</span> 个球，同种颜色的球不区分。现要将所有球放入盒子里，要求每个盒子里面，颜色 <span class="math inline">\(1\)</span> 的球的个数要占到一半以上（严格）。问方案数。</p>
<p>比较巧妙的计数套路（雾），即我们考虑将 <span class="math inline">\(1\)</span> 颜色的球和其他的球一一配对，即将 <span class="math inline">\(a_1:=a_1 - \sum_{i = 2}^na_i\)</span>，然后将 <span class="math inline">\([2, n]\)</span> 颜色的球放入 <span class="math inline">\(K\)</span> 个盒子里（可以有空盒），求出方案数，然后再乘上将 <span class="math inline">\(1\)</span> 颜色的球放入 <span class="math inline">\(K\)</span> 个盒子的方案数（不允许有空盒），即 <span class="math display">\[
\binom{a_1 - \sum_{i = 2}^na_i}{K + 1}\prod_{i=2}^n\binom{a_i + K + 1}{K+1}
\]</span> 正确性显然，思想较为重要，marked。</p>
<h4 id="arc134d---concatenate-subsequences">ARC134D - Concatenate Subsequences</h4>
<p>给定长度为 <span class="math inline">\(2N\)</span> 的正整数序列 <span class="math inline">\(a\)</span>。现要构造 <span class="math inline">\(a\)</span> 的一个子序列，方案为：从 <span class="math inline">\(1, 2, \cdots, N\)</span> 中取出一个子序列 <span class="math inline">\(x_1, \cdots, x_k\)</span>，然后取出 <span class="math inline">\(a_{x_1}, a_{x_2},\cdots, a_{x_k}, a_{x_1 + N}, a_{x_2 +N},\cdots, a_{x_k + N}\)</span>。要求构造出来的这个序列字典序最小，输出这个序列。</p>
<p>字典序问题一般考虑贪心。我们令 <span class="math inline">\(A = a_1, a_2, \cdots, a_N\)</span>，<span class="math inline">\(B = a_{N+ 1},\cdots, a_{2N}\)</span>，取 <span class="math inline">\(A\)</span> 中的最小值为 <span class="math inline">\(X\)</span>。</p>
<p>则如果存在一个 <span class="math inline">\(A_i\)</span> 使得 <span class="math inline">\(A_i = X\land B_i\le A_i\)</span>，则把只最小的 <span class="math inline">\(B_i\)</span> 取走就一定是最优的。</p>
<p>下面我们假设对于所有的 <span class="math inline">\(A_i = X\)</span> 都有 <span class="math inline">\(A_i&lt;B_i\)</span>，可以证明把他们全部取走是最优的，而后就需要考虑取剩下的元素了。令所有 <span class="math inline">\(A_i = X\)</span> 的 <span class="math inline">\(i\)</span> 升序构成序列 <span class="math inline">\(y_1,\cdots, y_k\)</span>。接下来考虑的就是满足 <span class="math inline">\(y_k&lt;j\le N\land A_j\le B_{y_1}\)</span> 的 <span class="math inline">\(j\)</span>。</p>
<p>可以发现，将其按照 <span class="math inline">\((A_j, j)\)</span> 升序排序之后，我们会优先取走所有的 <span class="math inline">\(A_j &lt; B_{y_1}\)</span> 的 <span class="math inline">\(j\)</span>，最后就是考虑 <span class="math inline">\(A_j = B_{y_1}\)</span> 的情况，这时候就需要考虑第一个 <span class="math inline">\(B_{y_m}\)</span> 满足 <span class="math inline">\(B_{y_m}\ne B_{y_1}\)</span>，即如果加进去能使得字典序更小，那就加，否则就不要加。</p>
<p>于是这题就做完了，细节有点烦，<a href="https://atcoder.jp/contests/arc134/submissions/29161132">评测记录</a>。</p>
<h3 id="arc137">ARC137</h3>
<p>A + B + D，rk281。</p>
<h4 id="arc137a---coprime-pair">ARC137A - Coprime Pair</h4>
<p>题意：给定 <span class="math inline">\(1\le L &lt; R\le 10^{18}\)</span>，求一对 <span class="math inline">\((x,y)\)</span> 满足 <span class="math inline">\(L\le x\le y\le R\)</span> 使得 <span class="math inline">\(\gcd(x,y) = 1\)</span>。</p>
<p>由于在题目约束下，素数间隔至多为 <span class="math inline">\(K= 1500\)</span> 左右，所以直接从 <span class="math inline">\(L\)</span> 右边和 <span class="math inline">\(R\)</span> 左边暴力找答案即可。时间复杂度 <span class="math inline">\(O(K^2\log R)\)</span>。</p>
<p>然而这个东西似乎有更紧的界，但是 atcoder 官方题解我看不懂。</p>
<h4 id="arc137b---count-1s">ARC137B - Count 1’s</h4>
<p>题意：给定一个 0-1 串，可以将一个子段翻转一次，问最后能达到多少种不同的 <span class="math inline">\(1\)</span>。</p>
<p>首先可以观察到最后达到的 <span class="math inline">\(1\)</span> 的个数肯定是连续的一段。</p>
<p>所以考虑求出 <em><span class="math inline">\(0\)</span> 的个数减 <span class="math inline">\(1\)</span> 的个数</em> 的最大值和最小值。发现 <span class="math inline">\(\max + \min + 1\)</span> 即为答案。</p>
<h4 id="arc137c---distinct-numbers">ARC137C - Distinct Numbers</h4>
<p>题意：给定 <span class="math inline">\(N\)</span> 个元素的数集 <span class="math inline">\(S\)</span>，保证元素两两不同。先手后手博弈，轮到每人操作时，将最大的数取出，换成一个更小的非负整数再塞回去，需保证元素两两不同的性质不被破坏。第一个没办法进行操作的玩家输。问赢家。</p>
<p>结论题（？）。分类讨论：</p>
<ul>
<li><p><span class="math inline">\(a_n - a_{n-1}&gt;1\)</span>。</p>
<p>考虑 <span class="math inline">\(a_1, a_2,\cdots, a_{n-1}, a_{n-1} +1\)</span> 的局面。</p>
<p>若其为必胜态，那么其可以转移到一个必败态，原序列也可以直接转移到那个必败态。</p>
<p>若其为必败态，那么原序列可以直接转移到他。</p>
<p>所以 Alice 必胜。</p></li>
<li><p><span class="math inline">\(a_n - a_{n-1} = 1\)</span>。</p>
<p>发现双方都要尽可能维持这个状态，否则就变成对手必胜。</p>
<p>每次操作的时候 <span class="math inline">\(a_{n} - a_{n-1}\)</span> 都是 <span class="math inline">\(1\)</span>。每次操作后会发现原来的次大值变成了新的最大值。判断 <span class="math inline">\(a_n - n\)</span> 的奇偶性即可。</p></li>
</ul>
<div class="sourceCode" id="cb23"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a aria-hidden="true" href="#cb23-1"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">3e5</span> + <span class="dv">5</span>;</span>
<span id="cb23-2"><a aria-hidden="true" href="#cb23-2"></a><span class="dt">int</span> a[maxn], n;</span>
<span id="cb23-3"><a aria-hidden="true" href="#cb23-3"></a></span>
<span id="cb23-4"><a aria-hidden="true" href="#cb23-4"></a><span class="dt">int</span> main() {</span>
<span id="cb23-5"><a aria-hidden="true" href="#cb23-5"></a>    read(n);</span>
<span id="cb23-6"><a aria-hidden="true" href="#cb23-6"></a>    FOR(i, <span class="dv">1</span>, n) read(a[i]);</span>
<span id="cb23-7"><a aria-hidden="true" href="#cb23-7"></a>    <span class="cf">if</span> (a[n] - a[n - <span class="dv">1</span>] &gt; <span class="dv">1</span>) print(<span class="st">"Alice"</span>);</span>
<span id="cb23-8"><a aria-hidden="true" href="#cb23-8"></a>    <span class="cf">else</span> <span class="cf">if</span> ((n + a[n] + <span class="dv">1</span>) &amp; <span class="dv">1</span>) print(<span class="st">"Alice"</span>);</span>
<span id="cb23-9"><a aria-hidden="true" href="#cb23-9"></a>    <span class="cf">else</span> print(<span class="st">"Bob"</span>);</span>
<span id="cb23-10"><a aria-hidden="true" href="#cb23-10"></a>    <span class="cf">return</span> output(), <span class="dv">0</span>;</span>
<span id="cb23-11"><a aria-hidden="true" href="#cb23-11"></a>}</span></code></pre></div>
<h4 id="arc137d---prefix-xors">ARC137D - Prefix XORs</h4>
<p>题意：给定整数序列 <span class="math inline">\(A\)</span>，<span class="math inline">\(N\le 10^6\)</span>，以及整数 <span class="math inline">\(m\)</span>。对每个 <span class="math inline">\(k=1,2,\cdots, m\)</span>，求出经过下面操作 <span class="math inline">\(k\)</span> 次之后 <span class="math inline">\(A_n\)</span> 的值。</p>
<ul>
<li>对于每个 <span class="math inline">\(i\)</span>，令 <span class="math inline">\(B_i = \displaystyle\bigoplus_{i=1}^i A_i\)</span>，其中 <span class="math inline">\(\oplus\)</span> 代表异或。</li>
<li>然后令 <span class="math inline">\(A = B\)</span>。</li>
</ul>
<p>那么很显然，我们可以考虑对于一个固定的 <span class="math inline">\(k\)</span>，<span class="math inline">\(A_i\)</span> 对 <span class="math inline">\(A_n\)</span> 贡献了多少次，下面假定 <span class="math inline">\(i\)</span> 从 <span class="math inline">\(0\)</span> 开始编号。</p>
<p>然后你发现 <span class="math inline">\(A_i\)</span> 对 <span class="math inline">\(A_n\)</span> 会贡献 <span class="math inline">\(\dbinom{n - i + k - 1}{k - 1}\)</span> 次。你会注意到我们只需要知道他的奇偶性，其为奇数就会产生贡献。</p>
<p>考虑卢卡斯定理的 <span class="math inline">\(p\)</span> 进制形式，发现当且仅当 <span class="math inline">\(n - i + k - 1\)</span> 为 <span class="math inline">\(k - 1\)</span> 在二进制表示下的超集时，Lucas 的式子里面才不会有 <span class="math inline">\(0\)</span> 项，才会产生 <span class="math inline">\(\dbinom{n - i + k - 1}{k - 1}\)</span> 的贡献。</p>
<p>然后注意到，因为 <span class="math inline">\(n - i + k - 1\)</span> 为 <span class="math inline">\(k - 1\)</span> 的超集，所以 <span class="math inline">\(n - i\)</span> 按位与上 <span class="math inline">\(k - 1\)</span> 必然是 <span class="math inline">\(0\)</span>。那么就考虑做一个高维前缀和，然后对每个 <span class="math inline">\(k - 1\)</span> 查询的时候把 <span class="math inline">\(k - 1\)</span> 取补集即可。</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb24-1"><a aria-hidden="true" href="#cb24-1"></a><span class="at">const</span> <span class="dt">int</span> maxn = (<span class="dv">1</span> &lt;&lt; <span class="dv">20</span>) | <span class="dv">5</span>;</span>
<span id="cb24-2"><a aria-hidden="true" href="#cb24-2"></a><span class="dt">int</span> a[maxn], n, m;</span>
<span id="cb24-3"><a aria-hidden="true" href="#cb24-3"></a></span>
<span id="cb24-4"><a aria-hidden="true" href="#cb24-4"></a><span class="dt">int</span> main() {</span>
<span id="cb24-5"><a aria-hidden="true" href="#cb24-5"></a>    read(n, m);</span>
<span id="cb24-6"><a aria-hidden="true" href="#cb24-6"></a>    FOR(i, <span class="dv">0</span>, n - <span class="dv">1</span>) read(a[i]);</span>
<span id="cb24-7"><a aria-hidden="true" href="#cb24-7"></a>    reverse(a, a + n);</span>
<span id="cb24-8"><a aria-hidden="true" href="#cb24-8"></a>    FOR(j, <span class="dv">0</span>, <span class="dv">19</span>) FOR(i, <span class="dv">0</span>, (<span class="dv">1</span> &lt;&lt; <span class="dv">20</span>) - <span class="dv">1</span>) <span class="cf">if</span> (i &amp; (<span class="dv">1</span> &lt;&lt; j)) a[i] ^= a[i ^ (<span class="dv">1</span> &lt;&lt; j)];</span>
<span id="cb24-9"><a aria-hidden="true" href="#cb24-9"></a>    FOR(k, <span class="dv">1</span>, m) print(a[(k - <span class="dv">1</span>) ^ ((<span class="dv">1</span> &lt;&lt; <span class="dv">20</span>) - <span class="dv">1</span>)], <span class="ch">' '</span>);</span>
<span id="cb24-10"><a aria-hidden="true" href="#cb24-10"></a>    <span class="cf">return</span> output(), <span class="dv">0</span>;</span>
<span id="cb24-11"><a aria-hidden="true" href="#cb24-11"></a>}</span></code></pre></div>
<h4 id="arc137e---bakery">ARC137E - Bakery</h4>
<p>题意：规划面包店，天数为 <span class="math inline">\(1,2,\cdots, N\)</span>。有 <span class="math inline">\(M\)</span> 个面包师，编号从 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(M\)</span>，雇用 <span class="math inline">\(i\)</span> 的开支是 <span class="math inline">\(C_i\)</span>，然后其会在 <span class="math inline">\(L_i,\cdots, R_i\)</span> 每天做一个面包。第 <span class="math inline">\(i\)</span> 天面包师一共做了 <span class="math inline">\(x_i\)</span> 个面包的话，售出的就是 <span class="math inline">\(\min(A_i,x_i)\)</span> 个面包。每个面包获利 <span class="math inline">\(D\)</span>，求最大利润（售出面包的获利减去雇佣面包师的开支）</p>
<p><span class="math inline">\(1\le N,M\le 2000\)</span>，<span class="math inline">\(1\le D,C_i\le 10^9\)</span>。</p>
<p>第一眼考虑建费用流，然而用面包来流似乎不好处理面包师的开支。</p>
<p>那么只能拿面包师来流了，对于面包的贡献，就考虑在天数之间流。具体地：建立图，编号从 <span class="math inline">\(0\)</span> 到 <span class="math inline">\(N\)</span>。</p>
<ul>
<li><span class="math inline">\(j\to(j - 1)\)</span>，流量 <span class="math inline">\(A_j\)</span>，费用 <span class="math inline">\(-D\)</span>。这部分处理产生贡献的面包。</li>
<li><span class="math inline">\(j\to (j-1)\)</span>，流量 <span class="math inline">\(M - A_j\)</span>，费用 <span class="math inline">\(0\)</span>。这部分要让剩下产生不了贡献的流过去。</li>
<li><span class="math inline">\((L_{i} - 1)\to R_i\)</span>，流量 <span class="math inline">\(1\)</span>，费用 <span class="math inline">\(C_i\)</span>。这部分处理面包师的费用。</li>
</ul>
<p>上图的<strong>最小费用循环流</strong>的费用就是答案。然而我们不会直球做费用循环流，所以考虑一下怎么转化。</p>
<p>首先，选一个面包师相当于选了一个环，我们肯定是会选<strong>负环</strong>（否则不如不选）。那么就对所有的负权边 <span class="math inline">\((u,v,w,c)\)</span> 进行如下处理：加边 <span class="math inline">\((s, v, w, 0)\)</span>，<span class="math inline">\((u, t, w, 0)\)</span> 和 <span class="math inline">\((v, u, w, -c)\)</span>，然后费用预先加上 <span class="math inline">\(c\)</span>。剩下的正权和 <span class="math inline">\(0\)</span> 权边照旧不变，然后跑一个<strong>流量为 <span class="math inline">\(M\)</span> 的最小费用流</strong>。</p>
<p>这样做的正确性是：先假设负权边全部流满，然后若流了 <span class="math inline">\(s\to v\to u\to t\)</span> 相当于退掉原来的流。剩下就是和正权边连环计算了。</p>
<p>具体地，在本题里面，由于图结构的特殊性，<span class="math inline">\((s,v,w,0)\)</span> 和 <span class="math inline">\((u,t,w,0)\)</span> 是没必要加的，因为对于一个点，其一定会同时连 <span class="math inline">\(s\)</span> 和 <span class="math inline">\(t\)</span>，最小费用最大流告诉我们会优先流满 <span class="math inline">\(s\to u\to t\)</span>，对费用不产生影响。所以我们甚至可以丢掉超级源汇。</p>
<p>综上，连边方式如下：对每个天连 <span class="math inline">\((j-1,j,A_j,D)\)</span>，<span class="math inline">\((j-1,j,M - A_j,0)\)</span>，再对每个面包师连 <span class="math inline">\((L_i - 1, R_i, 1, C_i)\)</span>，跑 <span class="math inline">\(0\)</span> 到 <span class="math inline">\(N\)</span> 的流量为 <span class="math inline">\(M\)</span> 的最小费用流即可。</p>
<blockquote>
<p>本题卡朴素的 EK + SPFA 费用流，正解是原始对偶算法，时间复杂度 <span class="math inline">\(O(N^2\log N)\)</span>，视 <span class="math inline">\(N\)</span> 与 <span class="math inline">\(M\)</span> 同阶。如果你是和我一样的懒狗的话可以用一下 ACL 官方的费用流，用的就是原始对偶，很快。</p>
</blockquote>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a aria-hidden="true" href="#cb25-1"></a><span class="kw">using</span> ll = <span class="dt">long</span> <span class="dt">long</span>;</span>
<span id="cb25-2"><a aria-hidden="true" href="#cb25-2"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="dv">2005</span>;</span>
<span id="cb25-3"><a aria-hidden="true" href="#cb25-3"></a><span class="dt">int</span> N, M, D;</span>
<span id="cb25-4"><a aria-hidden="true" href="#cb25-4"></a></span>
<span id="cb25-5"><a aria-hidden="true" href="#cb25-5"></a><span class="dt">int</span> main() {</span>
<span id="cb25-6"><a aria-hidden="true" href="#cb25-6"></a>    read(N, M, D);</span>
<span id="cb25-7"><a aria-hidden="true" href="#cb25-7"></a>    atcoder::mcf_graph&lt;ll, ll&gt; G(N + <span class="dv">1</span>);</span>
<span id="cb25-8"><a aria-hidden="true" href="#cb25-8"></a>    ll ans = <span class="dv">0</span>;</span>
<span id="cb25-9"><a aria-hidden="true" href="#cb25-9"></a>    FOR(i, <span class="dv">1</span>, N) {</span>
<span id="cb25-10"><a aria-hidden="true" href="#cb25-10"></a>        <span class="dt">int</span> a; read(a);</span>
<span id="cb25-11"><a aria-hidden="true" href="#cb25-11"></a>        G.add_edge(i - <span class="dv">1</span>, i, a, D), G.add_edge(i - <span class="dv">1</span>, i, M - a, <span class="dv">0</span>);</span>
<span id="cb25-12"><a aria-hidden="true" href="#cb25-12"></a>        ans += <span class="dv">1</span><span class="bu">ll</span> * D * a;</span>
<span id="cb25-13"><a aria-hidden="true" href="#cb25-13"></a>    }</span>
<span id="cb25-14"><a aria-hidden="true" href="#cb25-14"></a>    FOR(i, <span class="dv">1</span>, M) {</span>
<span id="cb25-15"><a aria-hidden="true" href="#cb25-15"></a>        <span class="dt">int</span> l, r, c; read(l, r, c);</span>
<span id="cb25-16"><a aria-hidden="true" href="#cb25-16"></a>        G.add_edge(l - <span class="dv">1</span>, r, <span class="dv">1</span>, c);</span>
<span id="cb25-17"><a aria-hidden="true" href="#cb25-17"></a>    }</span>
<span id="cb25-18"><a aria-hidden="true" href="#cb25-18"></a>    print(ans - G.flow(<span class="dv">0</span>, N, M).second);</span>
<span id="cb25-19"><a aria-hidden="true" href="#cb25-19"></a>    <span class="cf">return</span> output(), <span class="dv">0</span>;</span>
<span id="cb25-20"><a aria-hidden="true" href="#cb25-20"></a>}</span></code></pre></div>
<h3 id="arc138">ARC138</h3>
<h4 id="arc138c---rotate-and-play-game">ARC138C - Rotate and Play Game</h4>
<p>第一步通过观察大样例发现，Snuke 一定会取走最大的 <span class="math inline">\(n / 2\)</span> 个元素。</p>
<p>那么我们考虑对于一个静态的序列，Snuke 如何能够成功取走最大的 <span class="math inline">\(n/2\)</span> 个元素。</p>
<p>发现若视最大的（要取走的） <span class="math inline">\(n/2\)</span> 个元素为 <span class="math inline">\(-1\)</span>，剩余的为 <span class="math inline">\(1\)</span> 的话，相当于对于每一个位置，前缀和都不能为负（虽然只是充分，但不必要）。证明：每一轮中，Snuke 取走最靠前的 <span class="math inline">\(-1\)</span>（肯定要避免他被抢走），然后 Mr. Min 照常取一个 <span class="math inline">\(+1\)</span>，于是乎原序列前缀和的性质肯定还是满足的。</p>
<p>现在问题就变为如何求循环位移的偏移量。注意到根据括号序列的性质，其一定有解。</p>
<p>那么就将这个序列复制一份，然后看 <span class="math inline">\([i, i + n - 1]\)</span> 中的前缀和最小值是否 <span class="math inline">\(\ge S_i\)</span> 即可。可以使用 ST 表或者滑动窗口一类的来做。</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb26-1"><a aria-hidden="true" href="#cb26-1"></a><span class="pp">#include </span><span class="im">&lt;bits/stdc++.h&gt;</span></span>
<span id="cb26-2"><a aria-hidden="true" href="#cb26-2"></a><span class="pp">#define il </span><span class="kw">inline</span></span>
<span id="cb26-3"><a aria-hidden="true" href="#cb26-3"></a><span class="pp">#define FOR</span>(i,<span class="pp"> </span>a,<span class="pp"> </span>b)<span class="pp"> </span><span class="cf">for</span><span class="pp"> </span>(<span class="dt">int</span><span class="pp"> </span>i<span class="pp"> </span>=<span class="pp"> </span>(a);<span class="pp"> </span>i<span class="pp"> </span>&lt;=<span class="pp"> </span>(b);<span class="pp"> </span>++i)</span>
<span id="cb26-4"><a aria-hidden="true" href="#cb26-4"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb26-5"><a aria-hidden="true" href="#cb26-5"></a></span>
<span id="cb26-6"><a aria-hidden="true" href="#cb26-6"></a><span class="kw">using</span> ll = <span class="dt">long</span> <span class="dt">long</span>;</span>
<span id="cb26-7"><a aria-hidden="true" href="#cb26-7"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">2e5</span> + <span class="dv">5</span>;</span>
<span id="cb26-8"><a aria-hidden="true" href="#cb26-8"></a><span class="dt">int</span> n, st[<span class="dv">20</span>][maxn &lt;&lt; <span class="dv">1</span>], lg[maxn &lt;&lt; <span class="dv">1</span>];</span>
<span id="cb26-9"><a aria-hidden="true" href="#cb26-9"></a></span>
<span id="cb26-10"><a aria-hidden="true" href="#cb26-10"></a><span class="kw">struct</span> Node {</span>
<span id="cb26-11"><a aria-hidden="true" href="#cb26-11"></a>    ll val; <span class="dt">int</span> id;</span>
<span id="cb26-12"><a aria-hidden="true" href="#cb26-12"></a>} a[maxn &lt;&lt; <span class="dv">1</span>];</span>
<span id="cb26-13"><a aria-hidden="true" href="#cb26-13"></a></span>
<span id="cb26-14"><a aria-hidden="true" href="#cb26-14"></a><span class="dt">int</span> main() {</span>
<span id="cb26-15"><a aria-hidden="true" href="#cb26-15"></a>    cin &gt;&gt; n;</span>
<span id="cb26-16"><a aria-hidden="true" href="#cb26-16"></a>    FOR(i, <span class="dv">1</span>, n) cin &gt;&gt; a[i].val, a[i].id = i;</span>
<span id="cb26-17"><a aria-hidden="true" href="#cb26-17"></a>    sort(a + <span class="dv">1</span>, a + n + <span class="dv">1</span>, [](<span class="at">const</span> Node &amp;a, <span class="at">const</span> Node &amp;b) {<span class="cf">return</span> a.val &gt; b.val;});</span>
<span id="cb26-18"><a aria-hidden="true" href="#cb26-18"></a>    ll sum = <span class="dv">0</span>, tmp = a[n &gt;&gt; <span class="dv">1</span>].val;</span>
<span id="cb26-19"><a aria-hidden="true" href="#cb26-19"></a>    FOR(i, <span class="dv">1</span>, n &gt;&gt; <span class="dv">1</span>) sum += a[i].val, a[i].val = <span class="dv">1</span>;</span>
<span id="cb26-20"><a aria-hidden="true" href="#cb26-20"></a>    FOR(i, (n &gt;&gt; <span class="dv">1</span>) + <span class="dv">1</span>, n) a[i].val = -<span class="dv">1</span>;</span>
<span id="cb26-21"><a aria-hidden="true" href="#cb26-21"></a>    sort(a + <span class="dv">1</span>, a + n + <span class="dv">1</span>, [](<span class="at">const</span> Node &amp;a, <span class="at">const</span> Node &amp;b) {<span class="cf">return</span> a.id &lt; b.id;});</span>
<span id="cb26-22"><a aria-hidden="true" href="#cb26-22"></a>    FOR(i, <span class="dv">1</span>, n) a[n + i] = a[i];</span>
<span id="cb26-23"><a aria-hidden="true" href="#cb26-23"></a>    lg[<span class="dv">0</span>] = -<span class="dv">1</span>;</span>
<span id="cb26-24"><a aria-hidden="true" href="#cb26-24"></a>    FOR(i, <span class="dv">1</span>, n &lt;&lt; <span class="dv">1</span>) st[<span class="dv">0</span>][i] = st[<span class="dv">0</span>][i - <span class="dv">1</span>] + a[i].val, lg[i] = lg[i &gt;&gt; <span class="dv">1</span>] + <span class="dv">1</span>;</span>
<span id="cb26-25"><a aria-hidden="true" href="#cb26-25"></a>    FOR(j, <span class="dv">1</span>, <span class="dv">19</span>) FOR(i, <span class="dv">1</span>, (n &lt;&lt; <span class="dv">1</span>) - (<span class="dv">1</span> &lt;&lt; j) + <span class="dv">1</span>) st[j][i] = max(st[j - <span class="dv">1</span>][i], st[j - <span class="dv">1</span>][i + (<span class="dv">1</span> &lt;&lt; (j - <span class="dv">1</span>))]);</span>
<span id="cb26-26"><a aria-hidden="true" href="#cb26-26"></a>    <span class="at">const</span> <span class="dt">int</span> s = <span class="dv">31</span> - <span class="fu">__builtin_clz</span>(n);</span>
<span id="cb26-27"><a aria-hidden="true" href="#cb26-27"></a>    FOR(i, <span class="dv">1</span>, n) <span class="cf">if</span> (a[i].val == <span class="dv">1</span>) {</span>
<span id="cb26-28"><a aria-hidden="true" href="#cb26-28"></a>        <span class="dt">int</span> ret = max(st[s][i], st[s][i + n - (<span class="dv">1</span> &lt;&lt; s)]);</span>
<span id="cb26-29"><a aria-hidden="true" href="#cb26-29"></a>        <span class="cf">if</span> (ret &lt;= st[<span class="dv">0</span>][i]) <span class="cf">return</span> cout &lt;&lt; i - <span class="dv">1</span> &lt;&lt; <span class="ch">' '</span> &lt;&lt; sum &lt;&lt; endl, <span class="dv">0</span>;</span>
<span id="cb26-30"><a aria-hidden="true" href="#cb26-30"></a>    }</span>
<span id="cb26-31"><a aria-hidden="true" href="#cb26-31"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb26-32"><a aria-hidden="true" href="#cb26-32"></a>}</span></code></pre></div>
<p>注意代码里面的 <span class="math inline">\(\pm 1\)</span> 和 <span class="math inline">\(\min/\max\)</span> 性似乎和题解相反（反正是对称的，不管了）。</p>
<h4 id="arc138d---differ-by-k-bits">ARC138D - Differ by K bits</h4>
<p>撞了洛谷原题 <a href="https://www.luogu.com.cn/problem/P7949">P7949</a>。</p>
<p>本题中，暴力的复杂度貌似是对的，具体原因不详。</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb27-1"><a aria-hidden="true" href="#cb27-1"></a><span class="pp">#include </span><span class="im">&lt;bits/stdc++.h&gt;</span></span>
<span id="cb27-2"><a aria-hidden="true" href="#cb27-2"></a><span class="pp">#define FOR</span>(i,<span class="pp"> </span>a,<span class="pp"> </span>b)<span class="pp"> </span><span class="cf">for</span><span class="pp"> </span>(<span class="dt">int</span><span class="pp"> </span>i<span class="pp"> </span>=<span class="pp"> </span>(a);<span class="pp"> </span>i<span class="pp"> </span>&lt;=<span class="pp"> </span>(b);<span class="pp"> </span>++i)</span>
<span id="cb27-3"><a aria-hidden="true" href="#cb27-3"></a></span>
<span id="cb27-4"><a aria-hidden="true" href="#cb27-4"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb27-5"><a aria-hidden="true" href="#cb27-5"></a></span>
<span id="cb27-6"><a aria-hidden="true" href="#cb27-6"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="dv">1</span> &lt;&lt; <span class="dv">20</span> | <span class="dv">5</span>;</span>
<span id="cb27-7"><a aria-hidden="true" href="#cb27-7"></a><span class="dt">int</span> n, k, vis[maxn];</span>
<span id="cb27-8"><a aria-hidden="true" href="#cb27-8"></a>vector&lt;<span class="dt">int</span>&gt; a, b;</span>
<span id="cb27-9"><a aria-hidden="true" href="#cb27-9"></a></span>
<span id="cb27-10"><a aria-hidden="true" href="#cb27-10"></a><span class="dt">void</span> dfs(<span class="dt">int</span> x) {</span>
<span id="cb27-11"><a aria-hidden="true" href="#cb27-11"></a>    a.push_back(x); vis[x] = <span class="dv">1</span>;</span>
<span id="cb27-12"><a aria-hidden="true" href="#cb27-12"></a>    <span class="cf">if</span> (a.size() == (<span class="dv">1</span> &lt;&lt; n)) {</span>
<span id="cb27-13"><a aria-hidden="true" href="#cb27-13"></a>        puts(<span class="st">"Yes"</span>);</span>
<span id="cb27-14"><a aria-hidden="true" href="#cb27-14"></a>        <span class="cf">for</span> (<span class="kw">auto</span> &amp;x : a)</span>
<span id="cb27-15"><a aria-hidden="true" href="#cb27-15"></a>            cout &lt;&lt; x &lt;&lt; <span class="st">" "</span>; exit(<span class="dv">0</span>);</span>
<span id="cb27-16"><a aria-hidden="true" href="#cb27-16"></a>    }</span>
<span id="cb27-17"><a aria-hidden="true" href="#cb27-17"></a>    <span class="cf">for</span> (<span class="kw">auto</span> &amp;c : b) <span class="cf">if</span> (!vis[c ^ x]) dfs(c ^ x);</span>
<span id="cb27-18"><a aria-hidden="true" href="#cb27-18"></a>    <span class="cf">return</span>;</span>
<span id="cb27-19"><a aria-hidden="true" href="#cb27-19"></a>}</span>
<span id="cb27-20"><a aria-hidden="true" href="#cb27-20"></a></span>
<span id="cb27-21"><a aria-hidden="true" href="#cb27-21"></a><span class="dt">int</span> main() {</span>
<span id="cb27-22"><a aria-hidden="true" href="#cb27-22"></a>    cin &gt;&gt; n &gt;&gt; k;</span>
<span id="cb27-23"><a aria-hidden="true" href="#cb27-23"></a>    <span class="cf">if</span> (k % <span class="dv">2</span> == <span class="dv">0</span>) <span class="cf">return</span> puts(<span class="st">"No"</span>), <span class="dv">0</span>;</span>
<span id="cb27-24"><a aria-hidden="true" href="#cb27-24"></a>    FOR(i, <span class="dv">0</span>, (<span class="dv">1</span> &lt;&lt; n) - <span class="dv">1</span>) <span class="cf">if</span> (<span class="fu">__builtin_popcount</span>(i) == k) b.push_back(i);</span>
<span id="cb27-25"><a aria-hidden="true" href="#cb27-25"></a>    dfs(<span class="dv">0</span>);</span>
<span id="cb27-26"><a aria-hidden="true" href="#cb27-26"></a>    <span class="cf">return</span> puts(<span class="st">"No"</span>), <span class="dv">0</span>;</span>
<span id="cb27-27"><a aria-hidden="true" href="#cb27-27"></a>}</span></code></pre></div>
<p>考虑正解：首先我们注意到，若 <span class="math inline">\(k\)</span> 为偶数，其一定无解。因为不可能所有数的 <span class="math inline">\(\mathrm{popcount}\)</span> 都是偶数。且 <span class="math inline">\(k = n\)</span> 的情况也无解。</p>
<p>而我们若是将 <span class="math inline">\(\mathrm{popcount}(x) = k\)</span> 的 <span class="math inline">\(x\)</span> 插入线性基 <span class="math inline">\(\mathfrak B\)</span>，则可以将成功插入的数看作一组基底，而若 <span class="math inline">\(|\mathfrak B|&lt;n\)</span> 显然也无解。否则我们总能构造出答案：只需要满足构成相邻两个数的线性组合中，有一项不一样即可，具体这个可以用格雷码实现：</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb28-1"><a aria-hidden="true" href="#cb28-1"></a><span class="pp">#include </span><span class="im">&lt;bits/stdc++.h&gt;</span></span>
<span id="cb28-2"><a aria-hidden="true" href="#cb28-2"></a><span class="pp">#define FOR</span>(i,<span class="pp"> </span>a,<span class="pp"> </span>b)<span class="pp"> </span><span class="cf">for</span><span class="pp"> </span>(<span class="dt">int</span><span class="pp"> </span>i<span class="pp"> </span>=<span class="pp"> </span>(a);<span class="pp"> </span>i<span class="pp"> </span>&lt;=<span class="pp"> </span>(b);<span class="pp"> </span>++i)</span>
<span id="cb28-3"><a aria-hidden="true" href="#cb28-3"></a><span class="pp">#define DEC</span>(i,<span class="pp"> </span>a,<span class="pp"> </span>b)<span class="pp"> </span><span class="cf">for</span><span class="pp"> </span>(<span class="dt">int</span><span class="pp"> </span>i<span class="pp"> </span>=<span class="pp"> </span>(a);<span class="pp"> </span>i<span class="pp"> </span>&gt;=<span class="pp"> </span>(b);<span class="pp"> </span>--i)</span>
<span id="cb28-4"><a aria-hidden="true" href="#cb28-4"></a></span>
<span id="cb28-5"><a aria-hidden="true" href="#cb28-5"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb28-6"><a aria-hidden="true" href="#cb28-6"></a></span>
<span id="cb28-7"><a aria-hidden="true" href="#cb28-7"></a><span class="dt">int</span> n, k, a[<span class="dv">22</span>], p[<span class="dv">22</span>], cnt;</span>
<span id="cb28-8"><a aria-hidden="true" href="#cb28-8"></a></span>
<span id="cb28-9"><a aria-hidden="true" href="#cb28-9"></a><span class="dt">void</span> insert(<span class="dt">int</span> x0) {</span>
<span id="cb28-10"><a aria-hidden="true" href="#cb28-10"></a>    <span class="dt">int</span> x = x0;</span>
<span id="cb28-11"><a aria-hidden="true" href="#cb28-11"></a>    DEC(j, n - <span class="dv">1</span>, <span class="dv">0</span>) <span class="cf">if</span> ((x &gt;&gt; j) &amp; <span class="dv">1</span>) {</span>
<span id="cb28-12"><a aria-hidden="true" href="#cb28-12"></a>        <span class="cf">if</span> (!p[j]) {</span>
<span id="cb28-13"><a aria-hidden="true" href="#cb28-13"></a>            p[j] = x, a[cnt++] = x0;</span>
<span id="cb28-14"><a aria-hidden="true" href="#cb28-14"></a>            <span class="cf">break</span>;</span>
<span id="cb28-15"><a aria-hidden="true" href="#cb28-15"></a>        } <span class="cf">else</span> x ^= p[j];</span>
<span id="cb28-16"><a aria-hidden="true" href="#cb28-16"></a>    }</span>
<span id="cb28-17"><a aria-hidden="true" href="#cb28-17"></a>    <span class="cf">return</span>;</span>
<span id="cb28-18"><a aria-hidden="true" href="#cb28-18"></a>}</span>
<span id="cb28-19"><a aria-hidden="true" href="#cb28-19"></a></span>
<span id="cb28-20"><a aria-hidden="true" href="#cb28-20"></a><span class="dt">int</span> main() {</span>
<span id="cb28-21"><a aria-hidden="true" href="#cb28-21"></a>    cin &gt;&gt; n &gt;&gt; k;</span>
<span id="cb28-22"><a aria-hidden="true" href="#cb28-22"></a>    FOR(i, <span class="dv">0</span>, (<span class="dv">1</span> &lt;&lt; n) - <span class="dv">1</span>) <span class="cf">if</span> (<span class="fu">__builtin_popcount</span>(i) == k) insert(i);</span>
<span id="cb28-23"><a aria-hidden="true" href="#cb28-23"></a>    <span class="cf">if</span> (cnt &lt; n) <span class="cf">return</span> puts(<span class="st">"No"</span>), <span class="dv">0</span>;</span>
<span id="cb28-24"><a aria-hidden="true" href="#cb28-24"></a>    cout &lt;&lt; <span class="st">""</span> &lt;&lt; endl;</span>
<span id="cb28-25"><a aria-hidden="true" href="#cb28-25"></a>    FOR(i, <span class="dv">0</span>, (<span class="dv">1</span> &lt;&lt; n) - <span class="dv">1</span>) {</span>
<span id="cb28-26"><a aria-hidden="true" href="#cb28-26"></a>        <span class="dt">int</span> g = i ^ (i &gt;&gt; <span class="dv">1</span>), now = <span class="dv">0</span>;</span>
<span id="cb28-27"><a aria-hidden="true" href="#cb28-27"></a>        FOR(j, <span class="dv">0</span>, n - <span class="dv">1</span>) <span class="cf">if</span> ((g &gt;&gt; j) &amp; <span class="dv">1</span>) now ^= a[j];</span>
<span id="cb28-28"><a aria-hidden="true" href="#cb28-28"></a>        cout &lt;&lt; now &lt;&lt; <span class="ch">' '</span>;</span>
<span id="cb28-29"><a aria-hidden="true" href="#cb28-29"></a>    }</span>
<span id="cb28-30"><a aria-hidden="true" href="#cb28-30"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb28-31"><a aria-hidden="true" href="#cb28-31"></a>}</span></code></pre></div>
</section>
<footer class="article-footer">
<section class="article-tags">
<a href="/tags/OI/">OI</a>
<a href="/tags/solution/">解题报告</a>
<a href="/tags/AtCoder/">AtCoder</a>
<a href="/tags/prime/">素数与筛法</a>
<a href="/tags/implementation/">模拟</a>
<a href="/tags/constructive/">构造</a>
<a href="/tags/diameter-of-tree/">树的直径</a>
<a href="/tags/combinatorics/">组合数学</a>
<a href="/tags/lucas/">Lucas定理</a>
<a href="/tags/binary-search/">二分答案</a>
<a href="/tags/greedy/">贪心</a>
<a href="/tags/gcd/">最大公约数</a>
<a href="/tags/prefix-sum/">前缀和</a>
<a href="/tags/bi-graph/">二分图</a>
<a href="/tags/segtree/">线段树</a>
<a href="/tags/primitive-root/">原根</a>
<a href="/tags/SA/">后缀数组</a>
<a href="/tags/FWT/">FWT</a>
<a href="/tags/gf/">生成函数</a>
<a href="/tags/FFT/">FFT</a>
<a href="/tags/NTT/">NTT</a>
<a href="/tags/dp/">动态规划</a>
<a href="/tags/interval-dp/">区间dp</a>
<a href="/tags/root-changing-dp/">换根dp</a>
<a href="/tags/ddp/">动态dp</a>
<a href="/tags/cdq/">cdq分治</a>
<a href="/tags/expection/">期望</a>
<a href="/tags/mono-stack/">单调栈</a>
<a href="/tags/sosdp/">高维前缀和</a>
<a href="/tags/game-theory/">博弈论</a>
<a href="/tags/linear-basis/">线性基</a>
<a href="/tags/mincostflow/">费用流</a>
</section>
<section class="article-copyright">
<svg class="icon icon-tabler icon-tabler-copyright" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<circle cx="12" cy="12" r="9"></circle>
<path d="M14.5 9a3.5 4 0 1 0 0 6"></path>
</svg>
<span>Licensed under CC BY-NC-SA 4.0</span>
</section>
</footer>
<link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css" integrity="sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn" rel="stylesheet"/><script crossorigin="anonymous" defer="" integrity="sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8" src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js">
</script><script crossorigin="anonymous" defer="" integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js">
</script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.querySelector(`.article-content`), {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ]
        });})
</script>
</article>
<aside class="related-contents--wrapper">
<h2 class="section-title">相关文章</h2>
<div class="related-contents">
<div class="flex article-list--tile">
<article class="has-image">
<a href="/summary-codeforces/">
<div class="article-image">
<img data-hash="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg1.webp" data-key="" loading="lazy" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg1.webp"/>
</div>
<div class="article-details">
<h2 class="article-title">Codeforces 比赛日记</h2>
</div>
</a>
</article>
<article class="has-image">
<a href="/sol-past-noip/">
<div class="article-image">
<img data-hash="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg35.webp" data-key="" loading="lazy" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg35.webp"/>
</div>
<div class="article-details">
<h2 class="article-title">历年联赛真题选做</h2>
</div>
</a>
</article>
<article class="has-image">
<a href="/sol-agc027d/">
<div class="article-image">
<img data-hash="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg01.webp" data-key="" loading="lazy" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg01.webp"/>
</div>
<div class="article-details">
<h2 class="article-title">AGC027D - Modulo Matrix</h2>
</div>
</a>
</article>
<article class="has-image">
<a href="/sol-abc239h/">
<div class="article-image">
<img data-hash="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg35.webp" data-key="" loading="lazy" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg35.webp"/>
</div>
<div class="article-details">
<h2 class="article-title">ABC239Ex - Dice Product 2</h2>
</div>
</a>
</article>
<article class="has-image">
<a href="/sol-agc001e/">
<div class="article-image">
<img data-hash="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg36.webp" data-key="" loading="lazy" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg36.webp"/>
</div>
<div class="article-details">
<h2 class="article-title">AGC001E - BBQ Hard</h2>
</div>
</a>
</article>
</div>
</div>
</aside>
<footer class="site-footer">
<section class="copyright">
        © 
        
            2019 - 
        
        2024 清烛的博客
    </section>
<section class="powerby">
        Built with <a href="https://gohugo.io/" rel="noopener" target="_blank">Hugo</a> <br/>
        主题 <b><a data-version="3.11.0" href="https://github.com/CaiJimmy/hugo-theme-stack" rel="noopener" target="_blank">Stack</a></b> 由 <a href="https://jimmycai.com" rel="noopener" target="_blank">Jimmy</a> 设计
    </section>
</footer>
<div aria-hidden="true" class="pswp" role="dialog" tabindex="-1">
<div class="pswp__bg"></div>
<div class="pswp__scroll-wrap">
<div class="pswp__container">
<div class="pswp__item"></div>
<div class="pswp__item"></div>
<div class="pswp__item"></div>
</div>
<div class="pswp__ui pswp__ui--hidden">
<div class="pswp__top-bar">
<div class="pswp__counter"></div>
<button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title="Share"></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
<div class="pswp__preloader">
<div class="pswp__preloader__icn">
<div class="pswp__preloader__cut">
<div class="pswp__preloader__donut"></div>
</div>
</div>
</div>
</div>
<div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
<div class="pswp__share-tooltip"></div>
</div>
<button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
</button>
<div class="pswp__caption">
<div class="pswp__caption__center"></div>
</div>
</div>
</div>
</div><script crossorigin="anonymous" defer="" integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js">
</script><script crossorigin="anonymous" defer="" integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js">
</script><link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css" integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" rel="stylesheet"/><link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css" integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" rel="stylesheet"/>
</main>
</div>
<script crossorigin="anonymous" integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js">
</script><script defer="" src="/ts/main.js" type="text/javascript"></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>
</body>
</html>

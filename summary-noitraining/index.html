<!DOCTYPE html>
<html dir="ltr" lang="zh-CN">
<head><meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/><meta content="前言 菜死了。
XJOI D16 A 组合 题意：对于 \(|a|\le 1\)，\(T\le 5000\) 次询问 \[ \sum_{k=r}^n(-1)^k\binom nk^a\binom kr \] 对质数 \(p\) 取模的结果，\(0&amp;lt;r\le 5000, r\le n\le 8\times 10^8\)，且 \(9\times 10^8\le p\le 10^9 + 7\)。
首先对于 \(a = 1\) 的情况，化简式子： \[ \begin{aligned} &amp;amp;\sum_{k=r}^n(-1)^k\binom nk\binom kr\\ =&amp;amp;(-1)^r\binom nr\sum_{k=r}^n(-1)^{k-r}\binom{n-r}{k-r}\\ =&amp;amp;(-1)^r\binom nr\sum_{k=0}^{n-r}(-1)^k\binom{n-r}{k}\\ =&amp;amp;(-1)^r\binom nr[n=r] \end{aligned} \] 然后就有了 10pts。
对于 \(a = 0\) 的情况： \[ \begin{aligned} &amp;amp;\sum_{k=r}^n(-1)^k\binom{k}{r}\\ =&amp;amp;\frac{1}{r!}\sum_{k=r}^n(-1)^kk^{\underline r}\\ \end{aligned} \] \(a=-1\) 的情况：太难了，不会。
B 亚登 \(n\) 个点的树，\(m\) 种魔法。第 \(i\) 种魔法 \((a_i, d_i)\) 会使得到 \(a_i\) 的距离 \(\le d_i\) 的连通块内点权 \(+1\)。一开始选择一个整数 \(t\le [0,m]\)，然后选择 \(t\) 种魔法依次施法，令点权恰好为 \(t\) 的点有 \(k\) 个，设 \(f_x\) 表示选择施法方式使得 \(k=x\) 的方案数，对 \(x\in[0,R]\) 求 \(f_x\bmod 998244353\)。" name="description"/><title>NOI 赛前训练总结</title>
<link href="https://oi.imyangty.com/summary-noitraining/" rel="canonical"/>
<link href="/scss/style.min.a5821f3d3ab84ce5a0ac21477e347a2e0ca00292e398d16c5e8e36ded6e35a23.css" rel="stylesheet"/><meta content="NOI 赛前训练总结" property="og:title"/>
<meta content="前言 菜死了。
XJOI D16 A 组合 题意：对于 \(|a|\le 1\)，\(T\le 5000\) 次询问 \[ \sum_{k=r}^n(-1)^k\binom nk^a\binom kr \] 对质数 \(p\) 取模的结果，\(0&amp;lt;r\le 5000, r\le n\le 8\times 10^8\)，且 \(9\times 10^8\le p\le 10^9 + 7\)。
首先对于 \(a = 1\) 的情况，化简式子： \[ \begin{aligned} &amp;amp;\sum_{k=r}^n(-1)^k\binom nk\binom kr\\ =&amp;amp;(-1)^r\binom nr\sum_{k=r}^n(-1)^{k-r}\binom{n-r}{k-r}\\ =&amp;amp;(-1)^r\binom nr\sum_{k=0}^{n-r}(-1)^k\binom{n-r}{k}\\ =&amp;amp;(-1)^r\binom nr[n=r] \end{aligned} \] 然后就有了 10pts。
对于 \(a = 0\) 的情况： \[ \begin{aligned} &amp;amp;\sum_{k=r}^n(-1)^k\binom{k}{r}\\ =&amp;amp;\frac{1}{r!}\sum_{k=r}^n(-1)^kk^{\underline r}\\ \end{aligned} \] \(a=-1\) 的情况：太难了，不会。
B 亚登 \(n\) 个点的树，\(m\) 种魔法。第 \(i\) 种魔法 \((a_i, d_i)\) 会使得到 \(a_i\) 的距离 \(\le d_i\) 的连通块内点权 \(+1\)。一开始选择一个整数 \(t\le [0,m]\)，然后选择 \(t\) 种魔法依次施法，令点权恰好为 \(t\) 的点有 \(k\) 个，设 \(f_x\) 表示选择施法方式使得 \(k=x\) 的方案数，对 \(x\in[0,R]\) 求 \(f_x\bmod 998244353\)。" property="og:description"/>
<meta content="https://oi.imyangty.com/summary-noitraining/" property="og:url"/>
<meta content="清烛的博客" property="og:site_name"/>
<meta content="article" property="og:type"/><meta content="Post" property="article:section"/><meta content="OI" property="article:tag"/><meta content="2022-06-13T08:15:49+08:00" property="article:published_time"/><meta content="2022-06-13T08:15:49+08:00" property="article:modified_time"/><meta content="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg29.webp" property="og:image"/>
<meta content="NOI 赛前训练总结" name="twitter:title"/>
<meta content="前言 菜死了。
XJOI D16 A 组合 题意：对于 \(|a|\le 1\)，\(T\le 5000\) 次询问 \[ \sum_{k=r}^n(-1)^k\binom nk^a\binom kr \] 对质数 \(p\) 取模的结果，\(0&amp;lt;r\le 5000, r\le n\le 8\times 10^8\)，且 \(9\times 10^8\le p\le 10^9 + 7\)。
首先对于 \(a = 1\) 的情况，化简式子： \[ \begin{aligned} &amp;amp;\sum_{k=r}^n(-1)^k\binom nk\binom kr\\ =&amp;amp;(-1)^r\binom nr\sum_{k=r}^n(-1)^{k-r}\binom{n-r}{k-r}\\ =&amp;amp;(-1)^r\binom nr\sum_{k=0}^{n-r}(-1)^k\binom{n-r}{k}\\ =&amp;amp;(-1)^r\binom nr[n=r] \end{aligned} \] 然后就有了 10pts。
对于 \(a = 0\) 的情况： \[ \begin{aligned} &amp;amp;\sum_{k=r}^n(-1)^k\binom{k}{r}\\ =&amp;amp;\frac{1}{r!}\sum_{k=r}^n(-1)^kk^{\underline r}\\ \end{aligned} \] \(a=-1\) 的情况：太难了，不会。
B 亚登 \(n\) 个点的树，\(m\) 种魔法。第 \(i\) 种魔法 \((a_i, d_i)\) 会使得到 \(a_i\) 的距离 \(\le d_i\) 的连通块内点权 \(+1\)。一开始选择一个整数 \(t\le [0,m]\)，然后选择 \(t\) 种魔法依次施法，令点权恰好为 \(t\) 的点有 \(k\) 个，设 \(f_x\) 表示选择施法方式使得 \(k=x\) 的方案数，对 \(x\in[0,R]\) 求 \(f_x\bmod 998244353\)。" name="twitter:description"/><meta content="summary_large_image" name="twitter:card"/>
<meta content="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg29.webp" name="twitter:image"/>
<link href="https://q1.qlogo.cn/g?b=qq&amp;nk=375836877&amp;s=5" rel="shortcut icon"/>
<link href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/styles/github-dark-dimmed.min.css" rel="stylesheet"/>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
</head>
<body class="article-page">
<script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky">
<button aria-label="切换菜单" class="hamburger hamburger--spin" id="toggle-menu" type="button">
<span class="hamburger-box">
<span class="hamburger-inner"></span>
</span>
</button>
<header>
<figure class="site-avatar">
<a href="/">
<img alt="Avatar" class="site-logo" height="300" loading="lazy" src="/img/avatar_huea3ce2119467b51fdd2a81393644a76d_51594_300x0_resize_q75_box.jpg" width="300"/>
</a>
<span class="emoji">😅</span>
</figure>
<div class="site-meta">
<h1 class="site-name"><a href="/">清烛的博客</a></h1>
<h2 class="site-description">烟火已谢，笙歌未停</h2>
</div>
</header><ol class="social-menu">
<li>
<a href="mailto:i@imyangty.com" target="_blank" title="email">
<svg class="icon icon-tabler icon-tabler-mail" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
<rect height="14" rx="2" width="18" x="3" y="5"></rect>
<polyline points="3 7 12 13 21 7"></polyline>
</svg>
</a>
</li>
<li>
<a href="https://github.com/Cgfyufsygsm" target="_blank" title="GitHub">
<svg class="icon icon-tabler icon-tabler-brand-github" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
<path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5"></path>
</svg>
</a>
</li>
<li>
<a href="https://t.me/Cgfyufsygsm" target="_blank" title="Telegram">
<svg class="icon icon-tabler icon-tabler-brand-telegram" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
<path d="M15 10l-4 4l6 6l4 -16l-18 7l4 2l2 6l3 -4"></path>
</svg>
</a>
</li>
<li>
<a href="https://twitter.com/Cgfyufsygsm" target="_blank" title="Twitter">
<svg class="icon icon-tabler icon-tabler-brand-twitter" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" fill="none" stroke="none"></path>
<path d="M22 4.01c-1 .49 -1.98 .689 -3 .99c-1.121 -1.265 -2.783 -1.335 -4.38 -.737s-2.643 2.06 -2.62 3.737v1c-3.245 .083 -6.135 -1.395 -8 -4c0 0 -4.182 7.433 4 11c-1.872 1.247 -3.739 2.088 -6 2c3.308 1.803 6.913 2.423 10.034 1.517c3.58 -1.04 6.522 -3.723 7.651 -7.742a13.84 13.84 0 0 0 .497 -3.753c-.002 -.249 1.51 -2.772 1.818 -4.013z"></path>
</svg>
</a>
</li>
</ol><ol class="menu" id="main-menu">
<li>
<a href="/">
<svg class="icon icon-tabler icon-tabler-home" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<polyline points="5 12 3 12 12 3 21 12 19 12"></polyline>
<path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7"></path>
<path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6"></path>
</svg>
<span>主页</span>
</a>
</li>
<li>
<a href="/about/">
<svg class="icon icon-tabler icon-tabler-user" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<circle cx="12" cy="7" r="4"></circle>
<path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2"></path>
</svg>
<span>关于</span>
</a>
</li>
<li>
<a href="/idx/">
<svg class="icon icon-tabler icon-tabler-hash" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<line x1="5" x2="19" y1="9" y2="9"></line>
<line x1="5" x2="19" y1="15" y2="15"></line>
<line x1="11" x2="7" y1="4" y2="20"></line>
<line x1="17" x2="13" y1="4" y2="20"></line>
</svg>
<span>导航</span>
</a>
</li>
<li>
<a href="/archives/">
<svg class="icon icon-tabler icon-tabler-archive" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<rect height="4" rx="2" width="18" x="3" y="4"></rect>
<path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10"></path>
<line x1="10" x2="14" y1="12" y2="12"></line>
</svg>
<span>归档</span>
</a>
</li>
<li>
<a href="/search/">
<svg class="icon icon-tabler icon-tabler-search" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<circle cx="10" cy="10" r="7"></circle>
<line x1="21" x2="15" y1="21" y2="15"></line>
</svg>
<span>搜索</span>
</a>
</li>
<li>
<a href="/friends/">
<svg class="icon icon-tabler icon-tabler-link" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5"></path>
<path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5"></path>
</svg>
<span>友链</span>
</a>
</li>
<li>
<a href="https://blog.imyangty.com" target="_blank">
<svg class="icon icon-tabler icon-tabler-home" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<polyline points="5 12 3 12 12 3 21 12 19 12"></polyline>
<path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7"></path>
<path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6"></path>
</svg>
<span>主博客</span>
</a>
</li>
<div class="menu-bottom-section">
<li id="dark-mode-toggle">
<svg class="icon icon-tabler icon-tabler-toggle-left" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<circle cx="8" cy="12" r="2"></circle>
<rect height="12" rx="6" width="20" x="2" y="6"></rect>
</svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<circle cx="16" cy="12" r="2"></circle>
<rect height="12" rx="6" width="20" x="2" y="6"></rect>
</svg>
<span>暗色模式</span>
</li>
</div>
</ol>
</aside>
<main class="main full-width">
<article class="has-image main-article">
<header class="article-header">
<div class="article-image">
<a href="/summary-noitraining/">
<img alt="Featured image of post NOI 赛前训练总结" loading="lazy" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg29.webp"/>
</a>
</div>
<div class="article-details">
<header class="article-category">
<a href="/categories/oi/">
                OI
            </a>
<a href="/categories/summary/">
                总结
            </a>
</header>
<div class="article-title-wrapper">
<h2 class="article-title">
<a href="/summary-noitraining/">NOI 赛前训练总结</a>
</h2>
</div>
<footer class="article-time">
<div>
<svg class="icon icon-tabler icon-tabler-calendar-time" fill="none" height="56" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="56" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4"></path>
<circle cx="18" cy="18" r="4"></circle>
<path d="M15 3v4"></path>
<path d="M7 3v4"></path>
<path d="M3 11h16"></path>
<path d="M18 16.496v1.504l1 1"></path>
</svg>
<time class="article-time--published">Jun 13, 2022</time>
</div>
<div>
<svg class="icon icon-tabler icon-tabler-clock" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<circle cx="12" cy="12" r="9"></circle>
<polyline points="12 7 12 12 15 15"></polyline>
</svg>
<time class="article-time--reading">
                    阅读时长: 17 分钟
                </time>
</div>
</footer>
</div>
</header>
<section class="article-content">
<h2 id="前言">前言</h2>
<p>菜死了。</p>
<h2 id="xjoi-d16">XJOI D16</h2>
<h3 id="a-组合">A 组合</h3>
<p>题意：对于 <span class="math inline">\(|a|\le 1\)</span>，<span class="math inline">\(T\le 5000\)</span> 次询问 <span class="math display">\[
\sum_{k=r}^n(-1)^k\binom nk^a\binom kr
\]</span> 对质数 <span class="math inline">\(p\)</span> 取模的结果，<span class="math inline">\(0&lt;r\le 5000, r\le n\le 8\times 10^8\)</span>，且 <span class="math inline">\(9\times 10^8\le p\le 10^9 + 7\)</span>。</p>
<p>首先对于 <span class="math inline">\(a = 1\)</span> 的情况，化简式子： <span class="math display">\[
\begin{aligned}
&amp;\sum_{k=r}^n(-1)^k\binom nk\binom kr\\
=&amp;(-1)^r\binom nr\sum_{k=r}^n(-1)^{k-r}\binom{n-r}{k-r}\\
=&amp;(-1)^r\binom nr\sum_{k=0}^{n-r}(-1)^k\binom{n-r}{k}\\
=&amp;(-1)^r\binom nr[n=r]
\end{aligned}
\]</span> <del>然后就有了 10pts</del>。</p>
<p>对于 <span class="math inline">\(a = 0\)</span> 的情况： <span class="math display">\[
\begin{aligned}
&amp;\sum_{k=r}^n(-1)^k\binom{k}{r}\\
=&amp;\frac{1}{r!}\sum_{k=r}^n(-1)^kk^{\underline r}\\
\end{aligned}
\]</span> <span class="math inline">\(a=-1\)</span> 的情况：太难了，不会。</p>
<h3 id="b-亚登">B 亚登</h3>
<p><span class="math inline">\(n\)</span> 个点的树，<span class="math inline">\(m\)</span> 种魔法。第 <span class="math inline">\(i\)</span> 种魔法 <span class="math inline">\((a_i, d_i)\)</span> 会使得到 <span class="math inline">\(a_i\)</span> 的距离 <span class="math inline">\(\le d_i\)</span> 的连通块内点权 <span class="math inline">\(+1\)</span>。一开始选择一个整数 <span class="math inline">\(t\le [0,m]\)</span>，然后选择 <span class="math inline">\(t\)</span> 种魔法依次施法，令点权恰好为 <span class="math inline">\(t\)</span> 的点有 <span class="math inline">\(k\)</span> 个，设 <span class="math inline">\(f_x\)</span> 表示选择施法方式使得 <span class="math inline">\(k=x\)</span> 的方案数，对 <span class="math inline">\(x\in[0,R]\)</span> 求 <span class="math inline">\(f_x\bmod 998244353\)</span>。</p>
<h4 id="b.part1">B.part1</h4>
<p><span class="math inline">\(n,m\le 500, R\le n\)</span>。设 <span class="math inline">\(S(u,d)\)</span> 表示到 <span class="math inline">\(u\)</span> 的距离 <span class="math inline">\(\le d\)</span> 的点集，</p>
<h3 id="c-旅行家">C 旅行家</h3>
<p>给定 <span class="math inline">\(a,b\)</span> 数组。一棵树，根为 <span class="math inline">\(1\)</span>。对 <span class="math inline">\(s\in[1, n]\)</span>，对于 <span class="math inline">\(1\to s\)</span> 链上的所有点，设其到 <span class="math inline">\(s\)</span> 的距离为 <span class="math inline">\(t\)</span>，对 <span class="math inline">\(|a_u - b_t|^2\)</span> 求和。<span class="math inline">\(1\le n\le 5\times 10^5\)</span>，<span class="math inline">\(0\le a_i,b_i&lt;16\)</span>。</p>
<p>对于链的情况，拆开可得到 <span class="math inline">\(a_u^2 + b_t^2 - 2a_ub_t\)</span>，<span class="math inline">\(a_u^2\)</span> 和 <span class="math inline">\(b_t^2\)</span> 很好求和，主要问题在于 <span class="math inline">\(a_ub_t\)</span>。发现可以 NTT。</p>
<p>而树上不会弱于链，所以考虑进行链剖分。对于树根引下来的链，我们可以直接计算上面每个点的答案，但是对于其他的链（长为 <span class="math inline">\(l\)</span>），由于链顶上面有点，所以要做一个长 <span class="math inline">\(l\)</span> 的数组和长 <span class="math inline">\(n\)</span> 的数组的卷积。但是链上面的部分已经被计算过了，所以对于当前链深度为 <span class="math inline">\(d\)</span> 的点可以复用上一条链深度为 <span class="math inline">\(d\)</span> 的答案，然后再处理多卷的部分（减掉）。</p>
<p>详见代码。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a aria-hidden="true" href="#cb1-1"></a><span class="kw">using</span> polynomial::Poly;</span>
<span id="cb1-2"><a aria-hidden="true" href="#cb1-2"></a></span>
<span id="cb1-3"><a aria-hidden="true" href="#cb1-3"></a><span class="kw">using</span> fastIO::is;</span>
<span id="cb1-4"><a aria-hidden="true" href="#cb1-4"></a><span class="kw">using</span> fastIO::os;</span>
<span id="cb1-5"><a aria-hidden="true" href="#cb1-5"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">5e5</span> + <span class="dv">5</span>;</span>
<span id="cb1-6"><a aria-hidden="true" href="#cb1-6"></a><span class="dt">int</span> a[maxn], b[maxn], a2[maxn], b2[maxn], fa[maxn], n;</span>
<span id="cb1-7"><a aria-hidden="true" href="#cb1-7"></a><span class="dt">int</span> dep[maxn], son[maxn], h[maxn], *arr[maxn], ans[maxn];</span>
<span id="cb1-8"><a aria-hidden="true" href="#cb1-8"></a>vector&lt;<span class="dt">int</span>&gt; G[maxn];</span>
<span id="cb1-9"><a aria-hidden="true" href="#cb1-9"></a></span>
<span id="cb1-10"><a aria-hidden="true" href="#cb1-10"></a><span class="dt">void</span> dfs1(<span class="dt">int</span> u) {</span>
<span id="cb1-11"><a aria-hidden="true" href="#cb1-11"></a>    <span class="cf">for</span> (<span class="dt">int</span> &amp;v : G[u]) {</span>
<span id="cb1-12"><a aria-hidden="true" href="#cb1-12"></a>        dep[v] = dep[u] + <span class="dv">1</span>;</span>
<span id="cb1-13"><a aria-hidden="true" href="#cb1-13"></a>        dfs1(v);</span>
<span id="cb1-14"><a aria-hidden="true" href="#cb1-14"></a>        <span class="cf">if</span> (h[v] &gt;= h[son[u]])</span>
<span id="cb1-15"><a aria-hidden="true" href="#cb1-15"></a>            son[u] = v, h[u] = h[son[u]] + <span class="dv">1</span>;</span>
<span id="cb1-16"><a aria-hidden="true" href="#cb1-16"></a>    }</span>
<span id="cb1-17"><a aria-hidden="true" href="#cb1-17"></a>    <span class="cf">return</span>;</span>
<span id="cb1-18"><a aria-hidden="true" href="#cb1-18"></a>}</span>
<span id="cb1-19"><a aria-hidden="true" href="#cb1-19"></a></span>
<span id="cb1-20"><a aria-hidden="true" href="#cb1-20"></a><span class="dt">void</span> dfs2(<span class="dt">int</span> u) {</span>
<span id="cb1-21"><a aria-hidden="true" href="#cb1-21"></a>    vector&lt;<span class="dt">int</span>&gt; stk;</span>
<span id="cb1-22"><a aria-hidden="true" href="#cb1-22"></a>    <span class="cf">for</span> (<span class="dt">int</span> x = u; x; x = son[x]) stk.emplace_back(x);</span>
<span id="cb1-23"><a aria-hidden="true" href="#cb1-23"></a>    Poly f(szof(stk)), g(szof(stk));</span>
<span id="cb1-24"><a aria-hidden="true" href="#cb1-24"></a>    FOR(i, <span class="dv">0</span>, szof(stk) - <span class="dv">1</span>) f[i] = a[stk[i]], g[i] = b[i];</span>
<span id="cb1-25"><a aria-hidden="true" href="#cb1-25"></a>    f = f * g;</span>
<span id="cb1-26"><a aria-hidden="true" href="#cb1-26"></a>    FOR(i, <span class="dv">0</span>, szof(stk) - <span class="dv">1</span>) arr[u][i] += f[i];</span>
<span id="cb1-27"><a aria-hidden="true" href="#cb1-27"></a>    FOR(i, <span class="dv">0</span>, szof(stk) - <span class="dv">1</span>) ans[stk[i]] = arr[u][i];</span>
<span id="cb1-28"><a aria-hidden="true" href="#cb1-28"></a>    FOR(i, <span class="dv">0</span>, szof(stk) - <span class="dv">1</span>) {</span>
<span id="cb1-29"><a aria-hidden="true" href="#cb1-29"></a>        <span class="dt">int</span> x = stk[i], d = i + <span class="dv">1</span>;</span>
<span id="cb1-30"><a aria-hidden="true" href="#cb1-30"></a>        <span class="cf">for</span> (<span class="kw">auto</span> &amp;v : G[x]) <span class="cf">if</span> (v != son[x]) {</span>
<span id="cb1-31"><a aria-hidden="true" href="#cb1-31"></a>            arr[v] = <span class="kw">new</span> <span class="dt">int</span>[h[v] + <span class="dv">1</span>];</span>
<span id="cb1-32"><a aria-hidden="true" href="#cb1-32"></a>            FOR(j, <span class="dv">0</span>, h[v]) arr[v][j] = arr[u][j + d];</span>
<span id="cb1-33"><a aria-hidden="true" href="#cb1-33"></a>            Poly A(h[v] + <span class="dv">1</span>), B(h[v] + <span class="dv">1</span>);</span>
<span id="cb1-34"><a aria-hidden="true" href="#cb1-34"></a>            FOR(j, <span class="dv">0</span>, h[v]) A[j] = a[stk[j + d]];</span>
<span id="cb1-35"><a aria-hidden="true" href="#cb1-35"></a>            FOR(j, <span class="dv">0</span>, h[v]) B[j] = b[j];</span>
<span id="cb1-36"><a aria-hidden="true" href="#cb1-36"></a>            A = A * B;</span>
<span id="cb1-37"><a aria-hidden="true" href="#cb1-37"></a>            FOR(j, <span class="dv">0</span>, h[v]) arr[v][j] -= A[j];</span>
<span id="cb1-38"><a aria-hidden="true" href="#cb1-38"></a>            dfs2(v);</span>
<span id="cb1-39"><a aria-hidden="true" href="#cb1-39"></a>        }</span>
<span id="cb1-40"><a aria-hidden="true" href="#cb1-40"></a>    }</span>
<span id="cb1-41"><a aria-hidden="true" href="#cb1-41"></a>    <span class="cf">return</span>;</span>
<span id="cb1-42"><a aria-hidden="true" href="#cb1-42"></a>}</span>
<span id="cb1-43"><a aria-hidden="true" href="#cb1-43"></a></span>
<span id="cb1-44"><a aria-hidden="true" href="#cb1-44"></a><span class="dt">int</span> main() {</span>
<span id="cb1-45"><a aria-hidden="true" href="#cb1-45"></a>    fileIn(<span class="st">"tourist.in"</span>);</span>
<span id="cb1-46"><a aria-hidden="true" href="#cb1-46"></a>    fileOut(<span class="st">"tourist.out"</span>);</span>
<span id="cb1-47"><a aria-hidden="true" href="#cb1-47"></a>    is &gt;&gt; n;</span>
<span id="cb1-48"><a aria-hidden="true" href="#cb1-48"></a>    FOR(i, <span class="dv">2</span>, n) is &gt;&gt; fa[i], G[fa[i]].emplace_back(i);</span>
<span id="cb1-49"><a aria-hidden="true" href="#cb1-49"></a>    FOR(i, <span class="dv">1</span>, n) is &gt;&gt; a[i], a2[i] = a[i] * a[i];</span>
<span id="cb1-50"><a aria-hidden="true" href="#cb1-50"></a>    FOR(i, <span class="dv">0</span>, n - <span class="dv">1</span>) is &gt;&gt; b[i], b2[i] = b[i] * b[i];</span>
<span id="cb1-51"><a aria-hidden="true" href="#cb1-51"></a>    FOR(i, <span class="dv">1</span>, n) a2[i] += a2[fa[i]], b2[i] += b2[i - <span class="dv">1</span>];</span>
<span id="cb1-52"><a aria-hidden="true" href="#cb1-52"></a>    dfs1(<span class="dv">1</span>);</span>
<span id="cb1-53"><a aria-hidden="true" href="#cb1-53"></a>    arr[<span class="dv">1</span>] = <span class="kw">new</span> <span class="dt">int</span>[h[<span class="dv">1</span>] + <span class="dv">1</span>];</span>
<span id="cb1-54"><a aria-hidden="true" href="#cb1-54"></a>    FOR(i, <span class="dv">0</span>, h[<span class="dv">1</span>]) arr[<span class="dv">1</span>][i] = <span class="dv">0</span>;</span>
<span id="cb1-55"><a aria-hidden="true" href="#cb1-55"></a>    dfs2(<span class="dv">1</span>);</span>
<span id="cb1-56"><a aria-hidden="true" href="#cb1-56"></a>    FOR(i, <span class="dv">1</span>, n) os &lt;&lt; a2[i] + b2[dep[i]] - <span class="dv">2</span> * ans[i] &lt;&lt; <span class="ch">' '</span>;</span>
<span id="cb1-57"><a aria-hidden="true" href="#cb1-57"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb1-58"><a aria-hidden="true" href="#cb1-58"></a>}</span></code></pre></div>
<h2 id="xjoi-d17">XJOI D17</h2>
<h3 id="a-双色砖">A 双色砖</h3>
<p>设白色为 <span class="math inline">\(0\)</span>，红色为 <span class="math inline">\(1\)</span>。</p>
<p>则首先我们知道，任意两个对边的颜色不同，所以对于 <span class="math inline">\(H,W\le 10\)</span> 的点可以考虑枚举第一行和第一列的颜色，然后就可以确定整个矩形，在此基础上判环即可。</p>
<p>然后考虑到 <span class="math inline">\(n\)</span> 个限制点，实际上 <span class="math inline">\((R, C, D)\)</span> 等价于钦定 <span class="math inline">\(colorx_R\)</span> 和 <span class="math inline">\(colorx_C\)</span> 为一个值，发现矛盾即无解。</p>
<p>对于不能成环的限制即考虑定义 <span class="math inline">\(parityx_i = (colorx_i + i)\bmod 2\)</span>，<span class="math inline">\(parityy_i = (colory_i + i)\bmod 2\)</span>。则当 <span class="math inline">\(parityx\)</span> 全相同的时候，所有的同色段都形如一个从左到右的“波浪”，不可能成环。该结论对 <span class="math inline">\(parityy\)</span> 类似。</p>
<h2 id="xjoi-d18">XJOI D18</h2>
<h3 id="a-数学题">A 数学题</h3>
<p>首先问题转化为求和 <span class="math display">\[
\sum_{i=0}^n\left(\sum_{j=0}^i\binom{i - j + 1}{j}\right)^k = \sum_{i=2}^{n + 2}F_i^k
\]</span> 由于 <span class="math inline">\(p\)</span> 不一定是质数所以无法使用其通项公式辅助求解。由于 <span class="math inline">\(k\)</span> 很小故考虑矩阵。</p>
<p>不难发现我们可以构造出齐次矩阵 <span class="math inline">\(\begin{bmatrix}F_{i-1}^k&amp;F_{i-1}^{k-1}F_{i}&amp;F_{i-2}^{k-2}F_i^2&amp;\cdots&amp;F_{i-1}F_i^{k-1}&amp;F_{i}^k&amp;S_i\end{bmatrix}^T\)</span>，手玩发现转移矩阵就是个类似于杨辉三角的东西，直接处理十进制快速幂可以通过 <span class="math inline">\(\lg n\le 10^5\)</span> 的部分分，时间复杂度 <span class="math inline">\(k^3\log n\)</span>。</p>
<p>但是 <span class="math inline">\(\log n\)</span> 很大，所以考虑在此基础上优化。回忆斐波那契的循环节的上界为 <span class="math inline">\(6p\)</span>，枚举这个循环节可以通过 <span class="math inline">\(\lg n\le 10^7,p\le 10^4\)</span> 的部分分，随机化找循环节根据生日悖论最多 <span class="math inline">\(O(\sqrt p)\)</span> 次，所以可以在 <span class="math inline">\(O(\sqrt p + k^3)\log p + \log n\)</span> 的时间复杂度解决本题。</p>
<blockquote>
<p>不要写封装的矩阵乘法，十倍常数。</p>
</blockquote>
<h3 id="b-青金石的图书馆">B 青金石的图书馆</h3>
<p>给定一棵带点权和边权的树 <span class="math inline">\(T\)</span>，设节点 <span class="math inline">\(i\)</span> 的点权为 <span class="math inline">\(a_i\)</span>，<span class="math inline">\(i,j\)</span> 间的树上路径长度为 <span class="math inline">\(dis(i,j)\)</span>。现在要根据这棵树构出一张完全图 <span class="math inline">\(G\)</span>，<span class="math inline">\(G\)</span> 中对应节点 <span class="math inline">\(i,j\)</span> 的连边长度 <span class="math inline">\(b(i,j)=\min(a_i,a_j)+dis(i,j)\)</span>，求图 <span class="math inline">\(G\)</span> 中最小生成树的最大边长度和最大边出现次数。</p>
<p>首先可以考虑二分答案之后转为判定图是否联通的问题（将 <span class="math inline">\(&gt; mid\)</span> 的边删掉）。</p>
<p>结论：根据我们定义的代价，原树 <span class="math inline">\(T\)</span> 最后一定会被划分成若干树形连通块。所以若是图不连通，则说明对于原树上的某一条边 <span class="math inline">\((u, v)\)</span>，两侧的点集的连边的最小值是大于 <span class="math inline">\(mid\)</span> 的。将 <span class="math inline">\((i,j,\min(a_i, a_j) + dis(i,j))\)</span> 拆贡献变成 <span class="math inline">\((i,j,a_i)\)</span> 和 <span class="math inline">\((j,i,a_j)\)</span> 之后可以 dp 来求出这个最小值。</p>
<p>然后发现没必要二分了，直接换根 dp 就行了，时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a aria-hidden="true" href="#cb2-1"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">5e5</span> + <span class="dv">5</span>;</span>
<span id="cb2-2"><a aria-hidden="true" href="#cb2-2"></a><span class="kw">using</span> ll = <span class="dt">long</span> <span class="dt">long</span>;</span>
<span id="cb2-3"><a aria-hidden="true" href="#cb2-3"></a><span class="kw">struct</span> Edge {</span>
<span id="cb2-4"><a aria-hidden="true" href="#cb2-4"></a>    <span class="dt">int</span> to; ll w;</span>
<span id="cb2-5"><a aria-hidden="true" href="#cb2-5"></a>    Edge(<span class="dt">int</span> _to, ll _w) : to(_to), w(_w) {}</span>
<span id="cb2-6"><a aria-hidden="true" href="#cb2-6"></a>};</span>
<span id="cb2-7"><a aria-hidden="true" href="#cb2-7"></a>vector&lt;Edge&gt; G[maxn];</span>
<span id="cb2-8"><a aria-hidden="true" href="#cb2-8"></a>ll a[maxn], f[maxn], ans;</span>
<span id="cb2-9"><a aria-hidden="true" href="#cb2-9"></a><span class="dt">int</span> n, cnt;</span>
<span id="cb2-10"><a aria-hidden="true" href="#cb2-10"></a></span>
<span id="cb2-11"><a aria-hidden="true" href="#cb2-11"></a><span class="dt">void</span> dfs1(<span class="dt">int</span> u, <span class="dt">int</span> fa) {</span>
<span id="cb2-12"><a aria-hidden="true" href="#cb2-12"></a>    f[u] = a[u];</span>
<span id="cb2-13"><a aria-hidden="true" href="#cb2-13"></a>    <span class="cf">for</span> (<span class="kw">auto</span> &amp;e : G[u]) <span class="cf">if</span> (e.to != fa) {</span>
<span id="cb2-14"><a aria-hidden="true" href="#cb2-14"></a>        <span class="dt">int</span> &amp;v = e.to; ll &amp;w = e.w;</span>
<span id="cb2-15"><a aria-hidden="true" href="#cb2-15"></a>        dfs1(v, u);</span>
<span id="cb2-16"><a aria-hidden="true" href="#cb2-16"></a>        chkmin(f[u], f[v] + w);</span>
<span id="cb2-17"><a aria-hidden="true" href="#cb2-17"></a>    }</span>
<span id="cb2-18"><a aria-hidden="true" href="#cb2-18"></a>    <span class="cf">return</span>;</span>
<span id="cb2-19"><a aria-hidden="true" href="#cb2-19"></a>}</span>
<span id="cb2-20"><a aria-hidden="true" href="#cb2-20"></a></span>
<span id="cb2-21"><a aria-hidden="true" href="#cb2-21"></a><span class="dt">void</span> dfs2(<span class="dt">int</span> u, <span class="dt">int</span> fa, ll _mv) {</span>
<span id="cb2-22"><a aria-hidden="true" href="#cb2-22"></a>    <span class="dt">int</span> mx = u;</span>
<span id="cb2-23"><a aria-hidden="true" href="#cb2-23"></a>    ll mv = min(a[u], _mv), h = <span class="fl">1e18</span>;</span>
<span id="cb2-24"><a aria-hidden="true" href="#cb2-24"></a>    <span class="cf">for</span> (<span class="kw">auto</span> &amp;e : G[u]) <span class="cf">if</span> (e.to != fa) {</span>
<span id="cb2-25"><a aria-hidden="true" href="#cb2-25"></a>        <span class="dt">int</span> &amp;v = e.to; ll &amp;w = e.w;</span>
<span id="cb2-26"><a aria-hidden="true" href="#cb2-26"></a>        <span class="cf">if</span> (f[v] + w &lt; mv) mx = v, h = mv, mv = f[v] + w;</span>
<span id="cb2-27"><a aria-hidden="true" href="#cb2-27"></a>        <span class="cf">else</span> <span class="cf">if</span> (f[v] + w &lt; h) h = f[v] + w;</span>
<span id="cb2-28"><a aria-hidden="true" href="#cb2-28"></a>    }</span>
<span id="cb2-29"><a aria-hidden="true" href="#cb2-29"></a>    <span class="cf">for</span> (<span class="kw">auto</span> &amp;e : G[u]) <span class="cf">if</span> (e.to != fa) {</span>
<span id="cb2-30"><a aria-hidden="true" href="#cb2-30"></a>        <span class="dt">int</span> &amp;v = e.to; ll &amp;w = e.w;</span>
<span id="cb2-31"><a aria-hidden="true" href="#cb2-31"></a>        ll now = (v == mx ? h : mv);</span>
<span id="cb2-32"><a aria-hidden="true" href="#cb2-32"></a>        ll val = min(now, f[v]) + w;</span>
<span id="cb2-33"><a aria-hidden="true" href="#cb2-33"></a>        <span class="cf">if</span> (val &gt; ans) ans = val, cnt = <span class="dv">1</span>;</span>
<span id="cb2-34"><a aria-hidden="true" href="#cb2-34"></a>        <span class="cf">else</span> <span class="cf">if</span> (val == ans) ++cnt;</span>
<span id="cb2-35"><a aria-hidden="true" href="#cb2-35"></a>        dfs2(v, u, now + w);</span>
<span id="cb2-36"><a aria-hidden="true" href="#cb2-36"></a>    }</span>
<span id="cb2-37"><a aria-hidden="true" href="#cb2-37"></a>    <span class="cf">return</span>;</span>
<span id="cb2-38"><a aria-hidden="true" href="#cb2-38"></a>}</span>
<span id="cb2-39"><a aria-hidden="true" href="#cb2-39"></a></span>
<span id="cb2-40"><a aria-hidden="true" href="#cb2-40"></a><span class="dt">int</span> main() {</span>
<span id="cb2-41"><a aria-hidden="true" href="#cb2-41"></a>    fileIn(<span class="st">"tree.in"</span>);</span>
<span id="cb2-42"><a aria-hidden="true" href="#cb2-42"></a>    fileOut(<span class="st">"tree.out"</span>);</span>
<span id="cb2-43"><a aria-hidden="true" href="#cb2-43"></a>    is &gt;&gt; n;</span>
<span id="cb2-44"><a aria-hidden="true" href="#cb2-44"></a>    FOR(i, <span class="dv">1</span>, n) is &gt;&gt; a[i];</span>
<span id="cb2-45"><a aria-hidden="true" href="#cb2-45"></a>    FOR(i, <span class="dv">2</span>, n) {</span>
<span id="cb2-46"><a aria-hidden="true" href="#cb2-46"></a>        <span class="dt">int</span> u, v, w;</span>
<span id="cb2-47"><a aria-hidden="true" href="#cb2-47"></a>        is &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span>
<span id="cb2-48"><a aria-hidden="true" href="#cb2-48"></a>        G[u].push_back(Edge(v, w));</span>
<span id="cb2-49"><a aria-hidden="true" href="#cb2-49"></a>        G[v].push_back(Edge(u, w));</span>
<span id="cb2-50"><a aria-hidden="true" href="#cb2-50"></a>    }</span>
<span id="cb2-51"><a aria-hidden="true" href="#cb2-51"></a>    dfs1(<span class="dv">1</span>, <span class="dv">0</span>);</span>
<span id="cb2-52"><a aria-hidden="true" href="#cb2-52"></a>    dfs2(<span class="dv">1</span>, <span class="dv">0</span>, <span class="fl">1e18</span>);</span>
<span id="cb2-53"><a aria-hidden="true" href="#cb2-53"></a>    os &lt;&lt; ans &lt;&lt; <span class="ch">' '</span> &lt;&lt; cnt;</span>
<span id="cb2-54"><a aria-hidden="true" href="#cb2-54"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb2-55"><a aria-hidden="true" href="#cb2-55"></a>}</span></code></pre></div>
<h3 id="c-序列计数">C 序列计数</h3>
<p>一个 <span class="math inline">\(n\times m\)</span> 的 <span class="math inline">\(0-1\)</span> 矩阵 <span class="math inline">\(C\)</span>。现想生成两个长度分别为 <span class="math inline">\(n\)</span> 和 <span class="math inline">\(m\)</span> 且值域 <span class="math inline">\([0, k]\)</span> 的数组 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span>。要求 <span class="math inline">\(\forall 1\le i\le n,1\le j\le m\)</span>，都满足若 <span class="math inline">\(C_{i,j} = 0\)</span> 则 <span class="math inline">\(A_i + B_j \le k\)</span>，若 <span class="math inline">\(C_{i,j} = 1\)</span> 则 <span class="math inline">\(A_i + B_j\ge k\)</span>。对可能的 <span class="math inline">\((A,B)\)</span> 计数，答案模 <span class="math inline">\(998244353\)</span>，<span class="math inline">\(n,m\le 3000\)</span>，<span class="math inline">\(k\le 100\)</span>。</p>
<p>令 <span class="math inline">\(B_i'\leftarrow k - B_i\)</span>，则 <span class="math inline">\(C\)</span> 矩阵变成了一个描述 <span class="math inline">\(A_i\)</span> 和 <span class="math inline">\(B_j'\)</span> 大小关系的一个矩阵。 下文令 <span class="math inline">\(B_i\leftarrow B'_i\)</span>。</p>
<h2 id="xjoi-d20">XJOI D20</h2>
<h3 id="b-萌萌计数题">B 萌萌计数题</h3>
<p>给定 <span class="math inline">\(n,k\)</span>，随机生成排列 <span class="math inline">\(\pi\)</span>，问逆序对数 <span class="math inline">\(\operatorname{inv}(\pi)^k\)</span> 的期望。<span class="math inline">\(n\le 10^9,k\le 10^5\)</span>。</p>
<h2 id="xjoi-d21">XJOI D21</h2>
<h3 id="a-加边">A 加边</h3>
<p>首先一棵树加边后要变成边双连通分量的充要条件是这些边对应的树链能将整棵树覆盖完。</p>
<h3 id="b-加零">B 加零</h3>
<p>定义 <span class="math inline">\(1\)</span> 阶斐波那契数列 <span class="math inline">\(F_1\)</span>： <span class="math display">\[
F_{1,0} =1 , F_{1,1} = 1\\
F_{1,i} = F_{1,i-1} + F_{1,i-2}
\]</span> 在此基础上定义 <span class="math inline">\(k\)</span> 阶斐波那契数列 <span class="math inline">\(F_k\)</span>： <span class="math display">\[
F_{k,0} = 1, F_{k,1} = F_{k-1,1} + F_{k,0}\\
F_{k,i} = F_{k-1,i} + F_{k,i - 1} + F_{k,i - 2}
\]</span> 求 <span class="math inline">\(F_{k,n}\bmod 469762049\)</span>。其中 <span class="math inline">\(469762049\)</span> 为 NTT 模数，<span class="math inline">\(g=3\)</span>，且 <span class="math inline">\(\sqrt 5\equiv 13845527\pmod{469762049}\)</span>。<span class="math inline">\(1\le k\le 10^7\)</span>，<span class="math inline">\(10\le \lg n\le 10^5\)</span>。</p>
<p>注意到 <span class="math inline">\(F_k\)</span> 的本质就是 <span class="math inline">\(F_{k-1}\)</span> 卷上 <span class="math inline">\(F_1\)</span>。所以我们要求的就是 <span class="math inline">\(\displaystyle[x^n]\frac{1}{(1-x-x^2)^k}\)</span>。 <span class="math display">\[
\begin{aligned}
&amp;\left[x^n\right] \frac{1}{(1-x-x^2)^k}\\
=&amp;[x^n]\frac{1}{(1-\lambda_1x)^k}\frac{1}{(1-\lambda_2x)^k}\\
=&amp;\sum_{i=0}^n\binom{i+K}{K}\binom{n-i+K}{K}\lambda_1^i\lambda_2^{n-i}&amp;&amp;\text{let }K = k + 1\\
=&amp;\frac{\lambda_2^n}{(K!)^2}\sum_{i=0}^n(i+K)^{\underline K}(n-i+K)^{\underline K}q^i&amp;&amp;\text{let }q = \frac{\lambda_1}{\lambda_2}\\
=&amp;C \sum_{i=0}^n(i+K)^{\underline K}(i-n-1)^{\underline K}q^i&amp;&amp;\text{let }C = \frac{\lambda_2^n(-1)^k}{(K!)^2}\\
=&amp;C\sum_{i=0}^n(i+K)^{\underline K}q_i\sum_{j=0}^K\binom Kji^{\underline j}(-n-1)^{\underline{K-j}}\\
=&amp;C\sum_{j=0}^n\binom Kj(-n-1)^{\underline{K - j}}\sum_{i=0}^n(i+K)^{\underline{K+j}}q^i
\end{aligned}
\]</span> 令 <span class="math inline">\(S_p = \displaystyle\sum_{i=0}^n(i+K)^{\underline p}q^i\)</span>，这个东西可以递推： <span class="math display">\[
\begin{aligned}
S_p &amp;= \sum_{i=0}^n(i+K)^{\underline p}q^i\\
&amp;= \sum_{i=0}^n(i+K-1)^{\underline p}q^i+p(i+K-1)^{\underline{p-1}}q^i\\
&amp;= 
\end{aligned}
\]</span> 后面不会了，告辞。</p>
<h3 id="c-嘉然">C 嘉然</h3>
<p>给定长为 <span class="math inline">\(n\)</span> 的排列 <span class="math inline">\(p\)</span>，<span class="math inline">\(q\)</span> 次询问。每次询问给定 <span class="math inline">\(l,r\)</span>，求 <span class="math display">\[
\max_{l\le i&lt; j\le r}\varphi(p_i\times p_j)
\]</span> 首先有恒等式 <span class="math inline">\(\displaystyle\varphi(ab) = \varphi(a)\varphi(b)\frac{\gcd(a,b)}{\varphi(\gcd(a,b))}\)</span>。那么就考虑枚举 <span class="math inline">\(d = \gcd(p_i, p_j)\)</span>，发现若对于 <span class="math inline">\(\gcd(p_i, p_j) = g\)</span>，而枚举的 <span class="math inline">\(d\)</span> 是 <span class="math inline">\(g\)</span> 的因数，则算出来的 <span class="math inline">\(\varphi(p_i)\varphi(p_j)\frac{d}{\varphi(d)}\)</span> 不会大于真实结果。所以对于一次询问，枚举 <span class="math inline">\(d\)</span>，然后在区间内拿出 <span class="math inline">\(d\)</span> 的所有倍数，直接按照 <span class="math inline">\(\varphi(p_ip_j) = \varphi(p_i)\varphi(p_j)\frac{d}{\varphi(d)}\)</span> 计算，一定能得到答案，由于是排列，所有 <span class="math inline">\(d\)</span> 的倍数个数和是 <span class="math inline">\(O(n\ln n)\)</span> 的，所以复杂度 <span class="math inline">\(O(qn\ln n)\)</span>。</p>
<p>枚举 <span class="math inline">\(d\)</span> 的时候，我们可以将所有 <span class="math inline">\(d\mid p_i\)</span> 和 <span class="math inline">\(d\mid p_j\)</span> 的 <span class="math inline">\((i,j)\)</span> 对拿出来，然后计算其贡献 <span class="math inline">\(v = \varphi(p_i)\varphi(p_j)\frac{d}{\varphi(d)}\)</span>，抽象成三元组 <span class="math inline">\((i,j,v)\)</span>。于是每次询问就只需要找到 <span class="math inline">\(l\le i&lt;j\le r\)</span> 的三元组中 <span class="math inline">\(v\)</span> 最大的一个，可以通过排序 + 扫描线实现。</p>
<p>这样做的话会发现无用的三元组个数很多，注意到 <span class="math inline">\(d\)</span> 确定时 <span class="math inline">\(v\)</span> 的大小只与 <span class="math inline">\(\varphi(p_i)\)</span> 和 <span class="math inline">\(\varphi(p_j)\)</span> 有关。考虑枚举较小的一个，设为 <span class="math inline">\(p_i\)</span>，那么有一个关键结论：三元组中的 <span class="math inline">\(j\)</span> 只可能是 <span class="math inline">\(i\)</span> 左边第一个 <span class="math inline">\(\varphi(p_j)\ge \varphi(p_i)\)</span> 的 <span class="math inline">\(j\)</span> 或者 <span class="math inline">\(i\)</span> 右边第一个 <span class="math inline">\(\varphi(p_j)\ge \varphi(p_i)\)</span> 的 <span class="math inline">\(j\)</span>。</p>
<p>先考虑 <span class="math inline">\(j&lt;i\)</span>，<span class="math inline">\(\varphi(p_j)\ge \varphi(p_i)\)</span>，且 <span class="math inline">\(\exist k\in (j,i)\)</span> 满足 <span class="math inline">\(\varphi(p_k)\ge \varphi(p_i)\)</span>，则 <span class="math inline">\(j,k\)</span> 构成的三元组的 <span class="math inline">\(v\)</span> 一定不小于 <span class="math inline">\(i,j\)</span> 构成的三元组的 <span class="math inline">\(v\)</span>，且 <span class="math inline">\((j,k)\)</span> 被 <span class="math inline">\((j,i)\)</span> 完全包含，一定更容易被 <span class="math inline">\((l,r)\)</span> 包含。<span class="math inline">\(j&gt;i\)</span> 同理。</p>
<p>那么就枚举 <span class="math inline">\(d\)</span>，然后用单调栈找每个 <span class="math inline">\(i\)</span> 的 <span class="math inline">\(j_L\)</span> 和 <span class="math inline">\(j_R\)</span>，然后只记录 <span class="math inline">\((j_L, i)\)</span> 和 <span class="math inline">\((i, j_R)\)</span> 所在的三元组，有用的三元组就是 <span class="math inline">\(O(n\ln n)\)</span> 级别的了，总时间复杂度 <span class="math inline">\(O(n\ln n + q)\log n\)</span>。</p>
<h2 id="xjoi-d22">XJOI D22</h2>
<h3 id="a-复盘">A 复盘</h3>
<p>见<a href="/sol-cf1033g">CF1033G</a>。</p>
<h3 id="b-王位之争">B 王位之争</h3>
<p>长度为 <span class="math inline">\(n\)</span> 的字符串 <span class="math inline">\(s\)</span>，考虑其所有本质不同子串 <span class="math inline">\(t\)</span>。对于 <span class="math inline">\(t\)</span> 的每一个前缀 <span class="math inline">\(p\)</span>，若其也是另一个长度为 <span class="math inline">\(|t|\)</span> 且 <span class="math inline">\(\ne t\)</span> 的子串 <span class="math inline">\(u\)</span> 的前缀，则 <span class="math inline">\(p\)</span> 对于 <span class="math inline">\(t\)</span> 产生 <span class="math inline">\(1\)</span> 的贡献。求长为偶数的 <span class="math inline">\(p\)</span> 的贡献减去长为奇数的 <span class="math inline">\(p\)</span> 的贡献。</p>
<p>对于 <span class="math inline">\(n\le 2000\)</span> 的情况，首先可以将所有的后缀插入一棵 Trie 树（哦好像就是后缀树但问题不大），然后遍历每一个节点（枚举 <span class="math inline">\(p\)</span>）然后考虑枚举 <span class="math inline">\(u\)</span>，发现实际上要求的就是在对应深度至少有两个子节点，这个可能可以用长链剖分或者 bitset 什么维护一下，时间复杂度我觉得能过。于是真的踏马能过。</p>
<p>正解是用对反串建 SAM 来得到后缀树，统计没有贡献的节点，</p>
<h3 id="c-数论题">C 数论题</h3>
<p>定义序列 <span class="math inline">\(a\)</span> 是好的当且仅当 <span class="math inline">\(\forall a_i,a_i\in[1,m]\cap\mathbb Z\)</span>，且 <span class="math inline">\(\forall i,\forall j&lt;i, a_j\mid a_i\)</span>。定义一个序列的权值是序列中所有数的乘积。两种询问：</p>
<ul>
<li>求所有长度为 <span class="math inline">\(n\)</span> 的好序列的权值之和。</li>
<li>求所有长度为 <span class="math inline">\(n\)</span> 且以 <span class="math inline">\(x\)</span>（<span class="math inline">\(x\)</span> 为质数的整数次幂）结尾的好序列的权值之和。</li>
</ul>
<p>答案模 <span class="math inline">\(10^9 + 7\)</span>，<span class="math inline">\(1\le n\le 10^9\)</span>，<span class="math inline">\(1\le m\le 10^7\)</span>。</p>
<p>显然有 <span class="math inline">\(O(nm\log m)\)</span> 的 dp：<span class="math inline">\(f_{i,j}\)</span> 表示长 <span class="math inline">\(i\)</span>，<span class="math inline">\(j\)</span> 结尾的好序列权值之和，则 <span class="math display">\[
f_{i,j} = j\times \sum_{k\mid j}f_{i - 1,k }
\]</span> 暴力转移有 <span class="math inline">\(20\)</span> 分。</p>
<p>然后对于 <span class="math inline">\(n,m\le 10^5\)</span> 的询问二，可以改状态为 <span class="math inline">\(f_{i,j}\)</span>：长度为 <span class="math inline">\(i\)</span>，以 <span class="math inline">\(p^j\)</span> 结尾的好序列权值之和，时间复杂度 <span class="math inline">\(O(n\log^2m)\)</span>。</p>
<p>而对于 <span class="math inline">\(n,m\le 10^7\)</span>，写出转移方程： <span class="math display">\[
f_{i,j} = p^j\times \sum_{k\le j}f_{i - 1, k}
\]</span> 考虑其生成函数，设 <span class="math inline">\([z^m]F_n(z) = f_{n,m}\)</span>，在上面的转移中将 <span class="math inline">\(p^j\)</span> 拆成 <span class="math inline">\(p^kp^{j-k}\)</span> 之后将 <span class="math inline">\(p^k\)</span> 分配到求和号内， <span class="math display">\[
f_{i,j} = \sum_{k\le j}f_{i-1,k}p^kp^{j-k}
\]</span> 所以 <span class="math display">\[
[z^j]F_i(z) = \sum_{k=0}^j[z^k]F_{i-1}(pz)p^{j-k}
\]</span> 这个东西是一个卷积的形式，所以 <span class="math display">\[
F_i(z) = \frac{F_{i-1}(pz)}{1-pz} = \prod_{j\le i}\frac{1}{1-p^jz} = \frac{F_{i-1}(z)}{1-p^iz}
\]</span></p>
<p>所以 <span class="math display">\[
F_{n}(pz)(1-p^{n+1}z) = F_{n}(z)(1-pz)
\]</span> 拆开， <span class="math display">\[
\begin{aligned}
F_n(pz) - p^{n+1}zF_n(pz) &amp;= F_n(z) - pzF_n(z)\\
f_{n, i}p^i - p^{n+i}f_{n,i-1} &amp;= f_{n,i} - pf_{n,i -1}\\
f_{n,i} &amp;= f_{n,i-1}\times\frac{p^{n+i} - p}{p^i - 1}
\end{aligned}
\]</span> 所以对于质数幂处的值，可以递推。</p>
<p>回顾一开始的转移方程，发现其就为 <span class="math display">\[
f_{i,j} = j\times \sum_{k\mid j}f_{i-1,k}
\]</span> 可以发现 <span class="math inline">\(f_i = \mathrm{id}\cdot (f_{i-1}*1)\)</span>，而 <span class="math inline">\(f_0 = [x=1]\)</span>，所以每个 <span class="math inline">\(f_i\)</span> 都是积性函数，所以可以线性筛。</p>
<h2 id="xjoi-d25">XJOI D25</h2>
<h3 id="a-星海">A 星海</h3>
<p>首先令 <span class="math inline">\(a_i\leftarrow a_i - i\)</span>，然后严格递增就变成了非严格递增，考虑其差分数组 <span class="math inline">\(d_i = a_i - a_{i-1}\)</span>，最终目的就是让所有 <span class="math inline">\(d_i\)</span> 变为 <span class="math inline">\(0\)</span>。每次操作可以让 <span class="math inline">\(d_i\leftarrow d_i -x\)</span> 然后让 <span class="math inline">\(d_{i+1}\leftarrow d_{i+1} + x\)</span>，特别地对于 <span class="math inline">\(i=n\)</span> 只有 <span class="math inline">\(d_n \leftarrow d_n - x\)</span>。</p>
<p>然后就是我学不会的神秘结论：</p>
<ul>
<li><span class="math inline">\(n\)</span> 为奇数时，令 <span class="math inline">\(x = d_1\oplus d_3\oplus \cdots \oplus d_n\)</span>；</li>
<li><span class="math inline">\(n\)</span> 为偶数时，令 <span class="math inline">\(x = d_2\oplus d_4\oplus\cdots \oplus d_n\)</span>；</li>
</ul>
<p>若 <span class="math inline">\(x = 0\)</span> 则先手必败，证明：</p>
<p>考虑一次操作涉及相邻的两个数，所以必败态无法走向必败态。记 <span class="math inline">\(\operatorname{highbit}(x)\)</span> 表示二进制中 <span class="math inline">\(x\)</span> 的最高位，则对于一个必胜态，判定式中的 <span class="math inline">\(d\)</span> 必然至少一个在 <span class="math inline">\(\operatorname{highbit}(x)\)</span> 位上为 <span class="math inline">\(1\)</span>，找到一个这样的 <span class="math inline">\(d_q\)</span>，那么判定式中其他成员的异或和即为 <span class="math inline">\(x' = x\oplus d_q\)</span>。</p>
<p>发现 <span class="math inline">\(x'&lt; d_q\)</span>，所以存在 <span class="math inline">\(\Delta = d_q - x'&gt; 0\)</span>，这便能指引新的判定式变为 <span class="math inline">\(x'\oplus x' = 0\)</span>，走向一个必败态。证毕。</p>
<h3 id="b-卷怪">B 卷怪</h3>
<h2 id="xjoi-d27">XJOI D27</h2>
<h3 id="a-高维游走">A 高维游走</h3>
<p><span class="math display">\[
\sum_{s\ge 0}\left(\left(\sum_{\sum c_i i = s}\binom{t_0}{c_1,c_2,\cdots, c_m }\prod_{i=1}^m\binom{t_i}{c_i}\right)\bmod 2\right)
\]</span></p>
<h2 id="xjoi-tp1done">XJOI TP1（Done）</h2>
<h3 id="a-求解">A 求解</h3>
<p>随机序列 <span class="math inline">\(a_i\)</span>，找到 <span class="math inline">\(k\)</span> 个非空不交区间使得 <span class="math display">\[
\bigoplus_{i=1}^k\bigoplus_{j=l_i}^{r_i}a_j = p
\]</span> <span class="math inline">\(T\)</span> 组询问，<span class="math inline">\(1\le k\le n\le 64\)</span>，<span class="math inline">\(a_i\in[0, 2^{64})\)</span>。</p>
<p>注意到 <span class="math inline">\(a_i\)</span> 随机，所以线性基会比较满。那么线性基外面的元素就很少，直接枚举外面的元素选了啥，然后往线性基里面斗出另外要选的元素看满不满足 <span class="math inline">\(k\)</span> 的限制即可。</p>
<p>好难写啊，你妈的。</p>
<h3 id="b-求值">B 求值</h3>
<p>给定长度为 <span class="math inline">\(n\le 5\times 10^5\)</span> 的正整数序列 <span class="math inline">\(\langle a_n\rangle\)</span>。对于一个置换 <span class="math inline">\(p\)</span>，定义其价值 <span class="math inline">\(f(p)\)</span> 为其每个轮换内最小的 <span class="math inline">\(a_i\)</span> 之积。定义 <span class="math inline">\(b_i\)</span> 表示有 <span class="math inline">\(i\)</span> 个轮换的置换的价值之和，求 <span class="math inline">\(\gcd\limits_{i=1}^n\{b_i\}\bmod 998244353\)</span>。</p>
<p>分成圆排列，考虑第一类斯特林数，将其递推式内新建圆排列的系数改成此圆排列的最小值即可。本题中可以将 <span class="math inline">\(a\)</span> 升序排序，然后 <span class="math inline">\(f_{i,j} = a_if_{i-1,j-1} + (i-1)f_{i-1,j}\)</span>。</p>
<p>则 <span class="math inline">\(f_{n,i}\)</span> 的 GF 为 <span class="math inline">\(\prod\limits_{i=1}^n(a_iz + i - 1)\)</span>。然后有结论：若有多项式 <span class="math inline">\(P(z),Q(z)\)</span> 和函数 <span class="math inline">\(c(P(z)) = \gcd\limits_i\{[z^i]P(z)\}\)</span>，则 <span class="math inline">\(c(P(z)Q(z)) = c(P(z))c(Q(z))\)</span>。本题答案即为 <span class="math inline">\(\prod\limits_{i=1}^n\gcd(a_i, i - 1)\)</span>。</p>
<p>证明可以考虑反证，证明 <span class="math inline">\(c(P) = c(Q) = 1\)</span> 时 <span class="math inline">\(c(PQ) = 1\)</span> 即可。</p>
<h3 id="c-求和">C 求和</h3>
<p>给定两个长度为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(A,B\)</span>。可以选择若干 <span class="math inline">\(i\)</span> 并交换 <span class="math inline">\(A_i, B_i\)</span>。最大化 <span class="math inline">\(\sum\limits_{i=1}^n\sum\limits_{j=1}^n\min(A_i,B_j)\)</span>。并构造方案。</p>
<p>奇怪套路题。</p>
<p>假设 <span class="math inline">\(a_i\le b_i\)</span>。讨论 <span class="math inline">\(a_i,b_i,a_j,b_j\)</span> 的贡献。</p>
<ul>
<li>若 <span class="math inline">\(a_i\le b_i\le a_j\le b_j\)</span>，交换某一组 <span class="math inline">\(a,b\)</span> 后答案不变。</li>
<li>若 <span class="math inline">\(a_i\le a_j\le b_i\le b_j\)</span>，交换后答案增加 <span class="math inline">\(b_i - a_j\)</span>。</li>
<li>若 <span class="math inline">\(a_i\le a_j\le b_j\le b_i\)</span>，交换后答案增加 <span class="math inline">\(b_j - a_j\)</span>。</li>
</ul>
<p>即，交换一组 <span class="math inline">\(a,b\)</span> 后，<span class="math inline">\((a_i,b_i)\)</span> 和 <span class="math inline">\((a_j,b_j)\)</span> 的贡献会加上这两条线段的交的大小。所以现在问题变为将 <span class="math inline">\(n\)</span> 条线段染色，使得每一对异色线段的交之和最大。</p>
<p>考虑每个连续段，若其被覆盖了 <span class="math inline">\(k\)</span> 次，则其能贡献 <span class="math inline">\(len\times\lceil k / 2\rceil\times\lfloor k / 2\rfloor\)</span>，下面构造这个上界。</p>
<p>若某个小段被覆盖奇数次，则额外连一条边。这样所有点的度数都为偶数，跑个欧拉回路，被覆盖了 <span class="math inline">\(k\)</span> 次的小段会被从左往右走 <span class="math inline">\(k/2\)</span> 次，从右往左走 <span class="math inline">\(k/2\)</span> 次。而他只会被额外边覆盖一次，将左往右的边染成黑色，右往左的边染成白色，上界即可达到。</p>
<h2 id="xjoi-noi-d14">XJOI NOI D14</h2>
<h3 id="b-可怜">B 可怜</h3>
<h2 id="实验舱-7.21">实验舱 7.21</h2>
<h3 id="a-平面嵌入">A 平面嵌入</h3>
<h3 id="b-序列">B 序列</h3>
<p>方案很好构造，直接莫队即可。</p>
<h3 id="c-划分">C 划分</h3>
<h2 id="实验舱-7.22">实验舱 7.22</h2>
<h3 id="a-集合">A 集合</h3>
<p>题意：设 <span class="math inline">\([n] = \{1,2,\cdots, n\}\)</span>，设 <span class="math inline">\(F(S) = T^{\min S}\)</span>，求 <span class="math inline">\(E[F(S)\mid S\subseteq[n], |S|=k]\)</span>，模 <span class="math inline">\(M = 998244353\)</span>，<span class="math inline">\(1\le k\le n&lt;M\)</span>，<span class="math inline">\(k\le 10^7\)</span>。</p>
<p>枚举最小值容易得到 <span class="math display">\[
\sum_{i=1}^{n}T^i\binom{n-i}{k-1}
\]</span> 当然这个算法是 <span class="math inline">\(O(n)\)</span> 的，观察数据范围发现我们想要的是一个 <span class="math inline">\(O(k)\)</span> 的递推式。设 <span class="math inline">\(A_k = \sum\limits_{i=1}^{n}T^i\binom{n-i}{k-1}\)</span>，注意到组合数的下标全部是 <span class="math inline">\(k-1\)</span>，那么我们自然希望找到一个组合数下标为 <span class="math inline">\(k\)</span> 的形式来方便代入。枚举最小值至少是多少，简单容斥一下得到： <span class="math display">\[
\begin{aligned}
A_{k-1} &amp;= T\binom n {k-1} + \sum_{i=2}^{n}(T^i - T^{i-1})\binom{n-i + 1}{k-1}\\
&amp;=T\binom{n}{k-1} + \sum_{i=1}^{n-1}(T-1)T^{i}\binom{n-i}{k-1}
\end{aligned}
\]</span> 然后注意到上面可以代入下面，注意到 <span class="math inline">\(k&gt;1\)</span> 的时候第 <span class="math inline">\(n\)</span> 项没有贡献： <span class="math display">\[
A_{k-1} = T\binom{n}{k-1} + (T-1)A_k
\]</span> 递推式就有了： <span class="math display">\[
\begin{aligned}
A_k &amp;= \frac{1}{T-1}\left(A_{k-1}-T\binom{n}{k-1}\right)\\
A_1 &amp;= \sum_{i=1}^nT^i = \frac{T(1-T^n)}{1-T}
\end{aligned}
\]</span> 直接推就行了。细节：线性筛逆元，<span class="math inline">\(\dbinom ni = \dfrac{n-i+1}{i}\dbinom{n}{i-1}\)</span>。</p>
<h3 id="b">B</h3>
<h3 id="c">C</h3>
<h2 id="实验舱-7.23">实验舱 7.23</h2>
<p>Rushcheyo Round，orz rushcheyo。</p>
<h3 id="a-covering">A Covering</h3>
<p>题意：<span class="math inline">\(n\le 5\times 10^5\)</span> 个点，<span class="math inline">\(q\le 5000\)</span>，区间询问最小圆覆盖，<span class="math inline">\(\varepsilon = 10^{-4}\)</span>。</p>
<p><span class="math inline">\(60\)</span> 分暴力还算良心（</p>
<p>本题的切入点在于 <span class="math inline">\(\varepsilon\)</span> 特别大，因此可以使用 coreset 近似方法来将点的规模缩减到能接受的范围内。</p>
<p>考虑点集 <span class="math inline">\(S\)</span>，均匀取 <span class="math inline">\(k=\dfrac{\pi}{\sqrt\varepsilon}\)</span> 个单位向量，对每个单位向量 <span class="math inline">\(\boldsymbol v\)</span>，取 <span class="math inline">\(S\)</span> 中投影到 <span class="math inline">\(\boldsymbol v\)</span> 的两端点，这样 <span class="math inline">\(S\)</span> 就只剩下 <span class="math inline">\(O(\varepsilon^{-0.5})\)</span> 个点，记为 <span class="math inline">\(S\)</span> 的核心集 <span class="math inline">\(S'\)</span>，示意图：</p>
<figure>
<img alt="" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/syc0723_1.png"/><figcaption>syc0723_1</figcaption>
</figure>
<p>可以证明，<span class="math inline">\((1-\varepsilon)v(S)\le v(S')\le v(S)\)</span>。下面给出证明。</p>
<figure>
<img alt="" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/syc0723_2.png"/><figcaption>syc0723_2</figcaption>
</figure>
<p>考虑任意点 <span class="math inline">\(x\)</span>，设 <span class="math inline">\(z\)</span> 是 <span class="math inline">\(S\)</span> 中距离 <span class="math inline">\(x\)</span> 最远的点，找一个与 <span class="math inline">\(x\)</span> 夹角不超过 <span class="math inline">\(\sqrt\varepsilon\)</span> 的方向 <span class="math inline">\(\boldsymbol u_i\)</span>，设 <span class="math inline">\(z\)</span> 在上面投影为 <span class="math inline">\(z'\)</span>，则 <span class="math inline">\(S'\)</span> 中必然有一个点投影到 <span class="math inline">\(\boldsymbol u_i\)</span> 上介于 <span class="math inline">\(z'y\)</span> 之间。<span class="math inline">\(x\)</span> 到其距离至少为 <span class="math inline">\(d(x,z)\cos(\sqrt\varepsilon)\ge (1-\epsilon)d(x,z)\)</span>，证毕。</p>
<p>那么就使用数据结构维护区间核心集，查询的时候对其使用随机增量的最小圆覆盖算法，用时 <span class="math inline">\(O(k)\)</span>。拿线段树维护的时间复杂度大概是 <span class="math inline">\(O(nk + q\varepsilon^{-1/2}\log n)\)</span>。</p>
<h3 id="b-sorting">B Sorting</h3>
<p>题意：交互题，一个长度为 <span class="math inline">\(n\)</span> 的排列，逆序对数为 <span class="math inline">\(k\)</span>，要求在 <span class="math inline">\(M\)</span> 次内排好序，其中 <span class="math inline">\(M\)</span> 为 <span class="math inline">\(n\log(k/n)\)</span> 级别。</p>
<h3 id="c-factor">C Factor</h3>
<p>题意：<span class="math inline">\(T\le 10^4\)</span> 次询问，给定 <span class="math inline">\(n\le 9\times 10^{18}\)</span>，已知其为奇素数 <span class="math inline">\(p,q\)</span> 之积，且 <span class="math inline">\(q-p\le k\le 10^8\)</span>，求 <span class="math inline">\(p\)</span>。</p>
<h2 id="实验舱-7.24">实验舱 7.24</h2>
<h3 id="a-经典题">A 经典题</h3>
<p><span class="math display">\[
\sum_{i=1}^n\sum_{j=1}^n\gcd(a^i+1,a^j+1)
\]</span></p>
<p><span class="math inline">\(n,a\le 10^9\)</span>。</p>
<p>打了个表发现 <span class="math inline">\(\gcd\)</span> 一定在 <span class="math inline">\(a^k + 1\)</span> 和 <span class="math inline">\((a\bmod 2) + 1\)</span> 里面产生。并且 <span class="math inline">\(a^{kx} + 1~(k\bmod 2=1)\)</span> 一定是 <span class="math inline">\(a^x + 1\)</span> 的倍数。 <span class="math display">\[
\sum_{k=1}^n(a^k+1)\sum_{\substack{i\text{ is odd}\\i\le \lfloor n / k\rfloor}}\sum_{\substack{j\text{ is odd}\\j\le \lfloor n/k\rfloor}}[\gcd(a^{ik}+1, a^{jk}+1)=a^k+1]
\]</span> 再打个表发现一定有 <span class="math inline">\(\gcd(i, j) = 1\)</span>，很神奇，嗨嗨。而对于 <span class="math inline">\(\gcd = (a\bmod 2) + 1\)</span> 的情况，发现只有当 <span class="math inline">\(i/d\)</span> 和 <span class="math inline">\(j/d\)</span> 其中有一个是偶数的时候存在，这一部分的贡献就初始令 <span class="math inline">\(ans = n^2\)</span>，<span class="math inline">\(a^k+1\)</span> 的贡献就把 <span class="math inline">\(+1\)</span> 扔掉，然后如果 <span class="math inline">\(a\)</span> 为奇数的话为那些位置再贡献一波。</p>
<p>那么考虑 <span class="math inline">\(\gcd = a^{k} + 1\)</span> 的贡献： <span class="math display">\[
\begin{aligned}
&amp;\sum_{d=1}^na^d\sum_{\substack{i\text{ is odd}\\i\le \lfloor n / d\rfloor}}\sum_{\substack{j\text{ is odd}\\j\le \lfloor n/d\rfloor}}[\gcd(i,j)=1]\\
=&amp;\sum_{d=1}^na^d\sum_{k=1}^{\lfloor n / d\rfloor}\mu(k)\sum_{\substack{i\text{ is odd}\\i\le n / d}}\sum_{\substack{j\text{ is odd}\\j\le n/d}}[k\mid\gcd(i,j)]\\
=&amp;\sum_{d=1}^na^d\sum_{\substack{k\text{ is odd}\\k\le \lfloor n/d\rfloor }}\mu(k)g^2\left(\left\lfloor\frac{n}{dk}\right\rfloor\right)
\end{aligned}
\]</span> 其中 <span class="math inline">\(g(n)\)</span> 表示 <span class="math inline">\([1,n]\)</span> 内奇数个数，其等于 <span class="math inline">\(\left\lfloor\dfrac{n+1}{2}\right\rfloor\)</span>。设 <span class="math inline">\(f(d) = a^d\)</span>，然后对于右半边这个部分，令 <span class="math display">\[
F(x) =\sum_{\substack{k\text{ is odd}\\k\le x }}\mu(k)g^2\left(\left\lfloor\frac{x}{k}\right\rfloor\right)
\]</span> 则原式就是 <span class="math display">\[
\sum_{d=1}^nf(d)F\left(\left\lfloor\frac{n}{d}\right\rfloor\right)
\]</span> 一段 <span class="math inline">\(f(d)\)</span> 之和拿等比数列求和公式随便求一下，所以最外层可以整除分块，而若我们可以快速维护奇数位置上的 <span class="math inline">\(\mu\)</span> 的前缀和，则 <span class="math inline">\(F(x)\)</span> 也是可以整除分块的。整除分块套整除分块，复杂度大概是 <span class="math inline">\(O(n^{3/4})\)</span> 但应该能过。筛奇数位置上 <span class="math inline">\(\mu\)</span> 的前缀和可以递归。</p>
<h2 id="实验舱-7.26">实验舱 7.26</h2>
<h3 id="a-猫">A 猫</h3>
<p>原题。</p>
<h3 id="b-生成树">B 生成树</h3>
<p>萌萌构造，考虑这样一件事：我们考虑将 <span class="math inline">\(1\sim n\)</span> 连成一个环，然后随便删一条边即可得到一棵生成树。对于 <span class="math inline">\(u\)</span> 若 <span class="math inline">\((u-1,u)\)</span> 和 <span class="math inline">\((u,u+1)\)</span> 异色，则将 <span class="math inline">\(u\)</span> 删掉，再把 <span class="math inline">\(u-1\)</span> 和 <span class="math inline">\(u+1\)</span> 连起来，变成一个子问题，最后再把 <span class="math inline">\(u\)</span> 加回来。</p>
<p>栈维护，时间复杂度 <span class="math inline">\(O(n)\)</span>。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a aria-hidden="true" href="#cb3-1"></a><span class="kw">using</span> ll = <span class="dt">long</span> <span class="dt">long</span>;</span>
<span id="cb3-2"><a aria-hidden="true" href="#cb3-2"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="fl">5e5</span> + <span class="dv">5</span>;</span>
<span id="cb3-3"><a aria-hidden="true" href="#cb3-3"></a>unordered_map&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt; G[maxn];</span>
<span id="cb3-4"><a aria-hidden="true" href="#cb3-4"></a>ll x, y, z, p[maxn];</span>
<span id="cb3-5"><a aria-hidden="true" href="#cb3-5"></a><span class="dt">int</span> n, m;</span>
<span id="cb3-6"><a aria-hidden="true" href="#cb3-6"></a></span>
<span id="cb3-7"><a aria-hidden="true" href="#cb3-7"></a><span class="dt">int</span> query(<span class="dt">int</span> a, <span class="dt">int</span> b) {</span>
<span id="cb3-8"><a aria-hidden="true" href="#cb3-8"></a>    <span class="cf">if</span> (G[a].count(b)) <span class="cf">return</span> G[a][b];</span>
<span id="cb3-9"><a aria-hidden="true" href="#cb3-9"></a>    <span class="cf">else</span> <span class="cf">return</span> (min(a, b) * x + max(a, b) * y) % z &gt;= p[a] + p[b];</span>
<span id="cb3-10"><a aria-hidden="true" href="#cb3-10"></a>}</span>
<span id="cb3-11"><a aria-hidden="true" href="#cb3-11"></a></span>
<span id="cb3-12"><a aria-hidden="true" href="#cb3-12"></a><span class="dt">int</span> main() {</span>
<span id="cb3-13"><a aria-hidden="true" href="#cb3-13"></a>    is &gt;&gt; n &gt;&gt; m;</span>
<span id="cb3-14"><a aria-hidden="true" href="#cb3-14"></a>    FOR(i, <span class="dv">1</span>, m) {</span>
<span id="cb3-15"><a aria-hidden="true" href="#cb3-15"></a>        <span class="dt">int</span> a, b, c; is &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span>
<span id="cb3-16"><a aria-hidden="true" href="#cb3-16"></a>        G[a][b] = G[b][a] = c;</span>
<span id="cb3-17"><a aria-hidden="true" href="#cb3-17"></a>    }</span>
<span id="cb3-18"><a aria-hidden="true" href="#cb3-18"></a>    is &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span>
<span id="cb3-19"><a aria-hidden="true" href="#cb3-19"></a>    FOR(i, <span class="dv">1</span>, n) is &gt;&gt; p[i];</span>
<span id="cb3-20"><a aria-hidden="true" href="#cb3-20"></a>    stack&lt;<span class="dt">int</span>&gt; stk;</span>
<span id="cb3-21"><a aria-hidden="true" href="#cb3-21"></a>    vector&lt;pair&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt;&gt; ans[<span class="dv">2</span>];</span>
<span id="cb3-22"><a aria-hidden="true" href="#cb3-22"></a>    stk.push(<span class="dv">1</span>);</span>
<span id="cb3-23"><a aria-hidden="true" href="#cb3-23"></a>    <span class="dt">int</span> col = <span class="dv">0</span>;</span>
<span id="cb3-24"><a aria-hidden="true" href="#cb3-24"></a>    FOR(i, <span class="dv">2</span>, n) {</span>
<span id="cb3-25"><a aria-hidden="true" href="#cb3-25"></a>        <span class="cf">while</span> (!stk.empty()) {</span>
<span id="cb3-26"><a aria-hidden="true" href="#cb3-26"></a>            <span class="dt">int</span> u = stk.top();</span>
<span id="cb3-27"><a aria-hidden="true" href="#cb3-27"></a>            <span class="dt">int</span> c = query(u, i);</span>
<span id="cb3-28"><a aria-hidden="true" href="#cb3-28"></a>            ans[c].emplace_back(u, i);</span>
<span id="cb3-29"><a aria-hidden="true" href="#cb3-29"></a>            <span class="cf">if</span> (c ^ col) stk.pop();</span>
<span id="cb3-30"><a aria-hidden="true" href="#cb3-30"></a>            <span class="cf">else</span> <span class="cf">break</span>;</span>
<span id="cb3-31"><a aria-hidden="true" href="#cb3-31"></a>        }</span>
<span id="cb3-32"><a aria-hidden="true" href="#cb3-32"></a>        <span class="cf">if</span> (stk.empty()) col ^= <span class="dv">1</span>, stk.push(<span class="dv">1</span>);</span>
<span id="cb3-33"><a aria-hidden="true" href="#cb3-33"></a>        stk.push(i);</span>
<span id="cb3-34"><a aria-hidden="true" href="#cb3-34"></a>    }</span>
<span id="cb3-35"><a aria-hidden="true" href="#cb3-35"></a>    <span class="cf">if</span> (ans[col].size() != n - <span class="dv">1</span>) <span class="cf">return</span> os &lt;&lt; <span class="st">"No solution</span><span class="sc">\n</span><span class="st">"</span>, <span class="dv">0</span>;</span>
<span id="cb3-36"><a aria-hidden="true" href="#cb3-36"></a>    <span class="cf">else</span> {</span>
<span id="cb3-37"><a aria-hidden="true" href="#cb3-37"></a>        <span class="cf">for</span> (<span class="kw">auto</span> &amp;p : ans[col])</span>
<span id="cb3-38"><a aria-hidden="true" href="#cb3-38"></a>            os &lt;&lt; p.first &lt;&lt; <span class="ch">' '</span> &lt;&lt; p.second &lt;&lt; <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span>;</span>
<span id="cb3-39"><a aria-hidden="true" href="#cb3-39"></a>    }</span>
<span id="cb3-40"><a aria-hidden="true" href="#cb3-40"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb3-41"><a aria-hidden="true" href="#cb3-41"></a>}</span></code></pre></div>
<h3 id="c-打地鼠">C 打地鼠</h3>
<p><span class="math inline">\(n\times m\)</span> 的网格。给定地鼠的初态和目标态。打一次地鼠会使得其本身缩回去但是同行同列的都会全部冒出来。问初态能否到达目标态。<span class="math inline">\(n,m\le 1000\)</span>。</p>
<p>正着做很不好做，考虑倒着做。</p>
<p>令黑色表示缩下去，白色表示出头。正着的每次操作相当于每次选一个白的变黑，然后将整行整列变白。</p>
<p>而倒着做的话可以考虑令灰色为可能缩下去可能出头。</p>
<p>操作变成选一个黑色或灰色的，满足<strong>这行这列除了它没有黑色</strong>，然后把它变白然后整行整列变灰。</p>
<h2 id="实验舱-7.27">实验舱 7.27</h2>
<h3 id="b-mirror">B mirror</h3>
<p>首先 Mirror 序列也不过是若干个二元环和自环拼接在一起的结构。</p>
<p>结论：若 <span class="math inline">\(b\)</span> 为 <span class="math inline">\(a\)</span> 的子序列，则 <span class="math inline">\(\forall i &lt; j\)</span> 有 <span class="math inline">\(a_{b_i}&lt;a_{b_j}\)</span>。</p>
<p>证明：令 <span class="math inline">\(a_u = b_i\)</span>，<span class="math inline">\(a_v = b_j\)</span>，一定有 <span class="math inline">\(u&lt;v\)</span>，而 <span class="math inline">\(a_{b_i} = u, a_{b_j}=v\)</span>，所以 <span class="math inline">\(a_{b_i}&lt;a_{b_j}\)</span>。</p>
<p>所以这个取值有单调性什么的，枚举 <span class="math inline">\(0\le k\le m\)</span>，强制对于 <span class="math inline">\(i\le k\)</span> 满足 <span class="math inline">\(a_{b_i}\le m\)</span>，且对于 <span class="math inline">\(i&gt;k\)</span> 满足 <span class="math inline">\(a_{b_i}&gt;m\)</span>。</p>
<ul>
<li><p>考虑 <span class="math inline">\(i\le k\)</span> 的 <span class="math inline">\(a_{b_i}\)</span>，有 <span class="math inline">\(a_{b_i}\le m\)</span>。</p>
<p>由于对于 <span class="math inline">\(i&gt;k\)</span> 满足 <span class="math inline">\(a_{b_i}&gt;m\)</span>，所以对 <span class="math inline">\(i\le k\)</span>，<span class="math inline">\(a_{b_i}\)</span> 的取值必须在 <span class="math inline">\(b_j~(j\le k)\)</span> 里面。</p>
<p>填写方式是唯一的，暴力判一下即可。</p></li>
<li><p>考虑 <span class="math inline">\(i&gt;k\)</span> 的 <span class="math inline">\(a_{b_i}\)</span>，有 <span class="math inline">\(a_{b_i}&gt; m\)</span>。</p>
<p>因为对于 <span class="math inline">\(i&lt;j\)</span> 有 <span class="math inline">\(a_{b_i}&lt;a_{b_j}\)</span>，所以填写方式为 <span class="math inline">\(\dbinom{n-m}{m-k}\)</span>。即这些是前 <span class="math inline">\(m\)</span> 个里面和后面有“交换”的。</p></li>
<li><p>考虑 <span class="math inline">\(i&gt;m\)</span> 且 <span class="math inline">\(a_i&gt;m\)</span> 的位置，有 <span class="math inline">\(n-2m+k\)</span> 个。</p>
<p>答案之和位置有关，dp 一遍可以弄出来 <span class="math inline">\(f_n = f_{n-1} + (n-1)f_{n-2}\)</span>。</p></li>
</ul>
<p>时间复杂度 <span class="math inline">\(O(n+m^2)\)</span>。</p>
<h2 id="实验舱-7.28">实验舱 7.28</h2>
<h3 id="b-graph">B Graph</h3>
<p>转化成若干形如 <span class="math inline">\(x_i+x_j = z_{i,j}'\)</span>，<span class="math inline">\(x_i\le p_i\)</span> 的限制。</p>
<p>现在就是要分别最小化和最大化 <span class="math inline">\(\sum x_i\)</span>。这尼玛是不是可以转化成差分约束？</p>
<p>会发现如果我们钦定了一个 <span class="math inline">\(x_u\)</span> 的值之后，剩下的都会变成关于 <span class="math inline">\(x_u\)</span> 的一次函数表达式，这个在某个连通块内可以随缘预处理一下。</p>
<h3 id="c-树">C 树</h3>
<p>给你一棵 <span class="math inline">\(n\le 2000\)</span> 个点的树 <span class="math inline">\(A\)</span>，<span class="math inline">\(t\le 10000\)</span> 次询问，每次询问给你一棵 <span class="math inline">\(m\le 12\)</span> 个点的树 <span class="math inline">\(B\)</span>，问有多少个 <span class="math inline">\(A\)</span> 的连通子图和<span class="math inline">\(B\)</span> 同构，答案对 <span class="math inline">\(10^9+7\)</span> 取模。</p>
<p>首先 <span class="math inline">\(12\)</span> 个点的无标号有根树只有不到 <span class="math inline">\(8000\)</span> 棵，想到可以使用树哈希进行处理。先预处理出所有的无标号有根树，即考虑将叶子接到之前的树上然后哈希去重。之后处理出 <span class="math inline">\(tr_{i,j}\)</span> 表示将 <span class="math inline">\(j\)</span> 树接到 <span class="math inline">\(i\)</span> 的根上后得到哪棵树，由于 <span class="math inline">\(|i| + |j|\le 12\)</span> 所以大概也只有 <span class="math inline">\(10000\)</span> 来对这样的关系。</p>
<p>于是可以预处理一下 <span class="math inline">\(f_{u, i}\)</span> 表示 <span class="math inline">\(A\)</span> 的 <span class="math inline">\(u\)</span> 子树中抽出树 <span class="math inline">\(j\)</span> 的方案数，这个可以很容易的 dp。然后对于每个询问的 <span class="math inline">\(B\)</span>，枚举根并去重，然后对每个得到的树 <span class="math inline">\(i\)</span> 求 <span class="math inline">\(\sum_u f_{u, i}\)</span> 再加在一起即可。</p>
<p>树哈希调死我了，为什么会有问题。最小表示法才正确，但是喜提最劣解。</p>
<h2 id="实验舱-7.30">实验舱 7.30</h2>
<h3 id="a.-陶森特的实验室">A. 陶森特的实验室</h3>
<p>首先应该可以跑一个边双缩点，因为显然只有割了桥之后才可能出现问题。然后对于每个连通块（树）来考虑。</p>
<p>设 <span class="math inline">\(f_{i,j}\)</span> 为 <span class="math inline">\(i\)</span> 子树内颜色 <span class="math inline">\(j\)</span> 的个数，随便推一下可以推出来，然后求出 <span class="math inline">\(f_{1,\cdots}\)</span> 后应该是可以求出 <span class="math inline">\(g_{i,\cdots}\)</span> 表示子树外的。</p>
<p>发现我们要断开一条边，然后取 <span class="math inline">\(\max_i\{f_{u,i}\} + \max_i\{g_{u,i}\}\)</span>。这个东西不是很知道可以怎么处理啊。。。</p>
<p>好哦，最后是 dsu on tree。多测出题人我祝你全家健康。</p>
<h3 id="b.-诺维格瑞的街道">B. 诺维格瑞的街道</h3>
<p>题意：给定若干点到 <span class="math inline">\((0,0)\)</span> 的欧氏距离 <span class="math inline">\(e_i\)</span>，满足 <span class="math inline">\(e_i\le e_{i+1}\)</span>。要求构造一组方案，使得其曼哈顿距离 <span class="math inline">\(t_i\)</span> 的序列中逆序对数量最大。</p>
<p>首先显然 <span class="math inline">\(e_i\le t_i\le \sqrt 2e_i\)</span>。然后由调整法可以证明最优答案中的 <span class="math inline">\(t_i\)</span> 一定呈若干下降的段。即在各自段内 <span class="math inline">\(t_i&gt;t_{i+1}\)</span>。</p>
<p>所以可以捏一个 dp：<span class="math inline">\(f_i\)</span> 表示 <span class="math inline">\([1,i]\)</span> 的答案。转移： <span class="math display">\[
f_i = \max_{e_i&lt;\sqrt2e_{j+1}}\left\{f_j + \dfrac{(i-j)(i-j-1)}{2}\right\}
\]</span> 化简一下式子得到 <span class="math display">\[
\begin{aligned}
f_i &amp;= f_j + \dfrac{i^2-ij-i - ij + j^2 + j}{2}\\
f_i &amp;= f_j + \frac{j^2 + j}{2} - i\times j + \frac{i^2 - i}{2}
\end{aligned}
\]</span> 斜率为 <span class="math inline">\(-j\)</span>，截距为 <span class="math inline">\(f_j + \dfrac{j^2 + j}{2}\)</span>，斜率优化。但是我好像不是很会这种，怎么办？</p>
<p>线段树套李超树写好了他告诉我过不去，我投降我投降。cdq 分治的那种真的不会写啊？我吐了。考虑本格斜率优化吧。按那种 cdq 分治的转移方法。下面假设 <span class="math inline">\(j &lt; k\)</span> 且 <span class="math inline">\(j\)</span> <span class="math display">\[
\begin{aligned}
f_j + \frac{j(j+1)}{2} - ij &amp;&gt; f_k + \frac{k(k+1)}{2} - ik\\
i(k - j)  &amp;&gt; f_k + \frac{k(k+1)}{2} - f_j - \frac{j(j+1)}{2}\\
i &amp;&gt; \frac{Y(k) - Y(j)}{X(k) - X(j)}
\end{aligned}
\]</span> 于是类似 cdq 状转移即可</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a aria-hidden="true" href="#cb4-1"></a><span class="dt">void</span> solve(<span class="dt">int</span> l, <span class="dt">int</span> r) {</span>
<span id="cb4-2"><a aria-hidden="true" href="#cb4-2"></a>    <span class="cf">if</span> (l == r) {</span>
<span id="cb4-3"><a aria-hidden="true" href="#cb4-3"></a>        h[l] = f[l] + l * (l + <span class="dv">1</span><span class="bu">ll</span>) / <span class="dv">2</span>;</span>
<span id="cb4-4"><a aria-hidden="true" href="#cb4-4"></a>        <span class="cf">return</span>;</span>
<span id="cb4-5"><a aria-hidden="true" href="#cb4-5"></a>    }</span>
<span id="cb4-6"><a aria-hidden="true" href="#cb4-6"></a>    <span class="dt">int</span> mid = (l + r) &gt;&gt; <span class="dv">1</span>;</span>
<span id="cb4-7"><a aria-hidden="true" href="#cb4-7"></a>    solve(l, mid);</span>
<span id="cb4-8"><a aria-hidden="true" href="#cb4-8"></a>    top = <span class="dv">0</span>;</span>
<span id="cb4-9"><a aria-hidden="true" href="#cb4-9"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = r, p = mid; i &gt; mid; --i) {</span>
<span id="cb4-10"><a aria-hidden="true" href="#cb4-10"></a>        <span class="cf">for</span> (; p &gt;= l &amp;&amp; <span class="dv">2</span> * e[p + <span class="dv">1</span>] &gt; e[i]; --p) {</span>
<span id="cb4-11"><a aria-hidden="true" href="#cb4-11"></a>            pll c = {p, h[p]};</span>
<span id="cb4-12"><a aria-hidden="true" href="#cb4-12"></a>            <span class="cf">while</span> (top &gt; <span class="dv">1</span> &amp;&amp; slope(stk[top - <span class="dv">1</span>], stk[top]) &gt;= slope(stk[top - <span class="dv">1</span>], c)) --top;</span>
<span id="cb4-13"><a aria-hidden="true" href="#cb4-13"></a>            stk[++top] = c;</span>
<span id="cb4-14"><a aria-hidden="true" href="#cb4-14"></a>        }</span>
<span id="cb4-15"><a aria-hidden="true" href="#cb4-15"></a>        <span class="cf">while</span> (top &gt; <span class="dv">1</span> &amp;&amp; slope(stk[top - <span class="dv">1</span>], stk[top]) &gt;= i) --top;</span>
<span id="cb4-16"><a aria-hidden="true" href="#cb4-16"></a>        <span class="cf">if</span> (top) {</span>
<span id="cb4-17"><a aria-hidden="true" href="#cb4-17"></a>            <span class="dt">int</span> j = stk[top].first;</span>
<span id="cb4-18"><a aria-hidden="true" href="#cb4-18"></a>            chkmax(f[i], f[j] + (i - j) * (i - j - <span class="dv">1</span><span class="bu">ll</span>) / <span class="dv">2</span>);</span>
<span id="cb4-19"><a aria-hidden="true" href="#cb4-19"></a>        }</span>
<span id="cb4-20"><a aria-hidden="true" href="#cb4-20"></a>    }</span>
<span id="cb4-21"><a aria-hidden="true" href="#cb4-21"></a>    solve(mid + <span class="dv">1</span>, r);</span>
<span id="cb4-22"><a aria-hidden="true" href="#cb4-22"></a>    <span class="cf">return</span>;</span>
<span id="cb4-23"><a aria-hidden="true" href="#cb4-23"></a>}</span></code></pre></div>
<h2 id="实验舱-7.31">实验舱 7.31</h2>
<h3 id="a.-替换排序">A. 替换排序</h3>
<p>首先将两个数组一起离散化之后可以编出这样的做法：</p>
<p>设 <span class="math inline">\(f_{i,j}\)</span> 表示将 <span class="math inline">\([1,i]\)</span> 弄成结尾为 <span class="math inline">\(j\)</span> 的序列的最小代价，然后转移就很蠢，考虑一下上一个转移位置 <span class="math inline">\(k\)</span>： <span class="math display">\[
f_{i,x} = \min_{\substack{y&lt;x, j&lt;i\\\sum\limits_{k=j+1}^i[a_k\ne x]\le cnt_a}}\left\{ f_{j, y} + \sum_{k=j+1}^i[a_k\ne x]\right\}
\]</span> 这个东西我也不是很知道怎么优化了。。。先写写看吧。妈的隔壁，<span class="math inline">\(O(n^4)\)</span> 的，打个锤子。</p>
<h2 id="实验舱-8.3">实验舱 8.3</h2>
<h3 id="a-stone">A stone</h3>
<p>Alice 和 Bob 取 <span class="math inline">\(n\)</span> 堆石子，每次可以取 <span class="math inline">\([a,b]\)</span> 个。无法取的人败，特别地若一个人直接取完了某堆石子那么就直接赢了。</p>
<p>主要考虑到 <span class="math inline">\(\exist x_i\in[a,b]\)</span> 的时候 Alice 必胜，然后考虑把这些状态从图上删掉来跑 SG 函数，跑出来的性质比较的好，打表找规律即可。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a aria-hidden="true" href="#cb5-1"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="dv">2005</span>;</span>
<span id="cb5-2"><a aria-hidden="true" href="#cb5-2"></a><span class="dt">int</span> n, a, b, x[maxn];</span>
<span id="cb5-3"><a aria-hidden="true" href="#cb5-3"></a></span>
<span id="cb5-4"><a aria-hidden="true" href="#cb5-4"></a><span class="dt">int</span> calc(<span class="dt">int</span> x) {</span>
<span id="cb5-5"><a aria-hidden="true" href="#cb5-5"></a>    <span class="cf">if</span> (x &lt;= a - <span class="dv">1</span>) <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb5-6"><a aria-hidden="true" href="#cb5-6"></a>    <span class="cf">else</span> <span class="cf">if</span> (a == <span class="dv">1</span>) <span class="cf">return</span> x % (a + b);</span>
<span id="cb5-7"><a aria-hidden="true" href="#cb5-7"></a>    <span class="cf">if</span> (x &lt;= b) <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb5-8"><a aria-hidden="true" href="#cb5-8"></a>    x = ((x - b) % (a + b)) / a;</span>
<span id="cb5-9"><a aria-hidden="true" href="#cb5-9"></a>    <span class="cf">if</span> (x &lt;= <span class="dv">1</span>) <span class="cf">return</span> x ^ <span class="dv">1</span>;</span>
<span id="cb5-10"><a aria-hidden="true" href="#cb5-10"></a>    <span class="cf">return</span> x;</span>
<span id="cb5-11"><a aria-hidden="true" href="#cb5-11"></a>}</span>
<span id="cb5-12"><a aria-hidden="true" href="#cb5-12"></a></span>
<span id="cb5-13"><a aria-hidden="true" href="#cb5-13"></a><span class="dt">int</span> main() {</span>
<span id="cb5-14"><a aria-hidden="true" href="#cb5-14"></a>    <span class="dt">int</span> T; cin &gt;&gt; T;</span>
<span id="cb5-15"><a aria-hidden="true" href="#cb5-15"></a>    <span class="cf">while</span> (T--) {</span>
<span id="cb5-16"><a aria-hidden="true" href="#cb5-16"></a>        cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;</span>
<span id="cb5-17"><a aria-hidden="true" href="#cb5-17"></a>        FOR(i, <span class="dv">1</span>, n) cin &gt;&gt; x[i];</span>
<span id="cb5-18"><a aria-hidden="true" href="#cb5-18"></a>        <span class="dt">bool</span> flg = <span class="dv">0</span>;</span>
<span id="cb5-19"><a aria-hidden="true" href="#cb5-19"></a>        FOR(i, <span class="dv">1</span>, n) flg |= (a &lt;= x[i] &amp;&amp; x[i] &lt;= b);</span>
<span id="cb5-20"><a aria-hidden="true" href="#cb5-20"></a>        <span class="cf">if</span> (flg) {</span>
<span id="cb5-21"><a aria-hidden="true" href="#cb5-21"></a>            puts(<span class="st">"Alice"</span>);</span>
<span id="cb5-22"><a aria-hidden="true" href="#cb5-22"></a>            <span class="cf">continue</span>;</span>
<span id="cb5-23"><a aria-hidden="true" href="#cb5-23"></a>        }</span>
<span id="cb5-24"><a aria-hidden="true" href="#cb5-24"></a>        <span class="dt">int</span> sg = <span class="dv">0</span>;</span>
<span id="cb5-25"><a aria-hidden="true" href="#cb5-25"></a>        FOR(i, <span class="dv">1</span>, n) sg ^= calc(x[i]);</span>
<span id="cb5-26"><a aria-hidden="true" href="#cb5-26"></a>        puts(sg ? <span class="st">"Alice"</span> : <span class="st">"Bob"</span>);</span>
<span id="cb5-27"><a aria-hidden="true" href="#cb5-27"></a>    }</span>
<span id="cb5-28"><a aria-hidden="true" href="#cb5-28"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb5-29"><a aria-hidden="true" href="#cb5-29"></a>}</span></code></pre></div>
<h3 id="c-tree">C tree</h3>
<p>给定 <span class="math inline">\(n\le 10^5\)</span> 的树，树带边权，问有多少条路径满足路径上边权的 <span class="math inline">\(\gcd = 1\)</span>。同时会有 <span class="math inline">\(q\le 100\)</span> 次单点修改，值域 <span class="math inline">\(10^6\)</span>。</p>
<p>没想到可以莫反纯脑瘫了那就是。</p>
<p>统计 <span class="math display">\[
\sum_{w}[\gcd w = 1] = \sum_{d}\mu(d)\sum_{w}[d\mid \gcd w]
\]</span> 首先由于有平方因子的 <span class="math inline">\(\mu\)</span> 都是 <span class="math inline">\(0\)</span>，这样子枚举量直接降到 <span class="math inline">\(O(2^c)\)</span>，其中 <span class="math inline">\(c = 7\)</span>。</p>
<p>然后对于不带修的情况就是枚举了 <span class="math inline">\(d\)</span> 之后把 <span class="math inline">\(d\)</span> 的倍数的边全部加进并查集里面然后挨个连通块算贡献了。</p>
<p>现在带上修改，由于 <span class="math inline">\(q\)</span> 很小，所以直接先不管这 <span class="math inline">\(O(q)\)</span> 条涉及到修改了的边，把之前的状态处理好，加进去 <span class="math inline">\(O(q)\)</span> 条边即可。时间复杂度 <span class="math inline">\(O(L + 2^c(n + q^2)\log n)\)</span>。利用线段树分治可以做到 <span class="math inline">\(n,q\)</span> 同阶的情况，即直接关于时间分治就行。</p>
<p>实际上我写了线段树分治，复杂度大概是 <span class="math inline">\(O(L + 2^c(n + q)\log n)\)</span>。</p>
<h2 id="实验舱-8.10">实验舱 8.10</h2>
<p>60 + 100 + 0。计算几何不想去补。</p>
<h3 id="c-商店">C 商店</h3>
<p>树上每个点的点权为标号（<span class="math inline">\(0\sim n - 1\)</span>），有 <span class="math inline">\(m\)</span> 个人，分别在点 <span class="math inline">\(c_i\)</span> 上（可以相同）。每个人可以取子树内一个点，要求总点权最大（不能重复选）。</p>
<p>事实上就是贪心，考虑从 <span class="math inline">\(n - 1\)</span> 开始倒序遍历，每次配对一个深度最低的人。线段树不太过得去，写个并查集才能过。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a aria-hidden="true" href="#cb6-1"></a><span class="dt">int</span> fa[maxn], n, m, c[maxn], p[maxn];</span>
<span id="cb6-2"><a aria-hidden="true" href="#cb6-2"></a></span>
<span id="cb6-3"><a aria-hidden="true" href="#cb6-3"></a><span class="dt">int</span> find(<span class="dt">int</span> x) {<span class="cf">return</span> x == fa[x] ? x : fa[x] = find(fa[x]);}</span>
<span id="cb6-4"><a aria-hidden="true" href="#cb6-4"></a></span>
<span id="cb6-5"><a aria-hidden="true" href="#cb6-5"></a><span class="dt">int</span> main() {</span>
<span id="cb6-6"><a aria-hidden="true" href="#cb6-6"></a>    is &gt;&gt; n &gt;&gt; m;</span>
<span id="cb6-7"><a aria-hidden="true" href="#cb6-7"></a>    FOR(i, <span class="dv">1</span>, n - <span class="dv">1</span>) {</span>
<span id="cb6-8"><a aria-hidden="true" href="#cb6-8"></a>        is &gt;&gt; p[i];</span>
<span id="cb6-9"><a aria-hidden="true" href="#cb6-9"></a>        fa[i] = i;</span>
<span id="cb6-10"><a aria-hidden="true" href="#cb6-10"></a>    }</span>
<span id="cb6-11"><a aria-hidden="true" href="#cb6-11"></a>    FOR(i, <span class="dv">1</span>, m) {</span>
<span id="cb6-12"><a aria-hidden="true" href="#cb6-12"></a>        <span class="dt">int</span> x; is &gt;&gt; x;</span>
<span id="cb6-13"><a aria-hidden="true" href="#cb6-13"></a>        ++c[x];</span>
<span id="cb6-14"><a aria-hidden="true" href="#cb6-14"></a>    }</span>
<span id="cb6-15"><a aria-hidden="true" href="#cb6-15"></a>    ll ans = <span class="dv">0</span>;</span>
<span id="cb6-16"><a aria-hidden="true" href="#cb6-16"></a>    DEC(i, n - <span class="dv">1</span>, <span class="dv">1</span>) {</span>
<span id="cb6-17"><a aria-hidden="true" href="#cb6-17"></a>        <span class="dt">int</span> x = i;</span>
<span id="cb6-18"><a aria-hidden="true" href="#cb6-18"></a>        <span class="cf">while</span> (<span class="kw">true</span>) {</span>
<span id="cb6-19"><a aria-hidden="true" href="#cb6-19"></a>            x = find(i);</span>
<span id="cb6-20"><a aria-hidden="true" href="#cb6-20"></a>            <span class="cf">if</span> (c[x]) {</span>
<span id="cb6-21"><a aria-hidden="true" href="#cb6-21"></a>                --c[x];</span>
<span id="cb6-22"><a aria-hidden="true" href="#cb6-22"></a>                ans += i;</span>
<span id="cb6-23"><a aria-hidden="true" href="#cb6-23"></a>                <span class="cf">break</span>;</span>
<span id="cb6-24"><a aria-hidden="true" href="#cb6-24"></a>            }</span>
<span id="cb6-25"><a aria-hidden="true" href="#cb6-25"></a>            <span class="cf">if</span> (!x) <span class="cf">break</span>;</span>
<span id="cb6-26"><a aria-hidden="true" href="#cb6-26"></a>            fa[x] = p[x];</span>
<span id="cb6-27"><a aria-hidden="true" href="#cb6-27"></a>        }</span>
<span id="cb6-28"><a aria-hidden="true" href="#cb6-28"></a>    }</span>
<span id="cb6-29"><a aria-hidden="true" href="#cb6-29"></a>    os &lt;&lt; ans &lt;&lt; <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span>;</span>
<span id="cb6-30"><a aria-hidden="true" href="#cb6-30"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb6-31"><a aria-hidden="true" href="#cb6-31"></a>}</span></code></pre></div>
<h3 id="a-nim">A nim</h3>
<p>从一个数列中删掉最少的数使得异或和为 <span class="math inline">\(0\)</span>。</p>
<p>实际上就是选最少的数使得异或和为原序列的异或和 <span class="math inline">\(s\)</span>。根据线性基发现这个上界是 <span class="math inline">\(\log s\)</span> 的，所以可以枚举答案来算。</p>
<p>搞一个集合幂级数出来，异或卷积的 <span class="math inline">\(k\)</span> 次方，<span class="math inline">\(i\)</span> 上有值说明 <span class="math inline">\(k\)</span> 个元素可以凑出 <span class="math inline">\(i\)</span>。然后就有 <span class="math inline">\(O(n\log^2 n)\)</span> 做法了，可过。</p>
<p>往集合幂级数里面加一个 <span class="math inline">\(x^0\)</span>，然后变得有可二分性，<span class="math inline">\(O(n\log n\log\log n)\)</span>。</p>
<p>当然由于 IFWT 只用算一个点，所以 <span class="math inline">\(O(n\log n)\)</span>。</p>
<h2 id="实验舱-8.11">实验舱 8.11</h2>
<p>100 + 50 + 0。最后 T2 调出来了 50pts 很极限，T3 暴力懒得打了。</p>
<h3 id="b-归并">B 归并</h3>
<p>给定一个排列 <span class="math inline">\(a\)</span>，两种操作：</p>
<ul>
<li><code>1 l m r</code>，将 <span class="math inline">\(a_{l..m}\)</span> 和 <span class="math inline">\(a_{m+1..r}\)</span> 归并排序，<strong>保证 <span class="math inline">\(l=1\)</span></strong>。</li>
<li><code>2 x</code>，查询当前 <span class="math inline">\(a_x\)</span> 的值。</li>
</ul>
<p>注意到归并排序的过程相当于是将待合并的两段分块，保证块首为块内最大值且为当前部分的前缀最大值，然后将这些块按照块首元素大小归并。</p>
<p>而我们考虑砍的这刀会发生什么。</p>
<ul>
<li>第一种情况是 <span class="math inline">\(m\)</span> 和 <span class="math inline">\(r\)</span> 不在同一块内，这种情况比较好处理，因为实际上会发现只有 <span class="math inline">\(m\)</span> 所在块内的后半段会被分裂然后放到前面归并，剩下的部分都不会动。但是需要将 <span class="math inline">\(r\)</span> 所在块的后半段也分裂掉并保持原来顺序（不参与归并）。</li>
<li>第二种情况是 <span class="math inline">\(m\)</span> 和 <span class="math inline">\(r\)</span> 在同一块内，这种情况就是 <span class="math inline">\([m+1,r]\)</span> 的部分会被分裂然后与前面归并，然后剩下的部分合并成一块（下图蓝色部分）</li>
</ul>
<figure>
<img alt="" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/NOI.AC609.png"/><figcaption>NOI.AC609</figcaption>
</figure>
<p>由于需要支持区间的分裂，所以需要用平衡树来维护这些区间。每棵平衡树维护这样的一块，最多分裂出 <span class="math inline">\(n\)</span> 块并且不会合并，时间复杂度没问题。</p>
<p>注意外层可以使用权值线段树来维护这些有序块（因为块首肯定有序）。反正调试得挺劲爆的，哈哈害。</p>
<h2 id="实验舱-8.16">实验舱 8.16</h2>
<h3 id="a-carry">A Carry</h3>
<p>显然有可二分性，现在就是问 <span class="math inline">\(a_1, a_2, a_3\)</span> 个体积分别为 <span class="math inline">\(1,2,3\)</span> 的物品能否装满 <span class="math inline">\(m\)</span> 个大小为 <span class="math inline">\(h_1,\cdots, h_m\)</span> 的背包。</p>
<p>如果只有大小为 <span class="math inline">\(1,2\)</span> 的物品那就是先尽可能不溢出地放 <span class="math inline">\(2\)</span>，然后用剩下的 <span class="math inline">\(1\)</span> 和 <span class="math inline">\(2\)</span> 补空。尽量避免体积的浪费。</p>
<p>而加上大小为 <span class="math inline">\(3\)</span>​ 的物品之后，贪心策略如下，如果过程中<span class="math inline">\(3\)</span>用完了就直接结束该过程：</p>
<ol type="1">
<li>往剩余空间大于等于 <span class="math inline">\(3\)</span> 的奇数位置放一个 <span class="math inline">\(3\)</span>。</li>
<li>往所有大于等于 <span class="math inline">\(6\)</span> 的位置尽量多地放两个一组的 <span class="math inline">\(3\)</span>（尽量保持偶数可以减少放 <span class="math inline">\(2\)</span> 和 <span class="math inline">\(1\)</span> 时的浪费）。</li>
<li>如果恰好剩下一个 <span class="math inline">\(3\)</span>，把它放到剩余的最大的位置里。</li>
<li>如果 <span class="math inline">\(3\)</span> 还有剩余，现在剩下的位置只剩下 <span class="math inline">\(4, 2, 1\)</span> 三种余量。依次贪心地放入即可。</li>
</ol>
<p>证明比较复杂，这里就不写了，orz Asd_Okuu。</p>
<h3 id="c-观察笔记">C 观察笔记</h3>
<p>给定一棵树，以及若干形如 <span class="math inline">\((x,y)\)</span> 链上的最大值/最小值是 <span class="math inline">\(z\)</span> 的信息，构造一棵满足条件的树。</p>
<p>可以让每条边的权值要么是覆盖其的记录中的最小的 <span class="math inline">\(1\)</span> 标记（最大值）或者最大的 <span class="math inline">\(2\)</span> 标记（最小值）：若都不满足，调整为其中之一不会使得满足的记录条数减少。</p>
<p>所以现在问题变为：</p>
<ul>
<li>对于每条边找到覆盖其的极值；</li>
<li>在两种极值中二选一，使每条记录至少被满足一次。</li>
</ul>
<p>第一个问题可以将标记按权值排序后依次覆盖，拿个树剖也许就可以统计了。哦当然拿并查集什么的似乎也行。</p>
<p>就是并查集的根维护未被染色的最浅的节点，然后假设需要找覆盖的最小值那么就直接从小到大向上找然后染色。</p>
<p>第二个问题发现是个二分图匹配，上 Dinic 就行。</p>
<h2 id="实验舱-8.18">实验舱 8.18</h2>
<h3 id="a-极差">A 极差</h3>
<p>最简单的想法是考虑对于每个子序列，计算一下其能被多少子段包含。</p>
<p>即我们考虑若最左端和最右端为 <span class="math inline">\(l,r\)</span>，极差为 <span class="math inline">\(d\)</span>，那么他会贡献出 <span class="math inline">\(l\times(n - r + 1)\times d\)</span>。</p>
<p>于是得到了一个 <span class="math inline">\(O(n2^n)\)</span> 的做法。</p>
<p>这种贡献方式太蠢了，思考一下 <span class="math inline">\(O(n^2)\)</span> 怎么搞。</p>
<p><strong>极差是可以拆成最大值 - 最小值的。</strong>问题就直接变成每个子段的所有子序列的最值之和。</p>
<p>直接冲正解的话，就是计算每个数被当作最值统计了几次。</p>
<p>首先为了避免算重，直接强行塞一个右边的数更大的偏序关系。</p>
<p>相当于我们要硬点子序列里面有这个数，然后比这个数大的都不可以选。</p>
<p>设成 <span class="math inline">\(a_x\)</span>，最大值： <span class="math display">\[
a_x\times\sum_{l\le x}[a_l \le a_x]\times l\times 2^{cnt(l + 1, x - 1, a_x)}\sum_{r\ge x}[a_r \le a_x] \times 2^{cnt(x + 1,r - 1, a_x)}\times (n - r + 1)
\]</span> 指数位上面可以拆成两半来维护，然后又和下标有关又和值域有关，所以放在一个二维平面上，<span class="math inline">\(l\le x\)</span> 和 <span class="math inline">\(a_l &lt; a_x\)</span> 的限制相当于二维数点，考虑扫描线从小到大扫值，然后加点，数点。在线段树维护该区间的答案以及数。</p>
<h3 id="c-历史">C 历史</h3>
<p>问题转化后，合法的主角序列应该为由若干段形如：若干 <span class="math inline">\(C\)</span>，相邻两个 <span class="math inline">\(C\)</span> 中可以插入若干整段别的元素，例如 <span class="math inline">\(CABBCCCEEEC\)</span>，这样的段。</p>
<p>然后考虑这样一件事：假设一共有 <span class="math inline">\(a\)</span> 个主角，然后我们拿来做连续段 <span class="math inline">\(C\)</span> 的有 <span class="math inline">\(k\)</span> 个，他们占用了 <span class="math inline">\(m\)</span> 的序列长度。然后对这个东西计数其实是很好计的，首先有个 <span class="math inline">\(k!\)</span> 的排列数，然后能插入的空有 <span class="math inline">\(m - k\)</span> 个，要插入 <span class="math inline">\(a - k\)</span> 段。这 <span class="math inline">\(a-k\)</span> 段有个 <span class="math inline">\((a-k)!\)</span> 的排列数，然后就是 <span class="math inline">\(a-k\)</span> 个球放入 <span class="math inline">\(m-k\)</span> 个盒子里，这样的方案数是 <span class="math inline">\(\dbinom{a + m - 2k - 1}{m - k - 1}\)</span>。</p>
<p>那么会发现这样的方案数只与 <span class="math inline">\(k\)</span> 和 <span class="math inline">\(m\)</span> 有关，所以就做一个二维体积的背包，对于每个状态合并一下答案即可。</p>
<p>时间复杂度 <span class="math inline">\(O(n\max\{a_i\}^2)\)</span>。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a aria-hidden="true" href="#cb7-1"></a><span class="at">const</span> <span class="dt">int</span> maxn = <span class="dv">5005</span>, maxa = <span class="dv">105</span>, N = <span class="dv">10005</span>, A = <span class="dv">100</span>;</span>
<span id="cb7-2"><a aria-hidden="true" href="#cb7-2"></a><span class="at">const</span> <span class="dt">int</span> mod = <span class="dv">998244353</span>;</span>
<span id="cb7-3"><a aria-hidden="true" href="#cb7-3"></a><span class="dt">int</span> n, c[maxn], fac[maxn &lt;&lt; <span class="dv">1</span>], ifac[maxn &lt;&lt; <span class="dv">1</span>], a;</span>
<span id="cb7-4"><a aria-hidden="true" href="#cb7-4"></a><span class="dt">int</span> f[maxa][maxn];</span>
<span id="cb7-5"><a aria-hidden="true" href="#cb7-5"></a></span>
<span id="cb7-6"><a aria-hidden="true" href="#cb7-6"></a><span class="dt">int</span> qPow(<span class="dt">int</span> a, <span class="dt">int</span> b) {</span>
<span id="cb7-7"><a aria-hidden="true" href="#cb7-7"></a>    <span class="dt">int</span> ret = <span class="dv">1</span>;</span>
<span id="cb7-8"><a aria-hidden="true" href="#cb7-8"></a>    <span class="cf">for</span> (a %= mod; b; b &gt;&gt;= <span class="dv">1</span>, a = <span class="dv">1</span><span class="bu">ll</span> * a * a % mod)</span>
<span id="cb7-9"><a aria-hidden="true" href="#cb7-9"></a>        <span class="cf">if</span> (b &amp; <span class="dv">1</span>) ret = <span class="dv">1</span><span class="bu">ll</span> * ret * a % mod;</span>
<span id="cb7-10"><a aria-hidden="true" href="#cb7-10"></a>    <span class="cf">return</span> ret;</span>
<span id="cb7-11"><a aria-hidden="true" href="#cb7-11"></a>}</span>
<span id="cb7-12"><a aria-hidden="true" href="#cb7-12"></a></span>
<span id="cb7-13"><a aria-hidden="true" href="#cb7-13"></a>il <span class="dt">int</span> binom(<span class="dt">int</span> n, <span class="dt">int</span> m) {</span>
<span id="cb7-14"><a aria-hidden="true" href="#cb7-14"></a>    <span class="cf">return</span> (n &lt; m || m &lt; <span class="dv">0</span>) ? <span class="dv">0</span> : <span class="dv">1</span><span class="bu">ll</span> * fac[n] * ifac[m] % mod * ifac[n - m] % mod;</span>
<span id="cb7-15"><a aria-hidden="true" href="#cb7-15"></a>}</span>
<span id="cb7-16"><a aria-hidden="true" href="#cb7-16"></a></span>
<span id="cb7-17"><a aria-hidden="true" href="#cb7-17"></a><span class="dt">int</span> main() {</span>
<span id="cb7-18"><a aria-hidden="true" href="#cb7-18"></a>    fac[<span class="dv">0</span>] = <span class="dv">1</span>;</span>
<span id="cb7-19"><a aria-hidden="true" href="#cb7-19"></a>    FOR(i, <span class="dv">1</span>, N) fac[i] = <span class="dv">1</span><span class="bu">ll</span> * fac[i - <span class="dv">1</span>] * i % mod;</span>
<span id="cb7-20"><a aria-hidden="true" href="#cb7-20"></a>    ifac[N] = qPow(fac[N], mod - <span class="dv">2</span>);</span>
<span id="cb7-21"><a aria-hidden="true" href="#cb7-21"></a>    DEC(i, N - <span class="dv">1</span>, <span class="dv">0</span>) ifac[i] = (i + <span class="dv">1</span><span class="bu">ll</span>) * ifac[i + <span class="dv">1</span>] % mod;</span>
<span id="cb7-22"><a aria-hidden="true" href="#cb7-22"></a>    cin &gt;&gt; n;</span>
<span id="cb7-23"><a aria-hidden="true" href="#cb7-23"></a>    FOR(i, <span class="dv">1</span>, n) {</span>
<span id="cb7-24"><a aria-hidden="true" href="#cb7-24"></a>        <span class="dt">int</span> x; cin &gt;&gt; x;</span>
<span id="cb7-25"><a aria-hidden="true" href="#cb7-25"></a>        ++c[x];</span>
<span id="cb7-26"><a aria-hidden="true" href="#cb7-26"></a>    }</span>
<span id="cb7-27"><a aria-hidden="true" href="#cb7-27"></a>    FOR(i, <span class="dv">1</span>, A) <span class="cf">if</span> (c[i]) c[++a] = c[i];</span>
<span id="cb7-28"><a aria-hidden="true" href="#cb7-28"></a>    f[<span class="dv">0</span>][<span class="dv">0</span>] = <span class="dv">1</span>;</span>
<span id="cb7-29"><a aria-hidden="true" href="#cb7-29"></a>    FOR(k, <span class="dv">1</span>, a)</span>
<span id="cb7-30"><a aria-hidden="true" href="#cb7-30"></a>        DEC(i, k, <span class="dv">1</span>)</span>
<span id="cb7-31"><a aria-hidden="true" href="#cb7-31"></a>            DEC(j, <span class="dv">5000</span>, c[k])</span>
<span id="cb7-32"><a aria-hidden="true" href="#cb7-32"></a>                f[i][j] = (f[i][j] + f[i - <span class="dv">1</span>][j - c[k]]) % mod;</span>
<span id="cb7-33"><a aria-hidden="true" href="#cb7-33"></a>    <span class="dt">int</span> ans = <span class="dv">0</span>;</span>
<span id="cb7-34"><a aria-hidden="true" href="#cb7-34"></a>    FOR(k, <span class="dv">1</span>, a) FOR(m, <span class="dv">1</span>, <span class="dv">5000</span>) <span class="cf">if</span> (f[k][m]) {</span>
<span id="cb7-35"><a aria-hidden="true" href="#cb7-35"></a>        <span class="cf">if</span> (k &lt; m) ans = (ans + <span class="dv">1</span><span class="bu">ll</span> * f[k][m] * fac[k] % mod * fac[a - k] % mod * binom(a + m - <span class="dv">2</span> * k - <span class="dv">1</span>, m - k - <span class="dv">1</span>) % mod) % mod;</span>
<span id="cb7-36"><a aria-hidden="true" href="#cb7-36"></a>        <span class="cf">else</span> <span class="cf">if</span> (k == a) ans = (ans + fac[k]) % mod; <span class="co">// 特判</span></span>
<span id="cb7-37"><a aria-hidden="true" href="#cb7-37"></a>    }</span>
<span id="cb7-38"><a aria-hidden="true" href="#cb7-38"></a>    FOR(k, <span class="dv">1</span>, a) ans = <span class="dv">1</span><span class="bu">ll</span> * ans * fac[c[k]] % mod;</span>
<span id="cb7-39"><a aria-hidden="true" href="#cb7-39"></a>    cout &lt;&lt; ans &lt;&lt; endl;</span>
<span id="cb7-40"><a aria-hidden="true" href="#cb7-40"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb7-41"><a aria-hidden="true" href="#cb7-41"></a>}</span></code></pre></div>
</section>
<footer class="article-footer">
<section class="article-tags">
<a href="/tags/OI/">OI</a>
</section>
<section class="article-copyright">
<svg class="icon icon-tabler icon-tabler-copyright" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M0 0h24v24H0z" stroke="none"></path>
<circle cx="12" cy="12" r="9"></circle>
<path d="M14.5 9a3.5 4 0 1 0 0 6"></path>
</svg>
<span>Licensed under CC BY-NC-SA 4.0</span>
</section>
</footer>
<link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css" integrity="sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn" rel="stylesheet"/><script crossorigin="anonymous" defer="" integrity="sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8" src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js">
</script><script crossorigin="anonymous" defer="" integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js">
</script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.querySelector(`.article-content`), {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ]
        });})
</script>
</article>
<aside class="related-contents--wrapper">
<h2 class="section-title">相关文章</h2>
<div class="related-contents">
<div class="flex article-list--tile">
<article class="has-image">
<a href="/sol-luogu-p5468/">
<div class="article-image">
<img data-hash="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg01.webp" data-key="" loading="lazy" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg01.webp"/>
</div>
<div class="article-details">
<h2 class="article-title">P5468 [NOI2019] 回家路线</h2>
</div>
</a>
</article>
<article class="has-image">
<a href="/travels-noi2022/">
<div class="article-image">
<img data-hash="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg01.webp" data-key="" loading="lazy" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg01.webp"/>
</div>
<div class="article-details">
<h2 class="article-title">NOI2022 游记</h2>
</div>
</a>
</article>
<article class="has-image">
<a href="/sol-cf715b/">
<div class="article-image">
<img data-hash="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg57.webp" data-key="" loading="lazy" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg57.webp"/>
</div>
<div class="article-details">
<h2 class="article-title">CF715B Complete The Graph</h2>
</div>
</a>
</article>
<article class="has-image">
<a href="/sol-agc027d/">
<div class="article-image">
<img data-hash="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg01.webp" data-key="" loading="lazy" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg01.webp"/>
</div>
<div class="article-details">
<h2 class="article-title">AGC027D - Modulo Matrix</h2>
</div>
</a>
</article>
<article class="has-image">
<a href="/sol-luogu-p5305/">
<div class="article-image">
<img data-hash="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg32.webp" data-key="" loading="lazy" src="https://yangty-pic.oss-cn-beijing.aliyuncs.com/bg32.webp"/>
</div>
<div class="article-details">
<h2 class="article-title">P5305 [GXOI/GZOI2019]旧词</h2>
</div>
</a>
</article>
</div>
</div>
</aside>
<footer class="site-footer">
<section class="copyright">
        © 
        
            2019 - 
        
        2024 清烛的博客
    </section>
<section class="powerby">
        Built with <a href="https://gohugo.io/" rel="noopener" target="_blank">Hugo</a> <br/>
        主题 <b><a data-version="3.11.0" href="https://github.com/CaiJimmy/hugo-theme-stack" rel="noopener" target="_blank">Stack</a></b> 由 <a href="https://jimmycai.com" rel="noopener" target="_blank">Jimmy</a> 设计
    </section>
</footer>
<div aria-hidden="true" class="pswp" role="dialog" tabindex="-1">
<div class="pswp__bg"></div>
<div class="pswp__scroll-wrap">
<div class="pswp__container">
<div class="pswp__item"></div>
<div class="pswp__item"></div>
<div class="pswp__item"></div>
</div>
<div class="pswp__ui pswp__ui--hidden">
<div class="pswp__top-bar">
<div class="pswp__counter"></div>
<button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title="Share"></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
<div class="pswp__preloader">
<div class="pswp__preloader__icn">
<div class="pswp__preloader__cut">
<div class="pswp__preloader__donut"></div>
</div>
</div>
</div>
</div>
<div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
<div class="pswp__share-tooltip"></div>
</div>
<button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
</button>
<div class="pswp__caption">
<div class="pswp__caption__center"></div>
</div>
</div>
</div>
</div><script crossorigin="anonymous" defer="" integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js">
</script><script crossorigin="anonymous" defer="" integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js">
</script><link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css" integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" rel="stylesheet"/><link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css" integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" rel="stylesheet"/>
</main>
</div>
<script crossorigin="anonymous" integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js">
</script><script defer="" src="/ts/main.js" type="text/javascript"></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>
</body>
</html>
